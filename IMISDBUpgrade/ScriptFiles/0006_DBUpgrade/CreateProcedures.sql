
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMChangeStatus]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMChangeStatus]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure changes the status of a content record
-- 
-- Modifications
-- 07/14/2003   E.Tatsui
-- =============================================

CREATE   PROCEDURE amsp_CMChangeStatus
  @InContentID numeric,
  @InNewWorkflowStatusCode char(1),
  @InContactID numeric
AS

BEGIN

  DECLARE
    @CurrentWorkflowStatus char(1),
    @CurrentContactID numeric

  SELECT @CurrentWorkflowStatus = WorkflowStatusCode,
         @CurrentContactID = ContactID
    FROM Content WITH (NOLOCK)
   WHERE ContentID = @InContentID
  -- Update only if it's changing.
  IF @CurrentWorkflowStatus != @InNewWorkflowStatusCode 
     OR IsNull(@CurrentContactID,0) != @InContactID BEGIN
  
    UPDATE Content
       SET WorkflowStatusCode = @InNewWorkflowStatusCode,
           ContactID = @InContactID
     WHERE ContentID = @InContentID
  
    INSERT INTO Content_Workflow_Log (ContentID,
                                      WorkflowStatusCode,
                                      ContactID,
                                      ChangeDateTime)
    VALUES (@InContentID,
            @InNewWorkflowStatusCode,
            @InContactID,
            CURRENT_TIMESTAMP)
  END
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_GetTableColumnList]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_GetTableColumnList]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- This procedure takes a table name and returns a string containing a comma delimited
-- list of column names from the table.  If the optional parameter InIncludeKeys is set
-- to Y, it will include the key columns in the list, by default, it will not. Also, by
-- specifying columns names to skip, the user can remove columns that would otherwise
-- have appeared in the list
--
-- Parameters:
--   IN - InTableName - the name fo the table for which the column list is desired
--   OUT - OutColumnList - the list of columns, comma delimited
--   IN - InIncludeKeys - Optional, Y (yes) or N (no) to include key columns in the list
--   IN - SkipColumnName1-5 - Optional, allows the user to specify up to 5 columns to 
--        leave out of the list.
--
-- Copyright 2005 Advanced Solutions Intl., All Rights Reserved

CREATE  PROCEDURE amsp_GetTableColumnList 
    @InTableName sysname,
    @OutColumnList nvarchar(4000) OUTPUT,
    @InIncludeKeys char(1) = 'N',
    @SkipColumnName1 sysname = '',
    @SkipColumnName2 sysname = '',
    @SkipColumnName3 sysname = '',
    @SkipColumnName4 sysname = '',
    @SkipColumnName5 sysname = '' AS
  DECLARE GetColumns CURSOR LOCAL READ_ONLY FOR
  SELECT b.name, (
         SELECT 1
           FROM sysindexes c, sysindexkeys d
          WHERE b.id = c.id 
            AND c.id = d.id
            AND c.status & 2048 = 2048
            AND c.indid = d.indid
            AND b.colid = d.colid) AS PK
    FROM sysobjects a, syscolumns b 
   WHERE a.id = b.id
     AND a.name = @InTableName
   ORDER BY b.colorder
  BEGIN
    DECLARE
    @ColumnName sysname,
    @ColumnStatus int
    
    SET @OutColumnList = ''
    OPEN GetColumns
     
    FETCH NEXT FROM GetColumns
     INTO @ColumnName, @ColumnStatus
    
    WHILE @@FETCH_STATUS = 0
    	BEGIN
        IF (@ColumnStatus IS NULL OR @ColumnStatus <> 1 OR 
           (@ColumnStatus = 1 AND @InIncludeKeys = 'Y')) AND
           @ColumnName NOT IN (@SkipColumnName1, @SkipColumnName2, @SkipColumnName3, @SkipColumnName4, @SkipColumnName5) 
          SET @OutColumnList = @OutColumnList + @ColumnName + ','
  
        FETCH NEXT FROM GetColumns
         INTO @ColumnName, @ColumnStatus
      END
      
    CLOSE GetColumns
    DEALLOCATE GetColumns
    
    SET @OutColumnList = Left(@OutColumnList,Len(@OutColumnList) - 1)
  END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMCopyContentRow]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMCopyContentRow]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This sp creates a new content record based on the content record passed in
-- 
-- Modifications
-- 09/08/2003    E.Tatsui    Created
-- =============================================

CREATE        PROCEDURE [dbo].[amsp_CMCopyContentRow]
  @InContentID numeric,
  @InContactID numeric,
  @OutContentID numeric OUTPUT
AS
BEGIN
  DECLARE
    @ColumnList nvarchar(4000),
    @InsertQuery nvarchar(4000)
  
  CREATE TABLE #SkipColumn (SkipColumnName varchar(255))
  
  -- Copy the content row 
  EXECUTE amsp_GetTableColumnList 'Content', @ColumnList OUTPUT, 'N', 'WorkflowStatusCode', 'PreviousContentID', 'PublishDateTime', 'ContactID'
  SET @InsertQuery = 'INSERT INTO Content (' + @ColumnList + ',WorkflowStatusCode, PreviousContentID, ContactID) SELECT ' + @ColumnList + ',''W'',' + CAST(@InContentID AS varchar) + ',' + CAST(@InContactID AS varchar)+  ' FROM Content WHERE ContentID = ' + CAST(@InContentID AS varchar)
  EXECUTE sp_executesql @InsertQuery
  SET @OutContentID = @@Identity
  
  -- Copy any Content_HTML rows
  EXECUTE amsp_GetTableColumnList 'Content_HTML', @ColumnList OUTPUT
  SET @InsertQuery = 'INSERT INTO Content_HTML (' + @ColumnList + ',ContentID) SELECT ' + @ColumnList + ',' + CAST(@OutContentID AS varchar) + ' FROM Content_HTML WHERE ContentID = ' + CAST(@InContentID AS varchar)
  EXECUTE sp_executesql @InsertQuery

  -- Copy any Content_Link rows
  EXECUTE amsp_GetTableColumnList 'Content_Link', @ColumnList OUTPUT, 'N', 'ContentID', 'PreviousContentLinkID'
  SET @InsertQuery = 'INSERT INTO Content_Link (' + @ColumnList + ',ContentID, PreviousContentLinkID) SELECT ' + @ColumnList + ',' + CAST(@OutContentID AS varchar) + ',CAST(ContentLinkID AS varchar)' + ' FROM Content_Link WHERE ContentID = ' + CAST(@InContentID AS varchar)
  EXECUTE sp_executesql @InsertQuery

  -- OK, Now if any of the Content_Link rows were specifying the old Content ID, let's fix them.
  UPDATE Content_Link
     SET LinkURL = Replace(LinkURL, 'ContentID=' + Convert(varchar(10), @InContentID), 'ContentID=' + Convert(varchar(10), @OutContentID))
   WHERE ContentID = @OutContentID

  -- Copy any Content_File rows
  EXECUTE amsp_GetTableColumnList 'Content_File', @ColumnList OUTPUT, 'N', 'ContentID','PreviousContentFileID'
  SET @InsertQuery = 'INSERT INTO Content_File (' + @ColumnList + ',ContentID,PreviousContentFileID) SELECT ' + @ColumnList + ',' + CAST(@OutContentID AS varchar) + ',CAST(ContentFileID AS varchar) FROM Content_File WHERE ContentID = ' + CAST(@InContentID AS varchar)
  EXECUTE sp_executesql @InsertQuery

  -- Copy any Tagged_Page_Interest_Category rows
  EXECUTE amsp_GetTableColumnList 'Tagged_Page_Interest_Category', @ColumnList OUTPUT, 'Y', 'ContentID'
  SET @InsertQuery = 'INSERT INTO Tagged_Page_Interest_Category (' + @ColumnList + ',ContentID) SELECT ' + @ColumnList + ',' + CAST(@OutContentID AS varchar) + ' FROM Tagged_Page_Interest_Category WHERE ContentID = ' + CAST(@InContentID AS varchar)
  EXECUTE sp_executesql @InsertQuery
  
  -- Copy any Component_Interest_Category rows
  EXECUTE amsp_GetTableColumnList 'Component_Interest_Category', @ColumnList OUTPUT,'Y','ComponentID'
  SET @InsertQuery = 'INSERT INTO Component_Interest_Category (' + @ColumnList + ',ComponentID) SELECT ' + @ColumnList + ',' + CAST(@OutContentID AS varchar) + ' FROM Component_Interest_Category WHERE ComponentCode = ''CM'' AND ComponentID = ' + CAST(@InContentID AS varchar)
  EXECUTE sp_executesql @InsertQuery

  -- Copy any Content_Security_Group rows
  EXECUTE amsp_GetTableColumnList 'Content_Security_Group', @ColumnList OUTPUT,'Y','ContentID'
  SET @InsertQuery = 'INSERT INTO Content_Security_Group (' + @ColumnList + ',ContentID) SELECT ' + @ColumnList + ',' + CAST(@OutContentID AS varchar) + ' FROM Content_Security_Group WHERE ContentID = ' + CAST(@InContentID AS varchar)
  EXECUTE sp_executesql @InsertQuery

  EXECUTE amsp_GetTableColumnList 'Content_Change_Request', @ColumnList OUTPUT,'N','ContentID'
  SET @InsertQuery = 'INSERT INTO Content_Change_Request (' + @ColumnList + ',ContentID) SELECT ' + @ColumnList + ',' + CAST(@OutContentID AS varchar) + ' FROM Content_Change_Request WHERE RequestStatusCode = ''A'' AND ContentID = ' + CAST(@InContentID AS varchar)
  EXECUTE sp_executesql @InsertQuery 

  -- Copy any Content_Publish_Server rows (Not used for this version of CM)
  --EXECUTE amsp_GetTableColumnList 'Content_Publish_Server', @ColumnList OUTPUT,'Y','ContentID'
  --SET @InsertQuery = 'INSERT INTO Content_Publish_Server (' + @ColumnList + ',ContentID) SELECT ' + @ColumnList + ',' + CAST(@OutContentID AS varchar) + ' FROM Content_Publish_Server WHERE ContentID = ' + CAST(@InContentID AS varchar)
  --EXECUTE sp_executesql @InsertQuery
  -- Create the Content_Workflow_Log entry
  INSERT INTO Content_Workflow_Log (ContentID, WorkflowStatusCode, ContactID, ChangeDateTime)
  VALUES (@OutContentID,'W',@InContactID, CURRENT_TIMESTAMP)
END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetUniqueContentName]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetUniqueContentName]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure cares a unique URLSafe name (Content.URLSafeName field)
-- for a specified Content record. 
--
-- Modifications
-- 08/22/2003   E.Tatsui
-- =============================================

CREATE          PROCEDURE amsp_CMGetUniqueContentName
  @InContentID numeric = NULL,
  @InContentName varchar(255) = NULL,
  @InNavMenuID numeric,
  @OutURLSafeName varchar(255) OUTPUT
AS
BEGIN

  IF @InContentID IS NULL AND @InContentName IS NULL BEGIN
    RAISERROR('Either ContentID or Title is required as input parameter',16,1)
    RETURN
  END

  DECLARE
    @Name varchar(255),
    @URLSafeName varchar(255),
    @RowNum integer,
    @Counter integer,
    @DefaultContentTitleLength numeric

  IF @InContentName IS NOT NULL
    SET @Name = @InContentName
  ELSE 
    SELECT @Name = Name
      FROM Content
     WHERE ContentID = @InContentID

  SELECT @DefaultContentTitleLength = CAST(Value as numeric)
    FROM System_Variable
   WHERE Name = 'CMDefaultContentTitleLength'

  -- Remove special characters that shouldn't be used in URL.
  SET @URLSafeName = REPLACE(@Name, ' ', '_')
  SET @URLSafeName = REPLACE(@URLSafeName, '.', '_')
  SET @URLSafeName = REPLACE(@URLSafeName, '?', '_')
  SET @URLSafeName = REPLACE(@URLSafeName, '\', '_')
  SET @URLSafeName = REPLACE(@URLSafeName, '/', '_')
  SET @URLSafeName = REPLACE(@URLSafeName, '*', '_')
  SET @URLSafeName = REPLACE(@URLSafeName, ':', '_')
  SET @URLSafeName = REPLACE(@URLSafeName, '|', '_')
  SET @URLSafeName = REPLACE(@URLSafeName, '<', '_')
  SET @URLSafeName = REPLACE(@URLSafeName, '&', '_')
  SET @URLSafeName = REPLACE(@URLSafeName, '''', '_')
  SET @URLSafeName = REPLACE(@URLSafeName, '#', '_')
  SET @URLSafeName = REPLACE(@URLSafeName, '>', '_')
  SET @URLSafeName = REPLACE(@URLSafeName, '>', '_')
  SET @URLSafeName = REPLACE(@URLSafeName, '>', '_')
  SET @URLSafeName = REPLACE(@URLSafeName, '@', '_')

  -- Multiple underscores looks so untidy.
  WHILE CHARINDEX('__', @URLSafeName) > 0 BEGIN
    SET @URLSafeName = REPLACE(@URLSafeName, '__','_')
  END
  
  SET @URLSafeName = Left(@URLSafeName,@DefaultContentTitleLength -1)

  -- It needs to be unique.
  SELECT @RowNum = COUNT(*)
    FROM Content
   WHERE UPPER(URLSafeName) = UPPER(@URLSafeName)
     AND NavMenuID = @InNavMenuID

  -- If we find a record with the same directory name, let's append a number at the end.    
  SET @Counter = 0
  WHILE @RowNum > 0 BEGIN
    SET @Counter = @Counter + 1
    SELECT @RowNum = COUNT(*)
      FROM Content
     WHERE UPPER(URLSafeName) = UPPER(@URLSafeName) + Cast(@Counter as varchar(255))
       AND NavMenuID = @InNavMenuID
  END    
  
  IF @Counter > 0
    SET @URLSafeName = @URLSafeName + Cast(@Counter as varchar(255))

  SET @OutURLSafeName = @URLSafeName
END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMCopyContentAsNew]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMCopyContentAsNew]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This procedure takes an original ContentID and ALTER  a copy of it with same attributes.
--
-- Modifications
-- 08/12/2003    E.Tatsui   Created
-- =============================================

CREATE           PROCEDURE [dbo].[amsp_CMCopyContentAsNew]
	@InOriginalContentID numeric,
  @InContactID numeric,
  @InTargetNavMenuID numeric = NULL,
  @OutNewContentID numeric OUTPUT
AS

BEGIN

  DECLARE
    @NavMenuID numeric,
    @OrigURLSafeName varchar(255),
    @URLSafeName varchar(255),
    @Counter smallint

  SELECT @OrigURLSafeName = URLSafeName,
         @NavMenuID = NavMenuID
    FROM Content WITH (NOLOCK)
   WHERE ContentID = @InOriginalContentID

  -- If there is a specific target to copy the content to, use the NavMenuID.
  IF @InTargetNavMenuID IS NOT NULL
    SET @NavMenuID = @InTargetNavMenuID

  EXEC amsp_CMCopyContentRow @InOriginalContentID, @InContactID, @OutNewContentID OUTPUT

  --Make a unique URLSafeName
  EXEC amsp_CMGetUniqueContentName NULL, @OrigURLSafeName, @NavMenuID, @URLSafeName OUTPUT

  -- amsp_CMCopyContentRow creates a Content record as a new version of the existing one,
  -- update fields to make this a new branch.
  UPDATE Content
     SET URLSafeName = @URLSafeName,
         OriginalContentID = NULL,
         PreviousContentID = NULL,
         ExpirationDate = NULL,
         PostFuseURL = NULL,
         PreFuseURL = NULL,
         PublishLocation = NULL,
         ReminderSentDateTime = NULL,
         PublicationDate = NULL,
         SortOrder = (SELECT IsNull(Max(SortOrder),0) + 1
                        FROM Content
                       WHERE NavMenuID = @NavMenuID)
   WHERE ContentID = @OutNewContentID
  
  DELETE FROM Content_Change_Request WHERE ContentID =  @OutNewContentID
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetUniqueSectionName]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetUniqueSectionName]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure cares a unique section name (Nav_Menu.Name field)
-- for a specified Nav_Menu record. 
--
-- Modifications
-- 08/22/2003   E.Tatsui
-- =============================================

CREATE      PROCEDURE amsp_CMGetUniqueSectionName
	@InNavMenuID numeric = NULL,
  @InTitle varchar(255) = NULL,
  @OutSectionName varchar(255) OUTPUT
AS
BEGIN

  IF @InNavMenuID IS NULL AND @InTitle IS NULL BEGIN
    RAISERROR('Either NavMenuID or Title is required as input parameter',16,1)
    RETURN
  END

  DECLARE
    @Title varchar(255),
    @Name varchar(255),
    @RowNum integer,
    @Counter integer

  IF @InTitle IS NOT NULL
    SET @Title = @InTitle
  ELSE 
    SELECT @Title = Title
      FROM Nav_Menu
     WHERE NavMenuID = @InNavMenuID

  -- Remove special characters that shouldn't be used in URL.
  SET @Name = REPLACE(@Title, ' ', '_')
  SET @Name = REPLACE(@Name, '.', '_')
  SET @Name = REPLACE(@Name, '?', '_')
  SET @Name = REPLACE(@Name, '\', '_')
  SET @Name = REPLACE(@Name, '/', '_')
  SET @Name = REPLACE(@Name, '*', '_')
  SET @Name = REPLACE(@Name, ':', '_')
  SET @Name = REPLACE(@Name, '|', '_')
  SET @Name = REPLACE(@Name, '<', '_')
  SET @Name = REPLACE(@Name, '&', '_')
  SET @Name = REPLACE(@Name, '''', '_')
  SET @Name = REPLACE(@Name, '#', '_')
  SET @Name = REPLACE(@Name, '>', '_')
  SET @Name = REPLACE(@Name, '>', '_')
  SET @Name = REPLACE(@Name, '>', '_')

  -- Multiple underscores looks so untidy.
  WHILE CHARINDEX('__', @Name) > 0 BEGIN
    SET @Name = REPLACE(@Name, '__','_')
  END
  
  SET @Name = Left(@Name,100)

  -- It needs to be unique.
  SELECT @RowNum = COUNT(*)
    FROM Nav_Menu
   WHERE UPPER(Name) = UPPER(@Name)

  -- If we find a record with the same directory name, let's append a number at the end.    
  SET @Counter = 0
  WHILE @RowNum > 0 BEGIN
    SET @Counter = @Counter + 1
    SELECT @RowNum = COUNT(*)
      FROM Nav_Menu
     WHERE UPPER(Name) = UPPER(@Name) + Cast(@Counter as varchar(255))
  END    
  
  IF @Counter > 0
    SET @Name = @Name + Cast(@Counter as varchar(255))

  SET @OutSectionName = @Name
END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMUpdateNavProperties]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMUpdateNavProperties]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure figures out some of the calculated values stored in Nav_Menu table 
-- for performance improvement.
--
-- Modifications
-- 10/10/2003   E.Tatsui
-- =============================================

CREATE           PROCEDURE amsp_CMUpdateNavProperties
	@InNavMenuID numeric
AS
BEGIN
  DECLARE
    @AncestoryList varchar(255),
    @FilePath varchar(255),
    @DescendantCount numeric,
    @SortOrder numeric(28,18),
    @CategoryDepth numeric,
    @ParentNavMenuID numeric,
    @Name varchar(255),
    @WebsiteKey uniqueidentifier,
    @CurrentAncestoryList varchar(255),
    @CurrentFilePath varchar(255),
    @CurrentDescendantCount numeric,
    @NavMenuID numeric,
    @CurrentParentNavMenuID numeric,
    @AncestorNavMenuID numeric,
    @NavContentGroupInd char(1)
 
  SELECT @SortOrder = SortOrder,
         @CategoryDepth = CategoryDepth,
         @Name = IsNull(DirectoryName,Name),
         @ParentNavMenuID = ParentNavMenuID,
         @WebsiteKey = WebsiteKey,
         @CurrentAncestoryList = IsNull(AncestoryList,''),
         @CurrentFilePath = IsNull(FilePath,''),
         @CurrentDescendantCount = DescendantCount,
         @AncestorNavMenuID = AncestorNavMenuID,
         @NavContentGroupInd = NavContentGroupInd
    FROM Nav_Menu WITH (NOLOCK)
   WHERE NavMenuID = @InNavMenuID

  SET @CurrentParentNavMenuID = @ParentNavMenuID

  -- First get descendant count.
  IF @NavContentGroupInd = 'N'
    SELECT @DescendantCount = Count(*)
      FROM Nav_Menu z
      WITH (NOLOCK)
    WHERE z.WebsiteKey = @WebsiteKey
      AND z.SortOrder > @SortOrder
      AND z.WorkflowStatusCode <> 'D'
      AND z.NavContentGroupInd = 'N'
      AND z.SortOrder <
         (SELECT IsNull(Min(x.SortOrder),999999999)
            FROM Nav_Menu x
             WITH (NOLOCK)
           WHERE x.SortOrder > @SortOrder
             AND x.CategoryDepth <= @CategoryDepth
             AND x.WebsiteKey = @WebsiteKey
             AND z.NavContentGroupInd = 'N')
  ELSE
    SELECT @DescendantCount = Count(*)
      FROM Nav_Menu z
      WITH (NOLOCK)
    WHERE z.NavContentGroupInd = 'C'
      AND z.WorkflowStatusCode <> 'D'
      AND z.SortOrder > @SortOrder
      AND z.SortOrder <
         (SELECT IsNull(Min(x.SortOrder),999999999)
            FROM Nav_Menu x
             WITH (NOLOCK)
           WHERE x.SortOrder > @SortOrder
             AND x.CategoryDepth <= @CategoryDepth
             AND x.NavContentGroupInd = 'C')

  -- Next, get file path and ancestory list.
  SET @FilePath = @Name + '/'
  SET @AncestoryList = ''
  WHILE @ParentNavMenuID IS NOT NULL BEGIN
    SET @AncestoryList = '''' + convert(varchar(10), @ParentNavMenuID) + ''',' + @AncestoryList

    SELECT @Name = IsNull(DirectoryName,Name),
           @ParentNavMenuID = ParentNavMenuID
      FROM Nav_Menu WITH (NOLOCK)
     WHERE NavMenuID = @ParentNavMenuID

    IF @@RowCount > 0
      SET @FilePath = @Name + '/' + @FilePath
    ELSE
      BREAK  
  END -- End while loop

  -- Strip out the last ","
  IF Len(@AncestoryList) > 0
    SET @AncestoryList = LEFT(@AncestoryList, Len(@AncestoryList) - 1)

  IF @CurrentAncestoryList <> @AncestoryList
     OR @CurrentFilePath <> @FilePath
     OR @CurrentDescendantCount <> @DescendantCount BEGIN
    UPDATE Nav_Menu
       SET FilePath = @FilePath,
           AncestoryList = NULLIF(@AncestoryList,''),
           DescendantCount = @DescendantCount
     WHERE NavMenuID = @InNavMenuID
  END

  IF @CurrentFilePath <> @FilePath BEGIN
    -- Replace filepath for all the children.
    UPDATE Nav_Menu
       SET FilePath = @FilePath + SUBSTRING(FilePath,LEN(@CurrentFilePath)+1, LEN(FilePath)- LEN(@CurrentFilePath))
     WHERE AncestorNavMenuID = @AncestorNavMenuID
       AND NavMenuID <> @InNavMenuID
       AND CHARINDEX(@CurrentFilePath, FilePath) = 1
  END

  -- If ancestory list or descendant count changes, the item's parents should
  -- be updated also.
  IF @CurrentParentNavMenuID IS NOT NULL
     AND (@CurrentAncestoryList <> @AncestoryList 
          OR @CurrentDescendantCount <> @DescendantCount) BEGIN
    EXEC amsp_CMUpdateNavProperties @CurrentParentNavMenuID
  END
END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMCopyNavMenu]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMCopyNavMenu]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure ALTER  another copy of a specified Nav_Menu record 
-- and all of its descendants.
-- In addition, it copies associated Tagged Pages.
--
-- Modifications
-- 08/22/2003      E.Tatsui    Created
-- =============================================

CREATE      PROCEDURE amsp_CMCopyNavMenu
	@InOriginalNavMenuID numeric,
  @InContactID numeric,
  @OutNewNavMenuID numeric OUTPUT
AS
BEGIN

  DECLARE
    @Title varchar(255),
    @SectionName varchar(255),
    @NewNavMenuID numeric,
    @ContentID numeric,
    @NavMenuID numeric,
    @Error integer,
    @BelowSortOrder numeric(28,18),
    @LowestSortOrder numeric(28,18),
    @SortIncrement numeric(28,18),
    @SortOrder numeric(28,18),
    @CategoryDepth integer,
    @AncestorNavMenuID numeric,
    @ParentNavMenuID numeric,
    @RowNum integer
  
  CREATE TABLE #NavMenu
               (NavMenuID numeric,
                SortOrder numeric(28,18),
                NewNavMenuID numeric)
  
  -- We want to figure out which Nav_Menu records need to be copied first.
  -- Loop through all the children and put them in a temp table.
  INSERT INTO #NavMenu
  SELECT NavMenuID, SortOrder, NULL
    FROM Nav_Menu WITH (NOLOCK) 
   WHERE NavMenuID = @InOriginalNavMenuID

  WHILE @@RowCount > 0 BEGIN
    INSERT INTO #NavMenu
    SELECT NavMenuID, SortOrder, NULL
      FROM Nav_Menu WITH (NOLOCK) 
     WHERE ParentNavMenuID IN (SELECT NavMenuID
                                 FROM #NavMenu)
       AND NavMenuID NOT IN (SELECT NavMenuID
                                 FROM #NavMenu)                                
  END

  -- Get all the Nav_Menu records we need to copy:
  DECLARE c_NavMenuToCopy CURSOR FOR 
  SELECT a.NavMenuID,
         b.Title,
         b.CategoryDepth,
         b.AncestorNavMenuID,
         b.ParentNavMenuID
    FROM #NavMenu a, Nav_Menu b WITH (NOLOCK)
   WHERE a.NavMenuID = b.NavMenuID
   ORDER BY b.SortOrder

  SELECT @LowestSortOrder = Max(SortOrder)
    FROM #NavMenu

  SELECT @BelowSortOrder = Min(SortOrder)
    FROM Nav_Menu WITH (NOLOCK)
   WHERE SortOrder > @LowestSortOrder
     AND NavContentGroupInd = (SELECT NavContentGroupInd FROM Nav_Menu WHERE NavMenuID = @InOriginalNavMenuID)

  SELECT @RowNum = COUNT(*)
    FROM #NavMenu

  IF @BelowSortOrder IS NULL
    SET @BelowSortOrder = @LowestSortOrder + @RowNum

  -- Figure out starting sort order and increment.
  SET @SortIncrement = (@BelowSortOrder - @LowestSortOrder) / (@RowNum + 1)
  SET @SortOrder = @LowestSortOrder

  OPEN c_NavMenuToCopy
  FETCH NEXT FROM  c_NavMenuToCopy
        INTO @NavMenuID,
             @Title,
             @CategoryDepth,
             @AncestorNavMenuID,
             @ParentNavMenuID

  WHILE @@FETCH_STATUS = 0 BEGIN

    -- For the first row, add "Copy of" to the title
    IF @NewNavMenuID IS NULL
      SET @Title = 'Copy of ' + @Title

    SET @Title = Left(@Title,255)
    
    EXEC amsp_CMGetUniqueSectionName NULL, @Title, @SectionName OUTPUT

    SET @SortOrder = @SortOrder + @SortIncrement

    -- If the parent is also copied previously, use the new ParentNavMenuID
    IF @ParentNavMenuID IS NOT NULL
      SELECT @ParentNavMenuID = NewNavMenuID
        FROM #NavMenu
       WHERE NavMenuID = @ParentNavMenuID

    -- If the ancestor is also copied previously, use the new ParentNavMenuID
    IF @AncestorNavMenuID IS NOT NULL
      SELECT @AncestorNavMenuID = NewNavMenuID
        FROM #NavMenu
       WHERE NavMenuID = @AncestorNavMenuID

    -- We'd create a record at the end as the 1st level, 
    -- and move it to appropriate position later.
    INSERT INTO Nav_Menu
                (WorkflowStatusCode,
                 HideFlag,
                 NavContentGroupInd,
                 Name,
                 Title,
                 ParentNavMenuID,
                 AncestorNavMenuID,
                 CategoryDepth, 
                 SortOrder,
                 DirectListComboInd,
                 ContentAuthorityGroupID,
                 AuthoritySetManuallyFlag,
                 OwnerContactID,
                 OwnerSetManuallyFlag,
                 ExpirationDays,
                 LastUpdatedByContactID,
                 WebsiteKey,
                 ShowInTopFlag,
                 ShowInSideFlag,
                 MicrositeFlag)
    SELECT 'W',
           HideFlag,
           NavContentGroupInd,
           @SectionName,
           @Title,
           @ParentNavMenuID,
           @AncestorNavMenuID,
           CategoryDepth,
           @SortOrder,
           DirectListComboInd,
           ContentAuthorityGroupID,
           AuthoritySetManuallyFlag,
           OwnerContactID,
           OwnerSetManuallyFlag,
           ExpirationDays,
           @InContactID,
           WebsiteKey,
           ShowInTopFlag,
           ShowInSideFlag,
           MicrositeFlag
      FROM Nav_Menu WITH (NOLOCK)
     WHERE NavMenuID = @NavMenuID

    SELECT @Error = @@Error

    IF @Error <> 0 BEGIN
      RETURN
    END
             
    SET @NewNavMenuID = @@Identity

    -- Save the new NavMenuID
    UPDATE #NavMenu
       SET NewNavMenuID = @NewNavMenuID
     WHERE NavMenuID = @NavMenuID

    -- We want to return the 1st NavMenuID.
    IF @OutNewNavMenuID IS NULL
      SET @OutNewNavMenuID = @NewNavMenuID

    -- If we didn't specify AncestorID on insertion, set it now.
    IF @AncestorNavMenuID IS NULL
      UPDATE Nav_Menu
         SET AncestorNavMenuID = @NewNavMenuID
       WHERE NavMenuID = @NewNavMenuID
    
    INSERT INTO Nav_Menu_Workflow_Log
                (NavMenuID,
                 WorkflowStatusCode,
                 ContactID,
                 ChangeDateTime)
     VALUES (@NewNavMenuID,
             'W',
             @InContactID,
             CURRENT_TIMESTAMP) 

    -- Copy BreadCrumb
    INSERT INTO Nav_Menu_Feature
                (NavMenuID,
                 BreadCrumb)
    SELECT @NewNavMenuID,
           @Title
      FROM Nav_Menu_Feature
     WHERE NavMenuID = @InOriginalNavMenuID

    -- Figure out FilePath, DescendantCount and AncestoryList
    EXEC amsp_CMUpdateNavProperties @NewNavMenuID 

    /* Comment this out until we actually need it 
    -- Copy all the tagged page associated with the original Nav_Menu record
    DECLARE c_CopyContent CURSOR FOR
     SELECT a.ContentID
       FROM  vCurrent_Content a, Content_Link b
      WHERE a.ContentID = b.ContentID
        AND a.NavMenuID = @InOriginalNavMenuID
        AND b.TaggedPageLayoutID IS NOT NULL
        AND a.WorkflowStatusCode IN ('A','P','W','E')
  
    OPEN c_CopyContent
    FETCH NEXT FROM c_CopyContent
     INTO @ContentID  
    
    WHILE @@FETCH_STATUS = 0 BEGIN
      EXEC amsp_CMCopyContentAsNew @ContentID, @InContactID, @NewNavMenuID, NULL
  
      FETCH NEXT FROM c_CopyContent
       INTO @ContentID  
    END
  
    SELECT @Error = @@Error
    IF @Error <> 0 BEGIN
      RETURN
    END
  
    CLOSE c_CopyContent
    DEALLOCATE c_CopyContent
    -- Ends copying all the tagged page.

    */

    FETCH NEXT FROM  c_NavMenuToCopy
          INTO @NavMenuID,
               @Title,
               @CategoryDepth,
               @AncestorNavMenuID,
               @ParentNavMenuID
  END -- Ends looping through Nav_Menu records to copy.

  CLOSE c_NavMenuToCopy
  DEALLOCATE c_NavMenuToCopy

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMRenumCurrentContent]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMRenumCurrentContent]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure updates SortOrder for current content records
-- that is contained in a specified nav menu or content folder.
--
-- Modifications
-- 09/11/2003    E.Tatsui     Created
-- 05/03/2004    E.Tatsui     Removed lines to reset WorkflowStatusCode to W and PublishedDateTime to NULL
--                            for Nav_Menu because it was causing a problem for amsp_CMDeleteContent.
--                            Reset logic seemed to be redundant anyway.
-- =============================================

CREATE  PROCEDURE [dbo].[amsp_CMRenumCurrentContent]
  @InNavMenuID numeric
AS
BEGIN
  DECLARE
    @Counter int,
    @ContentID numeric,
    @SortOrder numeric

  DECLARE c_Contents CURSOR FOR
   SELECT ContentID,
          SortOrder
     FROM vCurrent_Content
    WHERE NavMenuID = @InNavMenuID
    ORDER BY SortOrder

  SET @Counter = 0

  OPEN c_Contents
  FETCH NEXT FROM c_Contents
   INTO @ContentID,
        @SortOrder

  WHILE @@FETCH_STATUS = 0 BEGIN
    SET @Counter = @Counter + 1

    IF @Counter <> @SortOrder BEGIN
      UPDATE Content
         SET SortOrder = @Counter
       WHERE ContentID = @ContentID
      -- If this item is changing to 1st Content, make it a default content.
      -- Also mark the navigation item as "Working" and reset publish date, so that red flag
      -- will show up to notify the administrator to re-publish.
      IF @Counter = 1
        UPDATE Nav_Menu
           SET ContentID = @ContentID,
         WorkflowStatusCode = 'W',
         PublishedDateTime = NULL,
         ComponentCode = 'CM', 
         ComponentScriptCode = 'SC' 
         WHERE NavMenuID = @InNavMenuID
    END

    FETCH NEXT FROM c_Contents
     INTO @ContentID,
          @SortOrder
  END
  CLOSE c_Contents
  DEALLOCATE c_Contents

END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetFuseURL]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetFuseURL]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =======================================================================
-- This stored procedure gets PreFuseURL and PostFuseURL for ContentID
-- or NavMenuID
--
-- Modifications
-- 06/03/2003  E.Tatsui   Created
-- 10/15/2003  E.Tatsui   Added NavContentDisplayPath and FolderContentDisplayPath and used them.
-- =======================================================================

CREATE	PROCEDURE [dbo].[amsp_CMGetFuseURL]
  @InNavMenuID numeric = NULL,
  @InContentID numeric = NULL,
  @OutPreFuseURL varchar(255) OUTPUT,
  @OutPostFuseURL varchar(255) OUTPUT,
  @InPreviewFlag bit = 0
AS
BEGIN
  DECLARE
    @NavContentGroupInd   char(1),
    @CategoryDepth numeric,
    @ContentSecureFlag    char(1),
    @ContentMembersOnlyFlag   char(1),
    @MembersOnlyFlag char(1),
    @ShowInTemplateFlag   char(1),
    @TemplatePath   varchar(255),
    @ContentCount   integer,
    @LinkCount      integer,
    @FileCount      integer,
    @LinkURL      varchar(255),
    @NavMenuID  numeric,
    @Name     varchar(255),
    @PublishLocation    varchar(255),
    @FileSourceLocation   varchar(255),
    @DirectListComboInd   char(1),
    @HTMLContentID    numeric,
    @ContentID      numeric,
    @l_PreFuseURL   varchar(255),
    @l_PostFuseURL    varchar(255),
    @PreFuseURL     varchar(255),
    @PostFuseURL    varchar(255),
    @URLParamChar   char(1),
    @ContentDisplayPath varchar(255),
    @NavContentDisplayPath varchar(255),
    @FolderContentDisplayPath varchar(255),
    @URLSafeName varchar(255),
    @FilePath varchar(255),
    @FileName varchar(255),
    @DestDirectory varchar(255),
    @DefaultFileName varchar(255),
    @DefaultContentID numeric,
    @PreviousContentID numeric,
    @GenerateDefaultFlag char(1),
    @GECodePath varchar(255),
    @VirtualDirectoryPath varchar(255),
    @UseAspNetTemplateFlag char(1),
  @UrlVars varchar(1000),
    @MissingIncludeURL varchar(255)
  
  SELECT @NavMenuID = a.NavMenuID,
         @CategoryDepth = a.CategoryDepth,
         @NavContentGroupInd = a.NavContentGroupInd,
         @DirectListComboInd = a.DirectListComboInd,
         @MembersOnlyFlag = a.MembersOnlyFlag,
         @Name = a.Name,
         @TemplatePath = IsNull(a.TemplatePath,''),
         @FilePath = a.FilePath,
         @NavContentDisplayPath = b.NavContentDisplayPath,
         @FolderContentDisplayPath = b.FolderContentDisplayPath,
         @DefaultFileName = b.DefaultFileName,
         @DefaultContentID = a.ContentID,
         @UseAspNetTemplateFlag = b.UseAspNetTemplateFlag
    FROM Nav_Menu a WITH (NOLOCK), Website b WITH (NOLOCK)
   WHERE NavMenuID = @InNavMenuID
     AND a.WebsiteKey = b.WebsiteKey

  SET @GenerateDefaultFlag = 'N'
  SET @UrlVars = ''

  IF @NavContentGroupInd = 'N'
    SET @ContentDisplayPath = IsNull(@NavContentDisplayPath,'')
  ELSE
    SET @ContentDisplayPath = IsNull(@FolderContentDisplayPath,'')

  SELECT @GECodePath = Value
    FROM System_Variable
   WHERE Name = 'GECodePath'

  SELECT @VirtualDirectoryPath = Value
    FROM System_Variable
   WHERE Name = 'VirtualDirectoryPath'

  IF Len(@GECodePath) > 1
    SET @GECodePath = RIGHT(@GECodePath,Len(@GECodePath)-1)
  ELSE IF @GECodePath = '/'
    SET @GECodePath = ''

  IF Len(@VirtualDirectoryPath) > 1
    SET @VirtualDirectoryPath = RIGHT(@VirtualDirectoryPath,Len(@VirtualDirectoryPath)-1)
  ELSE IF @VirtualDirectoryPath = '/'
    SET @VirtualDirectoryPath = ''

  -- We are running this for a specific ContentID
  IF @InContentID IS NOT NULL BEGIN
    SET @ContentCount = 1
    SELECT @ShowInTemplateFlag = c.ShowInTemplateFlag,
           @PublishLocation = c.PublishLocation,
           @ContentMembersOnlyFlag = c.MembersOnlyFlag,
           @ContentSecureFlag = c.SecureFlag,
           @LinkURL = (SELECT TOP 1 LinkURL
                         FROM Content_Link z WITH (NOLOCK)
                        WHERE z.ContentID = c.ContentID),
        @FileName = (SELECT TOP 1 FileName
                                     FROM Content_File z WITH (NOLOCK)
                                    WHERE z.ContentID = c.ContentID),
           @HTMLContentID = ch.ContentID,
           @LinkCount = (SELECT Count(*) FROM Content_Link WITH (NOLOCK) WHERE ContentID = c.ContentID),
           @FileCount = (SELECT Count(*) FROM Content_File WITH (NOLOCK) WHERE ContentID = c.ContentID),
           @ContentID = c.ContentID,
           @URLSafeName = c.URLSafeName,
           @PreviousContentID = c.PreviousContentID
    FROM Content c WITH (NOLOCK) LEFT OUTER JOIN Content_HTML ch WITH (NOLOCK) 

      ON c.ContentID = ch.ContentID
   WHERE c.ContentID = @InContentID

   IF @NavContentGroupInd = 'N'
      AND (@DefaultContentID = @InContentID OR @PreviousContentID = @DefaultContentID)
     SET @GenerateDefaultFlag = 'Y'

  END
  -- We're running this for already published menu item.
  ELSE BEGIN
    SET @GenerateDefaultFlag = 'Y'
    
    IF @InPreviewFlag = 0
      SELECT @ContentCount = Count(*)
        FROM Content c WITH (NOLOCK)
       WHERE NavMenuID = @InNavMenuID
         AND c.WorkflowStatusCode = 'P'
         AND c.PublishDateTime <= CURRENT_TIMESTAMP 
         AND (c.ExpirationDate >= CURRENT_TIMESTAMP
               OR c.ArchiveAtExpirationFlag IS NULL 
               OR c.ArchiveAtExpirationFlag = 'N')
    ELSE
      SELECT @ContentCount = Count(*)
        FROM vCurrent_Content c WITH (NOLOCK)
       WHERE NavMenuID = @InNavMenuID

    -- Get the default content.
    SELECT @ShowInTemplateFlag = c.ShowInTemplateFlag,
           @PublishLocation = c.PublishLocation,
           @ContentMembersOnlyFlag = c.MembersOnlyFlag,
           @ContentSecureFlag = c.SecureFlag,
           @LinkURL = (SELECT TOP 1 LinkURL
                         FROM Content_Link z
                        WHERE z.ContentID = c.ContentID),
           @FileName = (SELECT TOP 1 FileName
                                     FROM Content_File z
                                    WHERE z.ContentID = c.ContentID),
           @HTMLContentID = ch.ContentID,
           @LinkCount = (SELECT Count(*) FROM Content_Link WITH (NOLOCK) WHERE ContentID = c.ContentID),
           @FileCount = (SELECT Count(*) FROM Content_File WITH (NOLOCK) WHERE ContentID = c.ContentID),
           @ContentID = c.ContentID,
           @URLSafeName = c.URLSafeName
      FROM Content c WITH (NOLOCK) LEFT OUTER JOIN Content_HTML ch WITH (NOLOCK)
        ON c.ContentID = ch.ContentID, Nav_Menu nm WITH (NOLOCK)
     WHERE c.NavMenuID = @InNavMenuID
       AND nm.ContentID = c.ContentID
  END
  
  IF (@NavContentGroupInd = 'N') BEGIN
  IF @UseAspNetTemplateFlag = 'N' BEGIN
    IF @ShowInTemplateFlag = 'Y' OR @ShowInTemplateFlag IS NULL
      SET @l_PreFuseURL = @GECodePath + 'Template.cfm'
    ELSE
      SET @l_PreFuseURL = @GECodePath + 'AMTemplate.cfm'

    SET @l_PreFuseURL = @l_PreFuseURL + '?Section=' + @Name + '&Template='
    SET @URLParamChar = '&'
    END 
  ELSE BEGIN
    SET @UrlVars = @UrlVars + 'Section=' + @Name
    IF @ShowInTemplateFlag = 'Y' OR @ShowInTemplateFlag IS NULL
      SET @l_PreFuseURL = @GECodePath + 'ContentManagerNet/'
    ELSE BEGIN
      SET @l_PreFuseURL = @GECodePath + 'ContentManagerNet/'
      SET @UrlVars = @UrlVars + '&NoTemplate=1'
    END
    SET @URLParamChar = '?'
  END
  SET @DestDirectory = @ContentDisplayPath + @FilePath
  END
  ELSE BEGIN -- Content Folder
    IF (@UseAspNetTemplateFlag = 'N')BEGIN
    SET @l_PreFuseURL = @GECodePath + 'TemplateRedirect.cfm' + '?Template='
    SET @URLParamChar = '&'
  END
    
  ELSE BEGIN -- ASP.NET TEmplate
    SET @l_PreFuseURL = @GECodePath + 'ContentManagerNet/TemplateRedirect.aspx?Template=/ContentManagerNet/'
    SET @URLParamChar = '&'
  END
  SET @DestDirectory =  @ContentDisplayPath + @FilePath
  END

  IF (@InContentID IS NOT NULL)
  SET @DirectListComboInd = 'D'

  /* Prepare Missing Include URL */
  IF @UseAspNetTemplateFlag = 'N'
  SET @MissingIncludeURL = @l_PreFuseURL + '/MissingInclude.htm'
  ELSE
    SET @MissingIncludeURL = @l_PreFuseURL + 'MissingInclude.aspx' + CASE WHEN Len(@UrlVars) > 0 THEN '?' + @UrlVars ELSE '' END

  /*
  ** A nav menu item will either have no, 1, or multiple content records associated with it.
  */

  /* No content to point to. */

  IF (@ContentCount = 0)
    BEGIN
    SET @l_PreFuseURL = @MissingIncludeURL
      SET @l_PostFuseURL = @l_PreFuseURL
    END

  /*
  ** If the default content record or nav menu record is flagged Members Only, 
  ** Pre- and PostFuseURL will go through MembersOnly.cfm.
  */

  ELSE IF ( (@ContentCount = 1 OR @ContentCount > 1) AND 
             (@MembersOnlyFlag = 'Y' OR @ContentMembersOnlyFlag = 'Y') )
  BEGIN
    /* If content is set to display outside template, use AMTemplate.cfm */
  IF(@UseAspNetTemplateFlag = 'N') BEGIN
    IF (@ShowInTemplateFlag = 'N')
    BEGIN
      SET @l_PreFuseURL = @GECodePath + 'AMTemplate.cfm?Section=' + @Name + '&Template=' + '/MembersOnly.cfm&' + 'NavMenuID=' + convert(varchar(10), @NavMenuID) + '&ContentID=' + convert(varchar(10), @ContentID) + '&DirectListComboInd=' + @DirectListComboInd
      SET @l_PostFuseURL = @l_PreFuseURL
    END
    ELSE IF (@ShowInTemplateFlag = 'Y')
    BEGIN -- Not show inside the template.
      SET @l_PreFuseURL = @l_PreFuseURL + '/MembersOnly.cfm' + @URLParamChar + 'NavMenuID=' + convert(varchar(10), @NavMenuID) + '&ContentID=' + convert(varchar(10), @ContentID) + '&DirectListComboInd=' + @DirectListComboInd
      SET @l_PostFuseURL = @l_PreFuseURL
    END
  END
  ELSE BEGIN -- ASP.NET Template
    IF (@ShowInTemplateFlag = 'N')
    BEGIN
      SET @l_PreFuseURL = @GECodePath + 'ContentManagerNet/MembersOnly.aspx?NavMenuID=' + convert(varchar(10), @NavMenuID) + '&ContentID=' + convert(varchar(10), @ContentID) + '&DirectListComboInd=' + @DirectListComboInd + CASE WHEN Len(@UrlVars) > 0 THEN '&' + @UrlVars ELSE '' END
      SET @l_PostFuseURL = @l_PreFuseURL
    END
    ELSE IF (@ShowInTemplateFlag = 'Y')
    BEGIN -- Not show inside the template.
      SET @l_PreFuseURL = @GECodePath + 'ContentManagerNet/MembersOnly.aspx?NavMenuID=' + convert(varchar(10), @NavMenuID) + '&ContentID=' + convert(varchar(10), @ContentID) + '&DirectListComboInd=' + @DirectListComboInd + CASE WHEN Len(@UrlVars) > 0 THEN '&' + @UrlVars ELSE '' END
      SET @l_PostFuseURL = @l_PreFuseURL
    END
  END
  END

  /*
  ** One content record and multiple content records with the DirectListComboInd set to 
  ** "D" are essentially the same. In the latter case, you go directly to the page and

  ** rely on navigation within the text to point to the other content.
  */

  ELSE IF ( (@ContentCount = 1) OR (@ContentCount > 1 AND @DirectListComboInd = 'D') )
  BEGIN

    /* If content record has no related links, files, or HTML, show MissingInclude.htm. */
    IF (@LinkCount = 0 AND @FileCount = 0 AND @HTMLContentID IS NULL)
    BEGIN
      SET @l_PreFuseURL = @MissingIncludeURL
      SET @l_PostFuseURL = @l_PreFuseURL
    END

    /* Single piece of content consists of a link. */
    ELSE IF (@LinkCount = 1 AND @FileCount = 0 AND @HTMLContentID IS NULL)
    BEGIN
      SET @LinkURL = Rtrim(Ltrim(@LinkURL))
      IF (Left(@LinkURL,1) = '/')  AND (CHARINDEX('TEMPLATEREDIRECT.CFM',UPPER(@LinkURL)) =0)
      BEGIN
        IF ((CHARINDEX('SECTION=', UPPER(@LinkURL)) = 0)
			AND (CHARINDEX('.CFM', UPPER(@LinkURL)) != 0 OR CHARINDEX('.HTM', UPPER(@LinkURL)) != 0 OR CHARINDEX('.GIF', UPPER(@LinkURL)) != 0 OR CHARINDEX('.JPG', UPPER(@LinkURL)) != 0 ) 
			AND (@ShowInTemplateFlag = 'Y')) 
        BEGIN
			IF (@UseAspNetTemplateFlag = 'N')
				SET @l_PreFuseURL = @GECodePath + 'Template.cfm' + '?Section=' + @Name + '&Template=' + @LinkURL
			ELSE
				SET @l_PreFuseURL = @GECodePath + 'ContentManagerNet/Default.aspx?Section=' + @Name + '&Template=' + @LinkURL
        END
        ELSE IF ((CHARINDEX('SECTION=', UPPER(@LinkURL)) = 0) 
			AND (CHARINDEX('.CFM', UPPER(@LinkURL)) != 0 OR CHARINDEX('.GIF', UPPER(@LinkURL)) != 0 OR CHARINDEX('.JPG', UPPER(@LinkURL)) != 0 ) 
			AND (@ShowInTemplateFlag = 'N')) 
        BEGIN
			IF (@UseAspNetTemplateFlag = 'N')
				SET @l_PreFuseURL = @GECodePath + 'AMTemplate.cfm?Section=' + @Name + '&Template=' + @LinkURL
			ELSE
				SET @l_PreFuseURL = @GECodePath + 'ContentManagerNet/Default.aspx?Section=' + @Name + '&NoTemplate=1&Template=' + @LinkURL
        END 
		ELSE IF ((CHARINDEX('.ASPX', UPPER(@LinkURL)) != 0))BEGIN
			IF (@UseAspNetTemplateFlag = 'N')
				SET @l_PreFuseURL = @l_PreFuseURL + '/CM/ContentDisplay.cfm' + @URLParamChar + 'ContentID=' + convert(varchar(10), @ContentID)
			ELSE 
				SET @l_PreFuseURL = @l_PreFuseURL + 'ContentDisplay.aspx' + @URLParamChar + 'ContentID=' + convert(varchar(10), @ContentID) + CASE WHEN Len(@UrlVars) > 0 THEN '&' + @UrlVars ELSE '' END
		END
        ELSE BEGIN
           SET @l_PreFuseURL = @LinkURL
        END
      END

      ELSE BEGIN
        IF (Upper(Left(@LinkURL, 4)) = 'HTTP') OR ((CHARINDEX('TEMPLATEREDIRECT.CFM',UPPER(@LinkURL)) != 0))
           SET @l_PreFuseURL = @LinkURL
        ELSE
           SET @l_PreFuseURL = 'http://' + @LinkURL
      END

      /* PostFuseURL will equal the PreFuseURL if content is a link. */
      SET @l_PostFuseURL = @l_PreFuseURL
    END

    /* Single piece of content consists of a file. */
    ELSE IF (@FileCount = 1 AND @LinkCount = 0 AND @HTMLContentID IS NULL)
    BEGIN
      IF (@UseAspNetTemplateFlag = 'N')
    SET @l_PreFuseURL = @l_PreFuseURL + '/CM/ContentDisplay.cfm' + @URLParamChar + 'ContentID=' + convert(varchar(10), @ContentID)
      ELSE 
    SET @l_PreFuseURL = @l_PreFuseURL + 'ContentDisplay.aspx' + @URLParamChar + 'ContentID=' + convert(varchar(10), @ContentID) + CASE WHEN Len(@UrlVars) > 0 THEN '&' + @UrlVars ELSE '' END
      IF @NavContentGroupInd = 'C'
        SET @l_PostFuseURL = @l_PreFuseURL
      --Only when we are figuring out default page for a navigation, set it to generated defaulg page.
      ELSE IF @GenerateDefaultFlag = 'Y' AND @DefaultFileName IS NOT NULL AND @InContentID IS NULL
        SET @l_PostFuseURL = @DestDirectory + @DefaultFileName
      ELSE 
        SET @l_PostFuseURL = @DestDirectory + @FileName
    END

    /* Single piece of content is an HTML record. */
    ELSE IF (@HTMLContentID IS NOT NULL AND @FileCount = 0 AND @LinkCount = 0) BEGIN
    IF(@UseAspNetTemplateFlag = 'N')
    SET @l_PreFuseURL = @l_PreFuseURL + '/CM/HTMLDisplay.cfm' + @URLParamChar + 'ContentID=' + convert(varchar(10), @HTMLContentID)
      ELSE
    SET @l_PreFuseURL = @l_PreFuseURL + 'HTMLDisplay.aspx' + @URLParamChar + 'ContentID=' + convert(varchar(10), @HTMLContentID) + CASE WHEN Len(@UrlVars) > 0 THEN '&' + @UrlVars ELSE '' END
    IF @NavContentGroupInd = 'C'
        SET @l_PostFuseURL = @l_PreFuseURL
      -- Only if we are generating default file for single piece of content (not the one for combo or list),
      -- use default name.
      ELSE IF @GenerateDefaultFlag = 'Y' AND @DefaultFileName IS NOT NULL AND @DirectListComboInd = 'D'
        SET @l_PostFuseURL = @DestDirectory + @DefaultFileName
      ELSE
        SET @l_PostFuseURL = @DestDirectory + @URLSafeName + '.htm'
    END
    
    /* Single piece of content is a mix of links, files, and/or HTML. */
    ELSE BEGIN
    IF @UseAspNetTemplateFlag = 'N'
    SET @l_PreFuseURL = @l_PreFuseURL + '/CM/ContentDisplay.cfm' + @URLParamChar + 'ContentID=' + convert(varchar(10), @ContentID)
      ELSE
    SET @l_PreFuseURL = @l_PreFuseURL + 'ContentDisplay.aspx' + @URLParamChar + 'ContentID=' + convert(varchar(10), @ContentID) + CASE WHEN Len(@UrlVars) > 0 THEN '&' + @UrlVars ELSE '' END
      IF @NavContentGroupInd = 'C'
        SET @l_PostFuseURL = @l_PreFuseURL
      ELSE IF @GenerateDefaultFlag = 'Y' AND @DefaultFileName IS NOT NULL
        SET @l_PostFuseURL = @DestDirectory + @DefaultFileName
      ELSE
        SET @l_PostFuseURL = @DestDirectory + @URLSafeName + '.htm'

    END
  END -- ENDS @DirectListComboInd = 'D'

  /* Multiple content records and DirectListComboInd set to "C". */
  ELSE IF (@ContentCount > 1 AND @DirectListComboInd = 'C')
  BEGIN
    /* If content record has no related links, files, or HTML, show MissingInclude.htm. */
    IF (@LinkCount = 0 AND @FileCount = 0 AND @HTMLContentID IS NULL)
    BEGIN
    SET @l_PreFuseURL = @MissingIncludeURL
      SET @l_PostFuseURL = @l_PreFuseURL
    END
    ELSE BEGIN
    IF @UseAspNetTemplateFlag = 'N'
    SET @l_PreFuseURL = @l_PreFuseURL + '/CM/ContentCombo.cfm' + @URLParamChar + 'NavMenuID=' + convert(varchar(10), @NavMenuID) + '&ContentID=' + convert(varchar(10), @ContentID)
    ELSE 
        SET @l_PreFuseURL = @l_PreFuseURL + 'ContentCombo.aspx' + @URLParamChar + 'NavMenuID=' + convert(varchar(10), @NavMenuID) + '&ContentID=' + convert(varchar(10), @ContentID) + (CASE WHEN Len(@UrlVars) > 0 THEN '&' + @UrlVars ELSE '' END)
      IF @NavContentGroupInd = 'C'
        SET @l_PostFuseURL = @l_PreFuseURL
      ELSE IF @GenerateDefaultFlag = 'Y' AND @DefaultFileName IS NOT NULL
        SET @l_PostFuseURL = @DestDirectory + @DefaultFileName
      ELSE
        SET @l_PostFuseURL = @DestDirectory + 'Default' + CONVERT(varchar(20),@InNavMenuID) + '.htm'
    END
  END

  /* Multiple content records and DirectListComboInd set to "L". */
  ELSE IF (@ContentCount > 1 AND @DirectListComboInd = 'L')
  BEGIN
    /* If content record has no related links, files, or HTML, show MissingInclude.htm. */
    IF (@LinkCount = 0 AND @FileCount = 0 AND @HTMLContentID IS NULL)
    BEGIN
      SET @l_PreFuseURL = @MissingIncludeURL
      SET @l_PostFuseURL = @l_PreFuseURL
    END
    ELSE BEGIN
      IF @UseAspNetTemplateFlag = 'N'
    SET @l_PreFuseURL = @l_PreFuseURL + '/CM/ContentList.cfm' + @URLParamChar + 'NavMenuID=' + convert(varchar(10), @NavMenuID)
      ELSE
        SET @l_PreFuseURL = @l_PreFuseURL + 'ContentList.aspx' + @URLParamChar + 'NavMenuID=' + convert(varchar(10), @NavMenuID) + '&' + @UrlVars
      IF @GenerateDefaultFlag = 'Y' AND @DefaultFileName IS NOT NULL
        SET @l_PostFuseURL = @DestDirectory + @DefaultFileName
      ELSE
        SET @l_PostFuseURL = @DestDirectory + 'Default' + CONVERT(varchar(20),@InNavMenuID) + '.htm'
    END
  END
  
  IF(@UseAspNetTemplateFlag = 'Y' AND CHARINDEX('templateredirect',LOWER(@l_PostFuseURL)) = 0 AND CHARINDEX('.aspx',LOWER(@l_PostFuseURL)) > 0 AND LEFT(@l_PostFuseURL,LEN(@VirtualDirectoryPath)) = @VirtualDirectoryPath)
  BEGIN
    IF (@VirtualDirectoryPath <> '')
      SET @l_PostFuseURL = @VirtualDirectoryPath + '/' + @Name + SUBSTRING(@l_PostFuseURL,LEN(@VirtualDirectoryPath) + 1, LEN(@l_PostFuseURL) - LEN(@VirtualDirectoryPath))
    ELSE
      SET @l_PostFuseURL = '/' + @Name + '/' + @l_PostFuseURL
  END
  
  IF LEFT(@l_PostFuseURL,1) = '/'
	SET @l_PostFuseURL = SUBSTRING(@l_PostFuseURL,2,Len(@l_PostFuseURL)-1)

  IF LEFT(@l_PreFuseURL,1) = '/'
	SET @l_PreFuseURL = SUBSTRING(@l_PreFuseURL,2,Len(@l_PreFuseURL)-1)

  SET @OutPreFuseURL = @l_PreFuseURL
  SET @OutPostFuseURL = @l_PostFuseURL

END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetNavMenuToRegenerate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetNavMenuToRegenerate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This procedure figures out which menu items need to be regenerated 
-- when item specified as @InNavMenuID is changed.
--
-- Modifications
-- 06/19/2003  E.Tatsui   Created
-- =============================================

CREATE                    PROCEDURE amsp_CMGetNavMenuToRegenerate
  @InNavMenuID numeric
AS
  DECLARE 
    @MinDepth numeric,
    @NavMenuID numeric,
    @PostFuseURL varchar(255)

  CREATE TABLE #Changed (NavMenuID numeric, ParentNavMenuID numeric, CategoryDepth numeric, PostFuseURL varchar(255))

  if object_id('tempdb..#Regenerate') is null
    CREATE TABLE #Regenerate (NavMenuID numeric)

  -- First put in our boy 
  INSERT INTO #Changed(NavMenuID, ParentNavMenuID, CategoryDepth)
  SELECT a.NavMenuID, a.ParentNavMenuID, a.CategoryDepth
    FROM Nav_Menu a WITH (NOLOCK)
   WHERE a.NavMenuID = @InNavMenuID
  
  -- then, let's go down from here to get all descendants
  WHILE @@RowCount > 0
    INSERT INTO #Changed(NavMenuID, ParentNavMenuID, CategoryDepth)
    SELECT b.NavMenuID, b.ParentNavMenuID, b.CategoryDepth
      FROM #Changed a, Nav_Menu b WITH (NOLOCK) LEFT OUTER JOIN #Changed c
        ON b.NavMenuID = c.NavMenuID
     WHERE a.NavMenuID = b.ParentNavMenuID
       AND c.NavMenuID IS NULL
       AND b.WorkflowStatusCode = 'P'

  -- make sure we start with @@Rowcount > 0, even if our boy had no descendants
  SELECT @MinDepth = 1

  -- and then, as long as we are getting records, let's go directly back up
  WHILE @@RowCount > 0
    INSERT INTO #Changed(NavMenuID, ParentNavMenuID, CategoryDepth)
    SELECT b.NavMenuID, b.ParentNavMenuID, b.CategoryDepth
      FROM #Changed a, Nav_Menu b WITH (NOLOCK) LEFT OUTER JOIN #Changed c
        ON b.NavMenuID = c.NavMenuID
     WHERE (b.NavMenuID = a.ParentNavMenuID OR b.ParentNavMenuID = a.ParentNavMenuID)
       AND c.NavMenuID IS NULL
       AND (b.WorkflowStatusCode = 'P' OR b.WorkflowStatusCode = 'D')

  -- now, we have a table of all of the items that could have changed. Find the highest level item
  -- (lowest depth) that changed according to the Nav_Menu_Log
  -- Note: Include WorkflowStatusCode = 'D' so that if one nav item is about to be deleted,
  -- we can regenerate items affected by the deletion.
  SELECT @MinDepth = IsNULL(Min(a.CategoryDepth), 999)
    FROM Nav_Menu a WITH (NOLOCK), #Changed b LEFT OUTER JOIN Nav_Menu_Setup_Log c WITH (NOLOCK)
      ON b.NavMenuID = c.NavMenuID
   WHERE a.NavMenuID = b.NavMenuID
     AND (a.Name != IsNull(c.Name, '') 
      OR a.Title != IsNull(c.Title, '')
      OR a.ParentNavMenuID != IsNull(c.ParentNavMenuID, 0)
      OR a.AncestorNavMenuID != IsNull(c.AncestorNavMenuID, 0)
      OR a.CategoryDepth != IsNull(c.CategoryDepth, 0)
      OR IsNULL(a.MembersOnlyFlag, '') != IsNull(c.MembersOnlyFlag, '')
      OR IsNull(a.PostFuseURL,'') != IsNull(c.PostFuseURL, '') 
      OR IsNull(a.FilePath,'') != IsNull(c.FilePath,'')
      OR a.WorkflowStatusCode = 'D')

  -- ok, so now that we have the lowest depth, we can get the parent of that guy (or
  -- that guy if he is the ultimate ancestor), then get everyone on down.
  INSERT INTO #Regenerate
  SELECT DISTINCT ISNULL(ParentNavMenuID, NavMenuID) AS NavMenuID
    FROM #Changed
   WHERE CategoryDepth = @MinDepth
     
  -- then, as long as we are getting records, let's keep going down
  WHILE @@RowCount > 0
	
  BEGIN
    INSERT INTO #Regenerate(NavMenuID)
    SELECT b.NavMenuID
      FROM #Regenerate a, Nav_Menu b WITH (NOLOCK) LEFT OUTER JOIN #Regenerate c
        ON b.NavMenuID = c.NavMenuID
           LEFT OUTER JOIN #Changed d
        ON b.NavMenuID = d.NavMenuID
     WHERE a.NavMenuID = b.ParentNavMenuID
       AND c.NavMenuID IS NULL
       AND b.WorkflowStatusCode = 'P'
  END

  BEGIN TRANSACTION

    DELETE Nav_Menu_Setup_Log
      FROM Nav_Menu_Setup_Log a, #Regenerate b
     WHERE a.NavMenuID = b.NavMenuID

    INSERT INTO Nav_Menu_Setup_Log (
           NavMenuID,
           Name,
           Title,
           ParentNavMenuID,
           AncestorNavMenuID,
           CategoryDepth,
           MembersOnlyFlag,
           PostFuseURL,
           FilePath)
    SELECT a.NavMenuID,
           a.Name,
    	     a.Title,
           a.ParentNavMenuID,
           IsNull(a.AncestorNavMenuID, a.NavMenuID),
           a.CategoryDepth,
           a.MembersOnlyFlag,
           a.PostFuseURL,
           a.FilePath
      FROM Nav_Menu a WITH (NOLOCK), #Regenerate b
     WHERE a.NavMenuID = b.NavMenuID

  COMMIT TRANSACTION

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMRequestPublish]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMRequestPublish]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure inserts a record to Publish_Request table to request content
-- to be published by publishing server.
--
-- Modificaitons
-- 06/12/2003    E.Tatsui      Created
-- =============================================

CREATE                 PROCEDURE [dbo].[amsp_CMRequestPublish]
	@InNavMenuID numeric = NULL,
  @InWebsiteKey uniqueidentifier = NULL,
  @InContactID numeric,
  @InPublishDescendants char(1) = 'N',
  @InForcePublishFlag char(1) = 'N',
  @InPublishRegenerateInd char(1) = 'P',
  @InMicrositeID numeric = 0,
  @InPublishRequestID numeric = NULL,
  @OutPublishRequestID numeric OUTPUT
AS
BEGIN

  IF @InNavMenuID IS NULL AND @InWebsiteKey IS NULL
    RAISERROR('Either NavMenuID or WebsiteKey is required', 16,1)  

  DECLARE
    @PublishRequestID numeric,
    @NavMenuID numeric,
    @WebsiteKey uniqueidentifier,
    @ContentID numeric,
    @PublishFrequency integer,
    @MinSort numeric(28,18),
    @MaxSort numeric(28,18),
    @PreFuseURL varchar(255),
    @PostFuseURL varchar(255),
    @NewPreFuseURL varchar(255),
    @NewPostFuseURL varchar(255),
    @NavContentGroupInd char(1),
    @ContentCount integer,
    @PreviousWebsiteKey uniqueidentifier,
    @SuperUserFlag bit

  -- First, find out if this user is a member of a super group as a nav creator or editor.
  SET @SuperUserFlag = 0
  SELECT @SuperUserFlag = 1
    FROM Content_Authority_Group a WITH (NOLOCK), Content_Authority_Producer b WITH (NOLOCK)
   WHERE a.ContentAuthorityGroupID = b.ContentAuthorityGroupID
     AND b.ContactID = @InContactID
     AND (b.NavCreatorFlag = 'Y' OR b.NavEditorFlag = 'Y')
     AND a.SuperGroupFlag = 'Y'

  SELECT @NavContentGroupInd = NavContentGroupInd,
         @WebsiteKey = WebsiteKey
    FROM Nav_Menu WITH (NOLOCK)
   WHERE NavMenuID = @InNavMenuID

  -- If PublishRequestID is not passed in, create a new request.
  IF @InPublishRequestID IS NULL BEGIN
    INSERT INTO Publish_Request
                (ContactID,
                 RequestDateTime,
                 NavMenuID)
    VALUES (@InContactID,
            CURRENT_TIMESTAMP,
            @InNavMenuID)
  
    SET @PublishRequestID = @@Identity
  END
  ELSE
    SET @PublishRequestID = @InPublishRequestID

  -- When this is publishing process.
  IF @InPublishRegenerateInd = 'P' BEGIN
    -- Build a temp table which holds all the nav items to publish.
    CREATE TABLE #NavMenu
                 (NavMenuID numeric,
                  SortOrder numeric(28,18),
                  ContentID numeric,
                  FilePath varchar(255),
                  WebsiteKey uniqueidentifier,
                  PreviousWebsiteKey uniqueidentifier,
                  MicrositeFlag char(1))

    -- When NavMenuID is specified.
    IF @InNavMenuID IS NOT NULL BEGIN
      -- Add the actual item that was specified.
      INSERT INTO #NavMenu
      SELECT NavMenuID,
             SortOrder,
             ContentID,
             FilePath,
             WebsiteKey,
             PreviousWebsiteKey,
             MicrositeFlag
        FROM Nav_Menu WITH (NOLOCK)
       WHERE NavMenuID = @InNavMenuID
    
      -- If decendants need to be published also, add them to the temp table.
      IF @InPublishDescendants = 'Y' BEGIN
        SELECT @MinSort = a.SortOrder,
               @MaxSort = (SELECT IsNull(Min(x.SortOrder),0)
                             FROM Nav_Menu x WITH (NOLOCK)
                             WHERE x.SortOrder > a.SortOrder
                               AND x.CategoryDepth <= a.CategoryDepth)
          FROM Nav_Menu a  WITH (NOLOCK)
         WHERE a.NavMenuID = @InNavMenuID
        -- Super user can publish anything.
        IF @SuperUserFlag = 1
          INSERT INTO #NavMenu
          SELECT a.NavMenuID,
                 a.SortOrder,
                 a.ContentID,
                 a.FilePath,
                 a.WebsiteKey,
                 a.PreviousWebsiteKey,
                 a.MicrositeFlag
            FROM Nav_Menu a WITH (NOLOCK)
           WHERE a.SortOrder > @MinSort
             AND a.SortOrder < @MaxSort
           ORDER BY a.SortOrder
        ELSE 
          -- We only care about the ones this user has permission to publish.
          INSERT INTO #NavMenu
          SELECT a.NavMenuID,
                 a.SortOrder,
                 a.ContentID,
                 a.FilePath,
                 a.WebsiteKey,
                 a.PreviousWebsiteKey,
                 a.MicrositeFlag
            FROM Nav_Menu a WITH (NOLOCK), Content_Authority_Producer b WITH (NOLOCK)
           WHERE a.ContentAuthorityGroupID = b.ContentAuthorityGroupID
             AND b.ContactID = @InContactID
             AND (b.NavCreatorFlag = 'Y' OR b.NavEditorFlag = 'Y')
             AND a.SortOrder > @MinSort
             AND a.SortOrder < @MaxSort
           ORDER BY a.SortOrder
        END   
    END -- Ends when NavMenuID is specified

    ELSE BEGIN-- When WebsiteKey is specified
      INSERT INTO #NavMenu
      SELECT NavMenuID,
             SortOrder,
             ContentID,
             FilePath,
             WebsiteKey,
             PreviousWebsiteKey,
             MicrositeFlag
        FROM Nav_Menu WITH (NOLOCK)
       WHERE WebsiteKey = @InWebsiteKey
         AND NavContentGroupInd = 'N'
      ORDER BY SortOrder
    END

    -- For alll these nav items, let's update the status.
    -- if it's not in Published status yet.
    UPDATE a
       SET WorkflowStatusCode = 'P',
           PublishedDateTime = CURRENT_TIMESTAMP,
           PublishedFlag = 'Y',
           ReminderSentDateTime = NULL,
           LastUpdatedByContactID = @InContactID
      FROM Nav_Menu a, #NavMenu b
     WHERE a.NavMenuID = b.NavMenuID
       AND a.WorkflowStatusCode <> 'P'

    INSERT INTO Nav_Menu_Workflow_Log (
           NavMenuID,
           ContactID,
           WorkflowStatusCode,
           ChangeDateTime)
    SELECT a.NavMenuID,
           @InContactID,
           'P',
           CURRENT_TIMESTAMP
      FROM #NavMenu a, Nav_Menu b WITH (NOLOCK)
     WHERE a.NavMenuID = b.NavMenuID
       AND b.WorkflowStatusCode <> 'P'

    /*  At this point we want to get the content records that are either:
        1) A content Record that is in the 'A'pproved status for a Nav Item being published, or
        2) The default content Record that is in the 'P'ublished status with no new version in 'A'pproved status
          OR if attributes.ForcePublish EQ "Yes" then all content records, not just the default.
        3) A content Record in the 'W'orking status for a MicroSite
      For each Nav Item, Sort will ensure the non-default records are published first. */
  
    DECLARE c_ContentRecords CURSOR FOR
    SELECT a.NavMenuID,
           a.WebsiteKey,
           a.PreviousWebsiteKey,
           b.ContentID,
           b.PublishFrequency,
           b.PreFuseURL,
           b.PostFuseURL
      FROM (Content b WITH (NOLOCK) LEFT OUTER JOIN Nav_Menu c WITH (NOLOCK) 
        ON b.ContentID = c.ContentID), #NavMenu a WITH (NOLOCK)
     WHERE a.NavMenuID = b.NavMenuID
       AND ( b.WorkflowStatusCode = 'A'
             OR ( b.WorkflowStatusCode = 'P'
                   AND ISNULL(a.MicrositeFlag, 'N') = 'N'
                 AND 1 = CASE WHEN @InForcePublishFlag ='N' AND c.ContentID IS NULL AND a.PreviousWebsiteKey IS NULL THEN 0
                     ELSE 1 END 
                 AND NOT EXISTS ( SELECT 1
                                    FROM Content x WITH (NOLOCK)
                                   WHERE x.PreviousContentID = b.ContentID
                                     AND x.WorkflowStatusCode = 'A' )
               )
             OR ( b.WorkflowStatusCode = 'W' AND
                 a.MicrositeFlag = 'Y'
               )
            )
     ORDER BY a.SortOrder, IsNULL(c.ContentID, 0)

  END
  -- Regenerating content that have been affected by a change.
  ELSE BEGIN
    CREATE TABLE #Regenerate (NavMenuID numeric)
  
    EXEC amsp_CMGetNavMenuToRegenerate @InNavMenuID

    /* Let's get all the content records in the 'P'ublished status.  It is important 
       to get the non-default records first so when we publish the List or Combo 
       default records, the links/titles for the non-default records will be correct. */
    DECLARE c_ContentRecords CURSOR FOR
    SELECT n.NavMenuID, 
           n.WebsiteKey,
           n.PreviousWebsiteKey,
           b.ContentID,
           b.PublishFrequency,
           b.PreFuseURL,
           b.PostFuseURL
      FROM (Content b WITH (NOLOCK) LEFT OUTER JOIN Nav_Menu c WITH (NOLOCK) 
        ON b.ContentID = c.ContentID)
      LEFT OUTER JOIN Content x WITH (NOLOCK)
        ON b.ContentID = x.PreviousContentID, Nav_Menu n WITH (NOLOCK)
     WHERE b.NavMenuID = n.NavMenuID
       AND b.WorkflowStatusCode = 'P'
       AND n.NavMenuID IN (SELECT NavMenuID FROM #Regenerate)
       AND x.ContentID IS NULL
     ORDER BY n.SortOrder, IsNULL(c.ContentID, 0)
  END


  OPEN c_ContentRecords

  FETCH NEXT FROM c_ContentRecords
   INTO @NavMenuID,
        @WebsiteKey,
        @PreviousWebsiteKey,
        @ContentID,
        @PublishFrequency,
        @PreFuseURL,
        @PostFuseURL

  WHILE @@FETCH_STATUS = 0 BEGIN

    -- Make sure PreFuseURL and PostFuseURL is up to date.
    EXEC amsp_CMGetFuseURL @NavMenuID, @ContentID, @NewPreFuseURL OUTPUT, @NewPostFuseURL OUTPUT

    IF IsNull(@NewPreFuseURL,'') <> IsNull(@PreFuseURL,'') 
       OR IsNull(@NewPostFuseURL,'') <> IsNull(@PostFuseURL,'') BEGIN
      UPDATE Content
         SET PreFuseURL = @NewPreFuseURL,
             PostFuseURL = @NewPostFuseURL
       WHERE ContentID = @ContentID
    END
    -- Publishing server for navigation items are determined by the Website.
    INSERT INTO Publish_Request_Detail
                (PublishRequestID,
                 ContentID,
                 PublishRegenerateInd,
                 PublishServerCode,
                 Frequency,
                 WebsiteKey)
    SELECT @PublishRequestID,
           @ContentID,
           @InPublishRegenerateInd,
           a.PublishServerCode,
           IsNull(@PublishFrequency,0) * 3600,
           a.WebsiteKey
      FROM Website a WITH (NOLOCK) LEFT OUTER JOIN Publish_Request_Detail x WITH (NOLOCK)
        ON a.WebsiteKey = x.WebsiteKey
       AND x.ContentID = @ContentID
       AND (x.PublishRequestStatusCode = 'N' OR x.Frequency > 0)
       AND x.PublishRegenerateInd = @InPublishRegenerateInd
     WHERE a.WebsiteKey = @WebsiteKey
       AND x.PublishRequestDetailID IS NULL

   -- If website key has been changed since the last publish, create another line
   -- to delete old files.
   IF @PreviousWebsiteKey IS NOT NULL AND @PreviousWebsiteKey <> @WebsiteKey BEGIN
      DELETE FROM Publish_Request_Detail
       WHERE WebsiteKey = @PreviousWebsiteKey
         AND ContentID = @ContentID
  
      INSERT INTO Publish_Request_Detail
                  (PublishRequestID,
                   ContentID,
                   PublishRegenerateInd,
                   PublishServerCode,
                   Frequency,
                   WebsiteKey,
                   DeleteFlag)
      SELECT @PublishRequestID,
             @ContentID,
             @InPublishRegenerateInd,
             PublishServerCode,
             0,
             WebsiteKey,
             'Y'
        FROM Website a WITH (NOLOCK)
       WHERE WebsiteKey = @PreviousWebsiteKey
    END
    /*  Commented out. Might be used in future versions.
    --Content from bucket may be published to more than 1 servers.
    ELSE BEGIN
      INSERT INTO Publish_Request_Detail
                  (PublishRequestID,
                   ContentID,
                   PublishRegenerateInd,
                   PublishServerCode,
                   Frequency)
      SELECT @PublishRequestID,
             @ContentID,
             @InPublishRegenerateInd,
             PublishServerCode,
             CASE WHEN @InPublishRegenerateInd = 'R' THEN 0
             ELSE IsNull(@PublishFrequency,0) * 3600 END
        FROM Content_Publish_Server a 
       WHERE ContentID = @ContentID
         AND NOT EXISTS (SELECT 1
                           FROM Publish_Request_Detail x
                          WHERE ContentID = @ContentID
                            AND (PublishedDateTime IS NULL OR Frequency > 0)
                            AND x.PublishServerCode = a.PublishServerCode
                            AND x.PublishRegenerateInd = @InPublishRegenerateInd)
       ORDER BY a.DefaultServerFlag DESC
    END      
    */
    FETCH NEXT FROM c_ContentRecords
     INTO @NavMenuID,
          @WebsiteKey,
          @PreviousWebsiteKey,
          @ContentID,
          @PublishFrequency,
          @PreFuseURL,
          @PostFuseURL

  END -- End while loop

  CLOSE c_ContentRecords
  DEALLOCATE c_ContentRecords  

  
  IF @InPublishRegenerateInd = 'P' BEGIN

    -- Let's also update PreFuseURL and PostFuseURL.
    DECLARE c_MenuItems CURSOR FOR
    SELECT a.NavMenuID,
           (SELECT Count(*)
              FROM Content b WITH (NOLOCK), Publish_Request_Detail c WITH (NOLOCK)
             WHERE a.NavMenuID = b.NavMenuID
               AND b.ContentID = c.ContentID
               AND c.PublishRequestID = @PublishRequestID)
      FROM #NavMenu a WITH (NOLOCK)

    OPEN c_MenuItems

    FETCH NEXT FROM c_MenuItems
     INTO @NavMenuID,
          @ContentCount
    
    WHILE @@FETCH_STATUS = 0 BEGIN
      EXEC amsp_CMGetFuseURL @NavMenuID, DEFAULT, @NewPreFuseURL OUTPUT, @NewPostFuseURL OUTPUT

      -- If there are no content associated with the nav item, update PostURL too.
      UPDATE Nav_Menu
         SET PreFuseURL = @NewPreFuseURL,
             PostFuseURL = CASE WHEN @ContentCount = 0 THEN @NewPostFuseURL
                           ELSE PostFuseURL END
       WHERE NavMenuID = @NavMenuID
      
      -- If no content is associated, see if we need to regenerate any nav items.
      IF @ContentCount = 0
        EXECUTE amsp_CMRequestPublish @NavMenuID, NULL, @InContactID, 'N', 'Y', 'R', DEFAULT, @PublishRequestID, NULL

      FETCH NEXT FROM c_MenuItems
       INTO @NavMenuID,
            @ContentCount
    END

    CLOSE c_MenuItems
    DEALLOCATE c_MenuItems
  END

  SET @OutPublishRequestID = @PublishRequestID
END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMRequestPublishContent]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMRequestPublishContent]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- Request individual content to be published.
--
-- Modifications
-- 07/11/2003  E.Tatsui
-- =============================================

CREATE                          PROCEDURE [dbo].[amsp_CMRequestPublishContent]
  @InContentID numeric,
  @InContactID numeric,
  @OutPublishRequestID numeric OUTPUT
AS
BEGIN

  DECLARE
  @NavContentGroupInd char(1),
  @PublishFrequency int,
  @PublishRequestID numeric,
  @WebsiteKey uniqueidentifier,
  @PreviousWebsiteKey uniqueidentifier,
  @PreFuseURL varchar(255),
  @PostFuseURL varchar(255),
  @NewPreFuseURL varchar(255),
  @NewPostFuseURL varchar(255),
  @NavMenuID numeric,
  @WorkflowStatusCode char(1),
  @HTMLContentID numeric,
  @FileCount numeric,
  @LinkCount numeric
  
  SELECT @NavContentGroupInd = b.NavContentGroupInd,
         @PublishFrequency = a.PublishFrequency,
         @WebsiteKey = b.WebsiteKey,
         @PreviousWebsiteKey = b.PreviousWebsiteKey,
         @PreFuseURL = a.PreFuseURL,
         @PostFuseURL = a.PostFuseURL,
         @NavMenuID = b.NavMenuID,
         @WorkflowStatusCode = a.WorkflowStatusCode,
         @HTMLContentID = ch.ContentID,
         @FileCount = (SELECT COUNT(*) FROM Content_File x WITH (NOLOCK) WHERE x.ContentID = a.ContentID),
         @LinkCount = (SELECT COUNT(*) FROM Content_Link x WITH (NOLOCK) WHERE x.ContentID = a.ContentID)
    FROM Content a WITH (NOLOCK) 
    LEFT OUTER JOIN Content_HTML ch WITH (NOLOCK)
      ON a.ContentID = ch.ContentID, Nav_Menu b WITH (NOLOCK)
   WHERE a.NavMenuID = b.NavMenuID
     AND a.ContentID = @InContentID

  INSERT INTO Publish_Request
              (ContactID,
               RequestDateTime)
  VALUES (@InContactID,
          CURRENT_TIMESTAMP)

  -- Make sure PreFuseURL is up to date.
  EXEC amsp_CMGetFuseURL @NavMenuID, @InContentID, @NewPreFuseURL OUTPUT, @NewPostFuseURL OUTPUT

  IF @WorkflowStatusCode IN ('P','A') AND
     (IsNull(@NewPreFuseURL,'') <> IsNull(@PreFuseURL,'') 
       OR IsNull(@NewPreFuseURL,'') <> IsNull(@PostFuseURL,'')) BEGIN
    UPDATE Content
       SET PreFuseURL = @NewPreFuseURL,
           PostFuseURL = @NewPostFuseURL
     WHERE ContentID = @InContentID
  END

  SELECT @PublishRequestID = @@Identity

  -- Insert this request as long it's not already there.
  IF @HTMLContentID IS NOT NULL OR @FileCount > 0 OR @LinkCount > 0 BEGIN
    INSERT INTO Publish_Request_Detail
              (PublishRequestID,
               ContentID,
               PublishRegenerateInd,
               PublishServerCode,
               Frequency,
               WebsiteKey)
    SELECT @PublishRequestID,
           @InContentID,
           'P',
           a.PublishServerCode,
           IsNull(@PublishFrequency,0) * 3600,
           @WebsiteKey
      FROM Website a WITH (NOLOCK) LEFT OUTER JOIN Publish_Request_Detail x WITH (NOLOCK)
        ON x.ContentID = @InContentID
       AND (x.PublishRequestStatusCode = 'N' OR x.Frequency > 0)
       AND x.WebsiteKey = a.WebsiteKey
       AND x.PublishRegenerateInd = 'P'
       AND x.PublishRequestStatusCode = 'N'
     WHERE a.WebsiteKey = @WebsiteKey
       AND x.PublishRequestDetailID IS NULL
  END

  IF @PreviousWebsiteKey IS NOT NULL AND @PreviousWebsiteKey <> @WebsiteKey BEGIN
    DELETE FROM Publish_Request_Detail
     WHERE WebsiteKey = @PreviousWebsiteKey
       AND ContentID = @InContentID

    INSERT INTO Publish_Request_Detail
              (PublishRequestID,
               ContentID,
               PublishRegenerateInd,
               PublishServerCode,
               Frequency,
               WebsiteKey,
               DeleteFlag)
    SELECT @PublishRequestID,
           @InContentID,
           'P',
           PublishServerCode,
           0,
           @PreviousWebsiteKey,
           'Y'
      FROM Website a WITH (NOLOCK)
     WHERE WebsiteKey = @PreviousWebsiteKey

  END

  /* Commented out for now. Might be used in future releases.
  ELSE BEGIN -- @NavContentGroupInd = 'C' 
    INSERT INTO Publish_Request_Detail
                (PublishRequestID,
                 ContentID,
                 PublishRegenerateInd,
                 PublishServerCode,
                 Frequency)
    SELECT @PublishRequestID,
           @InContentID,
           'P',
           PublishServerCode,
           IsNull(@PublishFrequency,0) * 3600
      FROM Content_Publish_Server a 
     WHERE ContentID = @InContentID
       AND NOT EXISTS (SELECT 1
                         FROM Publish_Request_Detail x
                        WHERE ContentID = @InContentID
                          AND (PublishedDateTime IS NULL OR Frequency > 0)
                          AND x.PublishServerCode = a.PublishServerCode
                          AND x.PublishRegenerateInd = 'P')
    
  END  */

  SET @OutPublishRequestID = @PublishRequestID
END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMDeleteContent]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMDeleteContent]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This procedure deletes specified content record from Content management system.
--
-- Modifications
-- 07/11/2003    E.Tatsui
-- 03/23/2004    E.Tatsui   Moved update statement to reset Default Content ID for a nav item
--                          to the end, because it shouldn't be run for "Revert" action.
-- =============================================

CREATE                                   PROCEDURE [dbo].[amsp_CMDeleteContent]
  @InContentID numeric,
  @InContactID numeric,
  @InRevertToPublishVerFlag char(1) = 'N',
  @OutPreviousContentID numeric OUTPUT
AS

BEGIN

  DECLARE
    @WorkflowStatusCode char(1),
    @PreviousContentID numeric,
    @DeletedFlag char(1),
    @NewDefaultContentID numeric,
    @NavMenuID numeric,
    @SortOrder numeric,
    @PreviousSortOrder numeric,
    @PreviousNavMenuID numeric,
    @NavContentGroupInd char(1),
    @DefaultContentID numeric,
    @RepublishNavItem bit

  SET @DeletedFlag = 'N'
  SET @RepublishNavItem = 0

  SELECT @WorkflowStatusCode = a.WorkflowStatusCode,
         @PreviousContentID = a.PreviousContentID,
         @NavMenuID = a.NavMenuID,
         @SortOrder = a.SortOrder,
         @NavContentGroupInd = b.NavContentGroupInd,
         @DefaultContentID = b.ContentID
    FROM Content a WITH (NOLOCK), Nav_Menu b WITH (NOLOCK)
   WHERE a.ContentID = @InContentID
     AND a.NavMenuID = b.NavMenuID

  -- If this is the default content record for any nav item, designate another content record (if any)
  -- as the default content. 
  IF @NavContentGroupInd = 'N' AND @InRevertToPublishVerFlag = 'N' 
     AND @DefaultContentID = @InContentID BEGIN
    SELECT TOP 1 @NewDefaultContentID = ContentID
      FROM vCurrent_Content WITH (NOLOCK)
     WHERE NavMenuID = @NavMenuID
       AND ContentID <> @InContentID
     ORDER BY SortOrder
  
    UPDATE Nav_Menu
       SET ContentID = @NewDefaultContentID
     WHERE NavMenuID = @NavMenuID

    SET @RepublishNavItem = 1
  END
  ELSE IF @NavContentGroupInd = 'C' AND @DefaultContentID = @InContentID 
     UPDATE Nav_Menu
        SET ContentID = NULL
      WHERE NavMenuID = @NavMenuID


  -- WorkflowStatus is Published
  IF @WorkflowStatusCode = 'P' BEGIN
    -- Delete prevoius publishing requests for this content.
    DELETE FROM Publish_Request_Detail WHERE ContentID = @InContentID

    -- Put the content in recycled status.
    UPDATE Content
       SET WorkflowStatusCode = 'D',
           ContactID = @InContactID
     WHERE ContentID = @InContentID

    INSERT 
      INTO Content_Workflow_Log (
           ContentID,
           WorkflowStatusCode,
           ContactID,
           ChangeDateTime)
    VALUES (@InContentID,
           'D',
            @InContactID,
            CURRENT_TIMESTAMP)

    -- We need to remove this from file system. Request to publishing server.
    EXEC amsp_CMRequestPublishContent @InContentID, @InContactID, NULL

    SET @DeletedFlag = 'Y'
  END 
  -- Working/approved/pending approval content
  ELSE IF @WorkflowStatusCode IN ('W','A','E','Q') BEGIN 
    
    BEGIN TRAN
    -- Delete the content. We don't need it any more.
    DELETE FROM Publish_Request_Detail WHERE ContentID = @InContentID
    DELETE FROM Content_HTML WHERE ContentID = @InContentID
    DELETE FROM Content_File WHERE ContentID = @InContentID
    DELETE FROM Content_Link WHERE ContentID = @InContentID
    DELETE FROM Content_Workflow_Log WHERE ContentID = @InContentID
    DELETE FROM Content_Security_Group WHERE ContentID = @InContentID
    DELETE FROM Component_Interest_Category WHERE ComponentID = @InContentID
    DELETE FROM Tagged_Page_Interest_Category WHERE ContentID = @InContentID
    DELETE FROM Content_Change_Request WHERE ContentID = @InContentID
    DELETE FROM Content WHERE ContentID = @InContentID
    COMMIT TRAN
  
    -- When we're simply deleting this, we want to make sure that the previous version
    -- is also recycled. Otherwise, previous version that is published is going to
    -- show up.
    IF @InRevertToPublishVerFlag = 'N' AND @PreviousContentID IS NOT NULL BEGIN

      UPDATE Content
         SET WorkflowStatusCode = 'D',
             ContactID = @InContactID
       WHERE ContentID = @PreviousContentID
  
      INSERT 
        INTO Content_Workflow_Log (
             ContentID,
             WorkflowStatusCode,
             ContactID,
             ChangeDateTime)
      VALUES (@PreviousContentID,
             'D',
              @InContactID,
              CURRENT_TIMESTAMP)

      -- We need to remove this from file system. Request to publishing server.
      EXEC amsp_CMRequestPublishContent @PreviousContentID, @InContactID, NULL

     SET @DeletedFlag = 'Y'
    END  -- Deleting.
    -- When we are reverting to published version and this is nav menu.
    ELSE IF @NavContentGroupInd = 'N' BEGIN
      -- See what has been changed.
      SELECT @PreviousNavMenuID = NavMenuID,
             @PreviousSortOrder = SortOrder
        FROM Content WITH (NOLOCK)
       WHERE ContentID = @PreviousContentID
      
      -- If this contet has been moved within the same folder/menu, 
      -- update previous version's sort order.
      IF @PreviousNavMenuID = @NavMenuID AND @PreviousSortOrder != @SortOrder
        UPDATE Content
           SET SortOrder = @SortOrder
         WHERE ContentID = @PreviousContentID
      -- If it has been moved, re-sort contents in the previous menu/folder.
      ELSE IF @PreviousNavMenuID != @NavMenuID
        EXEC amsp_CMRenumCurrentContent @PreviousNavMenuID
    END
  END -- Working/approved contents.

  IF @DeletedFlag = 'Y' AND @NavContentGroupInd = 'N' BEGIN
    -- If deleting this content record reduces the number of content records for the nav menu item to
    -- one, we must reset the DirectListComboInd to "D". This query will take care of every nav menu item.
    UPDATE Nav_Menu
       SET DirectListComboInd = 'D'
     WHERE NavMenuID IN (SELECT b.NavMenuID
                           FROM Nav_Menu b LEFT OUTER JOIN Content a
                             ON a.NavMenuID = b.NavMenuID
                          WHERE a.WorkflowStatusCode IN ('A','P')
                          GROUP BY b.NavMenuID
                         HAVING COUNT(a.NavMenuID) = 1)

    IF @RepublishNavItem = 1 BEGIN
      -- Re-publish the nav item.
      DECLARE @OutPublishRequestID numeric
      EXEC amsp_CMRequestPublish @InNavMenuID = @NavMenuID,
                                 @InContactID = @InContactID,
                                 @InPublishRegenerateInd = 'P',
                                 @OutPublishRequestID  = @OutPublishRequestID OUTPUT
    END
  END
  EXEC amsp_CMRenumCurrentContent @NavMenuID
  SET @OutPreviousContentID = @PreviousContentID
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMDeleteNavMenu]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMDeleteNavMenu]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure deletes specified NavMenu and all if its descendants
-- as well as associated content.
--
-- Modifications
-- 07/11/2003    E.Tatsui
-- =============================================

CREATE                                PROCEDURE amsp_CMDeleteNavMenu
  @InNavMenuID numeric,
  @InContactID numeric,
  @InIgnorePrivilege char(1) = 'N',
  @OutErrorMessage varchar(255) OUTPUT
AS
BEGIN
  DECLARE
    @ContentID numeric,
    @WebsiteKey uniqueidentifier,
    @ParentNavMenuID numeric,
    @UnAuthorizedNum numeric,
    @NavMenuID numeric,
    @ContentCount int

  CREATE TABLE #NavMenuToDelete 
  (NavMenuID numeric, 
   ContentCount numeric, 
   ContentAuthorityGroupID numeric,
   SortOrder numeric(28,18))

  -- Include the descendants as long as they have permission to delete this record.
  INSERT INTO #NavMenuToDelete
  SELECT a.NavMenuID,
         0,
         a.ContentAuthorityGroupID,
         a.SortOrder
    FROM Nav_Menu a WITH (NOLOCK)
   WHERE a.NavMenuID = @InNavMenuID

  WHILE @@RowCount > 0 BEGIN
    INSERT INTO #NavMenuToDelete
    SELECT a.NavMenuID,
           0,
           a.ContentAuthorityGroupID,
           a.SortOrder
      FROM Nav_Menu a WITH (NOLOCK)
     WHERE ParentNavMenuID IN (SELECT NavMenuID FROM #NavMenuToDelete)
       AND NavMenuID NOT IN (SELECT NavMenuID FROM #NavMenuToDelete)
  END

  -- Check to make sure the user has authorization to delete everything.
  IF @InIgnorePrivilege = 'N' BEGIN
    SELECT @UnAuthorizedNum = Count(*)
      FROM #NavMenuToDelete a LEFT OUTER JOIN Content_Authority_Producer b WITH (NOLOCK)
        ON a.ContentAuthorityGroupID = b.ContentAuthorityGroupID
       AND b.NavCreatorFlag = 'Y'
       AND b.ContactID = @InContactID
     WHERE b.ContentAuthorityGroupID IS NULL

    IF @UnAuthorizedNum > 0 BEGIN
      SET @OutErrorMessage = 'You are not allowed to delete this item, because there are descendants of this item you don''t have privileges to delete.'
      RETURN
    END
  END

  -- Mark all the nav item as deleted.
  UPDATE Nav_Menu
     SET WorkflowStatusCode = 'D'
   WHERE NavMenuID IN (SELECT NavMenuID FROM #NavMenuToDelete)

  -- Request each content record to be deleted.
  DECLARE cContentToDelete CURSOR FOR
  SELECT a.ContentID
    FROM vCurrent_Content a WITH (NOLOCK), #NavMenuToDelete b
   WHERE a.NavMenuID = b.NavMenuID
   ORDER BY b.SortOrder

  OPEN cContentToDelete
  
  FETCH NEXT FROM cContentToDelete
   INTO @ContentID

  WHILE @@FETCH_STATUS = 0 BEGIN
    EXEC amsp_CMDeleteContent @ContentID, @InContactID, 'N', NULL
  
    FETCH NEXT FROM cContentToDelete
     INTO @ContentID
  END
  CLOSE cContentToDelete
  DEALLOCATE cContentToDelete
  -- Ends taking care of content records.

  UPDATE #NavMenuToDelete
     SET ContentCount = (SELECT COUNT(*) FROM vCurrent_Content WHERE NavMenuID = #NavMenuToDelete.NavMenuID)

  -- For nav item that doesn't have any current content records, let's just delete them now.
  DECLARE c_NavMenuToDelete CURSOR FOR
   SELECT NavMenuID, ContentCount
     FROM #NavMenuToDelete

  OPEN c_NavMenuToDelete
  FETCH NEXT FROm c_NavMenuToDelete
   INTO @NavMenuID,
        @ContentCount
  WHILE @@FETCH_STATUS = 0 BEGIN
    -- For both the items deleted and items requested to be deleted...
    -- Grab the parent parent, unless it's also being deletecd.    
    SET @ParentNavMenuID = NULL
    SELECT @ParentNavMenuID = ParentNavMenuID
      FROM Nav_Menu WITH (NOLOCK)
     WHERE NavMenuID = @NavMenuID
       AND ParentNavMenuID NOT IN (SELECT NavMenuID FROM #NavMenuToDelete)

    -- Do the rest only if we're deleting right nwo.
    IF @ContentCount = 0 BEGIN
        UPDATE Content
         SET NavMenuID = (SELECT NavMenuID FROM Nav_Menu WHERE Name = 'Content_Recycle_Bin')
       WHERE NavMenuID = @NavMenuID

      -- IF there are no published content associated with this NavMenuID, go ahead and
      -- delete the record.
      UPDATE Publish_Request
         SET NavMenuID = NULL
       WHERE NavMenuID = @NavMenuID
  
      DELETE FROM Nav_Menu_Workflow_Log WHERE NavMenuID = @NavMenuID
      DELETE FROM Nav_Menu_Feature WHERE NavMenuID = @NavMenuID
      DELETE FROM Nav_Menu_Security_Group WHERE NavMenuID = @NavMenuID
      DELETE FROM Nav_Menu_Setup_Log WHERE NavMenuID = @NavMenuID
      DELETE FROM Nav_Menu WHERE NavMenuID = @NavMenuID
    END

    -- If we set the parent earlier, update it to reflect the changes.
    IF @ParentNavMenuID IS NOT NULL
      EXEC amsp_CMUpdateNavProperties @ParentNavMenuID

    FETCH NEXT FROm c_NavMenuToDelete
     INTO @NavMenuID, @ContentCount
  END
  CLOSE c_NavMenuToDelete
  DEALLOCATE c_NavMenuToDelete   
  
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMDeleteWebsite]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMDeleteWebsite]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- Stored procedure to delete Website table.
--
-- Modifications
-- 09/30/2003  E.Tatsui   Created
-- =============================================

CREATE      PROCEDURE amsp_CMDeleteWebsite
  @InWebsiteKey uniqueidentifier,
  @InContactID numeric
AS
BEGIN
  DECLARE
  @NavMenuID numeric,
  @ActiveContentCount numeric,
  @NavMenuLeft integer

  SELECT @ActiveContentCount = Count(*)
    FROM Nav_Menu a, vCurrent_Content b
   WHERE a.NavMenuID = b.NavMenuID
     AND a.WebsiteKey = @InWebsiteKey

  -- If there is active content, simply inactivate the Website.
  IF @ActiveContentCount = 0 BEGIN
    UPDATE Website
       SET ActiveFlag = 'N'
     WHERE WebsiteKey = @InWebsiteKey
  END
  ELSE BEGIN -- If there is no active content, go ahead and delete all the nav menus.
    DECLARE c_NMToDelete CURSOR FOR
     SELECT NavMenuID
       FROM Nav_Menu
      WHERE WebsiteKey = @InWebsiteKey
  
    OPEN c_NMToDelete
    FETCH NEXT FROM c_NMToDelete
     INTO @NavMenuID
  
    WHILE @@FETCH_STATUS = 0 BEGIN
      EXEC amsp_CMDeleteNavMenu @NavMenuID, @InContactID, 'Y', NULL
  
      FETCH NEXT FROM c_NMToDelete
       INTO @NavMenuID
    END
  
    CLOSE c_NMToDelete
    DEALLOCATE c_NMToDelete
    
    SELECT @NavMenuLeft = COUNT(*)
      FROM Nav_Menu
     WHERE WebsiteKey = @InWebsiteKey

    -- If we were successful in deleting all the navigation/folders, let's delete this website.
    IF @NavMenuLeft = 0 BEGIN
      DELETE FROM Website_Content_Authority WHERE WebsiteKey = @InWebsiteKey
      DELETE FROM Website_Security_Group WHERE WebsiteKey = @InWebsiteKey
      DELETE FROM Nav_Menu_Website WHERE WebsiteKey = @InWebsiteKey
      DELETE FROM Website WHERE WebsiteKey = @InWebsiteKey
    END
    ELSE BEGIN -- Otherwise, mark it as inactive.
      UPDATE Website
         SET ActiveFlag = 'N'
       WHERE WebsiteKey = @InWebsiteKey
    END
  END
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMFinalizePublish]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMFinalizePublish]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure should be called at the end of publishing process
-- to update all the necessary fields.
--
-- Modifications
-- 06/12/2003   E.Tatsui   Created
-- 04/16/2007	W.Archer   Updated
-- =============================================

CREATE                        PROCEDURE [dbo].[amsp_CMFinalizePublish]
	@InPublishRequestDetailID int,
  @InPublishedDateTime datetime,
  @InContactID numeric
  AS

BEGIN
  DECLARE
    @ContentID numeric,
    @NavMenuID numeric,
    @PreviousContentID numeric,
    @HTMLContentID numeric,
    @NavContentGroupInd char(1),
    @ParentNavMenuID numeric,
    @DefaultContentID numeric,
    @FilePath varchar(255),
    @FileName varchar(255),
    @WorkflowStatusCode char(1),
    @PublicationDate datetime,
    @DestDirectory varchar(255),
    @NewPreFuseURL varchar(255),
    @NewPostFuseURL varchar(255),
    @OldPreFuseURL varchar(255),
    @OldPostFuseURL varchar(255),
    @NewNavMenuPreFuseURL varchar(255),
    @NewNavMenuPostFuseURL varchar(255),
    @OldNavMenuPreFuseURL varchar(255),
    @OldNavMenuPostFuseURL varchar(255),
    @ExpirationDate datetime,
    @CMResetAllContentExpDate varchar(10),
    @ExpirationDays integer,
    @NavWorkflowStatusCode char(1),
    @ContentCount int,
    @PublishRegenerateInd char(1),
    @PublishRequestID int,
    @PublishedDirectory varchar(255),
    @PublishDirectory varchar(255),
    @NewDefaultContentID numeric,
    @RequestPublishedDateTime datetime,
    @RequestNavMenuID numeric,
    @WebsiteKey uniqueidentifier

  SELECT @ContentID = a.ContentID,
         @PreviousContentID = a.PreviousContentID,
         @HTMLContentID = b.ContentID,
         @OldPreFuseURL = a.PreFuseURL,
         @OldPostFuseURL = a.PostFuseURL,
         @WorkflowStatusCode = a.WorkflowStatusCode,
         @PublicationDate = a.PublicationDate,
         @ExpirationDate = a.ExpirationDate,
         @ExpirationDays = a.ExpirationDays,
         @NavContentGroupInd = c.NavContentGroupInd,
         @FilePath = c.FilePath,
         @NavMenuID = c.NavMenuID,
         @ParentNavMenuID = c.ParentNavMenuID,
         @DefaultContentID = c.ContentID,
         @OldNavMenuPreFuseURL = c.PreFuseURL,
         @OldNavMenuPostFuseURL = c.PostFuseURL,
         @NavWorkflowStatusCode = c.WorkflowStatusCode,
         @PublishRegenerateInd = d.PublishRegenerateInd,
         @PublishRequestID = d.PublishRequestID,
         @PublishedDirectory = c.PublishedDirectory,
         @PublishDirectory = Replace(CASE WHEN c.NavContentGroupInd = 'N' THEN IsNull(e.NavPublishDirectory,'')
                                          ELSE IsNull(e.ContentFolderPublishDirectory,'') END
                                     + c.FilePath,'\','/'),
         @WebsiteKey = e.WebsiteKey,
         @RequestPublishedDateTime = f.PublishedDateTime,
         @RequestNavMenuID = f.NavMenuID
    FROM Content a WITH (NOLOCK) LEFT OUTER JOIN Content_HTML b WITH (NOLOCK)
      ON a.ContentID = b.ContentID, Nav_Menu c WITH (NOLOCK), Publish_Request_Detail d WITH (NOLOCK),
         Website e WITH (NOLOCK), Publish_Request f WITH (NOLOCK)
   WHERE a.NavMenuID = c.NavMenuID
     AND a.ContentID = d.ContentID
     AND c.WebsiteKey = e.WebsiteKey
     AND d.PublishRequestDetailID = @InPublishRequestDetailID
     AND d.PublishRequestID = f.PublishRequestID

  -- Take care of Publish_Request first.
  IF @RequestPublishedDateTime IS NULL BEGIN
    UPDATE Publish_Request
       SET PublishedDateTime = @InPublishedDateTime
     WHERE PublishRequestID = @PublishRequestID
  END

  -- If we published the content (instead of deleting them).
  IF @WorkflowStatusCode = 'A' OR @WorkflowStatusCode = 'P' BEGIN
    SELECT @CMResetAllContentExpDate = Value
      FROM System_Variable
     WHERE Name = 'CMResetAllContentExpDate'
  
    -- Archive the previous content if there is one.
    IF @PreviousContentID IS NOT NULL AND @WorkflowStatusCode = 'A' BEGIN
      UPDATE Content
         SET WorkflowStatusCode = 'R'
       WHERE ContentID = @PreviousContentID
  
      INSERT INTO Content_Workflow_Log (
             ContentID,
             WorkflowStatusCode,
             ContactID,
             ChangeDateTime)
      VALUES (
             @PreviousContentID,
             'R',
             @InContactID,
             CURRENT_TIMESTAMP)
    END  -- Ends archiving
    
    -- Are we resetting expiration date?
    -- CMResetAllContentExpDate determines whether to reset expiration date when Nav_Menu is published. 
    -- If set to True, a content record will have a new expiration date every time it is published.
    -- If set to False, the content record will have a new expiration date only when the content has actually been 
    -- modified.

    IF (@WorkflowStatusCode = 'A' OR UPPER(@CMResetAllContentExpDate) = 'TRUE') AND @ExpirationDays IS NOT NULL AND @ExpirationDays > 0
      SET @ExpirationDate = DateAdd(dd,@ExpirationDays,CURRENT_TIMESTAMP)
    ELSE IF (@WorkflowStatusCode = 'A' OR UPPER(@CMResetAllContentExpDate) = 'TRUE') 
            AND (@ExpirationDays IS NULL OR @ExpirationDays = 0)
      SET @ExpirationDate = NULL

    -- Set PublicationDate only if it's null.
    IF @PublicationDate IS NULL
      SET @PublicationDate = @InPublishedDateTime 

    UPDATE Content
       SET WorkflowStatusCode = 'P',
           PublishDateTime = @InPublishedDateTime,
           ReminderSentDateTime = NULL,
           ExpirationDate = @ExpirationDate,
           PublicationDate = @PublicationDate,
           ContactID = @InContactID
     WHERE ContentID = @ContentID
  
    INSERT INTO Content_Workflow_Log (ContentID,
                                      WorkflowStatusCode,
                                      ContactID,
                                      ChangeDateTime)
         VALUES (@ContentID,
                 'P',
                 @InContactID,
                 CURRENT_TIMESTAMP)
  
    -- Update Pre & PostFuseURL if necessary.
    EXECUTE amsp_CMGetFuseURL @NavMenuID, @ContentID, @NewPreFuseURL OUTPUT, @NewPostFuseURL OUTPUT
    
    -- If PostFuseURL changes, update it.
    IF IsNull(@NewPreFuseURL,'') <> IsNull(@OldPreFuseURL,'') 
       OR IsNull(@NewPostFuseURL,'') <> IsNull(@OldPostFuseURL,'') BEGIN
      UPDATE Content
         SET PostFuseURL = @NewPostFuseURL
       WHERE ContentID = @ContentID
    END
    
    -- Default Content?
    IF @PreviousContentID = @DefaultContentID BEGIN
      SET @DefaultContentID = @ContentID
      UPDATE Nav_Menu
         SET ContentID = @ContentID
       WHERE NavMenuID = @NavMenuID
    END

  END -- When content's status is A or P.
  -- If Content's workflow status was "D"
  ELSE IF @WorkflowStatusCode = 'D' BEGIN

    -- Move the content to recycle bin. Change the ID to recycle bin's ID when Nav Item is deleted.
    UPDATE Content
       SET WorkflowStatusCode = 'Y',
           NavMenuID = CASE WHEN @NavWorkflowStatusCode = 'D' THEN (SELECT NavMenuID FROM Nav_Menu WHERE Name = 'Content_Recycle_Bin') 
                       ELSE NavMenuID END
     WHERE ContentID = @ContentID

    INSERT 
      INTO Content_Workflow_Log (
           ContentID,
           WorkflowStatusCode,
           ContactID,
           ChangeDateTime)
    VALUES (@ContentID,
           'Y',
            @InContactID,
            CURRENT_TIMESTAMP)
  END

  -- If NavMenu is marked for deletion, find out if there are more content associated with this nav item.
  IF @NavWorkflowStatusCode = 'D' BEGIN

    SELECT @ContentCount = Count(*)
      FROM Content
     WHERE NavMenuID = @NavMenuID

    IF @ContentCount = 0 BEGIN
      EXECUTE amsp_CMRequestPublish @NavMenuID, NULL, @InContactID, 'N', 'Y', 'R', DEFAULT, @PublishRequestID, NULL

      UPDATE Publish_Request
         SET NavMenuID = NULL
       WHERE NavMenuID = @NavMenuID

      -- Delete all the related records.
      DELETE FROM Nav_Menu_Workflow_Log WHERE NavMenuID = @NavMenuID
      DELETE FROM Nav_Menu_Feature WHERE NavMenuID = @NavMenuID
      DELETE FROM Nav_Menu_Security_Group WHERE NavMenuID = @NavMenuID
      DELETE FROM Nav_Menu WHERE NavMenuID = @NavMenuID
    END
  END
  -- Not marked for deletion. For default content only.
  ELSE IF @DefaultContentID = @ContentID BEGIN
    -- Update Nav_Menu table.
    EXECUTE amsp_CMGetFuseURL @NavMenuID, NULL, @NewNavMenuPreFuseURL OUTPUT, @NewNavMenuPostFuseURL OUTPUT
    -- If this is the default content, also update Nav_Menu table.
    IF IsNull(@NewNavMenuPreFuseURL,'')  <> IsNull(@OldNavMenuPreFuseURL,'')
       OR IsNull(@NewNavMenuPostFuseURL,'')  <> IsNull(@OldNavMenuPostFuseURL,'') BEGIN
      UPDATE Nav_Menu
         SET PreFuseURL = @NewNavMenuPreFuseURL,
             PostFuseURL = @NewNavMenuPostFuseURL
       WHERE NavMenuID = @NavMenuID
    END

    -- Store the new publish path.
    IF IsNull(@PublishedDirectory,'') <> @PublishDirectory
      UPDATE Nav_Menu
         SET PublishedDirectory =  @PublishDirectory
       WHERE NavMenuID = @NavMenuID

    -- Regenererate navigations if this is default content record for a nav item.
    IF @PublishRegenerateInd = 'P' AND @NavContentGroupInd = 'N' 
      EXECUTE amsp_CMRequestPublish @NavMenuID, NULL, @InContactID, 'N', 'Y', 'R', DEFAULT, @PublishRequestID, NULL
  END

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMFindContentIDtoEdit]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMFindContentIDtoEdit]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure looks for contentID based on the URL provided.
-- Used for "Surf to Edit" functionality.
-- 
-- Modifiations
-- 07/08/2003   E.Tatsui    Created
-- =============================================

CREATE              PROCEDURE amsp_CMFindContentIDtoEdit
	@InURL varchar(500),
  @OutContentID numeric OUTPUT,
  @OutEditable bit OUTPUT
AS
BEGIN

  DECLARE
    @HTMLContentID numeric,
    @ContentID numeric,
    @GECodePath varchar(255),
    @Rowcount numeric,
    @StartIndex smallint,
    @EndIndex smallint,
    @URLContentID int,
    @URLIDLen int

  SET @OutEditable = 0
  SET @Rowcount = 0

  SET @StartIndex = CHARINDEX ('&CONTENTID=', @InURL) 

  -- If there is ContactID in URL, use that instead of trying to figure out
  IF @StartIndex > 0 BEGIN

    SELECT @EndIndex = CHARINDEX ('&', @InURL, @StartIndex + 1) 
  
    IF @EndIndex = 0
      SET @EndIndex = LEN(@InURL) + 1
  
    SET @URLIDLen = @EndIndex - @StartIndex - 11
    SET @URLContentID = SUBSTRING(@InURL,@StartIndex+11,@URLIDLen)
  
    SELECT @ContentID = a.ContentID,
           @HTMLContentID = b.ContentID
      FROM Content a LEFT OUTER JOIN Content_HTML b
        ON a.ContentID = b.ContentID
     WHERE a.ContentID = b.ContentID
       AND a.ContentID = @URLContentID
       AND a.WorkflowStatusCode = 'P'

    SET @Rowcount = @@Rowcount
  END
  -- If we didn't find ContentID from URL or it wasn't a valid ContentID.
  IF @@Rowcount = 0 BEGIN
    SELECT @GECodePath = Value
      FROM System_Variable
     WHERE Name = 'GECodePath'

    IF Len(@GECodePath) > 1
      SET @GECodePath = RIGHT(@GECodePath,Len(@GECodePath)-1)
    ELSE IF @GECodePath = '/'
      SET @GECodePath = ''
  
    -- First match with content record.
    SELECT @ContentID = a.ContentID, 
           @HTMLContentID = b.ContentID
      FROM Content a LEFT OUTER JOIN Content_HTML b
        ON a.ContentID = b.ContentID, Nav_Menu c, Website d
     WHERE a.NavMenuID = c.NavMenuID
       AND c.WebsiteKey = d.WebsiteKey
       AND a.WorkflowStatusCode = 'P'
       AND @InURL = CASE WHEN a.SecureFlag = 'Y' THEN d.SecureWebsiteRootURL
                         ELSE d.WebsiteRootURL END
                    + a.PostFuseURL
    
    SET @Rowcount = @@Rowcount
    
    -- If there wasn't a match with content record, try nav_menu.
    IF @Rowcount = 0   BEGIN
  
      SELECT @ContentID = a.ContentID, 
             @HTMLContentID = b.ContentID
        FROM Content a LEFT OUTER JOIN Content_HTML b
          ON a.ContentID = b.ContentID, Nav_Menu c, Website d
       WHERE a.NavMenuID = c.NavMenuID
         AND c.ContentID = a.ContentID
         AND c.WebsiteKey = d.WebsiteKey
         AND a.WorkflowStatusCode = 'P'
         AND (@InURL = CASE WHEN a.SecureFlag = 'Y' THEN d.SecureWebsiteRootURL
                           ELSE d.WebsiteRootURL END
                       + c.PostFuseURL
           OR @InURL = CASE WHEN a.SecureFlag = 'Y' THEN d.SecureWebsiteRootURL
                           ELSE d.WebsiteRootURL END
                       + CASE WHEN c.NavContentGroupInd = 'C' 
                              THEN REPLACE(c.PublishedDirectory, REPLACE(IsNull(d.ContentFolderPublishDirectory,''),'\','/'), IsNull(d.FolderContentDisplayPath,''))
                              ELSE REPLACE(c.PublishedDirectory, REPLACE(IsNull(d.NavPublishDirectory,''),'\','/'), IsNull(d.NavContentDisplayPath,''))
                              END)
      SET @Rowcount = @@Rowcount
    END
  
  END -- Ends if @@Rowcount = 0

  -- If there is a record in Content_HTML, we can redirect the user to Ektron page.
  IF @Rowcount > 0 AND @HTMLContentID IS NOT NULL BEGIN
    SET @OutContentID = @ContentID
    SET @OutEditable = 1
    print 'here'
  END

 -- If there is a content record, use it.
  ELSE IF @Rowcount > 0 AND @ContentID IS NOT NULL
    SET @OutContentID = @ContentID
  ELSE IF @Rowcount = 0 BEGIN  
    -- If not, look for content_file.
    SELECT @ContentID = a.ContentID
      FROM Content_File a, Content b, Nav_Menu c, Website d
     WHERE a.ContentID = b.ContentID
       AND b.NavMenuID = c.NavMenuID
       AND c.WebsiteKey = d.WebsiteKey
       AND b.WorkflowStatusCode = 'P'
       AND @InURL = 
                    CASE WHEN b.SecureFlag = 'Y' THEN d.SecureWebsiteRootURL
                         ELSE d.WebsiteRootURL END
                    + CASE WHEN c.NavContentGroupInd = 'C' 
                           THEN REPLACE(c.PublishedDirectory, REPLACE(IsNull(d.ContentFolderPublishDirectory,''),'\','/'), IsNull(d.FolderContentDisplayPath,''))
                           ELSE REPLACE(c.PublishedDirectory, REPLACE(IsNull(d.NavPublishDirectory,''),'\','/'), IsNull(d.NavContentDisplayPath,''))
                           END + a.FileName

    IF @Rowcount > 0
      SET @OutContentID = @ContentID
  END

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetContentAuthority]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetContentAuthority]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- Stored procedure to get authority groups for a specified user.
--
-- Modifications
-- 10/10/2003  E.Tatsui   Created
-- =============================================

CREATE     PROCEDURE amsp_CMGetContentAuthority
	@InContactID numeric
AS
BEGIN
  DECLARE
    @SuperUserFlag bit,
    @SuperGroupID numeric
  
  SET @SuperUserFlag = 0
  -- First, find out if this user is a member of a super group.
  SELECT @SuperUserFlag = 1,
         @SuperGroupID = a.ContentAuthorityGroupID
    FROM Content_Authority_Group a, Content_Authority_Producer b
   WHERE a.ContentAuthorityGroupID = b.ContentAuthorityGroupID
     AND b.ContactID = @InContactID
     AND a.SuperGroupFlag = 'Y'

  -- If super user, they have access to all the groups.
  IF @SuperUserFlag = 1
    SELECT a.ContentAuthorityGroupID,
           b.ContactID,
           b.ContentEditorFlag,
           b.ContentApproverFlag,
           b.NavEditorFlag,
           b.NavCreatorFlag,
           b.LayoutFlag,
           b.EditorFlag,
           b.CustomPageFlag,
           b.ComponentScriptFlag,
           b.UploadFlag,
           b.DefaultOwnerFlag,
           b.HighestToolbarLevelInd,
           'Y' AS SuperGroupFlag
      FROM Content_Authority_Group a, Content_Authority_Producer b
     WHERE b.ContactID = @InContactID
       AND b.ContentAuthorityGroupID = @SuperGroupID
  ELSE
    SELECT b.*, 'N' AS SuperGroupFlag
      FROM Producer a LEFT OUTER JOIN Content_Authority_Producer b 
        ON a.ContactID = b.ContactID
     WHERE a.ContactID = @InContactID

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetContentFiles]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetContentFiles]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- Procedure to get all the files for the specified Content.
--
-- Modifications
-- 06/27/2003     E.Tatsui   Created
-- =============================================


CREATE       PROCEDURE amsp_CMGetContentFiles
  @InContentID numeric = 0 ,
  @InContentFileID numeric = 0
AS
BEGIN
  SELECT a.ContentID,
         a.ContentFileID,
         a.FileName,
         a.SourceLocation,
         a.PublishLocation,
         a.Description,
         b.MimeType,
         b.FileTypeCode,
         b.FileTypeDesc,
         c.OpenInNewWindowFlag,
         CASE WHEN c.MembersOnlyFlag = 'Y' THEN e.ProtectedRootPath
              ELSE e.PublishRootPath END AS PublishRootPath,
         CASE WHEN d.NavContentGroupInd = 'N' THEN
              REPLACE(a.PublishLocation,REPLACE(IsNull(e.NavPublishDirectory,''),'\','/'), IsNull(e.NavContentDisplayPath,''))
         ELSE 
              REPLACE(a.PublishLocation,REPLACE(IsNull(e.ContentFolderPublishDirectory,''),'\','/'), IsNull(e.FolderContentDisplayPath,''))
         END AS DisplayPublishLocation
    FROM Content_File a,
         File_Type_Ref b, 
				 Content c, Nav_Menu d 
    LEFT OUTER JOIN Website e
      ON d.WebsiteKey = e.WebsiteKey
   WHERE a.FileTypeCode = b.FileTypeCode
		 AND a.ContentID = c.ContentID
     AND c.NavMenuID = d.NavMenuID
     AND a.ContentID = CASE WHEN @InContentID > 0 THEN @InContentID
                            ELSE a.ContentID END
     AND a.ContentFileID =  CASE WHEN @InContentFileID > 0 THEN @InContentFileID
                                 ELSE a.ContentFileID END
		ORDER by a.SortOrder 

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetContentSecurity]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetContentSecurity]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure takes ContentID and ContactID and returns a row
-- from Content_Authority_Producer
-- 
-- Modifications
-- 08/12/2003    E.Tatsui   Created
-- =============================================

CREATE     PROCEDURE amsp_CMGetContentSecurity
	@InContentID numeric = NULL,
  @InNavMenuID numeric = NULL,
  @InContactID numeric
AS
BEGIN	
  DECLARE
    @SuperUserFlag bit
  
  SET @SuperUserFlag = 0
  -- First, find out if this user is a member of a super group.
  SELECT @SuperUserFlag = 1
    FROM Content_Authority_Group a, Content_Authority_Producer b
   WHERE a.ContentAuthorityGroupID = b.ContentAuthorityGroupID
     AND b.ContactID = @InContactID
     AND a.SuperGroupFlag = 'Y'

  IF @SuperUserFlag = 1
    SELECT b.*
      FROM Content_Authority_Group a, Content_Authority_Producer b
     WHERE a.ContentAuthorityGroupID = b.ContentAuthorityGroupID
       AND b.ContactID = @InContactID
       AND a.SuperGroupFlag = 'Y'
  ELSE IF @InContentID IS NOT NULL
    SELECT cap.*
      FROM Content c, Nav_Menu nm, Content_Authority_Producer cap
     WHERE c.NavMenuID = nm.NavMenuID
       AND nm.ContentAuthorityGroupID = cap.ContentAuthorityGroupID
       AND cap.ContactID = @InContactID
       AND c.ContentID = @InContentID
  ELSE IF @InNavMenuID IS NOT NULL
    SELECT cap.*
      FROM Nav_Menu nm, Content_Authority_Producer cap
     WHERE nm.NavMenuID = @InNavMenuID
       AND nm.ContentAuthorityGroupID = cap.ContentAuthorityGroupID
       AND cap.ContactID = @InContactID
  ELSE
    RAISERROR('Either NavMenuID or ContentID is required.',16,1)
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetContentToPublish]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetContentToPublish]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This procedures gets all the documents that need to be published.
--
-- Modofications
-- 06/16/2003     E.Tatsui
-- =============================================


CREATE  PROCEDURE [dbo].[amsp_CMGetContentToPublish]
  @InPublishRequestDetailID numeric,
  @InDeleteFlag char(1) = 'N'
AS
BEGIN
  
  DECLARE
    @ContentID numeric,
    @NavMenuID numeric,
    @FileCount integer,
    @LinkCount integer,
    @HTMLContentID numeric,
    @HTMLTitle varchar(255),
    @ContentName varchar(255),
    @SourceLocation varchar(255),
    @PublishLocation varchar(255),
    @WorkflowStatusCode char(1),
    @NavContentGroupInd char(1),
    @MicrositeID numeric,
    @PreFuseURL varchar(255),
    @PostFuseURL varchar(255),
    @NavMenuPreFuseURL varchar(255),
    @NavMenuPostFuseURL varchar(255),
    @FilePath varchar(255),
    @URLSafeName varchar(255),
    @DefaultContentID numeric,
    @PreviousContentID numeric,
    @ShowInTemplateFlag char(1),
    @FileTypeCode varchar(4),
    @FileName varchar(255),
    @Description varchar(255),
    @DirectListComboInd char(1),
    @WebsiteRootURL varchar(255),
    @SecureWebsiteRootURL varchar(255),
    @TemplatePath varchar(255),
    @SectionName varchar(255),
    @MembersOnlyFlag char(1),
    @PrevMembersOnlyFlag char(1),
    @SourceRootLocation varchar(255),
    @PublishDirectory varchar(255),
    @Header varchar(500),
    @Footer varchar(500),
    @Keywords varchar(255),
    @DefaultGenerated bit,
    @PublishRegenerateInd char(1),
    @DefaultFileName varchar(255),
    @DefaultContentFlag char(1),
    @OldPublishedDefaultFileName varchar(255),
    @NewPublishedDefaultFileName varchar(255),
    @NavMenuWorkflowStatus char(1),
    @PublishedDirectory varchar(255),
    @LinkURL varchar(510),
    @SecureFlag char(1),
    @Root varchar(255),
    @PreviousWebsiteKey uniqueidentifier,
    @WebsiteKey uniqueidentifier

  SELECT @ContentID = c.ContentID,
         @NavMenuID = c.NavMenuID,
         @ContentName = c.Name,
         @PreFuseURL = c.PreFuseURL,
         @PostFuseURL = c.PostFuseURL,
         @URLSafeName = c.URLSafeName,
         @MembersOnlyFlag = IsNull(c.MembersOnlyFlag,'N'),
         @PrevMembersOnlyFlag = IsNull(pv.MembersOnlyFlag,'N'),
         @WorkflowStatusCode = c.WorkflowStatusCode,
         @PreviousContentID = c.PreviousContentID,
         @ShowInTemplateFlag = c.ShowInTemplateFlag,
         @Keywords = c.Keywords,
         @SecureFlag = c.SecureFlag,
         @LinkCount = (SELECT Count(*) FROM Content_Link  WITH (NOLOCK) WHERE ContentID = c.ContentID),
         @FileCount = (SELECT Count(*) FROM Content_File  WITH (NOLOCK) WHERE ContentID = c.ContentID),
         @HTMLContentID = ch.ContentID,
         @HTMLTitle = ch.Title,
         @DefaultContentID = n.ContentID,
         @NavContentGroupInd = n.NavContentGroupInd,
         @FilePath = n.FilePath,
         @DirectListComboInd = n.DirectListComboInd,
         @TemplatePath = n.TemplatePath,
         @SectionName = n.Name,
         @WebsiteRootURL = w.WebsiteRootURL,
         @SecureWebsiteRootURL = w.SecureWebsiteRootURL,
         @PublishRegenerateInd = p.PublishRegenerateInd,
         @DefaultFileName = w.DefaultFileName,
         @OldPublishedDefaultFileName = n.PublishedDefaultFileName,
         @NavMenuWorkflowStatus = n.WorkflowStatusCode,
         @PublishedDirectory = n.PublishedDirectory,
         @PublishDirectory = Replace(CASE WHEN n.NavContentGroupInd = 'N' THEN IsNull(w.NavPublishDirectory,'')
                                          ELSE IsNull(w.ContentFolderPublishDirectory,'') END
                                     + n.FilePath,'\','/'),
         @PreviousWebsiteKey = n.PreviousWebsiteKey,
         @WebsiteKey = n.WebsiteKey
    FROM Nav_Menu n WITH (NOLOCK), Content c WITH (NOLOCK) LEFT OUTER JOIN Content_HTML ch WITH (NOLOCK)

      ON c.ContentID = ch.ContentID
    LEFT OUTER JOIN Content pv WITH (NOLOCK)
      ON c.PreviousContentID = pv.ContentID, Publish_Request_Detail p WITH (NOLOCK), Website w WITH (NOLOCK)
   WHERE n.NavMenuID = c.NavMenuID
     AND c.ContentID = p.ContentID
     AND p.WebsiteKey = w.WebsiteKey
     AND p.PublishRequestDetailID = @InPublishRequestDetailID


  -- Is this a default content for the nav item?
  IF (@PreviousContentID = @DefaultContentID OR @ContentID = @DefaultContentID)
      AND @NavContentGroupInd = 'N'
    SET @DefaultContentFlag = 'Y'

  SET @DefaultGenerated = 0
  SET @Header = ''
  SET @Footer = '<!--- Generated by eContentManager - Advanced Solutions International, Inc. --->' + Char(13) + Char(10)

  -- Approved or already published contents.
  IF @InDeleteFlag = 'N' AND (@WorkflowStatusCode = 'A' OR @WorkflowStatusCode = 'P') BEGIN

    IF (@FileCount > 0 OR @LinkCount > 0 OR @HTMLContentID IS NOT NULL) BEGIN
      IF @MicrositeID > 0 BEGIN
        SET @SourceLocation = NULL
      
      END -- Ends special rule for microsite contents.
  
      ELSE BEGIN -- Non-microsite contents
        IF @FileCount > 0 AND @PublishRegenerateInd = 'P' BEGIN
          -- Add all the uploaded files to copy
          INSERT INTO #PublishContent
                      (PublishRequestDetailID,
                       SourceLocation,
                       PublishLocation,
                       PublishDirectory,
                       ContentFileID,
                       UseProtectedPath)
          SELECT @InPublishRequestDetailID,
                 SourceLocation,
                 @PublishDirectory + FileName,
                 @PublishDirectory,
                 ContentFileID,
                 @MembersOnlyFlag
            FROM Content_File WITH (NOLOCK)
           WHERE ContentID = @ContentID
        END

        -- If this is a default content and it's a list or combo mode,
        -- create a default document.
        IF @MembersOnlyFlag = 'N' AND @DirectListComboInd IN ('L','C') AND @DefaultContentFlag = 'Y'
          BEGIN
          EXEC amsp_CMGetFuseURL @NavMenuID, NULL, @NavMenuPreFuseURL OUTPUT, @NavMenuPostFuseURL OUTPUT, 1

          SET @SourceLocation = @WebsiteRootURL + @NavMenuPreFuseURL + '&FuseFlag=1'

          -- If DefaultFileName is specified, use it.
          IF @DefaultFileName IS NOT NULL BEGIN
            SET @PublishLocation = @PublishDirectory + @DefaultFileName
            SET @NewPublishedDefaultFileName = @DefaultFileName
          END
          ELSE BEGIN
            SET @PublishLocation = @PublishDirectory + 'Default' + Convert(varchar(20),@NavMenuID) + '.htm'
            SET @NewPublishedDefaultFileName = 'Default' + Convert(varchar(20),@NavMenuID) + '.htm'
          END
          SET @DefaultGenerated = 1

          INSERT INTO #PublishContent
                      (PublishRequestDetailID,
                       SourceLocation,
                       PublishLocation,
                       PublishDirectory,
                       Header,
                       Footer,
                       UseProtectedPath,
                       DefaultContentFlag)
          VALUES (@InPublishRequestDetailID,
                  @SourceLocation,
                  @PublishLocation,
                  @PublishDirectory,
                  @Header,
                  @Footer,
                  @MembersOnlyFlag,
                  'Y')
        END

        -- If there is only a single file/link or this content is Member's only file, 
        -- and we're using default page,
        -- let's generate a file which simply redirects to the file.
        -- This file should always be in non-member's only directory (accessible through Web)
        IF @DefaultContentFlag = 'Y' AND @DefaultFileName IS NOT NULL
           AND @DefaultGenerated = 0
           AND ((@FileCount = 1 AND @LinkCount = 0 AND @HTMLContentID IS NULL)
                OR (@LinkCount = 1 AND @FileCount = 0 AND @HTMLContentID IS NULL)
                OR  @MembersOnlyFlag = 'Y')BEGIN

          SET @NewPublishedDefaultFileName = @DefaultFileName
          
          IF UPPER(LEFT(@PostFuseURL,4)) = 'HTTP'
            SET @LinkURL = @PostFuseURL
          ELSE IF @SecureFlag = 'Y'
            SET @LinkURL = @SecureWebsiteRootURL + @PostFuseURL
          ELSE 
            SET @LinkURL = @WebsiteRootURL + @PostFuseURL

          SET @DefaultGenerated = 1
          INSERT INTO #PublishContent
                      (PublishRequestDetailID,
                       SourceLocation,
                       PublishLocation,
                       PublishDirectory,
                       Header,
                       Footer,
                       UseProtectedPath,
                       RedirectFileFlag,
                       DefaultContentFlag)
          VALUES (@InPublishRequestDetailID,
                  @LinkURL,
                  @PublishDirectory + @DefaultFileName,
                  @PublishDirectory,
                  @Header,
                  @Footer,
                  'N',
                  'Y',
                  'N')
        END

        -- This content has mix of links, html and files, create a main page to go to.
        IF @MembersOnlyFlag = 'N' AND
            (@FileCount > 1 OR @LinkCount > 1
                 OR (@HTMLContentID IS NOT NULL AND (@FileCount > 0 OR @LinkCount > 0))
                 OR (@FileCount > 0 AND @LinkCount > 0)) BEGIN
          SET @SourceLocation = @WebsiteRootURL + @PreFuseURL + '&FuseFlag=1'
          -- If DefaultFileName is specified, use it.
          IF @DefaultFileName IS NOT NULL AND @DefaultContentFlag = 'Y' AND @DefaultGenerated = 0 BEGIN
            SET @PublishLocation = @PublishDirectory + @DefaultFileName
            SET @NewPublishedDefaultFileName = @DefaultFileName
            SET @DefaultGenerated = 1
          END
          ELSE BEGIN
            SET @PublishLocation = @PublishDirectory + @URLSafeName + '.htm'
            IF @DefaultContentFlag = 'Y'
              SET @NewPublishedDefaultFileName = @URLSafeName + '.htm'
          END
          INSERT INTO #PublishContent
                      (PublishRequestDetailID,
                       SourceLocation,
                       PublishLocation,
                       PublishDirectory,
                       Header,
                       Footer,
                       UseProtectedPath,
                       DefaultContentFlag)
          VALUES (@InPublishRequestDetailID,
                  @SourceLocation,
                  @PublishLocation,
                  @PublishDirectory,
                  @Header,
                  @Footer,
                  @MembersOnlyFlag,
                  'Y')
        END
  
        -- If this content record has only Content_HTML record, set source loc & publish loc.
        IF @HTMLContentID IS NOT NULL BEGIN
          DECLARE
            @TempDefaultFlag char(1)

          IF @MembersOnlyFlag = 'Y' BEGIN
      DECLARE @MembersOnlyURL varchar(255)
            SET @MembersOnlyURL = Replace(UPPER(@PreFuseURL),UPPER('/MembersOnly.cfm'),'/CM/HTMLDisplay.cfm')
            SET @MembersOnlyURL = Replace(UPPER(@MembersOnlyURL),UPPER('/MembersOnly.aspx'),'/HTMLDisplay.aspx')
            SET @SourceLocation = @WebsiteRootURL + @MembersOnlyURL + '&FuseFlag=1'
          END
          ELSE
            SET @SourceLocation = @WebsiteRootURL + @PreFuseURL + '&FuseFlag=1'
          IF @DefaultFileName IS NOT NULL AND @DefaultContentFlag = 'Y' AND @DefaultGenerated = 0 BEGIN
            SET @PublishLocation = @PublishDirectory + @DefaultFileName
            SET @NewPublishedDefaultFileName = @DefaultFileName
            SET @DefaultGenerated = 1
            SET @TempDefaultFlag = 'Y'
          END
          ELSE BEGIN
            SET @PublishLocation = @PublishDirectory + @URLSafeName + '.htm'
            IF @DefaultContentFlag = 'Y' AND @DefaultGenerated = 0
              SET @NewPublishedDefaultFileName = @URLSafeName + '.htm'
            SET @TempDefaultFlag = 'N'
          END

          INSERT INTO #PublishContent
                      (PublishRequestDetailID,
                       SourceLocation,
                       PublishLocation,
                       PublishDirectory,
                       Header,
                       Footer,
                       HTMLContentID,
                       UseProtectedPath,
                       DefaultContentFlag)
          VALUES (@InPublishRequestDetailID,
                  @SourceLocation,
                  @PublishLocation,
                  @PublishDirectory,
                  @Header,
                  @Footer,
                  @HTMLContentID,
                  @MembersOnlyFlag,
                  @TempDefaultFlag)
        END    
      END -- Ends non-microsite Contents
    END -- @FileCount > 0 OR @LinkCount > 0 OR @HTMLContentID IS NOT NULL

    -- Finally, add files to be deleted.
    IF @PublishRegenerateInd = 'P' BEGIN
      -- If default file name has changed, add the old default file to the delete list
      IF @DefaultContentFlag = 'Y' AND @OldPublishedDefaultFileName IS NOT NULL 
        AND (IsNull(@NewPublishedDefaultFileName,'') != @OldPublishedDefaultFileName) BEGIN
        INSERT INTO #PublishContent
                    (PublishRequestDetailID,
                     PublishLocation,
                     RemoveFlag,
                     UseProtectedPath)
        VALUES (@InPublishRequestDetailID,
                @PublishedDirectory + @OldPublishedDefaultFileName,
                'Y',
                @MembersOnlyFlag)

        IF @MembersOnlyFlag = 'Y'
          INSERT INTO #PublishContent
                      (PublishRequestDetailID,
                       PublishLocation,
                       RemoveFlag,
                       UseProtectedPath)
          VALUES (@InPublishRequestDetailID,
                  @PublishedDirectory + @OldPublishedDefaultFileName,
                  'Y',
                  'Y')
      END

      -- Save the new DefaultFileName
      IF @DefaultContentFlag = 'Y' AND IsNull(@NewPublishedDefaultFileName,'') != IsNull(@OldPublishedDefaultFileName,'')
        UPDATE Nav_Menu
           SET PublishedDefaultFileName = @NewPublishedDefaultFileName
         WHERE NavMenuID = @NavMenuID

      INSERT INTO #PublishContent
                  (PublishRequestDetailID,
                   PublishLocation,
                   RemoveFlag,
                   UseProtectedPath)
      SELECT @InPublishRequestDetailID,
             a.PublishLocation,
             'Y',
             @MembersOnlyFlag
        FROM Content a WITH (NOLOCK) LEFT OUTER JOIN #PublishContent x
          ON a.PublishLocation = x.PublishLocation
       WHERE a.ContentID IN (@PreviousContentID, @ContentID)
         AND a.PublishLocation IS NOT NULL
         AND (@PreviousWebsiteKey IS NULL OR a.PublishLocation LIKE @PublishDirectory + '%')
         AND x.PublishLocation IS NULL

      INSERT INTO #PublishContent
                  (PublishRequestDetailID,
                   PublishLocation,
                   RemoveFlag,
                   UseProtectedPath)
      SELECT @InPublishRequestDetailID,
             a.PublishLocation,
             'Y',
             @MembersOnlyFlag
        FROM Content_File a WITH (NOLOCK) LEFT OUTER JOIN #PublishContent x
          ON a.PublishLocation = x.PublishLocation
       WHERE a.ContentID IN (@PreviousContentID, @ContentID)
         AND a.PublishLocation IS NOT NULL
         AND x.PublishLocation IS NULL
         AND (@PreviousWebsiteKey IS NULL OR a.PublishLocation LIKE @PublishDirectory + '%')

      -- If FilePath has been changed since the last publish, 
      -- add the folder to the delete list.
      IF @DefaultContentFlag = 'Y' AND @PublishedDirectory IS NOT NULL AND @PublishedDirectory <> @PublishDirectory
        INSERT INTO #PublishContent
                    (PublishRequestDetailID,
                     PublishDirectory,
                     DeleteFolderFlag,
                     UseProtectedPath)
        VALUES (@InPublishRequestDetailID,
                @PublishedDirectory,
                'Y',
                @MembersOnlyFlag)

      -- If Member's only flag has been changed, remove files from old location.
      IF @WorkflowStatusCode = 'A' AND IsNull(@PrevMembersOnlyFlag,'N') <> IsNull(@MembersOnlyFlag,'N')
        INSERT INTO #PublishContent
                    (PublishRequestDetailID,
                     PublishLocation,
                     RemoveFlag,
                     UseProtectedPath)
        SELECT @InPublishRequestDetailID,
               a.PublishLocation,
               'Y',
               a.MembersOnlyFlag
          FROM Content a WITH (NOLOCK)
         WHERE a.ContentID = @PreviousContentID
        UNION
        SELECT @InPublishRequestDetailID,
               a.PublishLocation,
               'Y',
               IsNull(@PrevMembersOnlyFlag,'N')
          FROM Content_File a WITH (NOLOCK)
         WHERE a.ContentID = @PreviousContentID

    END --- PublishRegenrateInd = 'P'
  END -- Approved or already published contents
  -- If delete flag is set, delete the entire directory.
  ELSE IF @InDeleteFlag = 'Y' AND @PreviousWebsiteKey IS NOT NULL BEGIN
    DECLARE
      @PreviousDirectory varchar(255)

      SELECT @PreviousDirectory = Replace(CASE WHEN @NavContentGroupInd = 'N' THEN IsNull(w.NavPublishDirectory,'')
                                          ELSE IsNull(w.ContentFolderPublishDirectory,'') END
                                     + @FilePath,'\','/')
        FROM Website w WITH (NOLOCK)
       WHERE WebsiteKey = @PreviousWebsiteKey

      INSERT INTO #PublishContent
                  (PublishRequestDetailID,
                   PublishDirectory,
                   DeleteFolderContentFlag,
                   UseProtectedPath)
      VALUES (@InPublishRequestDetailID,
              @PreviousDirectory,
              'Y',
              @MembersOnlyFlag)

      IF @MembersOnlyFlag = 'Y' AND @OldPublishedDefaultFileName IS NOT NULL
        INSERT INTO #PublishContent
                    (PublishRequestDetailID,
                     PublishDirectory,
                     DeleteFolderContentFlag,
                     UseProtectedPath)
        VALUES (@InPublishRequestDetailID,
                @PreviousDirectory,
                'Y',
                'N')
  END
  ELSE IF (@WorkflowStatusCode = 'D' OR @WorkflowStatusCode = 'R') BEGIN -- Content to Delete
    -- Delete all the files from Content, Content_HTML and Content_File.
    INSERT INTO #PublishContent
                (PublishRequestDetailID,
                 PublishLocation,
                 RemoveFlag,
                 UseProtectedPath)
    SELECT @InPublishRequestDetailID,
           PublishLocation,
           'Y',
           a.MembersOnlyFlag
      FROM Content a WITH (NOLOCK)
     WHERE ContentID = @ContentID
       AND PublishLocation IS NOT NULL

    INSERT INTO #PublishContent
                (PublishRequestDetailID,
                 PublishLocation,
                 RemoveFlag,
                 UseProtectedPath)
    SELECT @InPublishRequestDetailID,
           PublishLocation,
           'Y',
           @MembersOnlyFlag
      FROM Content_HTML a WITH (NOLOCK)
     WHERE ContentID = @ContentID
       AND PublishLocation IS NOT NULL

    INSERT INTO #PublishContent
                (PublishRequestDetailID,
                 PublishLocation,
                 RemoveFlag,
                 UseProtectedPath)
    SELECT @InPublishRequestDetailID,
           PublishLocation,
           'Y',
           @MembersOnlyFlag
      FROM Content_File a WITH (NOLOCK)
     WHERE ContentID = @ContentID
       AND PublishLocation IS NOT NULL

    -- For Member's only flag, remove default file from regular path as well.
    IF @MembersOnlyFlag = 'Y'
      INSERT INTO #PublishContent
                  (PublishRequestDetailID,
                   PublishLocation,
                   RemoveFlag,
                   UseProtectedPath)
      SELECT @InPublishRequestDetailID,
             PublishLocation,
             'Y',
             'N'
        FROM Content a WITH (NOLOCK)
       WHERE ContentID = @ContentID
         AND PublishLocation IS NOT NULL

    --If Nav_Menu record is marked for deletion, add the folder to delete list.
    IF @NavMenuWorkflowStatus = 'D' BEGIN
        INSERT INTO #PublishContent
                    (PublishRequestDetailID,
                     PublishDirectory,
                     DeleteFolderFlag)
        VALUES (@InPublishRequestDetailID,
                @PublishedDirectory,
                'Y')

       -- If member's only, we need to remove member's only directory as well.
       IF @MembersOnlyFlag = 'Y'
        INSERT INTO #PublishContent
                    (PublishRequestDetailID,
                     PublishDirectory,
                     DeleteFolderFlag,
                     UseProtectedPath)
        VALUES (@InPublishRequestDetailID,
                @PublishedDirectory,
                'Y',
                'Y')
    END
  END 
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetCurrentContents]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetCurrentContents]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure gets current contents for specified NavMenuID
--
-- Modifications
-- 09/03/2003    E.Tatsui   Created
-- =============================================

CREATE          PROCEDURE [dbo].[amsp_CMGetCurrentContents]
	@InNavMenuID numeric
AS

  DECLARE
    @ContentID numeric,
    @HTMLCount integer,
    @TaggedPageLayoutID numeric,
    @LinkCount integer,
    @FileCount integer,
    @IconFileName varchar(255),
    @FileTypeDesc varchar(255),
    @EditPage varchar(255),
    @PreFuseURL varchar(500),
    @RecycleBinID numeric

  SELECT @RecycleBinID = NavMenuID
    FROM Nav_Menu
   WHERE Name = 'Content_Recycle_Bin'

  CREATE TABLE #Contents
  (ContentID numeric,
   PreviousContentID numeric,
   NavMenuID numeric,
   Name varchar(255),
   PublishLocation varchar(255),
   ShowInTemplateFlag char(1),
   WorkflowStatusCode char(1),
   MembersOnlyFlag char(1),
   HTMLCount integer,
   TaggedPageLayoutID integer,
   LinkCount integer,
   FileCount integer,
   IconFileName varchar(255),
   FileTypeDesc varchar(255),
   EditPage varchar(255),
   PreFuseURL varchar(500))

  -- Normal folder
  IF @RecycleBinID <> @InNavMenuID 
    INSERT INTO #Contents
    SELECT ContentID,
           PreviousContentID,
           NavMenuID,
           Name,
           PublishLocation,
           ShowInTemplateFlag,
           WorkflowStatusCode,
           MembersOnlyFlag,
           (SELECT count(*) FROM Content_HTML WITH (NOLOCK) WHERE ContentID = a.ContentID),
           (SELECT TOP 1 TaggedPageLayoutID FROM Content_Link  WITH (NOLOCK) WHERE ContentID = a.ContentID),
           (SELECT Count(*) FROM Content_Link WHERE ContentID = a.ContentID),
           (SELECT Count(*) FROM Content_File WHERE ContentID = a.ContentID),
           SPACE(255),
           SPACE(255),
           SPACE(255),
           SPACE(500)
      FROM vCurrent_Content a WITH (NOLOCK)
     WHERE NavMenuID = @InNavMenuID
  ELSE  -- Recycle bin
    INSERT INTO #Contents
    SELECT a.ContentID,
           a.PreviousContentID,
           a.NavMenuID,
           a.Name,
           a.PublishLocation,
           a.ShowInTemplateFlag,
           a.WorkflowStatusCode,
           a.MembersOnlyFlag,
           (SELECT count(*) FROM Content_HTML WITH (NOLOCK) WHERE ContentID = a.ContentID),
           (SELECT TOP 1 TaggedPageLayoutID FROM Content_Link  WITH (NOLOCK) WHERE ContentID = a.ContentID),
           (SELECT Count(*) FROM Content_Link WHERE ContentID = a.ContentID),
           (SELECT Count(*) FROM Content_File WHERE ContentID = a.ContentID),
           SPACE(255),
           SPACE(255),
           SPACE(255),
           SPACE(500)
      FROM vRecycle_Bin a WITH (NOLOCK)
 
  DECLARE c_Contents CURSOR FOR 
   SELECT ContentID,
          HTMLCount,
          TaggedPageLayoutID,
          LinkCount,
          FileCount
     FROM #Contents
 
  OPEN c_Contents
  FETCH NEXT FROM c_Contents
   INTO @ContentID,
        @HTMLCount,
        @TaggedPageLayoutID,
        @LinkCount,
        @FileCount

  WHILE @@FETCH_STATUS = 0 BEGIN
    IF @TaggedPageLayoutID IS NOT NULL BEGIN
      SET @IconFileName = 'TaggedPage_icon.gif'
      SET @FileTypeDesc = 'Tagged Page'
      SET @EditPage = 'ContentProperties'
    END
    ELSE IF @HTMLCount = 1 AND @FileCount = 0 AND @LinkCount = 0 BEGIN
      SET @IconFileName = 'html_icon.gif'
      SET @FileTypeDesc = 'HTML Document'
      SET @EditPage = 'Editor' 
    END
    ELSE IF @HTMLCount = 0 AND @FileCount = 0 AND @LinkCount = 1 BEGIN
      SET @IconFileName = 'link_icon.gif'
      SET @FileTypeDesc = 'Link'
      SET @EditPage = 'ContentProperties'
    END
    ELSE IF @HTMLCount = 0 AND @FileCount = 1 AND @LinkCount = 0 BEGIN
      SELECT @IconFileName = IsNull(b.IconFileName, 'OtherType_icon.gif'),
             @FileTypeDesc = IsNull(b.FileTypeDesc, 'OtherType_icon.gif')
        FROM Content_File a, File_Type_Ref b
       WHERE a.FileTypeCode = b.FileTypeCode
         AND a.ContentID = @ContentID
      SET @EditPage = 'ContentProperties'
    END
    ELSE IF (@HTMLCount + @FileCount + @LinkCount) > 0 BEGIN
      SET @IconFileName = 'list_icon.gif'
      SET @FileTypeDesc = 'Mixed Content'
      SET @EditPage = 'ContentProperties'
    END
    ELSE  BEGIN
      SET @IconFileName = 'none_icon.gif'
      SET @FileTypeDesc = 'Not defined'
    END

    EXECUTE amsp_CMGetFuseURL @InNavMenuID, @ContentID, @PreFuseURL OUTPUT, NULL
    
    UPDATE #Contents
       SET IconFileName = @IconFileName,
           FileTypeDesc = @FileTypeDesc,
           EditPage = @EditPage,
           PreFuseURL = @PreFuseURL
     WHERE ContentID = @ContentID

    FETCH NEXT FROM c_Contents
     INTO @ContentID,
          @HTMLCount,
          @TaggedPageLayoutID,
          @LinkCount,
          @FileCount
  END

  CLOSE c_Contents
  DEALLOCATE c_Contents
  
  SELECT * FROM #Contents ORDER BY Name

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetFuturePublishPath]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetFuturePublishPath]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This is a stored procedure to get future publish path.
--
-- Modifications
-- 06/05/2003  E.Tatsui   Coverted from CFML.
-- =============================================

CREATE                     PROCEDURE [dbo].[amsp_CMGetFuturePublishPath]
	@InContentID numeric,
  @InContentFileID numeric = 0,
  @InMicrositeID numeric = 0,
  @OutPublishPath varchar(255) OUTPUT 
AS
BEGIN

  DECLARE
    @Name varchar(255),
    @TemplatePath varchar(255),
    @NavContentGroupInd char(1),
    @URLSafeName varchar(255),
    @MembersOnlyFlag char(1),
    @ShowInTemplateFlag char(1),
    @FileName varchar(255),
    @l_TemplatePath varchar(255),
    @l_PublishPath varchar(255),
    @FilePath varchar(255),
    @NavMenuID numeric,
    @NavContentDisplayPath varchar(255),
    @GECodePath varchar(255),
    @UseAspNetTemplateFlag char(1),
    @NextURLChar char(1),
    @URLParams varchar(255)

    SET @URLParams = ''

    SELECT @GECodePath = Value
      FROM System_Variable
     WHERE Name = 'GECodePath'
 
    -- If ContentFileID is passed, figure out the location.
    IF @InContentFileID > 0 BEGIN
      SELECT @Name = a.Name,
             @NavContentGroupInd = a.NavContentGroupInd,
             @TemplatePath = a.TemplatePath,
             @MembersOnlyFlag = b.MembersOnlyFlag,
             @ShowInTemplateFlag = b.ShowInTemplateFlag,
             @FileName = c.FileName,
             @FilePath = a.FilePath,
             @NavContentDisplayPath = IsNull(w.NavContentDisplayPath,''),
             @UseAspNetTemplateFlag = w.UseAspNetTemplateFlag
        FROM Nav_Menu a WITH (NOLOCK),
             Content b WITH (NOLOCK),
             Content_File c WITH (NOLOCK), Website w WITH (NOLOCK)
       WHERE b.ContentID = @InContentID
         AND b.NavMenuID = a.NavMenuID
         AND a.WebsiteKey = w.WebsiteKey
         AND b.ContentID = c.ContentID
         AND c.ContentFileID = @InContentFileID
	  
	  IF (@UseAspNetTemplateFlag = 'N') BEGIN
		  IF @NavContentGroupInd = 'C' AND @ShowInTemplateFlag = 'Y'
			SET @l_TemplatePath = @GECodePath + 'TemplateRedirect.cfm?Template='
		  ELSE IF @ShowInTemplateFlag = 'N'
			SET @l_TemplatePath = @GECodePath + 'AMTemplate.cfm?Section=' + @Name + '&Template='
		  ELSE
			SET @l_TemplatePath = @GECodePath + 'Template.cfm?Section=' + @Name + '&Template='
	  
		  IF @MembersOnlyFlag = 'Y'
			SET @l_PublishPath = @l_TemplatePath + '/MembersOnly.cfm&ContentFileID=' + CONVERT(varchar(20),@InContentFileID)
		  ELSE IF @NavContentGroupInd = 'C' AND @MembersOnlyFlag = 'N'
			SET @l_PublishPath = @l_TemplatePath + '/CM/ContentDisplay.cfm&ContentFileID=' + CONVERT(varchar(20),@InContentFileID)
		  ELSE BEGIN
			SET @l_PublishPath = '/' + REPLACE(@NavContentDisplayPath,'\','/') + @FilePath
			SET @l_PublishPath = @l_PublishPath + @FileName
		   END
	  END
	  ELSE BEGIN--- ASP.NET Template
		  SET @NextURLChar = '?'
		  IF @NavContentGroupInd = 'C' AND @ShowInTemplateFlag = 'Y'BEGIN
			SET @l_TemplatePath = @GECodePath + 'ContenManagerNet/TemplateRedirect.aspx?Template=/ContentManagerNet/'
            SET @NextURLChar = '&'
		  END
		  ELSE IF @ShowInTemplateFlag = 'N' BEGIN
			SET @l_TemplatePath = @GECodePath + 'ContentManagerNet/'
            SET @URLParams = '&Section=' + @Name + '&NoTemplate=1'
		  END
		  ELSE BEGIN
			SET @l_TemplatePath = @GECodePath + 'ContentManagerNet/'
			SET @URLParams = '&Section=' + @Name
		  END
		  IF @MembersOnlyFlag = 'Y'
			SET @l_PublishPath = @l_TemplatePath + 'MembersOnly.aspx' + @NextURLChar + 'ContentFileID=' + CONVERT(varchar(20),@InContentFileID) + @URLParams
		  ELSE IF @NavContentGroupInd = 'C' AND @MembersOnlyFlag = 'N'
			SET @l_PublishPath = @l_TemplatePath + 'ContentDisplay.aspx' + @NextURLChar + 'ContentFileID=' + CONVERT(varchar(20),@InContentFileID) + @URLParams
		  ELSE BEGIN
			SET @l_PublishPath = '/' + REPLACE(@NavContentDisplayPath,'\','/') + @FilePath
			SET @l_PublishPath = @l_PublishPath + @FileName
		   END
	END
    END
    ELSE BEGIN -- Otherwise, use asmp_CMGetFuseURL sp.  
      SELECT @NavMenuID = NavMenuID
        FROM Content WITH (NOLOCK)
       WHERE ContentID = @InContentID
      EXEC amsp_CMGetFuseURL @NavMenuID, @InContentID, NULL, @l_PublishPath OUTPUT

      IF LEFT(UPPER(@l_PublishPath),4) <> 'HTTP' AND LEFT(UPPER(@l_PublishPath),1) <> '/'
        SET @l_PublishPath = '/' + @l_PublishPath
    END
      
  SET @OutPublishPath = @l_PublishPath
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetMenuItems]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetMenuItems]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This procedure gets all the menu items to display on the admin side.
--
-- MODIFICATION HISTORY
--
-- 01/03/2001	  N.Malhotra	Simplified joins in sub-selects for DescendantCount and AuthorizedDescendantCount for Performance Reasons
-- 02/23/2002   N.Malhotra	Increased Max Sort Value to 999999999
-- 02/27/2003   R.Wenger	Added NOLOCKs to fix problems deadlocking with massive concurrency
-- 08/01/2003   E.Tatsui    Added sub query for error count. Added logic to filter out by website key.
-- 10/10/2003   E.Tatsui    Added super user logic.
-- 09/26/2005   E.Tatsui    Updated super user logic.
-- =============================================

CREATE                                  procedure amsp_CMGetMenuItems
	@ContactID numeric,
	@NavContentGroupInd char(1),
  @WebsiteKey uniqueidentifier = NULL
as
BEGIN

  DECLARE
    @AdminWebsiteKey uniqueidentifier,
    @SuperGroupID numeric

  -- Find out if this user is a member of a super group.
  SELECT @SuperGroupID = a.ContentAuthorityGroupID
    FROM Content_Authority_Group a, Content_Authority_Producer b
   WHERE a.ContentAuthorityGroupID = b.ContentAuthorityGroupID
     AND b.ContactID = @ContactID
     AND a.SuperGroupFlag = 'Y'

  SELECT DISTINCT a.*,
         b.ContentEditorFlag,
         b.ContentApproverFlag,
         b.NavCreatorFlag,
         b.NavEditorFlag,
         b.CustomPageFlag,
         b.LayoutFlag,
         b.UploadFlag,
         b.EditorFlag,
         b.ComponentScriptFlag,
         c.HideFlag AS ParentHideFlag,
        (SELECT count(*)
           FROM Nav_Menu z WITH (NOLOCK)
          WHERE (z.NavContentGroupInd = 'C' OR z.WebsiteKey = a.WebsiteKey)
            AND z.NavContentGroupInd = a.NavContentGroupInd
            AND z.WorkflowStatusCode <> 'D'
            AND z.SortOrder > a.SortOrder
            AND z.SortOrder <
               (SELECT IsNull(Min(x.SortOrder),999999999)
                  FROM Nav_Menu x
                   WITH (NOLOCK)
                 WHERE x.SortOrder > a.SortOrder
                   AND x.CategoryDepth <= a.CategoryDepth
                   AND (x.NavContentGroupInd = 'C' OR x.WebsiteKey = a.WebsiteKey)
                   AND x.NavContentGroupInd = a.NavContentGroupInd)
            AND (@SuperGroupID IS NOT NULL
             OR z.ContentAuthorityGroupID IN (SELECT ContentAuthorityGroupID
						                                    FROM Content_Authority_Producer WITH (NOLOCK)
						                                   WHERE ContactID = @ContactID))) AS AuthorizedDescendantCount,
         NULL As AncestoryHideFlag,
         (SELECT count(*)
            FROM Content z
             WITH (NOLOCK)
           WHERE z.NavMenuID = a.NavMenuID
             AND z.WorkflowStatusCode = 'W') AS WorkingContentCount,
         (SELECT count(*)
            FROM Content z
             WITH (NOLOCK)
          WHERE z.NavMenuID = a.NavMenuID
             AND (z.WorkflowStatusCode = 'Q' OR z.WorkflowStatusCode = 'E')) AS PendingContentCount,
         (SELECT count(*)
            FROM Content z
            WITH (NOLOCK)
           WHERE z.NavMenuID = a.NavMenuID
             AND z.WorkflowStatusCode = 'A') AS ApprovedContentCount,
         (SELECT Count(ContentID)
            FROM vCurrent_Content z
             WITH (NOLOCK)
           WHERE z.NavMenuID = a.NavMenuID) AS CurrentContentCount,
         (SELECT MAX(ContentID)
            FROM vCurrent_Content z
             WITH (NOLOCK)
           WHERE z.NavMenuID = a.NavMenuID
             AND (z.ContentID = a.ContentID OR z.PreviousContentID = a.ContentID)) AS WorkingContentID,
         (SELECT Count(*)
            FROM Content z WITH (NOLOCK), Publish_Request_Detail y WITH (NOLOCK), Publish_Message_Log x WITH (NOLOCK)
           WHERE z.ContentID = y.ContentID
             AND y.PublishRequestDetailID = x.PublishRequestDetailID
             AND y.PublishRequestStatusCode = 'F'
             AND z.NavMenuID = a.NavMenuID
             AND x.DisplayFlag = 'Y') AS ErrorCount
    INTO #Temp
    FROM (Nav_Menu a WITH (NOLOCK) LEFT OUTER JOIN Content_Authority_Producer b
     WITH (NOLOCK)
      ON (@SuperGroupID IS NULL AND a.ContentAuthorityGroupID = b.ContentAuthorityGroupID
	        AND b.ContactID = @ContactID)
      OR (@SuperGroupID IS NOT NULL AND b.ContentAuthorityGroupID = @SuperGroupID
	         AND b.ContactID = @ContactID))
     LEFT OUTER JOIN Nav_Menu c WITH (NOLOCK)
    ON a.ParentNavMenuID = c.NavMenuID
   WHERE a.NavContentGroupInd = @NavContentGroupInd
     AND (a.MicrositeFlag IS NULL OR a.MicrositeFlag = 'N')
     AND (a.WebsiteKey = CASE WHEN @NavContentGroupInd = 'N' THEN @WebsiteKey
                            ELSE a.WebsiteKey END
      OR a.WebsiteKey IS NULL)
     AND a.WorkflowStatusCode <> 'D'
   ORDER BY a.SortOrder

        
  SELECT @AdminWebsiteKey = Value
    FROM System_Variable WITH (NOLOCK)
   WHERE Name = 'CMAdminWebsiteKey'
     

  -- For Admin site, only show licensed components.
  IF @WebsiteKey = @AdminWebsiteKey BEGIN
    DECLARE
      @NavMenuID numeric,
      @ParentNavMenuID numeric,
      @AncestorNavMenuID numeric,
      @LoopID numeric

    DECLARE c_Inactives CURSOR FOR
    SELECT NavMenuID,
           ParentNavMenuID,
           AncestorNavMenuID
      FROM #Temp
     WHERE ComponentCode IS NOT NULL 
       AND NOT EXISTS(SELECT 1
                        FROM Component_Ref x WITH (NOLOCK)
                       WHERE #Temp.ComponentCode = x.ComponentCode
                         AND x.ActiveFlag = 'Y')
     ORDER BY SortOrder

    OPEN c_Inactives
    FETCH NEXT FROM c_Inactives
          INTO @NavMenuID,
               @ParentNavMenuID,
               @AncestorNavMenuID

    WHILE @@FETCH_STATUS = 0 BEGIN
      SET @LoopID = @ParentNavMenuID
      -- Decrement DescendantCount for all the ancestors.
      WHILE @LoopID IS NOT NULL OR @LoopID <> @AncestorNavMenuID BEGIN
        UPDATE #Temp
           SET DescendantCount = DescendantCount -1
         WHERE NavMenuID = @LoopID

        SELECT @LoopID = ParentNavMenuID
          FROM #Temp
         WHERE NavMenuID = @LoopID

        IF @LoopID IS NULL OR @@RowCount = 0 
          BREAK
      END

      DELETE FROM #Temp
       WHERE NavMenuID = @NavMenuID

      FETCH NEXT FROM c_Inactives
            INTO @NavMenuID,
                 @ParentNavMenuID,
                 @AncestorNavMenuID
    END
    CLOSE c_Inactives
    DEALLOCATE c_Inactives
  END

  SELECT a.*,
         CASE WHEN c.ContentID IS NOT NULL THEN 'Y'
         ELSE 'N' END AS HTMLContentFlag
    FROM #Temp a LEFT OUTER JOIN Content b  WITH (NOLOCK)
      ON a.WorkingContentID = b.ContentID
    LEFT OUTER JOIN Content_HTML c  WITH (NOLOCK)
      ON b.ContentID = c.ContentID
   ORDER BY a.SortOrder

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetMissingTagContent]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetMissingTagContent]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- Stored Procedure to get all the content records from content fodlers that do not have
-- any tags associated.
--
-- 10/11/2003   E.Tatsui   Created
-- =============================================

CREATE     PROCEDURE amsp_CMGetMissingTagContent
  @InNavMenuID numeric = NULL,
  @InContentID numeric = NULL,
  @InContactID numeric,
  @InIncludeDescendants char(1) = 'N'
AS
BEGIN
  DECLARE
    @NavMenuID numeric,
    @MaxSort numeric(28,18),
    @MinSort numeric(28,18),
    @SuperUserFlag bit

  -- Find out if this user is a member of a super group as a nav creator or editor.
  SET @SuperUserFlag = 0
  SELECT @SuperUserFlag = 1
    FROM Content_Authority_Group a WITH (NOLOCK), Content_Authority_Producer b WITH (NOLOCK)
   WHERE a.ContentAuthorityGroupID = b.ContentAuthorityGroupID
     AND b.ContactID = @InContactID
     AND (b.NavCreatorFlag = 'Y' OR b.NavEditorFlag = 'Y')
     AND a.SuperGroupFlag = 'Y'

  IF @InContentID IS NOT NULL
    SELECT @NavMenuID = NavMenuID
      FROM Content WITH (NOLOCK)
     WHERE ContentID = @InContentID

  ELSE IF @InNavMenuID IS NOT NULL AND @InIncludeDescendants  = 'Y'
    SELECT @MinSort = a.SortOrder,
           @MaxSort = (SELECT IsNull(Min(x.SortOrder),0)
              FROM Nav_Menu x
              WITH (NOLOCK)
             WHERE x.SortOrder > a.SortOrder
               AND x.CategoryDepth <= a.CategoryDepth)
      FROM Nav_Menu a  WITH (NOLOCK)
     WHERE a.NavMenuID = @InNavMenuID
 ELSE
   SET @NavMenuID = @InNavMenuID

  -- Get all the content records w/o tags the user is authorized to publish.
  IF @SuperUserFlag = 1
    SELECT a.ContentID,
           a.Name,
           c.Title,
           c.NavMenuID
      FROM vCurrent_Content a WITH (NOLOCK) 
      LEFT OUTER JOIN Component_Interest_Category b WITH (NOLOCK)
        ON a.ContentID = b.ComponentID
       AND b.ComponentCode = 'CM', Nav_Menu c WITH (NOLOCK)
     WHERE a.WorkflowStatusCode IN ('P','A')
       AND a.NavMenuID = c.NavMenuID
       AND c.NavContentGroupInd = 'C'
       AND b.ComponentID IS NULL
       AND ((@NavMenuID IS NOT NULL AND a.NavMenuID = @NavMenuID)
            OR (@NavMenuID IS NULL 
                AND c.SortOrder >= @MinSort
                AND c.SortOrder < @MaxSort))
      ORDER BY c.SortOrder, a.SortOrder
  ELSE
    SELECT a.ContentID,
           a.Name,
           c.Title,
           c.NavMenuID
      FROM vCurrent_Content a WITH (NOLOCK) 
      LEFT OUTER JOIN Component_Interest_Category b WITH (NOLOCK)
        ON a.ContentID = b.ComponentID
       AND b.ComponentCode = 'CM', Nav_Menu c WITH (NOLOCK),
           Content_Authority_Producer d
     WHERE a.WorkflowStatusCode IN ('P','A')
       AND a.NavMenuID = c.NavMenuID
       AND c.NavContentGroupInd = 'C'
       AND b.ComponentID IS NULL
       AND c.ContentAuthorityGroupID = d.ContentAuthorityGroupID
       AND d.ContactID = @InContactID
       AND (d.NavCreatorFlag = 'Y' OR d.NavEditorFlag = 'Y')
       AND ((@NavMenuID IS NOT NULL AND a.NavMenuID = @NavMenuID)
            OR (@NavMenuID IS NULL 
                AND c.SortOrder >= @MinSort
                AND c.SortOrder < @MaxSort))
      ORDER BY c.SortOrder, a.SortOrder
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetPublishableDescendants]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetPublishableDescendants]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure gets descendatns for nav item.
--
-- Modifications
-- 06/11/2003    E.Tatsui   Created
-- =============================================

CREATE   PROCEDURE amsp_CMGetPublishableDescendants
  @InNavMenuID numeric,
  @InContactID numeric
AS
BEGIN

  DECLARE 
    @MaxSort numeric(28,18),
    @MinSort numeric(28,18),
    @SuperUserFlag bit

  SET @SuperUserFlag = 0
  -- First, find out if this user is a member of a super group as a nav creator or editor.
  SELECT @SuperUserFlag = 1
    FROM Content_Authority_Group a, Content_Authority_Producer b
   WHERE a.ContentAuthorityGroupID = b.ContentAuthorityGroupID
     AND b.ContactID = @InContactID
     AND (b.NavCreatorFlag = 'Y' OR b.NavEditorFlag = 'Y')
     AND a.SuperGroupFlag = 'Y'

  SELECT @MinSort = a.SortOrder,
         @MaxSort = (SELECT IsNull(Min(x.SortOrder),0)
            FROM Nav_Menu x
            WITH (NOLOCK)
           WHERE x.SortOrder > a.SortOrder
             AND x.CategoryDepth <= a.CategoryDepth)
    FROM Nav_Menu a  WITH (NOLOCK)
   WHERE a.NavMenuID = @InNavMenuID

  -- Super admin can publish anything.
  IF @SuperUserFlag = 1
    SELECT a.NavMenuID,
           a.Title,
           a.CategoryDepth,
           (SELECT count(*)
              FROM Content z WITH (NOLOCK)
             WHERE z.NavMenuID = a.NavMenuID
               AND (z.PublishDateTime IS NULL OR z.PublishDateTime < CURRENT_TIMESTAMP)
               AND (z.WorkflowStatusCode = 'A' OR z.WorkflowStatusCode = 'P')) AS ContentCount
      FROM Nav_Menu a WITH (NOLOCK)
     WHERE a.SortOrder > @MinSort
       AND a.SortOrder < @MaxSort
       AND a.WorkflowStatusCode <> 'D'
     ORDER BY a.SortOrder
  ELSE -- Everyone else needs to worry about which group they belong.
    SELECT a.NavMenuID,
           a.Title,
           a.CategoryDepth,
           (SELECT count(*)
              FROM Content z WITH (NOLOCK)
             WHERE z.NavMenuID = a.NavMenuID
               AND (z.PublishDateTime IS NULL OR z.PublishDateTime < CURRENT_TIMESTAMP)
               AND (z.WorkflowStatusCode = 'A' OR z.WorkflowStatusCode = 'P')) AS ContentCount
      FROM Nav_Menu a WITH (NOLOCK), Content_Authority_Producer b WITH (NOLOCK)
     WHERE a.ContentAuthorityGroupID = b.ContentAuthorityGroupID
       AND b.ContactID = @InContactID
       AND (b.NavCreatorFlag = 'Y' OR b.NavEditorFlag = 'Y')
       AND a.SortOrder > @MinSort
       AND a.SortOrder < @MaxSort
       AND a.WorkflowStatusCode <> 'D'
     ORDER BY a.SortOrder

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetPublishableNavMenu]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetPublishableNavMenu]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure gets descendatns for nav item.
--
-- Modifications
-- 06/11/2003    E.Tatsui   Created
-- =============================================

CREATE PROCEDURE amsp_CMGetPublishableNavMenu
  @InNavMenuID numeric,
  @InContactID numeric
AS
BEGIN

  DECLARE 
    @MaxSort numeric(28,18),
    @MinSort numeric(28,18)

  SELECT @MinSort = a.SortOrder,
         @MaxSort = (SELECT IsNull(Min(x.SortOrder),0)
            FROM Nav_Menu x
            WITH (NOLOCK)
           WHERE x.SortOrder > a.SortOrder
             AND x.CategoryDepth <= a.CategoryDepth)
    FROM Nav_Menu a
   WHERE a.NavMenuID = @InNavMenuID

  SELECT a.NavMenuID,
         a.Title,
         a.CategoryDepth,
         (SELECT count(*)
            FROM Content z WITH (NOLOCK)
           WHERE z.NavMenuID = a.NavMenuID
             AND (z.PublishDateTime IS NULL OR z.PublishDateTime < CURRENT_TIMESTAMP)
             AND (z.WorkflowStatusCode = 'A' OR z.WorkflowStatusCode = 'P')) AS ContentCount
    FROM Nav_Menu a WITH (NOLOCK), Content_Authority_Producer b WITH (NOLOCK)
   WHERE a.ContentAuthorityGroupID = b.ContentAuthorityGroupID
     AND b.ContactID = @InContactID
     AND (b.NavCreatorFlag = 'Y' OR b.NavEditorFlag = 'Y')
     AND a.SortOrder > @MinSort
     AND a.SortOrder < @MaxSort
   ORDER BY a.SortOrder

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetPublishedContentID]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetPublishedContentID]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/**************************************************************
** Finds the version of the content that is published.
**
**
***************************************************************
*/


CREATE    PROCEDURE amsp_CMGetPublishedContentID
    @InContentID numeric,
    @OutContentID numeric OUTPUT,
    @InFuseFlag Numeric = 0
AS
BEGIN
  DECLARE
    @MyWorkflowStatusCode char(1),
    @ParentWorkflowStatusCode char(1),
    @ChildWorkflowStatusCode char(1),
    @ChildContentID numeric,
    @ParentContentID numeric,
    @Counter integer
    
  -- Initialize our return code
  SET @OutContentID = 0
   
  -- First, figure out if this one is published, or there is one that is published associated
  -- with this one.
  SELECT @MyWorkflowStatusCode = a.WorkflowStatusCode, 
         @ParentContentID = a.PreviousContentID,
         @ParentWorkflowStatusCode = c.WorkflowStatusCode, 
         @ChildContentID = b.ContentID, 
         @ChildWorkflowStatusCode = b.WorkflowStatusCode
    FROM (Content a LEFT OUTER JOIN Content b ON a.ContentID = b.PreviousContentID)
         LEFT OUTER JOIN Content c ON a.PreviousContentID = c.ContentID
   WHERE a.ContentID = @InContentID
   
  -- If the status of the contentID sent in is P for Published, just return it
  -- IK: Check for @InFuseFlag to handle "Approved" status for fusing.
  IF @MyWorkflowStatusCode = 'P' OR (@InFuseFlag = '1' AND @MyWorkflowStatusCode = 'A')
    SET @OutContentID = @InContentID
  ELSE
    BEGIN
      -- Otherwise, if the status of the Parent is P for Published, return the Parent's ID
      -- this should occur if the current one is working
      IF @ParentWorkflowStatusCode = 'P'
        SET @OutContentID = @ParentContentID
      ELSE
        BEGIN
          -- Otherwise, if there is a child, check it's status
          IF @ChildWorkflowStatusCode = 'P'
            SET @OutContentID = @ChildContentID
          ELSE BEGIN
            -- Otherwise, if there is a child, it must have or need a child, so loop
            -- To make sure a bad content list doesn't lock the server, we also
            -- limit this to 50 iterations.
            SET @Counter = 0
              
            WHILE (@ChildWorkflowStatusCode IS NOT NULL AND @OutContentID = 0 AND @Counter < 50) BEGIN
              SET @Counter = @Counter + 1
              SELECT @ChildWorkflowStatusCode = WorkflowStatusCode,
                     @ChildContentID = ContentID
                FROM Content
               WHERE PreviousContentID = @ChildContentID
               
              IF (@@RowCount = 1) BEGIN
                IF (@ChildWorkflowStatusCode = 'P') BEGIN
                  SET @OutContentID = @ChildContentID
                END
              END
            END
          END
        END
    END
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetPublishingServer]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetPublishingServer]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- SP to get publishing server information based on the information provided.
--
-- Modifications
-- 06/20/2003    E.Tatsui    Created
-- =============================================
CREATE   PROCEDURE amsp_CMGetPublishingServer 
	@InServerCode char(1),
	@InIPAddress varchar(15),
	@InPollRequestInd char(1)

AS

BEGIN
   
  SELECT *
    FROM Publish_Server_Ref
   WHERE PublishServerCode = @InServerCode
     AND ServerIPAddress = @InIPAddress
     AND PollRequestInd = @InPollRequestInd;

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetPublishRequests]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetPublishRequests]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- Gets publishing requests that need to be executed.
--
-- Modifications
-- 06/05/2003  E.Tatsui   Converted from CFML.
-- =============================================

CREATE                                 PROCEDURE [dbo].[amsp_CMGetPublishRequests]
  @InServerCode char(1),
  @InServerIPAddress varchar(15),
  @InPublishRegenerateInd char(1)
AS

BEGIN

  DECLARE
    @PublishRequestDetailID numeric,
    @GECodePath varchar(255),
    @DeleteFlag char(1),
    @PublishingSpeed int,
    @RequestNum int,
    @SQL nvarchar (2500)

  SET @PublishingSpeed = 100

  SELECT @PublishingSpeed = PublishingSpeed
    FROM Publish_Server_Ref
   WHERE PublishServerCode = @InServerCode

  CREATE TABLE #PublishRequests
  (NextPublishDate datetime,
   PublishRequestID integer,
   PublishRequestDetailID integer,
   ContentID integer,
   SourceRootLocation varchar(255) COLLATE database_default,
   PublishRootPath varchar(255) COLLATE database_default,
   ProtectedRootPath varchar(255) COLLATE database_default,
   PublishRegenerateInd char(1) COLLATE database_default,
   WebsiteKey uniqueidentifier,
   ReloadMenuURL varchar(255) COLLATE database_default,
   DefaultServerFlag char(1) COLLATE database_default,
   DeleteFlag char(1) COLLATE database_default,
   PublishPriorityCode smallint)

  -- SET ROWCOUNT @PublishingSpeed
  SET @SQL = 'INSERT INTO #PublishRequests 
         SELECT TOP ' + CAST(@PublishingSpeed as varchar(20)) + 
         ' DATEADD(second, prd.Frequency, prd.PublishedDateTime) AS NextPublishDate, 
         pr.PublishRequestID,
         prd.PublishRequestDetailID, 
         Convert(int,prd.ContentID),
         psr.SourceRootLocation,
         w.PublishRootPath,
         w.ProtectedRootPath,
         prd.PublishRegenerateInd,
         w.WebsiteKey,
         w.WebsiteRootURL,
         ''Y'',
         prd.DeleteFlag,
         pr.PublishPriorityCode
    FROM Publish_Request pr WITH (NOLOCK), Publish_Request_Detail prd WITH (NOLOCK),
         Website w WITH (NOLOCK), Publish_Server_Ref psr WITH (NOLOCK), Content c
   WHERE pr.PublishRequestID = prd.PublishRequestID
     AND prd.WebsiteKey = w.WebsiteKey
     AND prd.PublishServerCode = psr.PublishServerCode
     AND prd.PublishRequestID = pr.PublishRequestID
     AND prd.ContentID = c.ContentID
     AND (c.PublishDateTime IS NULL OR c.PublishDateTime < GetDate())
     AND (prd.PublishRequestStatusCode = ''N''
          OR ((DATEADD(second, prd.Frequency, prd.PublishedDateTime) <= GetDate())
               AND (prd.Frequency <> 0))
          )
     AND pr.RequestDateTime <= GetDate()
     AND psr.ServerIPAddress = ''' + @InServerIPAddress + '''' + 
    'AND psr.PublishServerCode = ''' + @InServerCode + '''' + 
    'AND IsNull(prd.PublishRegenerateInd,''P'') = ''' + @InPublishRegenerateInd + '''' + 
  'ORDER BY pr.PublishPriorityCode, NextPublishDate, prd.PublishRequestDetailID'

  --print @SQL

  EXEC sp_executesql @SQL

  SET @RequestNum = @@Rowcount

  --SET ROWCOUNT 0

  ALTER TABLE #PublishRequests
  ALTER COLUMN PublishRequestDetailID int NULL

  ALTER TABLE #PublishRequests
  ALTER COLUMN ReloadMenuURL varchar(500) COLLATE database_default

  -- If this is publish requests, add requests to publish navigaiton.
  IF @InPublishRegenerateInd = 'P' AND @RequestNum < @PublishingSpeed
     INSERT INTO #PublishRequests
     SELECT  NULL AS NextPublishDate, 
             pr.PublishRequestID,
             NULL, 
             NULL AS ContentID,
             psr.SourceRootLocation,
             w.PublishRootPath,
             w.ProtectedRootPath,
             'P',
             w.WebsiteKey,
             w.WebsiteRootURL,
             'Y' AS DefaultServerFlag,
             'N' AS DeleteFlag,
             pr.PublishPriorityCode
        FROM Publish_Request pr WITH (NOLOCK) LEFT OUTER JOIN Publish_Request_Detail prd WITH (NOLOCK)
          ON pr.PublishRequestID = prd.PublishRequestID
         AND IsNull(prd.PublishRegenerateInd,'P') = 'P'
        LEFT OUTER JOIN Publish_Message_Log pml WITH (NOLOCK)
          ON pr.PublishRequestID = pml.PublishRequestID, Nav_Menu nm WITH (NOLOCK),
             Website w WITH (NOLOCK), Publish_Server_Ref psr WITH (NOLOCK)
       WHERE pr.NavMenuID = nm.NavMenuID
         AND nm.WebsiteKey = w.WebsiteKey
         AND w.PublishServerCode = psr.PublishServerCode
         AND (pr.PublishedDateTime is NULL)
         AND pr.RequestDateTime <= GetDate()
         AND psr.ServerIPAddress = @InServerIPAddress
         AND psr.PublishServerCode = @InServerCode
         AND prd.PublishRequestID IS NULL
         AND pml.PublishRequestID IS NULL

  SELECT @GECodePath = Value
    FROM System_Variable WITH (NOLOCK)
   WHERE Name = 'GECodePath'

  IF Len(@GECodePath) > 1
    SET @GECodePath = RIGHT(@GECodePath,Len(@GECodePath)-1)
  ELSE IF @GECodePath = '/'
    SET @GECodePath = ''

  UPDATE #PublishRequests
     SET ReloadMenuURL = ReloadMenuURL + @GECodePath + 'NavMenuSetup.cfm'

  CREATE TABLE #PublishContent
               (PublishRequestDetailID numeric,
                SourceLocation varchar(255) COLLATE database_default,
                PublishLocation varchar(255) COLLATE database_default,
                PublishDirectory varchar(255) COLLATE database_default,
                Header varchar(500) COLLATE database_default,
                Footer varchar(500) COLLATE database_default,
                ContentFileID int,
                HTMLContentID int,
                DefaultContentFlag char(1) DEFAULT('N') COLLATE database_default,
                RemoveFlag char(1) DEFAULT('N') COLLATE database_default,
                UseProtectedPath char(1) DEFAULT ('N') COLLATE database_default,
                RedirectFileFlag char(1) DEFAULT('N') COLLATE database_default,
                DeleteFolderFlag char(1) DEFAULT ('N') COLLATE database_default,
                DeleteFolderContentFlag char(1) DEFAULT('N') COLLATE database_default)

  DECLARE c_Request CURSOR FOR
   SELECT PublishRequestDetailID,
          DeleteFlag
     FROM #PublishRequests

  OPEN c_Request
  FETCH NEXT FROM c_Request
   INTO @PublishRequestDetailID,
        @DeleteFlag
  WHILE @@FETCH_STATUS = 0 BEGIN
    EXEC amsp_CMGetContentToPublish @PublishRequestDetailID, @DeleteFlag

    FETCH NEXT FROM c_Request
     INTO @PublishRequestDetailID,
          @DeleteFlag
  END
  CLOSE c_Request
  DEALLOCATE c_Request

  SELECT DISTINCT 
         a.WebsiteKey,
         a.NextPublishDate,
         a.PublishRequestID,
         a.PublishRequestDetailID,
         a.ContentID,
         a.SourceRootLocation,
         CASE WHEN b.UseProtectedPath = 'Y' THEN a.ProtectedRootPath
              ELSE a.PublishRootPath END AS PublishRootPath,
         a.PublishRegenerateInd,
         a.WebsiteKey,
         a.ReloadMenuURL,
         a.DefaultServerFlag,
         a.PublishPriorityCode,
         b.SourceLocation,
         b.PublishLocation,
         b.PublishDirectory,
         b.Header,
         b.Footer,
         b.ContentFileID,
         b.HTMLContentID,
         b.DefaultContentFlag,
         b.RemoveFlag,
         b.RedirectFileFlag,
         b.DeleteFolderFlag,
         b.DeleteFolderContentFlag,
         b.PublishRequestDetailID AS ContentExists
    FROM #PublishRequests a LEFT OUTER JOIN #PublishContent b
      ON a.PublishRequestDetailID = b.PublishRequestDetailID
  ORDER BY a.PublishPriorityCode, NextPublishDate, a.PublishRequestID, a.PublishRequestDetailID, b.RemoveFlag DESC, b.DefaultContentFlag
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetUniqueDirectoryName]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetUniqueDirectoryName]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure creates a unique directory name for a specified nav menu record
--
-- Modifications
-- 08/22/2003    E.Tatsui
-- =============================================

CREATE          PROCEDURE amsp_CMGetUniqueDirectoryName
  @InNavMenuID numeric,
  @InUpdate bit = 0,
  @OutDirectoryName varchar(255) OUTPUT
AS
BEGIN

  DECLARE
    @CategoryDepth integer,
    @ParentNavMenuID numeric,
    @DirectoryName varchar(255),
    @Title varchar(255),
    @RowNum integer,
    @WebsiteKey uniqueidentifier,
    @Counter integer,
    @Temp varchar(255),
    @Index int,
    @Ascii int

  SELECT @ParentNavMenuID = ParentNavMenuID,
         @CategoryDepth = CategoryDepth,
         @DirectoryName = DirectoryName,
         @Title = Title,
         @WebsiteKey = WebsiteKey
    FROM Nav_Menu WITH (NOLOCK)
   WHERE NavMenuID = @InNavMenuID

  -- If directory name is not provided, let's create it from name.
  IF @DirectoryName IS NULL BEGIN
    SET @DirectoryName = @Title
  END

  -- Remove special characters (Everything except for 0-9,a-z,A-Z,and "_")
  SET @Index = 0
  SET @Temp = ''
  WHILE @Index < = LEN(@DirectoryName) BEGIN
    SET @Index = @Index + 1
    SET @Ascii = ASCII(SUBSTRING(@DirectoryName,@Index,1)) 
    IF (@Ascii between 48 and 57 )
       or(@Ascii between 65 and 90)
       or(@Ascii = 95)
       or(@Ascii between 97 and 122)
     SET @Temp = @Temp + Substring(@DirectoryName,@Index,1)
  END
  SET @DirectoryName = @Temp
 
  SET @DirectoryName = Left(@DirectoryName,100)
  
  -- Now find out if this DirectoryName is unique.
  IF @CategoryDepth = 1 BEGIN

    -- For level ones, it needs to be unique regardless of nav item or content folder.
    SELECT @RowNum = COUNT(*)
      FROM Nav_Menu WITH (NOLOCK)
     WHERE DirectoryName = @DirectoryName
       AND WebsiteKey = @WebsiteKey
       AND CategoryDepth = 1
       AND NavMenuID <> @InNavMenuID

    -- If we find a record with the same directory name, let's append a number at the end.    
    SET @Counter = 0
    WHILE @RowNum > 0 BEGIN
      SET @Counter = @Counter + 1
      SELECT @RowNum = COUNT(*)
        FROM Nav_Menu WITH (NOLOCK)
       WHERE DirectoryName = @DirectoryName + Cast(@Counter as varchar(255))
         AND WebsiteKey = @WebsiteKey
         AND CategoryDepth = 1
         AND NavMenuID <> @InNavMenuID
      SET @Counter = @Counter + 1
    END    
    
    IF @Counter > 0
      SET @OutDirectoryName = @DirectoryName + Cast(@Counter as varchar(255))
    ELSE
      SET @OutDirectoryName = @DirectoryName
  END --Ends Level 1s.
  ELSE BEGIN -- For all others, it needs to be unique between sibilings.

    -- For level ones, it needs to be unique regardless of nav item or content folder.
    SELECT @RowNum = COUNT(*)
      FROM Nav_Menu WITH (NOLOCK)
     WHERE DirectoryName = @DirectoryName
       AND WebsiteKey = @WebsiteKey
       AND CategoryDepth = @CategoryDepth
       AND ParentNavMenuID = @ParentNavMenuID
       AND NavMenuID <> @InNavMenuID

    -- If we find a record with the same directory name, let's append a number at the end.    
    SET @Counter = 0
    WHILE @RowNum > 0 BEGIN
      SET @Counter = @Counter + 1
      SELECT @RowNum = COUNT(*)
        FROM Nav_Menu WITH (NOLOCK)
       WHERE DirectoryName = @DirectoryName + Cast(@Counter as varchar(255))
         AND WebsiteKey = @WebsiteKey
         AND CategoryDepth = @CategoryDepth
         AND ParentNavMenuID = @ParentNavMenuID
         AND NavMenuID <> @InNavMenuID
    END    
    
    IF @Counter > 0
      SET @OutDirectoryName = @DirectoryName + Cast(@Counter as varchar(255))
    ELSE
      SET @OutDirectoryName = @DirectoryName
  END -- Ends all other levels.

  -- If "Update" is 1, and the directory name changed, update it.
  IF @InUpdate = 1
    UPDATE Nav_Menu
       SET DirectoryName = @OutDirectoryName
     WHERE NavMenuID = @InNavMenuID

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMNavMenuSetup]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMNavMenuSetup]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE           procedure [dbo].[amsp_CMNavMenuSetup] 

@WebsiteKey uniqueidentifier = null, 
@NavContentGroupInd char(1) = 'N', @Runtime bit = 0

AS
BEGIN

/*
** MODIFICATION HISTORY
**
**    01/02/2001  N.Malhotra  Changed c_ChildNav to use #NavMenu instead of Nav_Menu
**    01/04/2002  E.Tatsui  Added logic for MicrositeFlag
**    01/22/2002  N.Malhotra  Added logic to keep level 1's dynamic
**    01/28/2002  N.Malhotra  Added @InFuseNavMenuID - If provided, the sp is being called to 
**                      calculate the lowest CategoryDepth value where a difference exists
**                      between the current and previous publish operation for the same level 1
**    02/14/2002    N.Malhotra  Changed logic on how PrefuseURL is generated for content with a single link
**    02/23/2002  N.Malhotra  Added indexes to #NavMenu for performance
**    03/04/2002  N.Malhotra  Fixed problem with single link content records where .HTM files were being 
**                      displayed using AMTemplate
**    03/06/2002  N.Malhotra  Deprecated retrieval of app vars to pre 4.1 versions only
**    04/09/2002  N.Malhotra  Added @App_RootPath or @App_SecurePath to beginning of all PostFuseURL values
**    04/11/2002  N.Malhotra  Changed base SQL statement from PublishedDateTime < CURRENT_TIMESTAMP to 
**                      PublishedDateTime <= CURRENT_TIMESTAMP
**    04/12/2002    E.Pfleckl Changed variable and column names for compatibility with case-sensitive DBs
**    10/22/2002    C.Jewell    Changed PreFuseURL for content consisting of a single file to coincide with
**                          Source folder consolidation.
**    01/03/2003    C.Jewell  Added logic for Members Only content to be displayed outside of the template
**    02/13/2003        R.Wenger        Rewrote logic that figures out what content needs to be regenerated, if InNavMenuID is passed.
**                                      It used to just return the category depth below which all content needs to be
**                                      regenerated (see Nitin's note 1/28/2002 above).  Now it returns a result set of all
**                                      nav items that need regeneration. The ended up doing too many
**    03/28/2003        E.Tatsui        Changed so that amsp_SetNavProperties is not run when the sp is run to get modified contents.
**    05/12/2003        E.Tatsui        Changed so that http:// is not appended when URL includes [TemplatePath]
**    05/28/2003        E.Tatsui        Replaced [TemplatePath] solution with /TemplateRedirect.cfm
**    06/18/2003        E.Tatsui        Removed input parameters and simplified the procedure.
**                                      - PostFuseURLs and PreFuseURLS are now stored in the Database.
**                                      - Logic to look for modified nav menus are moved to amsp_CMGetNavMenuToRegenerate
**                                      Limit the result to Navigation items.
**    09/12/2003         R.Wenger     Added @WebsiteKey parameter and code that filters the result set by the websitekey, for use in CM6
**                                                    Added @Runtime parameter and code that filters the result set by whether hidden things need to be included
**                                                   (they don't at runtime, just at design time)
**    10/12/2003       E.Tatsui        Removed a call to amsp_CMSetNavProperties. AncestoryList is stored in Nav_Menu table now.
**    06/09/2006    R.Wenger    Added  COLLATE database_default NULL to the alter table line on the temp
**                    table #Nav_Menu because if the default collation of the system (i.e., in the temp DB
**                    is different that that of this db, the alter will use the temp db's collation.                                
*/

  DECLARE
    @AncestoryHideFlag    char(1),
    @AncestoryNotPublishedFlag  char(1),
    @TemplatePath   varchar(255),
    @CategoryDepth    integer,
    @Name     varchar(255),
    @AncestoryList    varchar(255),
    @ChildNavMenuID        numeric,
    @NumChildren           numeric,
    @ContentID      numeric,
    @NavMenuID      numeric,
    @OldNavMenuID   numeric,
    @ParentNavMenuID    numeric,
    @OldPreFuseURL    varchar(255),
    @PreFuseURL     varchar(255),
    @PostFuseURL    varchar(255),
    @URLParamChar   char(1),
    @GECodePath    varchar(255),
    @AdminWebsiteKey varchar(50),
    @VirtualDirectoryPath varchar(255)

  /*
  ** Gets the currrent, published Nav_Menu into a temp table for use by the template. 
  ** This script reads the info into the table, and adds a few columns that it calculates
  ** to make the template's job a lot easier.
  */

  SELECT a.*,
         e.ImageInitial,
         e.ImageOther,
         e.ImageRollover,
         e.BreadCrumb,
         e.ImageWidth,
         e.ImageHeight,
         b.HideFlag AS ParentHideFlag,
         b.PublishedDateTime AS ParentPubValue,
         b.Name AS ParentName,
         c.ShowInTemplateFlag,
         c.OpenInNewWindowFlag,
         c.SecureFlag AS ContentSecureFlag,
         a.HideFlag AS AncestoryHideFlag,
         'N' AS AncestoryNotPublishedFlag,
         w.WebsiteRootURL,
         w.SecureWebsiteRootURL,
         w.GraphicsDirectory,
         w.TemplateHeaderFileName,
         w.TemplateFooterFileName,
         w.SiteStyleSheet,
         w.UseHierMenuFlag,
         w.ShowBreadCrumbFlag,
     w.UseAspNetTemplateFlag
    INTO #NavMenu
    FROM ((((Nav_Menu a WITH (NOLOCK)
         LEFT OUTER JOIN Nav_Menu b WITH (NOLOCK) ON a.ParentNavMenuID = b.NavMenuID) 
         LEFT OUTER JOIN Content c WITH (NOLOCK) ON a.ContentID = c.ContentID AND c.WorkflowStatusCode = 'P' 
          AND c.PublishDateTime <= CURRENT_TIMESTAMP AND (c.ExpirationDate >= CURRENT_TIMESTAMP
           OR c.ArchiveAtExpirationFlag IS NULL OR c.ArchiveAtExpirationFlag = 'N'))
         LEFT OUTER JOIN Content_HTML d WITH (NOLOCK)  ON c.ContentID = d.ContentID)
         LEFT OUTER JOIN Nav_Menu_Feature e WITH (NOLOCK) ON a.NavMenuID = e.NavMenuID),
         Website w
   WHERE ((a.NavContentGroupInd = 'N' AND a.PublishedDateTime <= CURRENT_TIMESTAMP)
      OR a.NavContentGroupInd = 'C')
     AND (a.MicrositeFlag = 'N' OR a.MicrositeFlag IS NULL)
     AND a.WebsiteKey = w.WebsiteKey
     AND a.NavContentGroupInd = @NavContentGroupInd
   ORDER BY a.NavContentGroupInd DESC, a.SortOrder

  ALTER TABLE #NavMenu
  ALTER Column PostFuseURL varchar(500) COLLATE database_default NULL

  -- For admin template, delete any products that are not licensed.
  SELECT @AdminWebsiteKey = Value
    FROM System_Variable WITH (NOLOCK)
   WHERE Name = 'CMAdminWebsiteKey'

   DELETE FROM #NavMenu
   WHERE WebsiteKey = @AdminWebsiteKey
     AND ComponentCode IS NOT NULL
     AND ComponentCode NOT IN (SELECT ComponentCode FROM Component_Ref WITH (NOLOCK) WHERE ActiveFlag = 'Y')

  /*
  ** Performance Boost
  */

  CREATE INDEX #IDX1 on #NavMenu(NavMenuID)
  CREATE INDEX #IDX2 on #NavMenu(ParentNavMenuID)
 
 /*
  ** Loop through Nav_Menu determine the URL each nav menu item points to. 
  */
  
  DECLARE c_Nav CURSOR FOR 
    SELECT Name,
           ContentID,
           NavMenuID,
           ParentNavMenuID,
           PreFuseURL,
           PostFuseURL
      FROM #NavMenu
     WHERE IsNull(HideFlag,'N') = 'N'
     ORDER BY SortOrder
  
  OPEN c_Nav

  FETCH NEXT FROM c_Nav INTO
    @Name,
    @ContentID,
    @NavMenuID,
    @ParentNavMenuID,
    @PreFuseURL,
    @PostFuseURL
    
  SET @OldPreFuseURL = 'NOT INITIALIZED'

  WHILE (@@FETCH_STATUS=0)
  BEGIN


    /*
    ** also, as long as we are looping through here, determine if the menu item has
    ** a place to link to.  If not, determine if he has a descendant.  If so, copy
    ** the link info from his first descendant. But don't do it for the last item in
    ** the query, it has no children.
    */

    IF (CHARINDEX('MissingInclude',@OldPreFuseURL) > 0 AND 
        @ParentNavMenuID = @OldNavMenuID AND
        CHARINDEX('MissingInclude',@PreFuseURL) =0) 
    BEGIN

      UPDATE #NavMenu
         SET PreFuseURL = @PreFuseURL,
             PostFuseURL = @PostFuseURL
       WHERE NavMenuID = @OldNavMenuID
    END

    SET @OldPreFuseURL = @PreFuseURL
    SET @OldNavMenuID = @NavMenuID

    FETCH NEXT FROM c_Nav 
      INTO
      @Name,
      @ContentID,
      @NavMenuID,

      @ParentNavMenuID,
      @PreFuseURL,
      @PostFuseURL
    
  END /* End While */
    
  
  CLOSE c_Nav
  DEALLOCATE c_Nav

  /*
  ** For items with Level = 1, the PostFuse should be dynamic (i.e. use section)
  ** UNLESS this is a single Link in which case, PostFuse should equal PreFuse.
  ** 04/09/2002 - We want to always nclude @App_RootPath or @App_SecurePath
  */

  SELECT @GECodePath = Value
    FROM System_Variable
   WHERE Name = 'GECodePath'

  SELECT @VirtualDirectoryPath = Value
    FROM System_Variable
   WHERE Name = 'VirtualDirectoryPath'

  IF Len(@GECodePath) > 1
    SET @GECodePath = RIGHT(@GECodePath,Len(@GECodePath)-1)
  ELSE IF @GECodePath = '/'
    SET @GECodePath = ''

  IF Len(@VirtualDirectoryPath) > 1
    SET @VirtualDirectoryPath = RIGHT(@VirtualDirectoryPath,Len(@VirtualDirectoryPath)-1)
  ELSE IF @VirtualDirectoryPath = '/'
    SET @VirtualDirectoryPath = ''

  UPDATE #NavMenu
     SET PostFuseURL = CASE
        WHEN IsNull(ShowInTemplateFlag,'Y') = 'Y' AND ContentSecureFlag = 'Y' THEN 
          a.SecureWebsiteRootURL + @GECodePath + 'Template.cfm' + '?Section=' + Name
        WHEN IsNull(ShowInTemplateFlag,'Y') = 'Y' AND IsNULL(ContentSecureFlag, 'N') = 'N' THEN 
          a.WebsiteRootURL + @GECodePath + 'Template.cfm' + '?Section=' + Name
        WHEN IsNULL(ShowInTemplateFlag, 'Y') = 'N' AND CHARINDEX('.CFM',UPPER(PreFuseURL)) > 0  AND ContentSecureFlag = 'Y' THEN 
          a.SecureWebsiteRootURL + @GECodePath + 'AMTemplate.cfm?Section=' + Name
        WHEN IsNULL(ShowInTemplateFlag, 'Y') = 'N' AND CHARINDEX('.CFM',UPPER(PreFuseURL)) > 0  AND IsNULL(ContentSecureFlag, 'N') = 'N' THEN 
          a.WebsiteRootURL + @GECodePath + 'AMTemplate.cfm?Section=' + Name
        ELSE 
          a.PreFuseURL
      END
    FROM #NavMenu a, Website b
   WHERE CategoryDepth = 1
     AND PostFuseURL != PreFuseURL
     AND a.WebsiteKey = b.WebsiteKey
     AND b.UseAspNetTemplateFlag = 'N'

  /* Added for ASP.NET Templates)*/
  UPDATE #NavMenu
     SET PostFuseURL = CASE
        WHEN IsNull(ShowInTemplateFlag,'Y') = 'Y' AND ContentSecureFlag = 'Y' THEN 
          a.SecureWebsiteRootURL + @VirtualDirectoryPath + '/' + Name + '/AM/ContentManagerNet/Default.aspx' + '?Section=' + Name
        WHEN IsNull(ShowInTemplateFlag,'Y') = 'Y' AND IsNULL(ContentSecureFlag, 'N') = 'N' THEN 
          a.WebsiteRootURL + @VirtualDirectoryPath + '/' + Name + '/AM/ContentManagerNet/Default.aspx' + '?Section=' + Name
        WHEN IsNULL(ShowInTemplateFlag, 'Y') = 'N' AND CHARINDEX('.ASPX',UPPER(PreFuseURL) ) > 0  AND ContentSecureFlag = 'Y' THEN 
          a.SecureWebsiteRootURL + @VirtualDirectoryPath + '/' + Name + '/AM/ContentManagerNet/Default.aspx?NoTemplate=1&Section=' + Name
        WHEN IsNULL(ShowInTemplateFlag, 'Y') = 'N' AND CHARINDEX('.ASPX',UPPER(PreFuseURL) ) > 0  AND IsNULL(ContentSecureFlag, 'N') = 'N' THEN 
          a.WebsiteRootURL + @VirtualDirectoryPath + '/' + Name + '/AM/ContentManagerNet/Default.aspx?NoTemplate=1&Section=' + Name
        ELSE 
          a.PreFuseURL
      END
    FROM #NavMenu a, Website b
   WHERE CategoryDepth = 1
     AND PostFuseURL != PreFuseURL
     AND a.WebsiteKey = b.WebsiteKey
     AND b.UseAspNetTemplateFlag = 'Y'

  /* Unless it's a link outside of this website, add root path or secure root to the URL. */

  UPDATE #NavMenu
     SET PreFuseURL = CASE 
                        WHEN ContentSecureFlag = 'Y' THEN SecureWebsiteRootURL 
                        ELSE WebsiteRootURL END + 
                      CASE WHEN Left(PreFuseURL,1) = '/' THEN Right(PreFuseURL,Len(PreFuseURL)-1)
                        ELSE PreFuseURL END
   WHERE PreFuseURL NOT LIKE 'htt%'

  UPDATE #NavMenu
     SET PostFuseURL =  CASE 
                        WHEN ContentSecureFlag = 'Y' THEN SecureWebsiteRootURL
                        ELSE WebsiteRootURL END + 
                        CASE WHEN Left(PostFuseURL,1) = '/' THEN Right(PostFuseURL,Len(PostFuseURL)-1)
                        ELSE PostFuseURL END
   WHERE PostFuseURL NOT LIKE 'http%'
  

  /* Set AncestoryHideFlag and AncestoryNotPublishedFlag*/
  UPDATE #NavMenu
     SET AncestoryHideFlag = 'Y',
         AncestoryNotPublishedFlag = CASE WHEN b.PublishedDateTime > CURRENT_TIMESTAMP
                                               OR b.PublishedDateTime IS NULL THEN 'Y'
                                     ELSE 'N' END
    FROM #NavMenu a, Nav_Menu b WITH (NOLOCK)
   WHERE a.AncestorNavMenuID = b.NavMenuID
     AND b.HideFlag = 'Y'

  /* Added 09/12/2003 - R. Wenger 
     Removes nav items that you can't see at runtime */
  IF @Runtime = 1
      DELETE FROM #NavMenu
      WHERE AncestoryHideFlag = 'Y'
              OR AncestoryNotPublishedFlag = 'Y'
              OR HideFlag = 'Y'
              OR PublishedFlag = 'N'

  /* Return the entire #NavMenu table if not filtering for CM6 */
  IF @WebsiteKey IS NULL
     SELECT * from #NavMenu
     ORDER BY NavContentGroupInd DESC, SortOrder
  /* Added 09/12/2002 - R.Wenger 
     otherwise, CM6 is per website, and we don't need all the crap you can't show anyway */
  ELSE
     SELECT *
       FROM #NavMenu
    WHERE WebsiteKey = @WebsiteKey
     ORDER BY NavContentGroupInd DESC, SortOrder
END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetWebsiteNavigation]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetWebsiteNavigation]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure amsp_CMGetWebsiteNavigation (@WebsiteKey uniqueidentifier) AS
BEGIN
 SELECT a.*,
        e.ImageInitial,
        e.ImageOther,
        e.ImageRollover,
        e.BreadCrumb,
        e.ImageWidth,
        e.ImageHeight,
        b.HideFlag AS ParentHideFlag,
        b.PublishedDateTime AS ParentPubValue,
        b.Name AS ParentName,
        c.ShowInTemplateFlag,
        c.OpenInNewWindowFlag,
        c.SecureFlag AS ContentSecureFlag,
        space(255) AS AncestoryList,
        a.HideFlag AS AncestoryHideFlag,
        ' ' AS AncestoryNotPublishedFlag,
        w.WebsiteRootURL,
        w.SecureWebsiteRootURL,
        w.TemplateHeaderFileName,
        w.TemplateFooterFileName,
        w.SiteStyleSheet,
        w.UseHierMenuFlag,
        w.ShowBreadCrumbFlag
    INTO #NavMenu
    FROM Nav_Menu a, Nav_Menu b, Content c, Nav_Menu_Feature e, Website w
   WHERE 1 = 0

  exec amsp_CMNavMenuSetup;

  SELECT TOP 1 * FROM #NavMenu
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetWorkingContentID]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetWorkingContentID]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.amsp_GetWorkingContentID    Script Date: 12/10/2001 10:54:33 AM ******/
-- This procedure takes a ContentID as a parameter and makes a new content row
-- to work on if the one given is already published and has no record in a working state
-- (which includes statuses of Working, PendingApproval, or Approved, .  It does this by 
-- duplicating the content record and all of the child records that reference that content 
-- row, including:
--   Content_HTML
--   Content_Link
--   Content_File
--   Custom_Page_Object
--   Custom_Page_Object_Text
--   Component_Interest_Category
--   Tagged_Page_Interest_Category
--
-- Parameters:
--   IN - InContentID - The contentID of the content to be worked on
--   OUT - OutContentID - The contentID of the working record
--   IN - InCreateFlag - indicates whether or not to ALTER  a working row if the latest is
--        Published or Archived.  By default, it does ALTER  a working row if there is not one
--
-- Modification History
--   09/27/2001  N.Malhotra  Added Tagged_Page_Interest_Category to list of Tables
--   12/10/2001  N.Malhotra  Changed 3rd parameter in call to amsp_GetTableColumnList to 'Y' for
--                           Tagged_Page_Interest_Category to include InterestCategoryID in result set.
--   04/11/2002  N.Malhotra  Added Update statement for Content_Link entries that are using the old ContentID
--                           in the link itself (e.g. tagged page links). 
--   04/15/2002  E.Pfleckl   Commented out the Custom_Page_Object and Custom_Page_Object_Text inserts                    
--   09/09/2003  E.Tatsui    Moved the logic to ALTER  a new record to amsp_CMCopyContentRow so that
--                           it can be used from other sps.
--
-- Copyright 2005 Advanced Solutions Intl., All Rights Reserved
CREATE             PROCEDURE amsp_CMGetWorkingContentID 
    @InContentID numeric,
    @InContactID numeric,
    @OutContentID numeric OUTPUT,
    @InCreateFlag char(1) = 'Y' AS
BEGIN
  DECLARE
    @MyWorkflowStatusCode char(1),
    @ChildWorkflowStatusCode char(1),
    @ChildContentID numeric
    
  -- First, figure out if this one is working, or there is one that is working associated
  -- with this one.
  SELECT @MyWorkflowStatusCode = a.WorkflowStatusCode, 
         @ChildContentID = b.ContentID, 
         @ChildWorkflowStatusCode = b.WorkflowStatusCode
    FROM Content a LEFT OUTER JOIN Content b ON a.ContentID = b.PreviousContentID
   WHERE a.ContentID = @InContentID
   
  -- If the status of the contentID sent in is one of the working statuses, just return it
  IF @MyWorkflowStatusCode IN ('W','E','A')
    SET @OutContentID = @InContentID
  ELSE
    BEGIN
      -- Otherwise, if the status of the child is one of the working ones, return the child's ID
      IF @ChildWorkflowStatusCode IN ('W','E','A')
        SET @OutContentID = @ChildContentID
      ELSE
        BEGIN
          -- Otherwise, if there is a child, it must have or need a child, so recurse
          IF @ChildWorkflowStatusCode IS NOT NULL
            EXECUTE amsp_CMGetWorkingContentID @ChildContentID, @InContactID, @OutContentID
          ELSE
            -- Otherwise, the one at the end of the line is not a working one, so make a new one
            EXECUTE amsp_CMCopyContentRow @InContentID, @InContactID, @OutContentID OUTPUT
        END
    END
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMInsertContent]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMInsertContent]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- Creates a Content record
--
-- Modifications:
-- 07/30/2003  E.Tatsui    Created
-- =============================================

CREATE           PROCEDURE amsp_CMInsertContent
	@InNavMenuID numeric,
  @InContactID numeric,
  @InContentTitle varchar(255),
  @OutContentID numeric OUTPUT
AS

BEGIN
  DECLARE
    @DefaultOwnerMeGroupSpecificInd char(1),
    @DefaultOwnerContactID numeric,
    @DefaultReminderDays int,
    @DefaultOwnerID numeric,
    @l_OwnerContactID numeric,
    @ExpirationDays int,
    @l_ExpirationDays int,
    @MembersOnlyFlag char(1),
    @OwnerContactID numeric,
    @DefaultContentID numeric,
    @RowNum int,
    @URLSafeName varchar(255),
    @Counter int,
    @SuperGroupID numeric
  
  -- Get producer's preferences.
  SELECT @DefaultOwnerMeGroupSpecificInd = DefaultOwnerMeGroupSpecificInd,
         @DefaultOwnerContactID = DefaultOwnerContactID,
         @DefaultReminderDays = DefaultReminderDays
    FROM Producer
   WHERE ContactID = @InContactID

  -- Find out if this user is a member of a super group.
  SELECT @SuperGroupID = a.ContentAuthorityGroupID
    FROM Content_Authority_Group a, Content_Authority_Producer b
   WHERE a.ContentAuthorityGroupID = b.ContentAuthorityGroupID
     AND b.ContactID = @InContactID
     AND a.SuperGroupFlag = 'Y'

  -- Get nav_menu's info.
  SELECT @DefaultOwnerID = (SELECT TOP 1 ContactID FROM Content_Authority_Producer  WHERE DefaultOwnerFlag = 'Y' AND ContentAuthorityGroupID = a.ContentAuthorityGroupID),
         @OwnerContactID = a.OwnerContactID,
         @ExpirationDays = a.ExpirationDays,
         @DefaultContentID = a.ContentID,
         @MembersOnlyFlag = a.MembersOnlyFlag
    FROM Nav_Menu a, Content_Authority_Producer b
   WHERE NavMenuID = @InNavMenuID
     AND (a.ContentAuthorityGroupID = b.ContentAuthorityGroupID OR b.ContentAuthorityGroupID = @SuperGroupID)
     AND b.ContactID = @InContactID
     AND b.ContentEditorFlag = 'Y' 
  
  -- Make sure the user has privilege to insert content record here.
  IF @@Rowcount = 0
    RAISERROR('You do not have privilege to create a content record for this navigation item/content folder.',16,1)

  -- Set default values according to preferences.
  IF @DefaultOwnerMeGroupSpecificInd = 'G'
    SET @l_OwnerContactID = @DefaultOwnerID
  ELSE IF @DefaultOwnerMeGroupSpecificInd = 'M'
    SET @l_OwnerContactID = @InContactID
  ELSE IF @DefaultOwnerMeGroupSpecificInd = 'S' AND @DefaultOwnerContactID IS NOT NULL
    SET @l_OwnerContactID = @DefaultOwnerContactID
  ELSE
    SET @l_OwnerContactID = @OwnerContactID

  IF @DefaultReminderDays IS NOT NULL
    SET @l_ExpirationDays = @DefaultReminderDays
  ELSE
    SET @l_ExpirationDays = @ExpirationDays

  --Make sure URLSafeName is unqiue.
  EXEC amsp_CMGetUniqueContentName NULL, @InContentTitle, @InNavMenuID, @URLSafeName OUTPUT

  INSERT
    INTO Content (
         WorkflowStatusCode,
         NavMenuID,
         Name,
         URLSafeName,
         ShowInTemplateFlag,
         OpenInNewWindowFlag,
         FuseFlag,
         SecureFlag,
         SuppressBannersFlag,
         OwnerContactID,
         ContactID,
         ExpirationDays,
         ArchiveAtExpirationFlag,
         MembersOnlyFlag)
  VALUES ('W',
          @InNavMenuID,
          @InContentTitle,
          @URLSafeName,
          'Y',
          'N',
          'Y',
          'N',
          'N',
          @l_OwnerContactID,
          @InContactID,
          @l_ExpirationDays,
          'N',
          @MembersOnlyFlag)

  SET @OutContentID = @@Identity

  -- If the Nav_Menu record doesn't have a default content record yet,
  -- make this a default.

  IF @DefaultContentID IS NULL
    UPDATE Nav_Menu
       SET ContentID = @OutContentID
     WHERE NavMenuID = @InNavMenuID

  --Copy security settings from Nav_Menu if there are any.
  IF @MembersOnlyFlag = 'Y'
      INSERT INTO Content_Security_Group
                  (ContentID,
                   SecurityGroupCode)
      SELECT @OutContentID,
             SecurityGroupCode
        FROM Nav_Menu_Security_Group
       WHERE NavMenuID = @InNavMenuID
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMNavMenuRenum]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMNavMenuRenum]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE             procedure amsp_CMNavMenuRenum AS
BEGIN
/*
** 02/22/2002  N.Malhotra  Extended Max Value for SortOrder to 999999999
** 04/18/2002  N.Malhotra  Added index to #temp.NavMenuID
** 08/20/2002  I.Kim       Changed UPDATE statement to not use inner select (to improve performance)
** 09/04/2003  E.Tatsui    
*/
  DECLARE 
    @NavMenuID		numeric,
    @NewSortOrder	numeric,
    @SortIncrement	integer,
    @NumNavMenuItems	integer

  CREATE TABLE #temp (
    ID Numeric Identity not null,
    NavMenuID numeric,
    SortOrder numeric)

  BEGIN TRANSACTION
   
  -- First insert all the nave item.
  INSERT INTO #temp (NavMenuID, SortOrder)
  SELECT NavMenuID, SortOrder
    FROM Nav_Menu
   WHERE NavContentGroupInd = 'N'
   ORDER BY SortOrder

  -- Then all the content folders.
  INSERT INTO #temp (NavMenuID, SortOrder)
  SELECT NavMenuID, SortOrder
    FROM Nav_Menu
   WHERE NavContentGroupInd = 'C'
   ORDER BY SortOrder

  SELECT @NumNavMenuItems = count(*)
    FROM Nav_Menu

  SET @SortIncrement = CEILING(999990000.0 / @NumNavMenuItems) - 1

  UPDATE #temp
     SET SortOrder = ID * @SortIncrement

  CREATE UNIQUE INDEX IDX_TEMP_1 ON #temp(NavMenuID)

  UPDATE Nav_Menu
     SET SortOrder = t.SortOrder
    FROM #temp t
   WHERE Nav_Menu.NavMenuID = t.NavMenuID

  COMMIT TRANSACTION
END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMMoveNavMenu]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMMoveNavMenu]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure moves a specified item to a target location.
-- 
-- Notes:
-- When @InMoveLevel is "Lower", it means that the move item should go 
-- right below the target item as a child. This is not the same as simply moving under
-- the target.
-- 
--
-- Modifications
-- 06/06/2003   E.Tatsui   Converted from NavMenuModifyCode.cfm
-- 02/06/2004   E.Tatsui   Removed transactions. 
-- 09/22/2005   E.Tatsui   Fixed a problem moving an item to an empty website.
-- 09/26/2005   E.Tatsui   Fixed a problem with missing children when a parent item is moved.
-- =============================================

CREATE                            PROCEDURE amsp_CMMoveNavMenu
  @InMoveNavMenuID numeric,
  @InTargetNavMenuID numeric = NULL,
  @InMovePromoteDemoteInd char(1) = 'M',
  @InMoveLevel varchar(10) = NULL,
  @OutErrorMessage varchar(255) OUTPUT
AS
BEGIN

  DECLARE
    @WebsiteKey uniqueidentifier,
    @MinSort numeric(28,18),
    @MaxSort numeric(28,18),
    @NavContentGroupInd char(1),
    @Move_ParentNavMenuID numeric,
    @Move_AncestorNavMenuID numeric,
    @Move_CategoryDepth numeric,
    @Move_ParentName varchar(255),
    @Move_SortOrder numeric(28,18),
    @Target_CategoryDepth numeric,
    @Target_SortOrder numeric(28,18),
    @Target_AncestorNavMenuID numeric,
    @Target_ParentNavMenuID numeric,
    @LowestSortOrder numeric(28,18),
    @Below_SortOrder numeric(28,18),
    @IncrementValue numeric(28,18),
    @DescendantCount integer,
    @Counter integer,
    @Loop_NavMenuID numeric,
    @Loop_SortOrder numeric(28,18),
    @Loop_LowestSortOrder numeric(28,18),
    @New_SortOrder numeric(28,18),
    @New_ParentNavMenuID numeric,
    @New_AncestorNavMenuID numeric,
    @New_CategoryDepth numeric,
    @IsTargetDescendant bit,
    @Sib_NavMenuID numeric,
    @Sib_SortOrder numeric(28,18),
    @Level varchar(10),
    @Error integer
    
  EXEC amsp_CMNavMenuRenum
  
  -- Get info of item to move. 
  SELECT @Move_ParentNavMenuID = a.ParentNavMenuID,
         @Move_AncestorNavMenuID = a.AncestorNavMenuID,
         @Move_CategoryDepth = a.CategoryDepth,
         @Move_ParentName = b.Name,
         @Move_SortOrder = a.SortOrder,
         @NavContentGroupInd = a.NavContentGroupInd,
         @WebsiteKey = a.WebsiteKey
    FROM Nav_Menu a WITH (NOLOCK) LEFT OUTER JOIN Nav_Menu b WITH (NOLOCK)
      ON a.ParentNavMenuID = b.NavMenuID
   WHERE a.NavMenuID = @InMoveNavMenuID

  IF @@Rowcount = 0
    RETURN

  -- For promote, look for the target ID
  IF @InMovePromoteDemoteInd = 'P' BEGIN
    SELECT TOP 1 @InTargetNavMenuID = NavMenuID
      FROM Nav_Menu WITH (NOLOCK)
     WHERE CategoryDepth = @Move_CategoryDepth - 1
       AND SortOrder < @Move_SortOrder
       AND NavContentGroupInd = @NavContentGroupInd
    ORDER BY SortOrder DESC

    SET @Level = 'Same'
  END
  -- Also for demote, look for the target ID
  ELSE IF @InMovePromoteDemoteInd = 'D' BEGIN
    SELECT TOP 1 
           @Sib_NavMenuID = NavMenuID, 
           @Sib_SortOrder = SortOrder
      FROM Nav_Menu WITH (NOLOCK)
     WHERE CategoryDepth = @Move_CategoryDepth
       AND SortOrder < @Move_SortOrder
       AND NavContentGroupInd = @NavContentGroupInd
     ORDER BY SortOrder DESC

    SELECT TOP 1 
           @InTargetNavMenuID = NavMenuID
      FROM Nav_Menu WITH (NOLOCK)
     WHERE CategoryDepth = @Move_CategoryDepth + 1
       AND SortOrder < @Move_SortOrder
       AND SortOrder > @Sib_SortOrder
       AND NavContentGroupInd = @NavContentGroupInd
     ORDER BY SortOrder DESC
  
    IF @@Rowcount > 0
      SET @Level = 'Same'
    ELSE BEGIN
      SET @InTargetNavMenuID = @Sib_NavMenuID
      SET @Level = 'Lower'
    END

  END

  -- For Move, if level is specified, set to the value. Otherwise, set to "Same"
  ELSE IF @InMoveLevel IS NOT NULL
    SET @Level = @InMoveLevel
  ELSE
    SET @Level = 'Same'

  -- Make sure we found a valid target ID.
  IF @InMoveNavMenuID = @InTargetNavMenuID
    SET @OutErrorMessage = 'Error! The target item can''t be the item you want to move.'
  IF @InTargetNavMenuID IS NULL  
    SET @OutErrorMessage = 'Error! Can''t find the target item.'

  IF @OutErrorMessage IS NULL BEGIN   
    -- Build a table of item's descendants
    SELECT @MinSort = a.SortOrder,
           @MaxSort = (SELECT IsNull(Min(x.SortOrder),0)
                         FROM Nav_Menu x
                         WITH (NOLOCK)
                        WHERE x.SortOrder > a.SortOrder
                          AND x.CategoryDepth <= a.CategoryDepth)
      FROM Nav_Menu a WITH (NOLOCK)
     WHERE a.NavMenuID = @InMoveNavMenuID
    
    SELECT a.NavMenuID, a.SortOrder
      INTO #Descendants
      FROM Nav_Menu a WITH (NOLOCK)
     WHERE a.SortOrder > @MinSort
       AND a.SortOrder < @MaxSort
 
    SET @DescendantCount = @@Rowcount

    SELECT 1
      FROM #Descendants
     WHERE NavMenuID = @InTargetNavMenuID

    IF @@Rowcount >= 1 
      SET @OutErrorMessage = 'Error! The target item can''t be a descendant of the item you want to move.'
  END -- @OutErrorMessage is null
  
  IF @OutErrorMessage IS NULL BEGIN
    -- Get info of the target item
    SELECT @Target_CategoryDepth = a.CategoryDepth,
           @Target_SortOrder = a.SortOrder,
           @Target_AncestorNavMenuID = a.AncestorNavMenuID,
           @Target_ParentNavMenuID = a.ParentNavMenuID
      FROM Nav_Menu a WITH (NOLOCK)
     WHERE NavMenuID = @InTargetNavMenuID

    IF @@Rowcount = 0
      RETURN
    SET @LowestSortOrder = @Target_SortOrder

    -- If first row (Navigation Menu/Content Groups heading) is target,
    -- we want inserted/moved items to appear up top. --->
    IF @Target_AncestorNavMenuID IS NOT NULL BEGIN
      SELECT @MinSort = a.SortOrder,
             @MaxSort = (SELECT IsNull(Min(x.SortOrder),0)
                           FROM Nav_Menu x
                           WITH (NOLOCK)
                          WHERE x.SortOrder > a.SortOrder
                            AND x.CategoryDepth <= a.CategoryDepth)
        FROM Nav_Menu a WITH (NOLOCK)
       WHERE a.NavMenuID = @InTargetNavMenuID

      SELECT a.NavMenuID, a.SortOrder
        INTO #TargetDescendants
        FROM Nav_Menu a WITH (NOLOCK)
       WHERE a.SortOrder > @MinSort
         AND a.SortOrder < @MaxSort
        ORDER BY a.SortOrder

      IF @@RowCount > 0
        SELECT @LowestSortOrder = Max(SortOrder)
          FROM #TargetDescendants
    END
    ELSE
      SET @Level = 'Lower'

    -- Also get information about the item below
    SELECT TOP 1 @Below_SortOrder = SortOrder
      FROM Nav_Menu WITH (NOLOCK)
     WHERE SortOrder > @LowestSortOrder
     ORDER BY SortOrder

    -- Create a cursor for Descendant
    DECLARE c_Descendant CURSOR LOCAL SCROLL FOR
    SELECT NavMenuID, SortOrder
      FROM #Descendants
     ORDER BY SortOrder 

    SET @Counter = 1
    SET @New_SortOrder = @Move_SortOrder
    SET @New_ParentNavMenuID = @Move_ParentNavMenuID
    SET @New_AncestorNavMenuID = @Move_AncestorNavMenuID
    SET @New_CategoryDepth = @Move_CategoryDepth

    -- At the same level?
    IF @Level = 'Same' BEGIN
      -- Creating a new main item.
      IF @Target_CategoryDepth = 1 BEGIN
        -- If we're moving around main menu items, adjust sort order and nothing else.
        IF @Move_CategoryDepth = 1 BEGIN
print 'case 1'
          SET @New_SortOrder = (@LowestSortOrder + @Below_SortOrder)/2

        END -- Ends @Move_CategoryDepth = 1
        ELSE BEGIN -- Something is promoted.
print 'case 2'
          SET @New_ParentNavMenuID = NULL
          SET @New_AncestorNavMenuID = @InMoveNavMenuID
          SET @New_CategoryDepth = @Target_CategoryDepth
          SET @New_SortOrder = (@LowestSortOrder + @Below_SortOrder)/2
        END -- Ends something is promoted.
      END -- Ends @Target_CategoryDepth = 1
      ELSE BEGIN -- Not creating main menu.
print 'case 3'
        SET @New_ParentNavMenuID = @Target_ParentNavMenuID
        SET @New_AncestorNavMenuID = @Target_AncestorNavMenuID
        SET @New_CategoryDepth = @Target_CategoryDepth
        SET @New_SortOrder = (@LowestSortOrder + @Below_SortOrder)/2

      END -- Ends not creating main menu
    END -- Ends @Level = 'Same'
    ELSE IF @Level = 'Lower' BEGIN
      -- Is target Web site name?
      IF @Target_CategoryDepth = 0 BEGIN
        -- Change BelowSortOrder to sort order of second item in menu.
        IF @NavContentGroupInd = 'N'
          SELECT TOP 1  @Below_SortOrder = SortOrder
            FROM Nav_Menu
           WHERE CategoryDepth = 1
             AND NavContentGroupInd = @NavContentGroupInd
             AND WebsiteKey = @WebsiteKey
	     AND NavMenuID <> @InMoveNavMenuID
           ORDER BY SortOrder
        ELSE
          SELECT TOP 1  @Below_SortOrder = SortOrder
            FROM Nav_Menu
           WHERE CategoryDepth = 1
             AND NavContentGroupInd = @NavContentGroupInd
             AND NavMenuID <> @InMoveNavMenuID
           ORDER BY SortOrder
print 'case 4'
        SET @Target_CategoryDepth = 1
        SET @New_ParentNavMenuID = NULL
        SET @New_AncestorNavMenuID = @InMoveNavMenuID
        SET @New_CategoryDepth = @Target_CategoryDepth
        SET @New_SortOrder = @Target_SortOrder + (@Below_SortOrder - @Target_SortOrder)/2
      END

      ELSE BEGIN -- Target is not Web site name.
        -- If item to move is a main menu item
        IF @Move_CategoryDepth = 1 BEGIN
print 'case 5'
          SET @New_ParentNavMenuID = @InTargetNavMenuID
          SET @New_AncestorNavMenuID = @Target_AncestorNavMenuID
          SET @New_CategoryDepth = @Target_CategoryDepth + 1
          SET @New_SortOrder = (@LowestSortOrder + @Below_SortOrder)/2
        END
        -- Otherwise, replace parent directory with target's directory.
        ELSE BEGIN
          -- If item to move is a descendant of target, or we are moving to
          -- right below the target on purpose, change l_BelowSortOrder to sort
          -- order of item immediately below target.
          SET @IsTargetDescendant = 0
    
          IF @Target_AncestorNavMenuID IS NOT NULL BEGIN
            SELECT @IsTargetDescendant = 1
              FROM #TargetDescendants
             WHERE NavMenuID = @InMoveNavMenuID
          END

          IF @IsTargetDescendant = 1 OR @InMoveLevel = 'Lower'  BEGIN
            IF @NavContentGroupInd = 'N' 
              SELECT TOP 1 @Below_SortOrder = SortOrder 
                FROM Nav_Menu
               WHERE SortOrder > @Target_SortOrder
                 AND WebsiteKey = @WebsiteKey
               ORDER BY SortOrder
            ELSE
              SELECT TOP 1 @Below_SortOrder = SortOrder 
                FROM Nav_Menu
               WHERE SortOrder > @Target_SortOrder
                 AND NavContentGroupInd = @NavContentGroupInd
               ORDER BY SortOrder
          END -- Ends: the item to move is a descendant of target
print 'case 6'
          SET @New_ParentNavMenuID = @InTargetNavMenuID
          SET @New_AncestorNavMenuID = @Target_AncestorNavMenuID
          SET @New_CategoryDepth = @Target_CategoryDepth + 1
          SET @New_SortOrder = (@Target_SortOrder + @Below_SortOrder) /2
        END -- Ends : Not moving a main item.
      END -- Ends: Target is not Web site name.
    
    END -- Ends @Level = Lower


    -- Update the item
    UPDATE Nav_Menu
       SET ParentNavMenuID = @New_ParentNavMenuID,
           AncestorNavMenuID = @New_AncestorNavMenuID,
           CategoryDepth = @New_CategoryDepth,
           SortOrder = @New_SortOrder,
			     WorkflowStatusCode = 'W',
					 PublishedDateTime = NULL
	   WHERE NavMenuID = @InMoveNavMenuID

    -- Make sure directory name is unique.
    EXECUTE amsp_CMGetUniqueDirectoryName @InMoveNavMenuID, 1, NULL


    -- Update properties of the old parent record.
    IF IsNull(@New_ParentNavMenuID,0) <> IsNull(@Move_ParentNavMenuID,0)
      EXEC amsp_CMUpdateNavProperties @Move_ParentNavMenuID

    SET @Loop_LowestSortOrder = @New_SortOrder
    SET @IncrementValue = (@Below_SortOrder - @Loop_LowestSortOrder) / (@DescendantCount + 2)

    -- Update descendants
    OPEN c_Descendant
    FETCH NEXT FROM c_Descendant
     INTO @Loop_NavMenuID,
          @Loop_SortOrder

    WHILE @@FETCH_STATUS = 0 BEGIN

      UPDATE Nav_Menu
         SET AncestorNavMenuID = @New_AncestorNavMenuID,
             CategoryDepth = CategoryDepth + @New_CategoryDepth - @Move_CategoryDepth,
             SortOrder = @Loop_LowestSortOrder + (@IncrementValue * @Counter),
				     WorkflowStatusCode = 'W',
						 PublishedDateTime = NULL
       WHERE NavMenuID = @Loop_NavMenuID

      EXECUTE amsp_CMGetUniqueDirectoryName @Loop_NavMenuID, 1, NULL

      SET @Counter = @Counter + 1
      FETCH NEXT FROM c_Descendant
       INTO @Loop_NavMenuID,
            @Loop_SortOrder
    END -- Ends while loop

    -- Figure out FilePath, DescendantCount and AncestoryList.
    EXEC amsp_CMUpdateNavProperties @InMoveNavMenuID

    -- Update properties of descendants
     FETCH FIRST FROM c_Descendant
      INTO @Loop_NavMenuID,
	   @Loop_SortOrder
    WHILE @@FETCH_STATUS = 0 BEGIN
      -- Figure out FilePath, DescendantCount and AncestoryList
      EXEC amsp_CMUpdateNavProperties @Loop_NavMenuID

    FETCH NEXT FROM c_Descendant
     INTO @Loop_NavMenuID,
          @Loop_SortOrder
    END

    CLOSE c_Descendant
    DEALLOCATE c_Descendant

  END -- @OutErrorMessage is null
END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMMoveContentFolder]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMMoveContentFolder]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure is used to content folder to a specified location.
-- InTargetNavMenuID represents a new parent folder for InMoveNavMenuID.
-- Content folders are ordered alphabetically, so the sp figures out the
-- correct position and calls amsp_CMMoveNavMenu 
--
-- Modifications
-- 09/10/2003    E.Tatsui
-- =============================================

CREATE PROCEDURE amsp_CMMoveContentFolder
  @InMoveNavMenuID numeric,
  @InTargetNavMenuID numeric,
  @OutErrorMessage varchar(255) = NULL OUTPUT
AS
BEGIN
  DECLARE
    @Title varchar(255),
    @BeforeID numeric,
    @ChildNum integer,
    @TargetCategoryDepth integer

  SELECT @TargetCategoryDepth = CategoryDepth
    FROM Nav_Menu
   WHERE NavMenuID = @InTargetNavMenuID

  -- If the target is the root of content folder, get all the level 1s.
  IF @TargetCategoryDepth = 0
    SELECT @ChildNum = Count(*)
      FROM Nav_Menu
     WHERE CategoryDepth = 1
       AND NavContentGroupInd = 'C'
  ELSE
    SELECT @ChildNum = Count(*)
      FROM Nav_Menu
     WHERE IsNull(ParentNavMenuID,0)  = IsNull(@InTargetNavMenuID,0)

  IF @ChildNum = 0
    EXEC amsp_CMMoveNavMenu @InMoveNavMenuID, @InTargetNavMenuID, 'M', 'Lower', @OutErrorMessage OUTPUT
  ELSE BEGIN
    SELECT @Title = Title
      FROM Nav_Menu
     WHERE NavMenuID = @InMoveNavMenuID
    
    -- Get the item that is going to be right before this item.
    IF @TargetCategoryDepth = 0
      SELECT TOP 1 @BeforeID = NavMenuID
        FROM Nav_Menu
       WHERE CategoryDepth = 1
         AND NavContentGroupInd = 'C'
         AND Title < @Title
       ORDER BY Title DESC
    ELSE
      SELECT TOP 1 @BeforeID = NavMenuID
        FROM Nav_Menu
       WHERE IsNull(ParentNavMenuID,0) = IsNull(@InTargetNavMenuID,0)
         AND Title < @Title
       ORDER BY Title DESC

    IF @BeforeID IS NOT NULL
      EXEC amsp_CMMoveNavMenu @InMoveNavMenuID, @BeforeID, 'M', 'Same', @OutErrorMessage OUTPUT
    ELSE -- If this item goes to the top, add it right below the parent.
      EXEC amsp_CMMoveNavMenu @InMoveNavMenuID, @InTargetNavMenuID, 'M', 'Lower', @OutErrorMessage OUTPUT
  END

END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMInsertNavMenu]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMInsertNavMenu]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure inserts a new Nav_Menu record at a specified location.
--
-- Modifications
-- 07/10/2003    E.Tatsui
-- =============================================

CREATE                           PROCEDURE [dbo].[amsp_CMInsertNavMenu]
  @InTargetNavMenuID numeric,
  @InTitle varchar(255),
  @InName varchar(255),
  @InContactID numeric,
  @InWebsiteKey uniqueidentifier,
  @InContentAuthorityGroupID numeric,
  @OutNavMenuID numeric OUTPUT
AS
BEGIN

  DECLARE
  @LowestSortOrder numeric(28,18),
  @TargetAncestorNavMenuID numeric,
  @TargetExpirationDays int,
  @TargetCategoryDepth int,
  @TargetTemplatePath varchar(255),
  @TargetNavContentGroupInd char(1),
  @TargetContentAuthorityGroupID numeric,
  @TargetMicrositeFlag char(1),
  @TargetWebsiteKey uniqueidentifier,
  @ParentNavMenuID numeric,
  @AncestorNavMenuID numeric,
  @ExpirationDays int,
  @MaxSortOrder numeric(28,18),
  @MinSortOrder numeric(28,18),
  @LastSortOrder numeric(28,18),
  @BelowSortOrder numeric(28,18),
  @WebsiteKey uniqueidentifier,
  @CMExpDaysDefault int,
  @NavMenuID numeric
  
  EXEC amsp_CMNavMenuRenum
  
  -- Creating a new website. Set default properties.
  IF @InTargetNavMenuID IS NULL BEGIN
    SELECT @LowestSortOrder = Max(SortOrder)
      FROM Nav_Menu
     WHERE NavContentGroupInd = 'N'
    SET @TargetCategoryDepth = -1
    SET @TargetNavContentGroupInd = 'N'
    SET @TargetContentAuthorityGroupID = @InContentAuthorityGroupID
  END
  ELSE 
    -- Get info on target item. 
    SELECT @LowestSortOrder = SortOrder,
           @TargetAncestorNavMenuID = AncestorNavMenuID,
           @TargetExpirationDays = ExpirationDays,
           @TargetCategoryDepth = CategoryDepth,
           @TargetTemplatePath = TemplatePath,
           @TargetNavContentGroupInd = NavContentGroupInd,
           @TargetContentAuthorityGroupID = ContentAuthorityGroupID,
           @TargetMicrositeFlag = MicrositeFlag,
           @TargetWebsiteKey = WebsiteKey
      FROM Nav_Menu
     WHERE NavMenuID = @InTargetNavMenuID
  
  IF @InContentAuthorityGroupID IS NOT NULL AND @TargetContentAuthorityGroupID <> @InContentAuthorityGroupID
    SET @TargetContentAuthorityGroupID = @InContentAuthorityGroupID

  SELECT @CMExpDaysDefault = CAST(Value as numeric)
    FROM System_Variable
   WHERE Name = 'CMExpDaysDefault'
  
  -- Is target Web site name? If so, must create new main menu item.
  IF @TargetAncestorNavMenuID IS NULL BEGIN
    SET @ParentNavMenuID = NULL
    SET @AncestorNavMenuID = NULL
    SET @ExpirationDays = @CMExpDaysDefault
  END
  ELSE BEGIN -- Target NOT Web site name or content folder.
    SET @ParentNavMenuID = @InTargetNavMenuID
    SET @AncestorNavMenuID = @TargetAncestorNavMenuID
    SET @ExpirationDays = @TargetExpirationDays
  END

  -- Get the min and max sort order of the target family.
  SELECT @MinSortOrder = a.SortOrder,
         @MaxSortOrder = (SELECT Min(x.SortOrder)
		            FROM Nav_Menu x
		            WITH (NOLOCK)
		           WHERE x.SortOrder > a.SortOrder
		             AND x.CategoryDepth <= a.CategoryDepth)
    FROM Nav_Menu a WITH (NOLOCK)
   WHERE a.NavMenuID = @InTargetNavMenuID

  -- Find out the last sort order from target descendants.
  IF @MaxSortOrder IS NOT NULL
    SELECT @LastSortOrder = Max(a.SortOrder)
      FROM Nav_Menu a WITH (NOLOCK)
     WHERE a.SortOrder > @MinSortOrder
       AND a.SortOrder < @MaxSortOrder
       AND a.NavContentGroupInd = @TargetNavContentGroupInd
  ELSE
    SELECT @LastSortOrder = Max(a.SortOrder)
      FROM Nav_Menu a WITH (NOLOCK)
     WHERE a.SortOrder > @MinSortOrder
       AND a.NavContentGroupInd = @TargetNavContentGroupInd

  IF @LastSortOrder IS NOT NULL
    SET @LowestSortOrder = @LastSortOrder

  -- Find the item right below the target item. 
  SELECT @BelowSortOrder = Min(SortOrder)
    FROM Nav_Menu WITH (NOLOCK)
   WHERE SortOrder > @LowestSortOrder
  
  IF @BelowSortOrder IS NULL
    SET @BelowSortOrder = @LowestSortOrder + 1

  IF @TargetWebsiteKey IS NOT NULL
    SET @WebsiteKey = @TargetWebsiteKey
  ELSE IF @TargetNavContentGroupInd = 'C'
    SELECT TOP 1 @WebsiteKey = WebsiteKey
      FROM Website
     WHERE SimpleAdvancedInd = 'A'
       AND ActiveFlag = 'Y'
       AND IsiMISWebsite = 0
       AND Cast(WebsiteKey as varchar(100)) <> (SELECT Value FROM System_Variable WHERE Name = 'CMAdminWebsiteKey')
  ELSE
    SET @WebsiteKey = @InWebsiteKey

  INSERT INTO Nav_Menu (
         Name,
         Title,
         ParentNavMenuID,
         AncestorNavMenuID,
         CategoryDepth,
         SortOrder,
         TemplatePath,
         WorkflowStatusCode,
         NavContentGroupInd,
         ContentAuthorityGroupID,
         DirectListComboInd,
         OwnerContactID,
         LastUpdatedByContactID,
         ExpirationDays,
         MicrositeFlag,
         WebsiteKey)
  VALUES (
         @InName,
         @InTitle,
         @ParentNavMenuID,
         @AncestorNavMenuID,
         @TargetCategoryDepth + 1,
         (@LowestSortOrder + @BelowSortOrder)/2,
         @TargetTemplatePath,
         'W',
         @TargetNavContentGroupInd,
         @TargetContentAuthorityGroupID,
         'D',
         @InContactID,
         @InContactID,
         @ExpirationDays,
         @TargetMicrositeFlag,
         @WebsiteKey)
  
  SELECT @NavMenuID = @@Identity
    
  -- If ancestor is not set previously, set it to itself now.
  IF @AncestorNavMenuID IS NULL AND @InTargetNavMenuID IS NOT NULL
    UPDATE Nav_Menu
       SET AncestorNavMenuID = @NavMenuID
     WHERE NavMenuID = @NavMenuID

  INSERT INTO Nav_Menu_Workflow_Log (
         NavMenuID,
         WorkflowStatusCode,
         ContactID,
         ChangeDateTime)
  VALUES (
         @NavMenuID,
         'W',
         @InContactID,
         CURRENT_TIMESTAMP)

  -- For content folder, we need to move it to right place.
  IF @TargetNavContentGroupInd = 'C'
    EXEC amsp_CMMoveContentFolder @NavMenuID, @InTargetNavMenuID, NULL

  -- Figure out FilePath, DescendantCount and AncestoryList
  EXEC amsp_CMUpdateNavProperties @NavMenuID

  SET @OutNavMenuID = @NavMenuID
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMInsertPublishMessageLog]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMInsertPublishMessageLog]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- Inserts a record to Publish_Message_Log
--
-- Modifications
-- 07/07/2003    E.Tatsui
-- =============================================


CREATE        PROCEDURE amsp_CMInsertPublishMessageLog
  @InPublishRequestID integer,
  @InPublishRequestDetailID integer,
  @InMessageNumber integer,
  @InMessageText varchar(2000),
  @InLocation varchar(100),
  @InPublishServerCode char(1) = NULL
AS
BEGIN
  DECLARE
    @RowNum integer,
    @PublishRequestStatusCode char(1),
    @NumOfAttempts integer,
    @MaxNumOfAttempts integer

  IF @InPublishRequestID = 0 OR @InPublishRequestDetailID = 0
    SET @RowNum = 0
  ELSE
    SELECT @RowNum = Count(*)
      FROM Publish_Message_Log
     WHERE PublishRequestDetailID = @InPublishRequestDetailID
       AND PublishRequestID = @InPublishRequestID
 
  IF @RowNum = 1
    UPDATE Publish_Message_Log
       SET MessageNumber = @InMessageNumber,
           MessageText = @InMessageText,
           Location = @InLocation,
           DisplayFlag = 'Y',
           MessageDateTime = CURRENT_TIMESTAMP
     WHERE PublishRequestDetailID = @InPublishRequestDetailID
       AND PublishRequestID = @InPublishRequestID

  ELSE
    INSERT INTO Publish_Message_Log
                (PublishRequestID,
                 PublishRequestDetailID,
                 MessageNumber,
                 MessageText,
                 MessageDateTime,
                 Location,
                 PublishServerCode)
    VALUES (@InPublishRequestID,
            @InPublishRequestDetailID,
            @InMessageNumber,
            @InMessageText,
            CURRENT_TIMESTAMP,
            @InLocation,
            @InPublishServerCode)

  IF @InPublishRequestDetailID IS NOT NULL AND @InPublishRequestDetailID <> 0 BEGIN
    UPDATE Publish_Request_Detail
       SET NumOfAttempts = NumOfAttempts + 1
     WHERE PublishRequestDetailID = @InPublishRequestDetailID

    SELECT @MaxNumOfAttempts = Convert(integer,Value)
      FROM System_Variable WITH (NOLOCK)
     WHERE Name = 'CMPublishingMaxNumOfAttempts'

    SELECT @PublishRequestStatusCode = PublishRequestStatusCode,
           @NumOfAttempts = NumOfAttempts
      FROM Publish_Request_Detail WITH (NOLOCK)
     WHERE PublishRequestDetailID = @InPublishRequestDetailID

    IF @PublishRequestStatusCode = 'N' AND @NumOfAttempts >= @MaxNumOfAttempts
      -- Mark this request as failed after the max tries.
      UPDATE Publish_Request_Detail
         SET PublishRequestStatusCode = 'F'
       WHERE PublishRequestDetailID = @InPublishRequestDetailID
  END
  -- If detail id is not specified, see if we can update using the request id.
  ELSE IF @InPublishRequestDetailID = 0 AND @InPublishRequestID <> 0 BEGIN
      UPDATE Publish_Request_Detail
         SET NumOfAttempts = NumOfAttempts + 1,
             PublishRequestStatusCode = CASE WHEN (NumOfAttempts + 1) >= @MaxNumOfAttempts
                                             THEN 'F' 
                                        ELSE PublishRequestStatusCode END
       WHERE PublishRequestID = @InPublishRequestID
  END
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMMoveContent]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMMoveContent]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure takes two ContentIDs from same Nav_Menu 
-- and move the first one below the second one.
--
-- Modifications
-- 08/20/2003  E.Tatsui
-- =============================================

CREATE              PROCEDURE amsp_CMMoveContent
  @InMoveContentID numeric,
  @InTargetContentID numeric	
AS
BEGIN
  DECLARE
    @NavMenuID numeric,
    @TargetSortOrder numeric,
    @MoveSortOrder numeric

  -- If TargetSortOrder is 0, it means it wants to go to the top of the list.
  IF @InTargetContentID = 0 BEGIN
    SET @TargetSortOrder = 0
    SELECT @NavMenuID = NavMenuID
      FROM Content WITH (NOLOCK) 
     WHERE ContentID = @InMoveContentID
  END
  ELSE BEGIN
    SELECT @NavMenuID = a.NavMenuID,
           @TargetSortOrder = IsNull(b.SortOrder,0),
           @MoveSortOrder = IsNull(a.SortOrder, 0)
      FROM Content a WITH (NOLOCK), Content b WITH (NOLOCK), Nav_Menu c WITH (NOLOCK)
     WHERE a.NavMenuID = b.NavMenuID
       AND a.ContentID = @InMoveContentID
       AND b.ContentID = @InTargetContentID
       AND a.NavMenuID = c.NavMenuID


    IF @@RowCount = 0 BEGIN
      RAISERROR ('The record to move and target record must have same NavMenuID.', 16, 1)
      RETURN
    END
  END

  -- Move everything below target by one.
  UPDATE Content
     SET SortOrder = IsNull(SortOrder,1) + 1
   WHERE NavMenuID = @NavMenuID
     AND SortOrder > @TargetSortOrder
     AND ContentID <> @InMoveContentID

  -- Move the request item right below the target.
  UPDATE Content
     SET SortOrder = @TargetSortOrder + 1
   WHERE ContentID = @InMoveContentID

  -- If SortOrder was changed to 1, make it the default content.
  IF @TargetSortOrder = 0
    UPDATE Nav_Menu
       SET ContentID = @InMoveContentID,
           WorkflowStatusCode = 'W',
           PublishedDateTime = NULL,
           ComponentCode = 'CM', 
           ComponentScriptCode = 'SC' 
     WHERE NavMenuID = @NavMenuID
       AND ContentID <> @InMoveContentID

  -- Now, re-sort everything.
  EXEC amsp_CMRenumCurrentContent @NavMenuID

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMMoveContentFile]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMMoveContentFile]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure moves a specified Content File record.
--
-- Modifications
-- 08/28/2003  E.Tatsui   Created
-- =============================================
CREATE     PROCEDURE amsp_CMMoveContentFile
  @InMoveContentFileID numeric,
  @InTargetContentFileID numeric,
  @InContentID numeric
AS
BEGIN
  DECLARE 
    @TargetSortOrder numeric,
    @ContentID numeric,
    @ContentFileID numeric,
    @SortOrder numeric,
    @Counter integer,
    @MoveContentFileID numeric,
    @TargetContentFileID numeric

  SELECT @TargetSortOrder = SortOrder,
         @ContentID = ContentID,
         @TargetContentFileID = ContentFileID
    FROM Content_File  WITH (NOLOCK)
   WHERE (ContentFileID = @InTargetContentFileID
      OR PreviousContentFileID = @InTargetContentFileID)
     AND ContentID = @InContentID

  SELECT @MoveContentFileID = ContentFileID
    FROM Content_File WITH (NOLOCK)
   WHERE (ContentFileID = @InMoveContentFileID
      OR PreviousContentFileID = @InMoveContentFileID)
     AND ContentID = @InContentID

  -- If we can't find either of the record, exit.
  IF @MoveContentFileID IS NULL OR @TargetContentFileID IS NULL
    RETURN

  -- Move everything below target by one.
  UPDATE Content_File
     SET SortOrder = SortOrder + 1
   WHERE ContentID = @ContentID
     AND SortOrder > @TargetSortOrder

  -- Move the request item right below the target.
  UPDATE Content_File
     SET SortOrder = @TargetSortOrder + 1
   WHERE ContentFileID = @MoveContentFileID

  -- Now, re-sort everything.
  DECLARE c_Files CURSOR FOR
   SELECT ContentFileID,
          SortOrder
     FROM Content_File WITH (NOLOCK)
    WHERE ContentID = @ContentID
    ORDER BY SortOrder

  SET @Counter = 0

  OPEN c_Files
  FETCH NEXT FROM c_Files
   INTO @ContentFileID,
        @SortOrder

  WHILE @@FETCH_STATUS = 0 BEGIN
    SET @Counter = @Counter + 1

    IF @Counter <> @SortOrder BEGIN
      UPDATE Content_File
         SET SortOrder = @Counter
       WHERE ContentFileID = @ContentFileID
    END

    FETCH NEXT FROM c_Files
     INTO @ContentFileID,
          @SortOrder
  END
  CLOSE c_Files
  DEALLOCATE c_Files
  
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMMoveContentLink]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMMoveContentLink]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure moves a specified ContentLink
--
-- Modifications
-- 08/28/2003  E.Tatsui   Created
-- =============================================
CREATE      PROCEDURE amsp_CMMoveContentLink
  @InMoveContentLinkID numeric,
  @InTargetContentLinkID numeric,
  @InContentID numeric
AS
BEGIN
  DECLARE 
    @TargetSortOrder numeric,
    @ContentID numeric,
    @ContentLinkID numeric,
    @SortOrder numeric,
    @Counter integer,
    @TargetContentLinkID numeric,
    @MoveContentLinkID numeric

  SELECT @ContentID = ContentID,
         @TargetSortOrder = SortOrder,
         @TargetContentLinkID = ContentLinkID
    FROM Content_Link WITH (NOLOCK)
   WHERE (ContentLinkID = @InTargetContentLinkID
      OR PreviousContentLinkID = @InTargetContentLinkID)
     AND ContentID = @InContentID

  SELECT @MoveContentLinkID = ContentLinkID
    FROM Content_Link WITH (NOLOCK)
   WHERE (ContentLinkID = @InMoveContentLinkID
      OR PreviousContentLinkID = @InMoveContentLinkID)
     AND ContentID = @InContentID

  IF @TargetContentLinkID IS NULL OR @MoveContentLinkID IS NULL
    RETURN

  -- Move everything below target by one.
  UPDATE Content_Link
     SET SortOrder = SortOrder + 1
   WHERE ContentID = @ContentID
     AND SortOrder > @TargetSortOrder

  -- Move the request item right below the target.
  UPDATE Content_Link
     SET SortOrder = @TargetSortOrder + 1
   WHERE ContentLinkID = @MoveContentLinkID

  -- Now, re-sort everything.
  DECLARE c_Links CURSOR FOR
   SELECT ContentLinkID,
          SortOrder
     FROM Content_Link WITH (NOLOCK)
    WHERE ContentID = @ContentID
    ORDER BY SortOrder

  SET @Counter = 0

  OPEN c_Links
  FETCH NEXT FROM c_Links
   INTO @ContentLinkID,
        @SortOrder

  WHILE @@FETCH_STATUS = 0 BEGIN
    SET @Counter = @Counter + 1
    IF @Counter <> @SortOrder BEGIN
      UPDATE Content_Link
         SET SortOrder = @Counter
       WHERE ContentLinkID = @ContentLinkID
    END

    FETCH NEXT FROM c_Links
     INTO @ContentLinkID,
          @SortOrder
  END
  CLOSE c_Links
  DEALLOCATE c_Links
  
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMMoveNavMenuToWebsite]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMMoveNavMenuToWebsite]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This SP moves the specified Nav_Menu record to the end of a Website.
--
-- Modifications
-- 07/16/2003   E.Tatsui
-- 09/22/2005   E.Tatsui  Changed so that an item can be moved to a website w/o any nav items.
-- =============================================
CREATE     PROCEDURE amsp_CMMoveNavMenuToWebsite
  @InToMoveNavMenuID numeric,
  @InWebsiteKey varchar(50)
AS 

BEGIN
  DECLARE
    @TargetNavMenuID numeric,
    @ErrorMessage varchar(255),
    @MinSort numeric(28,18),
    @MaxSort numeric(28,18)

  --Figure out what the target NavMenuID should be.
  SELECT TOP 1 @TargetNavMenuID = NavMenuID
    FROM Nav_Menu WITH (NOLOCK)
   WHERE WebsiteKey = @InWebsiteKey
     AND NavContentGroupInd = 'N'
     AND CategoryDepth = 1
   ORDER BY SortOrder DESC

  UPDATE Nav_Menu
     SET WebsiteKey = @InWebsiteKey
   WHERE NavMenuID = @InToMoveNavMenuID

  -- Build a table of item's descendants
  SELECT @MinSort = a.SortOrder,
         @MaxSort = (SELECT IsNull(Min(x.SortOrder),0)
                       FROM Nav_Menu x
                       WITH (NOLOCK)
                      WHERE x.SortOrder > a.SortOrder
                        AND x.CategoryDepth <= a.CategoryDepth)
    FROM Nav_Menu a WITH (NOLOCK)
   WHERE a.NavMenuID = @InToMoveNavMenuID
  
  SELECT a.NavMenuID, a.SortOrder
    INTO #Descendants
    FROM Nav_Menu a WITH (NOLOCK)
   WHERE a.SortOrder > @MinSort
     AND a.SortOrder < @MaxSort

  UPDATE Nav_Menu
     SET WebsiteKey = @InWebsiteKey
    FROM Nav_Menu a WITH (NOLOCK), #Descendants b
   WHERE a.NavMenuID = b.NavMenuID

  DROP TABLE #Descendants

  -- If we found out, go ahead and move to the position.
  IF @TargetNavMenuID IS NOT NULL BEGIN
    EXEC amsp_CMMoveNavMenu @InToMoveNavMenuID, @TargetNavMenuID, 'M', NULL, @ErrorMessage OUTPUT
  END
  -- Moving as the first item on the website
  ELSE BEGIN
    SELECT @TargetNavMenuID = NavMenuID
    FROM Nav_Menu WITH (NOLOCK)
   WHERE WebsiteKey = @InWebsiteKey
     AND NavContentGroupInd = 'N'
     AND CategoryDepth = 0
    EXEC amsp_CMMoveNavMenu @InToMoveNavMenuID, @TargetNavMenuID, 'M', 'Lower', @ErrorMessage OUTPUT
  END

  IF @ErrorMessage IS NOT NULL
    RAISERROR(@ErrorMessage,1,1)

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMProcessFolderDeletion]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMProcessFolderDeletion]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE amsp_CMProcessFolderDeletion
  @InContentID numeric,
  @InWebsiteKey uniqueidentifier
AS
BEGIN
  DECLARE
    @NavMenuID numeric,
    @PreviousWebsiteKey uniqueidentifier

  -- For now, we're only going to take care of the situation where
  -- we need to update PreviousWebsiteKey
  SELECT @NavMenuID = b.NavMenuID,
         @PreviousWebsiteKey = b.PreviousWebsiteKey
    FROM Content a WITH (NOLOCK), Nav_Menu b WITH (NOLOCK)
   WHERE a.NavMenuID = b.NavMenuID
     AND a.ContentID = @InContentID

  IF @PreviousWebsiteKey IS NOT NULL AND @PreviousWebsiteKey = @InWebsiteKey BEGIN
    UPDATE Nav_Menu
       SET PreviousWebsiteKey = NULL
     WHERE NavMenuID = @NavMenuID
  END
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMReorderContentFolder]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMReorderContentFolder]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure places specified content folder at the correct position.
-- Content folders are ordered alphabetically.
--
-- Modifications
-- 09/04/2003  E.Tatsui    Created
-- =============================================


CREATE            PROCEDURE amsp_CMReorderContentFolder
  @InNavMenuID numeric
AS
BEGIN
  DECLARE
    @ParentNavMenuID numeric,
    @RootFolderID numeric


  SELECT @ParentNavMenuID = ParentNavMenuID
    FROM Nav_Menu WITH (NOLOCK)
   WHERE NavMenuID = @InNavMenuID

  -- If there is a parent for this item, just call another sp and let it move.
  IF @ParentNavMenuID IS NOT NULL
    EXEC amsp_CMMoveContentFolder @InNavMenuID, @ParentNavMenuID, NULL
  ELSE BEGIN
  -- if this is level 1 and no parent, pass the root of content folder as parent id.
    SELECT TOP 1 @RootFolderID = NavMenuID
      FROM Nav_Menu WITH (NOLOCK)
     WHERE NavContentGroupInd = 'C'
       AND CategoryDepth = 0
     ORDER BY SortOrder
    EXEC amsp_CMMoveContentFolder @InNavMenuID, @RootFolderID, NULL
  END
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMResetNavContentURL]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMResetNavContentURL]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure resets Nav_Menu records and content records
-- with proper Pre and PostFuseURL.

-- This should be run on setup, deployment or whenever GECodePath changes.
-- Normally should be used for admin website or a site with only dynamic contents.
-- This is because for fused site, published files need to be moved and link should be updated.
-- =============================================
CREATE  PROCEDURE amsp_CMResetNavContentURL
  @InWebsiteKey uniqueidentifier  
AS
BEGIN
  DECLARE
    @NavMenuID numeric,
    @ContentID numeric,
    @PreFuseURL varchar(500),
    @PostFuseURL varchar(500),
    @NewPreFuseURL varchar(500),
    @NewPostFuseURL varchar(500)

  DECLARE c_NavMenu CURSOR FOR 
   SELECT NavMenuID,
          PreFuseURL,
          PostFuseURL
     FROM Nav_Menu
    WHERE WebsiteKey = @InWebsiteKey

  OPEN c_NavMenu
  FETCH NEXT FROM c_NavMenu
   INTO @NavMenuID,
        @PreFuseURL,
        @PostFuseURL

  WHILE @@FETCH_STATUS = 0 BEGIN
    EXECUTE amsp_CMGetFuseURL @NavMenuID, NULL, @NewPreFuseURL OUTPUT, @NewPostFuseURL OUTPUT
    
    IF IsNull(@NewPreFuseURL,'') <> IsNull(@PreFuseURL,'') OR IsNull(@NewPostFuseURL,'') <> IsNull(@PostFuseURL,'')
      UPDATE Nav_Menu
         SET PreFuseURL = @NewPreFuseURL,
             PostFuseURL = @NewPostFuseURL
       WHERE NavMenuID = @NavMenuID 

    FETCH NEXT FROM c_NavMenu
     INTO @NavMenuID,
          @PreFuseURL,
          @PostFuseURL
  END
  CLOSE c_NavMenu
  DEALLOCATE c_NavMenu


  DECLARE c_Content CURSOR FOR
   SELECT a.NavMenuID,
          a.ContentID,
          a.PreFuseURL,
          a.PostFuseURL
     FROM Content a, Nav_Menu b
    WHERE a.NavMenuID = b.NavMenuID
      AND b.WebsiteKey = @InWebsiteKey

  OPEN c_Content
  FETCH NEXT FROM c_Content
   INTO @NavMenuID,
        @ContentID,
        @PreFuseURL,
        @PostFuseURL

  WHILE @@FETCH_STATUS = 0 BEGIN
    EXECUTE amsp_CMGetFuseURL @NavMenuID, @ContentID, @NewPreFuseURL OUTPUT, @NewPostFuseURL OUTPUT

    IF IsNull(@NewPreFuseURL,'') <> IsNull(@PreFuseURL,'') OR IsNull(@NewPostFuseURL,'') <> IsNull(@PostFuseURL,'')
      UPDATE Content
         SET PreFuseURL = @NewPreFuseURL,
             PostFuseURL = @NewPostFuseURL
       WHERE ContentID = @ContentID

    FETCH NEXT FROM c_Content
     INTO @NavMenuID,
          @ContentID,
          @PreFuseURL,
          @PostFuseURL
  END
  CLOSE c_Content
  DEALLOCATE c_Content

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMRetrieveContentAsNew]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMRetrieveContentAsNew]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure deletes currently active content record
-- and creates a working version of old content record.
--
-- Modifications
-- 09/08/2003    E.Tatsui   Created
-- =============================================


CREATE       PROCEDURE amsp_CMRetrieveContentAsNew
  @InContentID numeric,
  @InContactID numeric,
  @OutWorkingContentID numeric OUTPUT
AS
BEGIN
  DECLARE 
    @CurrentContentID numeric,
    @CurrentContentStatus char(1),
    @OriginalContentID numeric,
    @CurrentNavMenuID numeric
    
  SELECT @CurrentContentID = b.ContentID,
         @CurrentContentStatus = b.WorkflowStatusCode,
         @OriginalContentID = b.OriginalContentID,
         @CurrentNavMenuID = b.NavMenuID
    FROM Content a, vCurrent_Content b
   WHERE a.OriginalContentID = b.OriginalContentID
     AND a.ContentID = @InContentID

  IF @CurrentNavMenuID IS NULL
     SELECT @CurrentNavMenuID = NavMenuID
       FROM Content
      WHERE ContentID = @InContentID

  IF @CurrentContentStatus IN ('A','W')
    EXEC amsp_CMDeleteContent @CurrentContentID, @InContactID, 'Y', NULL

  EXEC amsp_CMCopyContentRow @InContentID, @InContactID, @OutWorkingContentID OUTPUT
  
  -- Store the previous current content id as previous id.
  -- Also update NavMenuID to current nav menu id, in case it has been changed by moving.
  UPDATE Content
     SET PreviousContentID = (SELECT Max(ContentID)
                                FROM Content
                               WHERE OriginalContentID = @OriginalContentID
                                 AND ContentID <> @OutWorkingContentID),
         NavMenuID = @CurrentNavMenuID,
         SortOrder = (SELECT IsNull(Max(SortOrder),0) + 1
                        FROM Content
                       WHERE NavMenuID = @CurrentNavMenuID)
   WHERE ContentID = @OutWorkingContentID
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMSetMembersOnlyContent]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMSetMembersOnlyContent]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure sets Member's Only Content for simple websites.
-- For simple websites, Member's only flag is set on Nav_Menu table.
-- This sp reflects the change in Nav_Menu table to content records.
--
-- Modifications
-- 10/13/2003    E.Tatsui    Created
-- =============================================
CREATE PROCEDURE amsp_CMSetMembersOnlyContent
  @InNavMenuID numeric,
  @InMembersOnlyFlag char(1),
  @InContactID numeric
AS
BEGIN
  DECLARE
    @ContentID numeric,
    @OutContentID numeric

  -- All the outstanding content for this nav item needs to 
  DECLARE c_Content CURSOR FOR
  SELECT ContentID
    FROM vCurrent_Content
   WHERE NavMenuID = @InNavMenuID
  
  OPEN c_Content
  FETCH NEXT FROM c_Content
   INTO @ContentID

  WHILE @@FETCH_STATUS = 0 BEGIN
    -- In order to change Member's Only Flag, we need to make working versions of Content record.
    EXEC amsp_CMGetWorkingContentID @ContentID, @InContactID, @OutContentID OUTPUT
    -- Change the status to approved since this is simple site.
    EXEC amsp_CMChangeStatus @OutContentID, 'A', @InContactID
  
    SET @ContentID = @OutContentID
  
    -- Set Member's Only Flag.
    UPDATE Content
       SET MembersOnlyFlag = @InMembersOnlyFlag
     WHERE ContentID = @ContentID

    DELETE FROM Content_Security_Group
     WHERE ContentID = @ContentID

    -- If this is member's only, copy security group.
    IF @InMembersOnlyFlag = 'Y'
      INSERT INTO Content_Security_Group
                  (ContentID,
                   SecurityGroupCode)
      SELECT @ContentID,
             SecurityGroupCode
        FROM Nav_Menu_Security_Group
       WHERE NavMenuID = @InNavMenuID
    
    FETCH NEXT FROM c_Content
     INTO @ContentID
  END
  CLOSE c_Content
  DEALLOCATE c_Content
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMUpdateContentNavMenu]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMUpdateContentNavMenu]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure moves a content record to a specified folder/nav menu.
-- 
-- Modification
-- 09/08/2003    E.Tatsui   Created
-- =============================================

CREATE          PROCEDURE amsp_CMUpdateContentNavMenu
	@InMoveContentID numeric,
  @InTargetNavMenuID numeric,
  @InContactID numeric,
  @OutErrorMessage varchar(255) OUTPUT
AS
BEGIN
  DECLARE
    @OrigURLSafeName varchar(255),
    @URLSafeName varchar(255),
    @OriginalNavMenuID numeric,
    @DefaultContentID numeric,
    @ContentNum numeric,
    @NavContentGroupInd char(1),
    @RecycleBinID numeric,
    @WorkflowStatusCode char(1),
    @ContentID numeric,
    @OrigNavContentGroupInd char(1)

  SELECT @RecycleBinID = NavMenuID
    FROM Nav_Menu
   WHERE Name = 'Content_Recycle_Bin'

  SELECT @OrigURLSafeName = a.URLSafeName,
         @OriginalNavMenuID = a.NavMenuID,
         @DefaultContentID = b.ContentID,
         @ContentNum = (SELECT Count(*) FROM vCurrent_Content WHERE NavMenuID = b.NavMenuID),
         @OrigNavContentGroupInd = b.NavContentGroupInd,
         @WorkflowStatusCode = a.WorkflowStatusCode
    FROM Content a WITH (NOLOCK), Nav_Menu b WITH (NOLOCK)
   WHERE a.ContentID = @InMoveContentID
     AND a.NavMenuID = b.NavMenuID

  SELECT @NavContentGroupInd = NavContentGroupInd
    FROM Nav_Menu WITH (NOLOCK)
   WHERE NavMenuID = @InTargetNavMenuID

  -- If the target is recycle bin, delete the content.
  IF @InTargetNavMenuID = @RecycleBinID BEGIN  
    IF @WorkflowStatusCode IN ('P')
      EXEC amsp_CMDeleteContent @InMoveContentID, @InContactID, 'N', NULL
    ELSE BEGIN -- There is a working version. Mark it as recycled.
      UPDATE Content
         SET WorkflowStatusCode = 'Y',
             ContactID = @InContactID
       WHERE ContentID = @InMoveContentID

      INSERT INTO Content_Workflow_Log (
             ContentID,
             WorkflowStatusCode,
             ContactID,
             ChangeDateTime)
      VALUES (@InMoveContentID,
             'Y',
              @InContactID,
              CURRENT_TIMESTAMP)
    END
  END
  ELSE BEGIN -- Normal move.
    -- If there is no working version, create one.
    IF @WorkflowStatusCode NOT IN  ('W','A','E')
      EXEC amsp_CMGetWorkingContentID @InMoveContentID, @InContactID, @ContentID OUTPUT, 'N'
    ELSE
      SET @ContentID = @InMoveContentID

    -- Since ContentID has changed, get the values again.
    IF @ContentID <> @InMoveContentID 
      SELECT @OrigURLSafeName = a.URLSafeName,
             @OriginalNavMenuID = a.NavMenuID,
             @DefaultContentID = b.ContentID,
             @ContentNum = (SELECT Count(*) FROM vCurrent_Content WHERE NavMenuID = b.NavMenuID),
             @OrigNavContentGroupInd = b.NavContentGroupInd,
             @WorkflowStatusCode = a.WorkflowStatusCode
        FROM Content a WITH (NOLOCK), Nav_Menu b WITH (NOLOCK)
       WHERE a.ContentID = @ContentID
         AND a.NavMenuID = b.NavMenuID

    EXEC amsp_CMGetUniqueContentName NULL, @OrigURLSafeName, @InTargetNavMenuID, @URLSafeName OUTPUT

    UPDATE Content
       SET NavMenuID = @InTargetNavMenuID,
           URLSafeName = @URLSafeName,
           SortOrder = (SELECT IsNull(Max(SortOrder),0)+1
                          FROM vCurrent_Content
                         WHERE NavMenuID = @InTargetNavMenuID),
           ContactID = @InContactID
     WHERE ContentID = @ContentID 
  
    -- If destination is navigation menu.
    IF @NavContentGroupInd = 'N' BEGIN
      -- If this is the first content, make it default one.
      UPDATE Nav_Menu
         SET ContentID = @ContentID
       WHERE NavMenuID = @InTargetNavMenuID
         AND ContentID IS NULL
    END
    -- If content belonged to a nav item before.
    IF @OrigNavContentGroupInd = 'N' BEGIN
      -- If this is default content, need to assign a new default content.
      IF @DefaultContentID = @InMoveContentID BEGIN
        IF @ContentNum > 2
          UPDATE Nav_Menu
             SET ContentID = (SELECT TOP 1 ContentID 
                                FROM vCurrent_Content 
                               WHERE NavMenuID = @OriginalNavMenuID
                               ORDER BY SortOrder),
                 WorkflowStatusCode = 'W',
                 PublishedDateTime = NULL
           WHERE NavMenuID = @OriginalNavMenuID
        ELSE
          UPDATE Nav_Menu
             SET ContentID = NULL,
                 DirectListComboInd = 'D',
                 WorkflowStatusCode = 'W',
                 PublishedDateTime = NULL
           WHERE NavMenuID = @OriginalNavMenuID
      END
      -- Resort content.
      EXEC amsp_CMRenumCurrentContent @OriginalNavMenuID
    END

  END

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMUpdatePublishDate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMUpdatePublishDate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- Procedure to update PUblishedDateTime.
-- =============================================
CREATE         PROCEDURE amsp_CMUpdatePublishDate 
	@InPublishRequestDetailId numeric = NULL,
  @InPublishRequestID numeric =  NULL
AS

BEGIN

  DECLARE
    @ContactID numeric,
    @PublishedDateTime datetime

  IF @InPublishRequestDetailId IS NOT NULL BEGIN
     SET @PublishedDateTime = GetDATE()
     UPDATE Publish_Request_Detail
        SET PublishedDateTime = @PublishedDateTime,
            PublishRequestStatusCode = 'P'
      WHERE PublishRequestDetailID = @InPublishRequestDetailId

     UPDATE Publish_Message_Log
        SET DisplayFlag = 'N'
      WHERE PublishRequestDetailID = @InPublishRequestDetailId
  
    SELECT @ContactID = a.ContactID
      FROM Publish_Request a, Publish_Request_Detail b
     WHERE a.PublishRequestID = b.PublishRequestID
       AND b.PublishRequestDetailID = @InPublishRequestDetailId

    EXECUTE amsp_CMFinalizePublish @InPublishRequestDetailId, @PublishedDateTime, @ContactID
  END
  IF @InPublishRequestID IS NOT NULL BEGIN
     UPDATE Publish_Request
        SET PublishedDateTime = GetDATE()
      WHERE PublishRequestID = @InPublishRequestID

     UPDATE Publish_Message_Log
        SET DisplayFlag = 'N'
      WHERE PublishRequestDetailID = 0
        AND PublishRequestID = @InPublishRequestID
  END
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMUpdatePublishLocation]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMUpdatePublishLocation]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- Store published location in Content_File, Content_HTML or Content.
--
-- Modifications
-- 06/16/2003      E.Tatsui
-- =============================================

CREATE       PROCEDURE amsp_CMUpdatePublishLocation
  @InContentID numeric,
  @InContentFileID numeric = 0,
  @InHTMLContentID numeric = 0,
  @InDefaultContentFlag char(1) = 'N',
  @InPublishLocation varchar(255)
AS
BEGIN
  DECLARE
    @PublishLocation varchar(255)

  SET @PublishLocation = Replace(@InPublishLocation, '\','/')

  IF @InContentFileID > 0 AND @InPublishLocation IS NOT NULL
    UPDATE Content_File
       SET PublishLocation = @PublishLocation
     WHERE ContentFileID = @InContentFileID

  IF @InHTMLContentID > 0 AND @InPublishLocation IS NOT NULL
    UPDATE Content_HTML
       SET PublishLocation = @PublishLocation
     WHERE ContentID = @InHTMLContentID

  IF @InDefaultContentFlag = 'Y' AND @InPublishLocation IS NOT NULL
    UPDATE Content
       SET PublishLocation =  @PublishLocation
     WHERE ContentID = @InContentID

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_GetChildMenuItems]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_GetChildMenuItems]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE        PROCEDURE amsp_GetChildMenuItems
  @NavMenuID integer,
  @ContactID numeric
AS
BEGIN

  DECLARE
    @counter integer

  create table #temp (NavMenuID integer)

  /*
  ** First insert selfe
  */

  INSERT INTO #temp
  SELECT NavMenuID 
  FROM Nav_Menu
  WHERE NavMenuID = @NavMenuID
  
  /*
  ** As long as there are new children, keep adding them to #temp.
  ** To make sure a bad nav_menu item doesn't lock the server, we also
  ** limit this to 50 iterations.
  */
  SET @counter = 0
  WHILE @@rowCount > 0 AND @counter < 50 BEGIN
    SET @counter = @counter + 1
    INSERT INTO #temp
    SELECT a.NavMenuID
      FROM Nav_Menu a, #temp b
     WHERE a.ParentNavMenuID = b.NavMenuID
       AND a.NavMenuID NOT IN (SELECT NavMenuID FROM #temp)
  END

  /*
  ** Return our results
  */

  SELECT a.*,
         b.ContentEditorFlag,
         b.ContentApproverFlag,
         b.NavCreatorFlag,
         b.NavEditorFlag,
         b.CustomPageFlag,
         b.LayoutFlag,
         b.UploadFlag,
         b.EditorFlag,
         b.ComponentScriptFlag,
         c.HideFlag AS ParentHideFlag,
        (SELECT count(*)
           FROM Nav_Menu z
          WHERE z.SortOrder > a.SortOrder
            AND z.SortOrder <
               (SELECT IsNull(Min(x.SortOrder),99999)
                  FROM Nav_Menu x
                 WHERE x.SortOrder > a.SortOrder
                   AND x.CategoryDepth <= a.CategoryDepth)) AS DescendantCount,
        (SELECT count(*)
           FROM Nav_Menu z
          WHERE z.SortOrder > a.SortOrder
            AND z.SortOrder <
               (SELECT IsNull(Min(x.SortOrder),99999)
                  FROM Nav_Menu x
                 WHERE x.SortOrder > a.SortOrder
                   AND x.CategoryDepth <= a.CategoryDepth)
            AND z.ContentAuthorityGroupID IN (SELECT ContentAuthorityGroupID
						FROM Content_Authority_Producer
						WHERE ContactID = @ContactID)) AS AuthorizedDescendantCount,
         NULL AS AncestoryList,
         NULL As AncestoryHideFlag,
         (SELECT count(*)
            FROM Content z
           WHERE z.NavMenuID = a.NavMenuID
             AND z.WorkflowStatusCode = 'W') AS WorkingContentCount,
         (SELECT count(*)
            FROM Content z
           WHERE z.NavMenuID = a.NavMenuID
             AND (z.WorkflowStatusCode = 'D' OR z.WorkflowStatusCode = 'E')) AS PendingContentCount,
         (SELECT count(*)
            FROM Content z
           WHERE z.NavMenuID = a.NavMenuID
             AND z.WorkflowStatusCode = 'A') AS ApprovedContentCount,
         (SELECT MAX(ContentID)
            FROM vCurrent_Content z
           WHERE z.NavMenuID = a.NavMenuID
             AND (z.ContentID = a.ContentID OR z.PreviousContentID = a.ContentID)) AS WorkingContentID
    FROM (Nav_Menu a LEFT OUTER JOIN Content_Authority_Producer b
      ON a.ContentAuthorityGroupID = b.ContentAuthorityGroupID
     AND b.ContactID = @ContactID) LEFT OUTER JOIN Nav_Menu c
      ON a.ParentNavMenuID = c.NavMenuID, #temp t
   WHERE a.NavMenuID = t.NavMenuID
   ORDER BY a.SortOrder

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_GetSearchableComponents]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_GetSearchableComponents]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE                     procedure [dbo].[amsp_GetSearchableComponents] 
  @SearchComponentList varchar(1000),
  @KeyID numeric
AS
BEGIN
 
  /*
  ** DESCRIPTION:
  ** ------------
  ** This sp returns the desired fields to be indexed for searching
  **
  ** This sp is designed to support the following component codes:
  **
  ** CM - URL Links from Content_Link
  **
  ** INPUTS:
  ** -------
  ** @SearchComponentList -> A comma separated list of Component Codes for
  **                         which to generate search records
  ** @KeyID               -> The primary key value of a specific record to be retrieved.  If
  **                         this is 0 then return all records for the specified component codes. 
  **    
  ** 
  ** RESULT SET:
  ** -----------
  **   SearchKey            -> The Unique Search Key for the Record
  **   Title                -> Display Title in Search Results
  **   Body1                -> Main Content to be Indexed
  **   Body2                -> Optional Additional Content to Index
  **   InterestCategoryList -> Comma Separated List of IC's
  **   CustomField          -> Initially Set to Date, but may be Customized
  **
  ** NOTES:
  ** ------
  **   SearchKey has the following format:
  **     Position 1   -> 'Y' or 'N' indicating Members Only Content
  **     Position 2   -> ':'
  **     Position 3-4 -> 2 Character Component Code
  **     Position 5   -> ':' 
  **     Position 6-? -> Component ID
  **
  ** PROGRAMMING CONSIDERATIONS:
  ** ---------------------------
  ** Dynamic SQL is intentionally not used.  Speed overrides elegance.
  ** Do not convert to dynamic SQL - It cannot be parsed until runtime.
  **
  ** HISTORY:
  ** --------
  ** 06/02/2001   N.Malhotra  Initial Version Created
  ** 06/15/2001   N.Malhotra  Added Date and CustomField2
  ** 09/04/2001   N.Malhotra  Added template to handle sites with more than one template
  ** 09/27/2001   N.Malhotra  Fixed a bug where the InterestCategroyList for the
  **                          first matchind content record was not being set properly.
  ** 10/25/2001   I.Kim       Fixed Newsletter to refer Sent_Email table.
  **                          However, you must configure Component_Ref table.
  **                          Also commented out Conference section (to be fixed by Nitin)
  ** 03/20/2002   I.Kim       For PR --> ISNULL(ArchiveFlag,'N') since ArchiveFlag can
  **                          contain null.
  ** 03/07/2003   E.Pfleckl   Changed the description for conferences to be NULL.
  **                          Added Calendar Events
  **                          Fixed several issues in Forums block and added
  **                          where clause to only include active forums
  ** 03/10/2003   E.Pfleckl   Changed Conference block to only return active conferences
  ** 08/25/2003   J.Stopple   Updated 'NL' section for new Newsletter Manager
  ** 10/14/2003   E.Tatsui    Modified to exclude admin websites.
  **                          Changed UserDefinedField1 to PublicationDate
  ** 05/12/2004   E.Tatsui    Added changes for conference and ecommerce.
  */
 
  DECLARE 
    @ComponentCode                 char(2),
    @OldComponentCode              char(2),
    @ComponentID                   numeric,
    @OldComponentID                numeric,
    @InterestCategoryID            numeric,
    @InterestCategoryList          varchar(1000),
    @l_FirstRow                    int,
    @AdminWebsiteKey               uniqueidentifier,
    @NavMenuID                     numeric,
    @WebsiteKey                    uniqueidentifier
 
  /*
  ** Create a temp table that we'll fill with each type of component code 
  ** specified in ComponentCodeList.
  **
  ** NOTE: CustomField is not used in the standard deployment.  This field is

  ** included in the results so that deployments requiring a custom field in 

  ** their search (e.g. copyright date) need only modify this sp and not the CF
  ** code within each product utilizing this sp.
  */
 
  CREATE TABLE #temp (
    ComponentID            varchar(50),
    TemplatePath           varchar(255),
    ComponentCode          char(2),
    MembersOnlyFlag        char(1),
    Title                  varchar(255),
    Body1                  text,
    Body2                  text,
    InterestCategoryList   varchar(3000),
    CustomField2           varchar(255),
    NavMenuID              numeric,
    AllWebsiteKeys         varchar(1000),
    CustomID               varchar(50),
    IncludeInCrossSiteSearchFlag char(1) Default('Y')
  )
 
  SELECT @AdminWebsiteKey = Value
    FROM System_Variable
   WHERE Name = 'CMAdminWebsiteKey'

  /*
  ** For ComponentCode = 'CM' we need to pull Links
  */
  IF (CHARINDEX('CM', @SearchComponentList) > 0)
 
    IF @KeyID > 0
      INSERT INTO #temp (ComponentID, TemplatePath, ComponentCode, MembersOnlyFlag, Title, Body1, Body2, CustomField2, NavMenuID, AllWebsiteKeys, IncludeInCrossSiteSearchFlag, CustomID)
	SELECT     cl.ContentID, NULLIF (n.TemplatePath, '') AS Expr1, 'CM' AS Expr2, c.MembersOnlyFlag, cl.LinkName, c.Description, c.Keywords, 
	           CONVERT(VARCHAR(18), ISNULL(M.MicrositeID, '0')) + ',' + CONVERT(varchar(20), ISNULL(c.PublicationDate, CURRENT_TIMESTAMP), 102) AS Expr3, 
	           n.NavMenuID, n.WebsiteKey, w.IncludeInCrossSiteSearchFlag, cl.ContentLinkID
	FROM         Content_Link AS cl INNER JOIN
	                      vCurrent_Content AS c ON cl.ContentID = c.ContentID INNER JOIN
	                      Nav_Menu AS n ON c.NavMenuID = n.NavMenuID LEFT OUTER JOIN
	                      Microsite AS M ON n.AncestorNavMenuID = M.HomeNavMenuID INNER JOIN
	                      Website AS w ON n.WebsiteKey = w.WebsiteKey
	WHERE     (n.WebsiteKey <> @AdminWebsiteKey) AND (cl.ContentLinkID = @KeyID) AND (ISNULL(n.HideFlag, 'N') = 'N') 
    ELSE
      INSERT INTO #temp (ComponentID, TemplatePath, ComponentCode, MembersOnlyFlag, Title, Body1, Body2, CustomField2, NavMenuID, AllWebsiteKeys, IncludeInCrossSiteSearchFlag, CustomID)
	SELECT     cl.ContentID, NULLIF (n.TemplatePath, '') AS Expr1, 'CM' AS Expr2, c.MembersOnlyFlag, cl.LinkName, c.Description, c.Keywords, 
	                      CONVERT(VARCHAR(18), ISNULL(M.MicrositeID, '0')) + ',' + CONVERT(varchar(20), ISNULL(c.PublicationDate, CURRENT_TIMESTAMP), 102) AS Expr3, 
	                      n.NavMenuID, n.WebsiteKey, w.IncludeInCrossSiteSearchFlag, cl.ContentLinkID
	FROM         Content_Link AS cl INNER JOIN
	                      vCurrent_Content AS c ON cl.ContentID = c.ContentID INNER JOIN
	                      Nav_Menu AS n ON c.NavMenuID = n.NavMenuID LEFT OUTER JOIN
	                      Microsite AS M ON n.AncestorNavMenuID = M.HomeNavMenuID INNER JOIN
	                      Website AS w ON n.WebsiteKey = w.WebsiteKey
	WHERE     (n.WebsiteKey <> @AdminWebsiteKey) AND (c.WorkflowStatusCode = 'P') AND (ISNULL(n.HideFlag, 'N') = 'N')

  /*
  ** Finally, after all rows have been added to the temp table, we need to 
  ** generate the comma separated list of Interest Categories
  */
   DECLARE c_InterestCategory CURSOR FOR
    SELECT cic.ComponentCode, 
           cic.InterestCategoryID,
           cic.ComponentID
      FROM Component_Interest_Category cic, #temp t
     WHERE cic.ComponentCode = t.ComponentCode
       AND cic.ComponentID = t.ComponentID
     ORDER BY cic.ComponentCode, cic.ComponentID
 
  OPEN c_InterestCategory
  
  FETCH NEXT FROM c_InterestCategory INTO
    @ComponentCode,
    @InterestCategoryID,
    @ComponentID
 
  SET @OldComponentCode = @ComponentCode
  SET @OldComponentID = @ComponentID
  SET @InterestCategoryList = @InterestCategoryID
  SET @l_FirstRow = 1
 
  WHILE (@@FETCH_STATUS=0) BEGIN
    IF ( @OldComponentCode != @ComponentCode or @OldComponentID != @ComponentID ) BEGIN
      UPDATE #temp
         SET InterestCategoryList = @InterestCategoryList
       WHERE ComponentCode = @OldComponentCode
         AND ComponentID = @OldComponentID
 
      SET @InterestCategoryList = @InterestCategoryID
    END
    ELSE BEGIN
      IF ( @l_FirstRow = 1 ) BEGIN
        SET @InterestCategoryList = @InterestCategoryList + ',' + convert(varchar(10), @InterestCategoryID)      
      END
      ELSE BEGIN
        SET @l_FirstRow = 0
      END
    END
 
    SET @OldComponentCode = @ComponentCode
    SET @OldComponentID = @ComponentID
 
    FETCH NEXT FROM c_InterestCategory INTO
      @ComponentCode,
      @InterestCategoryID,
      @ComponentID
 
  END
 
  UPDATE #temp
     SET InterestCategoryList = @InterestCategoryList
   WHERE ComponentCode = @OldComponentCode
     AND ComponentID = @OldComponentID
 
  CLOSE c_InterestCategory
  DEALLOCATE c_InterestCategory

  -- For each nav item, add Websites are marked to include in the search
  -- and only include those websites that has the setting on.
  UPDATE #temp
     SET AllWebsiteKeys = AllWebsiteKeys + ','
   WHERE AllWebsiteKeys IS NOT NULL

  DECLARE c_NavMenu CURSOR FOR 
   SELECT DISTINCT b.NavMenuID, b.WebsiteKey
     FROM #temp a, Nav_Menu_Website b, Website c
    WHERE a.NavMenuID = b.NavMenuID
      AND a.AllWebsiteKeys NOT LIKE Convert(varchar(50),b.WebsiteKey) + '%'
      AND b.WebsiteKey = Convert(varchar(50),c.WebsiteKey)
      AND c.IncludeInCrossSiteSearchFlag = 'Y'

  OPEN c_NavMenu
  FETCH NEXT FROM c_NavMenu
   INTO @NavMenuID,
        @WebsiteKey
  WHILE @@FETCH_STATUS = 0 BEGIN
  
    UPDATE #temp
       SET AllWebsiteKeys = IsNull(AllWebsiteKeys,'') + Convert(varchar(50),@WebsiteKey) + ','
     WHERE NavMenuID = @NavMenuID

    FETCH NEXT FROM c_NavMenu
     INTO @NavMenuID,
          @WebsiteKey
  END
  CLOSE c_NavMenu
  DEALLOCATE c_NavMenu

  -- Remove extra ","
  UPDATE #temp
     SET AllWebsiteKeys = Left(AllWebsiteKeys,Len(AllWebsiteKeys)-1)
   WHERE AllWebsiteKeys IS NOT NULL

  UPDATE #temp
     SET ComponentID = ComponentID + '-' + CustomID
   WHERE CustomID IS NOT NULL 

  SELECT IsNull(MembersOnlyFlag, 'N') + ':' + ComponentCode + ':' + ComponentID + ':' + IsNull(TemplatePath, 'NONE') as SearchKey,
         Title,
         Body1,
         Body2,
         InterestCategoryList,
         CASE WHEN AllWebsiteKeys IS NULL THEN ''
              ELSE 'WKEY:' + AllWebsiteKeys  + ','
         END + 'CSEARCH:' + IsNull(IncludeInCrossSiteSearchFlag,'Y') + ',' + CustomField2 AS CustomField2
    FROM #temp
 
END

set ANSI_NULLS ON
set QUOTED_IDENTIFIER ON

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_GetSearchableFiles]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_GetSearchableFiles]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE                   procedure [dbo].[amsp_GetSearchableFiles]
    @InFileRootPath   varchar(255),
    @InWebRootPath    varchar(255),
    @InUseNewWindowFlag   char(1)='N',
    @InNewWindowWidth   int=500,
    @InNewWindowHeight    int=500,
    @InNewWindowToolbar   varchar(3)='no',
    @InNewWindowMenubar   varchar(3)='no',
    @InNewWindowStatusbar varchar(3)='no'

AS
BEGIN

  /*
  ** DESCRIPTION:
  ** ------------
  ** This sp returns the desired fields to be indexed for searching files
  **
  ** INPUTS:
  ** -------
  **   @InFileRootPath            -> Full path to root directory above Web root
  **   @InWebRootPath             -> Full path to the Web root
  **   @InUseNewWindowFlag        -> Should we use Content.OpenInNewWindowFlag
  **   @InNewWindowWidth          -> Width of new window
  **   @InNewWindowHeight         -> Height of new window
  **   @InNewWindowToolbar        -> Should new window have a toolbar (yes/no)
  **   @InNewWindowMenuBar        -> Should new window have a menubar (yes/no)
  **   @InNewWindowStatusBar      -> Should new window include the status bar (yes/no)
  ** 
  ** RESULT SET:
  ** -----------
  **   FilePath               -> Full Path to File to Index
  **   URL                    -> How to Display the Resulting File
  **   Title                  -> Display Title for File in Search Results
  **   InterestCategoryList   -> Comma Separated List of IC's
  **   CustomField            -> UserDefinedDate1 (Copyright Date)
  **
  ** NOTES:
  ** ------
  **
  ** PROGRAMMING CONSIDERATIONS:
  ** ---------------------------
  ** In General, the SQL used here is not all that fast ... this SP is
  ** designed to be used in batch as part of the daily re-indexing operation.
  ** It is not designed for real-time (i.e. while the user is waiting) use.
  **
  ** HISTORY:
  ** --------
  ** 06/01/2001  N.Malhotra   Initial Version Created
  ** 06/15/2001  N.Malhotra   Added Date and CustomField2
  ** 08/11/2001  N.Malhotra   Changed to use input parameters for File Paths and Admin Section
  **                          instead of querying application_variable table from within the proc.
  ** 09/04/2001  N.Malhotra   There are instances where PublishLocation is NULL or is the empty
  **                          string in content_file and content_html - added logic to deal with this.
  ** 09/27/2001  N.Malhotra   Fixed a bug where the InterestCategoryList for the
  **                          first matching content record was not being set properly.
  ** 10/22/2001  N.Malhotra   For MembersOnly content, changed logic to use the template specified 
  **                          by the NavMenuID --- no longer hard-code to use template.cfm
  ** 10/25/2001  N.Malhotra   Clients are expecting that if they specify 'Open in New Window' then
  **                          this will even flow through to search results.  So, added input variables
  **                          to define the behavior and added code to use Content.OpenInNewWindowFlag.
  ** 11/30/2001  N.Malhotra   Fixed a bug that was setting the filepath for MembersOnly files incorrectly
  ** 10/02/2003  B. Harbin    Rewritten for use with the new advanced search engine.
  ** 10/14/2003  E.Tatsui     Changed to exclude admin website.
  **                          Changed UserDefinedField1 to PublicationDate
  **                          Added logic so that ContentFolders are dynamic link and Navigations are 
  **                          linked to fused page.
  **                          Changed logic for directory structure to fit CM5\
  ** 05/04/2004  E.Tatsui     Added Nitin's change to use vCurrent_Content insead of content
  ** 01/30/2008  C.Robertson  Add "/" to @LeftNewWinString
  **                          Fixed bug where w.UseAspNetTemplateFlag = 'N' AND n.NavContentGroupInd = 'C' AND 
  **                          c.OpenInNewWindowFlag = 'Y' AND @InUseNewWindowFlag = 'Y' AND isNULL(c.MembersOnlyFlag, 'N') != 'Y'
  **                          was going to an aspx page
  */

  Declare  
    @ComponentID    numeric,
    @OldComponentID   numeric,
    @InterestCategoryID   numeric,
    @InterestCategoryName   varchar(255),
    @InterestCategoryList   varchar(1000),
    @InterestCategoryNameList   varchar(2000),
@LeftNewWinString   varchar(512),
    @RightNewWinString    varchar(512),
    @l_FirstRow  int,
    @AdminWebsiteKey uniqueidentifier,
    @GECodePath varchar(255),
    @NavMenuID numeric,
    @WebsiteKey uniqueidentifier,
    @VirtualDirectoryPath varchar(255)

  /*
  ** Create a temp table to hold our result set
  */
  CREATE table #temp (
    ContentID     numeric,
    FilePath      varchar(255),
    URL       varchar(1000),
    Title     varchar(255),
    InterestCategoryList  varchar(1000),
    CustomField2    varchar(255),
    Keywords      varchar(1000),
    Description     varchar(2000),
    WebsiteKey    uniqueidentifier,
    AllWebsiteKeys varchar(1000),
    IncludeInCrossSiteSearchFlag char(1) Default('N'),
    NavContentGroupInd char(1),
    NavMenuID     numeric
  )

  SELECT @AdminWebsiteKey = Value
    FROM System_Variable
   WHERE Name = 'CMAdminWebsiteKey'

  SELECT @GECodePath = Value
    FROM System_Variable
   WHERE Name = 'GECodePath'

  SELECT @VirtualDirectoryPath = Value
    FROM System_Variable
   WHERE Name = 'VirtualDirectoryPath'

  IF Len(@GECodePath) > 1
    SET @GECodePath = RIGHT(@GECodePath,Len(@GECodePath)-1)
  ELSE IF @GECodePath = '/'
    SET @GECodePath = ''

  IF Len(@VirtualDirectoryPath) > 1
    SET @VirtualDirectoryPath = RIGHT(@VirtualDirectoryPath,Len(@VirtualDirectoryPath)-1)
  ELSE IF @VirtualDirectoryPath = '/'
    SET @VirtualDirectoryPath = ''
    
  /* 
  ** If we are using Content.OpenInNewWindowFlag, then let's setup our string
  ** one time so it's not as messy in the SQL below
  */

  IF @InUseNewWindowFlag = 'Y' BEGIN
    SET @LeftNewWinString = '" target="_blank" onClick="newWin=open(''/'
    SET @RightNewWinString = ''', ''viewer'', ''width=' + 
                             Convert(varchar(4), @InNewWindowWidth) +
                             ',height=' + Convert(varchar(4), @InNewWindowHeight) +
                             ',toolbar=' + @InNewWindowToolbar + 
                             ',directories=no,menubar=' + + @InNewWindowMenubar + 
                             ',status=' + @InNewWindowStatusbar + 
                             ',resizable=yes,scrollbars=yes''); newWin.focus(); return false;"' 
  END
  
  /*
  ** A little ugly, but for performance I don't want to cursor loop if I don't
  ** have to.  So, we'll do all the data manipulation in the query.  We are 
  ** creating the complete FilePath a complete URL to be used direcly by verity.  
  */
  INSERT INTO #temp (ContentID, FilePath, URL, Title, Keywords, Description, CustomField2, WebsiteKey, IncludeInCrossSiteSearchFlag, NavContentGroupInd, NavMenuID)
    SELECT
      c.ContentID,
      FilePath = CASE
        WHEN c.MembersOnlyFlag = 'Y' THEN w.ProtectedRootPath + REPLACE(IsNULL(cf.PublishLocation, c.PublishLocation),'/','\')
        ELSE w.PublishRootPath + REPLACE(IsNull(cf.PublishLocation,c.PublishLocation),'/','\')
        END ,
      URL =  '"' +
       CASE WHEN n.NavContentGroupInd = 'C' THEN '/'
            WHEN c.SecureFlag = 'Y' THEN w.SecureWebsiteRootURL
            ELSE w.WebsiteRootURL END
      + CASE
        WHEN w.UseAspNetTemplateFlag = 'N' AND c.MembersOnlyFlag = 'Y' AND n.NavContentGroupInd = 'C'  AND c.OpenInNewWindowFlag = 'Y' AND @InUseNewWindowFlag = 'Y' THEN 
           @GECodePath + 'TemplateRedirect.cfm?template=/MembersOnly.cfm&ContentID=' + convert(varchar(18), c.ContentID) + @LeftNewWinString + @GECodePath + 'TemplateRedirect.cfm?template=/MembersOnly.cfm&ContentID=' + convert(varchar(18), c.ContentID) + @RightNewWinString
        WHEN w.UseAspNetTemplateFlag = 'N' AND c.MembersOnlyFlag = 'Y' AND n.NavContentGroupInd = 'C'  THEN 
           @GECodePath + 'TemplateRedirect.cfm?template=/MembersOnly.cfm&ContentID=' + convert(varchar(18), c.ContentID) + '"'
        WHEN w.UseAspNetTemplateFlag = 'N' AND c.MembersOnlyFlag = 'Y' AND c.OpenInNewWindowFlag = 'Y' AND @InUseNewWindowFlag = 'Y' THEN 
           @GECodePath + 'Template.cfm?section=' + n.Name + '&template=/MembersOnly.cfm&ContentID=' + convert(varchar(18), c.ContentID) + @LeftNewWinString + @GECodePath + 'Template.cfm?section=' + n.Name + '&template=/MembersOnly.cfm&ContentID=' + convert(varchar(18), c.ContentID) + @RightNewWinString
        WHEN w.UseAspNetTemplateFlag = 'N' AND c.MembersOnlyFlag = 'Y' THEN 
           @GECodePath + 'Template.cfm?section=' + n.Name + '&template=/MembersOnly.cfm&ContentID=' + convert(varchar(18), c.ContentID) + '"'
        WHEN w.UseAspNetTemplateFlag = 'N' AND n.NavContentGroupInd = 'C' AND c.OpenInNewWindowFlag = 'Y' AND @InUseNewWindowFlag = 'Y' AND isNULL(c.MembersOnlyFlag, 'N') != 'Y' THEN 
           @GECodePath + 'TemplateRedirect.cfm?section=' + n.Name + '&template=/CM/ContentDisplay.cfm&ContentFileID=' + convert(varchar(18), cf.ContentFileID) + @LeftNewWinString + @GECodePath + 'TemplateRedirect.cfm?section=' + n.Name + '&template=/CM/ContentDisplay.cfm&ContentFileID=' + convert(varchar(18), cf.ContentFileID) + @RightNewWinString
        WHEN w.UseAspNetTemplateFlag = 'N' AND n.NavContentGroupInd = 'C' THEN
           @GECodePath + 'TemplateRedirect.cfm?section=' + n.Name + '&template=/CM/ContentDisplay.cfm&ContentFileID=' + convert(varchar(18), cf.ContentFileID) +  + '"'
        WHEN w.UseAspNetTemplateFlag = 'N' AND c.OpenInNewWindowFlag = 'Y' AND @InUseNewWindowFlag = 'Y' AND isNULL(c.MembersOnlyFlag, 'N') != 'Y' THEN
           REPLACE(ISNULL(cf.PublishLocation, c.PublishLocation), REPLACE(IsNull(w.NavPublishDirectory,''),'\','/'), IsNull(w.NavContentDisplayPath,''))           
           + @LeftNewWinString + REPLACE(ISNULL(cf.PublishLocation, c.PublishLocation), REPLACE(IsNull(w.NavPublishDirectory,''),'\','/'), IsNull(w.NavContentDisplayPath,'')) + @RightNewWinString  
        WHEN w.UseAspNetTemplateFlag = 'Y' AND c.MembersOnlyFlag = 'Y' AND n.NavContentGroupInd = 'C'  AND c.OpenInNewWindowFlag = 'Y' AND @InUseNewWindowFlag = 'Y' THEN 
           @GECodePath + 'ContentManagerNet/TemplateRedirect.aspx?template=/ContentManagerNet/MembersOnly.aspx&ContentID=' + convert(varchar(18), c.ContentID) + @LeftNewWinString + @GECodePath + 'ContentManagerNet/TemplateRedirect.aspx?template=/ContentManagerNet/MembersOnly.aspx&ContentID=' + convert(varchar(18), c.ContentID) + @RightNewWinString
        WHEN w.UseAspNetTemplateFlag = 'Y' AND c.MembersOnlyFlag = 'Y' AND n.NavContentGroupInd = 'C'  THEN 
           @GECodePath + 'ContentManagerNet/TemplateRedirect.aspx?template=/ContentManagerNet/MembersOnly.aspx&ContentID=' + convert(varchar(18), c.ContentID) + '"'
        WHEN w.UseAspNetTemplateFlag = 'Y' AND c.MembersOnlyFlag = 'Y' AND c.OpenInNewWindowFlag = 'Y' AND @InUseNewWindowFlag = 'Y' THEN 
           @VirtualDirectoryPath + '/' + n.Name +  + '/AM/ContentManagerNet/MembersOnly.aspx?Section=' + n.Name + '&ContentID=' + convert(varchar(18), c.ContentID) + @LeftNewWinString + @VirtualDirectoryPath + '/' + n.Name +  + '/AM/ContentManagerNet/MembersOnly.aspx?Section=' + n.Name + '&ContentID=' + convert(varchar(18), c.ContentID) + @RightNewWinString
        WHEN w.UseAspNetTemplateFlag = 'Y' AND c.MembersOnlyFlag = 'Y' THEN 
           @VirtualDirectoryPath + '/' + n.Name +  + '/AM/ContentManagerNet/MembersOnly.aspx?Section=' + n.Name + '&ContentID=' + convert(varchar(18), c.ContentID) + '"'
        WHEN w.UseAspNetTemplateFlag = 'Y' AND n.NavContentGroupInd = 'C' AND c.OpenInNewWindowFlag = 'Y' AND @InUseNewWindowFlag = 'Y' AND isNULL(c.MembersOnlyFlag, 'N') != 'Y' THEN 
           @GECodePath + 'ContentManagerNet/TemplateRedirect.aspx?Section=' + n.Name + '&template=/ContentManagerNet/ContentDisplay.aspx&ContentFileID=' + convert(varchar(18), cf.ContentFileID) + @LeftNewWinString + @GECodePath + 'ContentManagerNet/TemplateRedirect.aspx?Section=' + n.Name + '&template=/ContentManagerNet/ContentDisplay.aspx&ContentFileID=' + convert(varchar(18), cf.ContentFileID) + @RightNewWinString
        WHEN w.UseAspNetTemplateFlag = 'Y' AND n.NavContentGroupInd = 'C' THEN
           @GECodePath + 'ContentManagerNet/TemplateRedirect.aspx?Section=' + n.Name + '&template=/ContentManagerNet/ContentDisplay.aspx&ContentFileID=' + convert(varchar(18), cf.ContentFileID) +  + '"'
        WHEN w.UseAspNetTemplateFlag = 'Y' AND c.OpenInNewWindowFlag = 'Y' AND @InUseNewWindowFlag = 'Y' AND isNULL(c.MembersOnlyFlag, 'N') != 'Y' THEN
           REPLACE(ISNULL(cf.PublishLocation, c.PublishLocation), REPLACE(IsNull(w.NavPublishDirectory,''),'\','/'), IsNull(w.NavContentDisplayPath,''))           
           + @LeftNewWinString + REPLACE(ISNULL(cf.PublishLocation, c.PublishLocation), REPLACE(IsNull(w.NavPublishDirectory,''),'\','/'), IsNull(w.NavContentDisplayPath,'')) + @RightNewWinString  
        ELSE 
           REPLACE(ISNULL(cf.PublishLocation, c.PublishLocation), REPLACE(IsNull(w.NavPublishDirectory,''),'\','/'), IsNull(w.NavContentDisplayPath,'')) + '"'
      END,
      IsNULL(cf.Description, cf.FileName),
      c.Keywords,
      c.Description,
      convert(varchar(20), IsNULL(c.PublicationDate, '01/01/1950'), 102),
      w.WebsiteKey,
      w.IncludeInCrossSiteSearchFlag,
      n.NavContentGroupInd,
      n.NavMenuID
    FROM
      vCurrent_Content c, Nav_Menu n, 
      Content_File cf, Website w
    WHERE c.WorkflowStatusCode = 'P'
      and c.NavMenuID = n.NavMenuID
      and n.WebsiteKey != @AdminWebsiteKey
      and c.ContentID = cf.ContentID
      and n.WebsiteKey = w.WebsiteKey
      and (LEN(RTrim(cf.PublishLocation)) > 0 OR LEN(RTrim(c.PublishLocation)) > 0)
      and cf.FileTypeCode not in ('JPG', 'GIF')
      AND IsNull(n.HideFlag,'N') = 'N'
    UNION
    SELECT
      c.ContentID,
      FilePath = 
        CASE
        WHEN c.MembersOnlyFlag = 'Y' THEN w.ProtectedRootPath + REPLACE(IsNULL(ch.PublishLocation, c.PublishLocation),'/','\')
        ELSE w.PublishRootPath + REPLACE(IsNull(ch.PublishLocation,c.PublishLocation),'/','\')
        END ,
      URL =  '"' +
       CASE WHEN n.NavContentGroupInd = 'C' THEN '/'
            WHEN c.SecureFlag = 'Y' THEN w.SecureWebsiteRootURL
            ELSE w.WebsiteRootURL END
      + CASE
        WHEN w.UseAspNetTemplateFlag = 'N' AND c.MembersOnlyFlag = 'Y' AND n.NavContentGroupInd = 'C' AND c.OpenInNewWindowFlag = 'Y' AND @InUseNewWindowFlag = 'Y' THEN 
           @GECodePath + 'TemplateRedirect.cfm?template=/MembersOnly.cfm&ContentID=' + convert(varchar(18), c.ContentID) + @LeftNewWinString + @GECodePath + 'TemplateRedirect.cfm?template=/MembersOnly.cfm&ContentID=' + convert(varchar(18), c.ContentID) + @RightNewWinString
        WHEN w.UseAspNetTemplateFlag = 'N' AND c.MembersOnlyFlag = 'Y' AND n.NavContentGroupInd = 'C' THEN 
           @GECodePath + 'TemplateRedirect.cfm?template=/MembersOnly.cfm&ContentID=' + convert(varchar(18), c.ContentID) + '"'    
        WHEN w.UseAspNetTemplateFlag = 'N' AND c.MembersOnlyFlag = 'Y' AND c.OpenInNewWindowFlag = 'Y' AND @InUseNewWindowFlag = 'Y' THEN 
           @GECodePath + 'Template.cfm?section=' + n.Name + '&template=/MembersOnly.cfm&ContentID=' + convert(varchar(18), c.ContentID) + @LeftNewWinString + @GECodePath + 'Template.cfm?section=' + n.Name + '&template=/MembersOnly.cfm&ContentID=' + convert(varchar(18), c.ContentID) + @RightNewWinString
        WHEN w.UseAspNetTemplateFlag = 'N' AND c.MembersOnlyFlag = 'Y' THEN 
           @GECodePath + 'Template.cfm?section=' + n.Name + '&template=/MembersOnly.cfm&ContentID=' + convert(varchar(18), c.ContentID) + '"'
        WHEN w.UseAspNetTemplateFlag = 'N' AND n.NavContentGroupInd = 'C' AND c.OpenInNewWindowFlag = 'Y' AND @InUseNewWindowFlag = 'Y' AND isNULL(c.MembersOnlyFlag, 'N') != 'Y' THEN 
           @GECodePath + 'TemplateRedirect.cfm?' + 'template=/CM/HTMLDisplay.cfm&ContentID=' + convert(varchar(18), c.ContentID) + @LeftNewWinString + @GECodePath + 'TemplateRedirect.cfm?'+ '?template=/HTMLDisplay.cfm&ContentID=' + convert(varchar(18), c.ContentID) + @RightNewWinString
        WHEN w.UseAspNetTemplateFlag = 'N' AND n.NavContentGroupInd = 'C' THEN
           @GECodePath + 'TemplateRedirect.cfm?' +'template=/CM/HTMLDisplay.cfm&ContentID=' + convert(varchar(18), c.ContentID) + '"'
        WHEN w.UseAspNetTemplateFlag = 'Y' AND c.MembersOnlyFlag = 'Y' AND n.NavContentGroupInd = 'C' AND c.OpenInNewWindowFlag = 'Y' AND @InUseNewWindowFlag = 'Y' THEN 
           @GECodePath + 'ContentManagerNet/TemplateRedirect.aspx?template=/ContentManagerNet/MembersOnly.aspx&ContentID=' + convert(varchar(18), c.ContentID) + @LeftNewWinString + @GECodePath + 'ContentManagerNet/TemplateRedirect.aspx?template=/ContentManagerNet/MembersOnly.aspx&ContentID=' + convert(varchar(18), c.ContentID) + @RightNewWinString
        WHEN w.UseAspNetTemplateFlag = 'Y' AND c.MembersOnlyFlag = 'Y' AND n.NavContentGroupInd = 'C' THEN 
           @GECodePath + 'ContentManagerNet/TemplateRedirect.aspx?template=/ContentManagerNet/MembersOnly.aspx&ContentID=' + convert(varchar(18), c.ContentID) + '"'    
        WHEN w.UseAspNetTemplateFlag = 'Y' AND c.MembersOnlyFlag = 'Y' AND c.OpenInNewWindowFlag = 'Y' AND @InUseNewWindowFlag = 'Y' THEN 
           @VirtualDirectoryPath + '/' + n.Name +  + '/AM/ContentManagerNet/MembersOnly.aspx?Section=' + n.Name + '&ContentID=' + convert(varchar(18), c.ContentID) + @LeftNewWinString + @VirtualDirectoryPath + '/' + n.Name +  + '/AM/ContentManagerNet/MembersOnly.aspx?Section=' + n.Name + '&ContentID=' + convert(varchar(18), c.ContentID) + @RightNewWinString
        WHEN w.UseAspNetTemplateFlag = 'Y' AND c.MembersOnlyFlag = 'Y' THEN 
           @VirtualDirectoryPath + '/' + n.Name +  + '/AM/ContentManagerNet/MembersOnly.aspx?Section=' + n.Name + '&ContentID=' + convert(varchar(18), c.ContentID) + '"'
        WHEN w.UseAspNetTemplateFlag = 'Y' AND n.NavContentGroupInd = 'C' AND c.OpenInNewWindowFlag = 'Y' AND @InUseNewWindowFlag = 'Y' AND isNULL(c.MembersOnlyFlag, 'N') != 'Y' THEN 
           @GECodePath + 'ContentManagerNet/TemplateRedirect.aspx?' + 'template=/ContentManagerNet/HTMLDisplay.aspx&ContentID=' + convert(varchar(18), c.ContentID) + @LeftNewWinString + @GECodePath + 'ContentManagerNet/TemplateRedirect.aspx?'+ '?template=/ContentManagerNet/HTMLDisplay.aspx&ContentID=' + convert(varchar(18), c.ContentID) + @RightNewWinString
        WHEN w.UseAspNetTemplateFlag = 'Y' AND n.NavContentGroupInd = 'C' THEN
           @GECodePath + 'ContentManagerNet/TemplateRedirect.aspx?' +'template=/ContentManagerNet/HTMLDisplay.aspx&ContentID=' + convert(varchar(18), c.ContentID) + '"'
        WHEN c.OpenInNewWindowFlag = 'Y' AND @InUseNewWindowFlag = 'Y' AND isNULL(c.MembersOnlyFlag, 'N') != 'Y' THEN
           REPLACE(ISNULL(ch.PublishLocation, c.PublishLocation), REPLACE(IsNull(w.NavPublishDirectory,''),'\','/'), IsNull(w.NavContentDisplayPath,''))+ @LeftNewWinString + REPLACE(ISNULL(ch.PublishLocation, c.PublishLocation), REPLACE(IsNull(w.NavPublishDirectory,''),'\','/'), IsNull(w.NavContentDisplayPath,'')) + @RightNewWinString
        ELSE 
           REPLACE(ISNULL(ch.PublishLocation, c.PublishLocation), REPLACE(IsNull(w.NavPublishDirectory,''),'\','/'), IsNull(w.NavContentDisplayPath,'')) + '"'
      END,
      c.Name,
      c.Keywords,
      c.Description,
      convert(varchar(20), IsNULL(c.PublicationDate, '01/01/1950'), 102),
      w.WebsiteKey,
      w.IncludeInCrossSiteSearchFlag,
      n.NavContentGroupInd,
      n.NavMenuID
    FROM
      vCurrent_Content c, Nav_Menu n,
      Content_HTML ch, Website w
    WHERE c.WorkflowStatusCode = 'P'
      and c.NavMenuID = n.NavMenuID
      and n.WebsiteKey <> @AdminWebsiteKey
      and c.ContentID = ch.ContentID
      and n.WebsiteKey = w.WebsiteKey
      and (LEN(RTrim(ch.PublishLocation)) > 0 OR LEN(RTrim(c.PublishLocation)) > 0)
      AND IsNull(n.HideFlag,'N') = 'N'

  /*
  ** Finally, after all rows have been added to the temp table, we need to 
  ** generate the comma separated list of Interest Categories
  */
  
  DECLARE c_InterestCategory CURSOR FOR
    select cic.InterestCategoryID,
           cic.ComponentID,
           ic.Name
      from Component_Interest_Category cic, #temp t, Interest_Category ic
     where cic.ComponentCode = 'CM'
       and cic.ComponentID = t.ContentID
       and cic.InterestCategoryID = ic.InterestCategoryID
     order by cic.ComponentID

  OPEN c_InterestCategory
  
  FETCH NEXT FROM c_InterestCategory INTO
    @InterestCategoryID,
    @ComponentID,
    @InterestCategoryName

  SET @OldComponentID = @ComponentID
  SET @InterestCategoryList = @InterestCategoryID
  SET @InterestCategoryNameList = @InterestCategoryName
  SET @l_FirstRow = 1
    
  WHILE (@@FETCH_STATUS=0) BEGIN
    IF ( @OldComponentID != @ComponentID ) BEGIN
      UPDATE #temp
         SET InterestCategoryList = @InterestCategoryList,
             Keywords = Keywords + ' ' + Left(@InterestCategoryNameList, 1000 - Len(Keywords) - 1)
       WHERE ContentID = @OldComponentID

      SET @InterestCategoryList = @InterestCategoryID
      SET @InterestCategoryNameList = @InterestCategoryName
    END
    ELSE BEGIN
      IF ( @l_FirstRow = 1 ) BEGIN
        SET @InterestCategoryList = @InterestCategoryID
        SET @InterestCategoryNameList = @InterestCategoryName
        SET @l_FirstRow = 0
      END
      ELSE BEGIN
        SET @InterestCategoryList = @InterestCategoryList + ',' + convert(varchar(10), @InterestCategoryID)      
        SET @InterestCategoryNameList = @InterestCategoryNameList + ' ' + @InterestCategoryName      
      END
    END

    SET @OldComponentID = @ComponentID

    FETCH NEXT FROM c_InterestCategory INTO
      @InterestCategoryID,
      @ComponentID,
      @InterestCategoryName

  END

  UPDATE #temp
     SET InterestCategoryList = @InterestCategoryList,
         Keywords = Keywords + ' ' + Left(@InterestCategoryNameList, 1000 - Len(Keywords) - 1)
    WHERE ContentID = @OldComponentID

  CLOSE c_InterestCategory
  DEALLOCATE c_InterestCategory

  /* Do the similar thing for WebsiteKey */
  UPDATE #temp
     SET AllWebsiteKeys = Convert(varchar(50),WebsiteKey) + ','

  -- For each nav item, add Websites are marked to include in the search
  -- and only include those websites that has the setting on.
  DECLARE c_NavMenu CURSOR FOR 
   SELECT DISTINCT b.NavMenuID, b.WebsiteKey
     FROM #temp a, Nav_Menu_Website b, Website c
    WHERE a.NavMenuID = b.NavMenuID
      AND a.WebsiteKey <> b.WebsiteKey
      AND b.WebsiteKey = c.WebsiteKey
      AND c.IncludeInCrossSiteSearchFlag = 'Y'

  OPEN c_NavMenu
  FETCH NEXT FROM c_NavMenu
   INTO @NavMenuID,
        @WebsiteKey
  WHILE @@FETCH_STATUS = 0 BEGIN
  
    UPDATE #temp
       SET AllWebsiteKeys = IsNull(AllWebsiteKeys,'') + Convert(varchar(50),@WebsiteKey) + ','
     WHERE NavMenuID = @NavMenuID

    FETCH NEXT FROM c_NavMenu
     INTO @NavMenuID,
          @WebsiteKey
  END
  CLOSE c_NavMenu
  DEALLOCATE c_NavMenu

  -- Remove extra ","
  UPDATE #temp
     SET AllWebsiteKeys = Left(AllWebsiteKeys,Len(AllWebsiteKeys)-1)
   WHERE AllWebsiteKeys IS NOT NULL

  /* 
  ** Return our Result Set
  */

  SELECT t.FilePath, 
         t.URL, 
         t.Title, 
         t.InterestCategoryList, 
         t.Keywords,
         t.Description,
         Convert(Varchar(10), IsNull(t.ContentID,0)) + ',NCInd:' + NavContentGroupInd + ',WKEY:' + t.AllWebsiteKeys + ',' +  'CSEARCH:' + IsNull(IncludeInCrossSiteSearchFlag,'Y') + ',' + CustomField2 AS CustomField2,
         t.WebsiteKey,
         t.AllWebsiteKeys
    FROM #temp t 

end

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_GetSiblingTree]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_GetSiblingTree]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create    procedure amsp_GetSiblingTree 
	@NavMenuID integer
as
begin

  declare
    @counter integer

  create table #temp (NavMenuID integer)

  /*
  ** First insert self and siblings based on ParentNavMenuID value
  */
  insert into #temp
  select NavMenuID 
  from Nav_Menu
  where IsNull(ParentNavMenuID, -1) = (select IsNull(ParentNavMenuID, -1)
                                         from Nav_Menu
                                        where NavMenuID = @NavMenuID)
  
  /*
  ** As long as there are new children, keep adding them to #temp.
  ** To make sure a bad nav_menu item doesn't lock the server, we also
  ** limit this to 50 iterations.
  */
  set @counter = 0
  while @@rowCount > 0 and @counter < 50 begin
    set @counter = @counter + 1
    insert into #temp
    select a.NavMenuID
      from Nav_Menu a, #temp b
     where a.ParentNavMenuID = b.NavMenuID
       and a.NavMenuID not in (select NavMenuID from #temp)
  end

  /*
  ** Return our results
  */
  select * from #temp

end

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_GetTaggedPage]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_GetTaggedPage]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[amsp_GetTaggedPage]
    @TPLID NUMERIC,
    @LstInterestCategoryID VARCHAR(1000),
    @TPPID NUMERIC,
    @HideMemberOnlyFlag NUMERIC,
    @ExtraURLVar VARCHAR(1000),
    @ContactID NUMERIC = 0,
    @TPOperator CHAR(1) = 'A'
AS
SET NOCOUNT ON
  /*
  ** DESCRIPTION:
  ** ------------
  ** Generate queries for a tagged page layout.  This stored procedure will perform the logic
  ** to follow most of the customization specified via the user interface.  It will filter out
  ** contents by the given interest categories, figures out maximum rows to return, sorting
  ** logic, etc.  
  **   
  ** Then the queries returned will be used by the portlets (components) to generate the output
  **
  ** INPUTS:
  ** -------
  ** @TPLID -> TaggedPageLayoutID - Identifies which tagged page has been called.
  ** @LstInterestCategoryID -> List of additional interest categories (vs ones specified in the tagged page)
  ** @TPPID -> TaggedPagePortletID - (Optional) Identifies "view all" mode.  Therefore, only the
  **           query for this portlet will be generated.
  ** @HideMemberOnlyFlag -> (Optional) Indicates Members only content/record/etc should not be returned (CM).
  ** @ExtraURLVar -> (Optional) Any extra URL variables that may be used by this script.
  ** @ContactID -> User's ContactID.  Currently, only used to retrieve user interest categories
  **               when @TPOperator = "U"
  ** @TPOperator -> An additional variable for indicating special attention.
  **
  ** RESULT SET:
  ** -----------
  ** Query sets for each TaggedPagePorletID (components specified in the tagged page).
  **
  ** NOTES:
  ** ------
  **
  ** PROGRAMMING CONSIDERATIONS:
  ** ---------------------------
  ** Dynamic SQL is only be used when absolutely necessary.
  **
  ** HISTORY:
  ** --------
  ** 01/17/2002   Intae Kim   Initial Version Created
  ** 06/20/2002   Intae Kim   Handles two new input variables, @ContactID and @TPOperator
  ** 10/22/2002   Intae Kim   Added Forum and Survey.  Also allows ability to accomodate more than
  **                          one SQL per component.
  ** 01/21/2003   Intae Kim   Added a feature for handling date range and border info.
  ** 07/08/2003   Intae Kim   Added ability to use a date column specified by the user.
  ** 08/18/2003   Intae Kim   Handles "Hide" feature for CM.
  ** 09/17/2003   Intae Kim   Corrected handling of different "Name" coloums in same query for CM
  ** 10/24/2003   Intae Kim   When no @LstInterestCategoryID is passed in and there are heavy amount
  **                          of data in the system, inserting "all" records into a temp table slowed 
  **                          the SP down.  Adding further checking to limit valid data enhanced performance.
  ** 11/04/2003   Intae Kim   Added ability to handle range instead of just date range
  ** 12/15/2003   E.Tatsui    Added a fix for ECM. It was failing when tables from other products don't exist.
  ** 03/22/2004   E.Tatsui    Removed where clause that filters out items by end date for conference and calendar.
  ** 09/27/2005   E.Tatsui    Added Perfomance changes by Dmitry. Some of the queries replaced with 
			      Views and improved dynamic SQL. Added optmization hints to the queries.
 */
 
BEGIN
  DECLARE
  @SQL                         nVARCHAR(4000),
  @TempVar                     VARCHAR(100),
  @TempList                    VARCHAR(1000),
  @StringPtr                   INT,
  @LastStringPtr               INT,
  @TaggedSectionID             NUMERIC,
  @TaggedPagePortletID         NUMERIC,
  @ComponentCode               CHAR(2),
  @MaxRows                     NUMERIC,
  @PrimarySort                 VARCHAR(50),
  @PrimarySortAscDescInd       CHAR(1),
  @SecondarySort               VARCHAR(50),
  @SecondarySortAscDescInd     CHAR(1),
  @OrderNum                    NUMERIC,
  @SQLNumber                   NUMERIC,
  @RangeColumn                 VARCHAR(50),
  @ColumnType                  VARCHAR(10),
  @RangeFrom                   VARCHAR(25),
  @RangeTo                     VARCHAR(25),
  @TempStr1                    VARCHAR(1000),
  @TempStr2                    VARCHAR(1000),
  @UserDefinedDate1            VARCHAR(50),
  @CurrentDate                 VARCHAR(10),
  @EcmFlag                     bit



DECLARE @DEBUG Datetime
DECLARE @tmpSQL nvarchar(2000)
DECLARE @SQLString nvarchar(4000)
  -- Figure out this database is for eCM.
  IF OBJECT_ID('Press_Release') IS NULL
    SET @EcmFlag = 1
  ELSE
    SET @EcmFlag = 0

  -- Tag page contains one or more "sections" of page, such as top and bottom or
  -- left and right.  Each section can contain one or more "portlets" which handles
  -- the display.  
 
  -- Grab all portlet information for every sections in this tagged page and put it into #TempTPP.
  -- This table will eventually contain records that have been filtered by the interest categories.

SELECT TPS.TaggedSectionID, TPP.TaggedPagePortletID, TT.ComponentCode, TT.SQLNumber, TPP.MaxRows, TPP.PrimarySort, TPP.PrimarySortAscDescInd, 
       TPP.SecondarySort, TPP.SecondarySortAscDescInd, TPP.OrderNum, TPP.UseOR, TPP.RangeFrom, TPP.RangeTo, TPP.RangeColumn, 
       TPCC.ColumnType
  INTO [#TempTPP]
  FROM Tagged_Page_Section AS TPS WITH (UPDLOCK) 
 INNER JOIN Tagged_Page_Portlet AS TPP WITH (UPDLOCK) ON TPS.TaggedPageSectionID = TPP.TaggedPageSectionID 
 INNER JOIN Tagged_Portlet AS TP WITH (UPDLOCK) ON TPP.TaggedPortletID = TP.TaggedPortletID 
 INNER JOIN Tagged_Template AS TT WITH (UPDLOCK) ON TP.TaggedTemplateID = TT.TaggedTemplateID 
  LEFT OUTER JOIN Tagged_Page_Component_Column AS TPCC WITH (UPDLOCK) ON TT.ComponentCode = TPCC.ComponentCode AND TPP.RangeColumn = TPCC.ColumnName
 WHERE (TPS.TaggedPageLayoutID = @TPLID)
 
  -- If TPPID is passed in, then we only care about this TaggedPagePortlet
  IF @TPPID <> 0
  BEGIN
    DELETE FROM #TempTPP WITH (UPDLOCK)
     WHERE TaggedPagePortletID <> @TPPID
  END
  
  -- Temporary table that will initially contain matched rows from Component_Interest_Categories table.
  -- This will be PER TaggedPagePortletID associated through ComponentCode
  CREATE TABLE #TempCIC
  ( 
   TaggedPagePortletID NUMERIC,
   UseOR CHAR(1),
   ComponentCode CHAR(2),
   ComponentID NUMERIC,
   InterestCategoryID NUMERIC
  )
 
  -- For each TaggedPagePortletID, put component info into a temporary table which matched
  -- all the ICs passedin via @LstInterestCategoryID
 
  -- Putting comma at the end to make logic a bit easier when I use CHARINDEX()
  SET @TempList = @LstInterestCategoryID + ','
  SET @LastStringPtr = 1
  SET @StringPtr = CHARINDEX(',', @TempList, @LastStringPtr)
 
  -- If 0 is passed as @LstInterestCategoryID, this means there is no IC to match so insert all
  -- valid records into this temporary table.  
  -- Note: Did join to Tagged_Page_PortletIC and checked for "current" records to cut down on
  -- insert time.
  /* Added on 12/15/2003 */

  IF SUBSTRING(@TempList, @LastStringPtr, @StringPtr - @LastStringPtr) = 0 
  BEGIN 
    INSERT INTO #TempCIC
           (TaggedPagePortletID, UseOR, ComponentCode, ComponentID, InterestCategoryID)
    SELECT TPP.TaggedPagePortletID, TPP.UseOR, CIC.ComponentCode, CIC.ComponentID, CIC.InterestCategoryID
      FROM #TempTPP TPP  WITH (UPDLOCK) LEFT OUTER JOIN Tagged_Page_PortletIC TPPIC WITH (UPDLOCK) ON TPP.TaggedPagePortletID = TPPIC.TaggedPagePortletID, 
           Component_Interest_Category CIC WITH (UPDLOCK)
     WHERE TPP.ComponentCode = CIC.ComponentCode
       AND (CIC.InterestCategoryID = TPPIC.InterestCategoryID
            OR TPPIC.InterestCategoryID IS NULL)
       AND (CIC.ComponentCode = 'CM'
            AND EXISTS (SELECT TOP 1 1
                          FROM Content C WITH (UPDLOCK)
                         WHERE C.ContentID = CIC.ComponentID
                           AND C.WorkflowStatusCode = 'P'))

  END
  -- Special operation to handle user defined interest categories
  ELSE IF @TPOperator = 'U'
  BEGIN
    INSERT INTO #TempCIC
           (TaggedPagePortletID, UseOR, ComponentCode, ComponentID, InterestCategoryID)
    SELECT TPP.TaggedPagePortletID, TPP.UseOR, 
           CIC.ComponentCode, CIC.ComponentID, CIC.InterestCategoryID
      FROM #TempTPP TPP WITH (UPDLOCK), Component_Interest_Category CIC WITH (UPDLOCK)
     WHERE TPP.ComponentCode = CIC.ComponentCode
       AND CIC.InterestCategoryID IN (SELECT CIC2.InterestCategoryID
                                        FROM Contact_Interest_Category CIC2 WITH (UPDLOCK)
                                       WHERE CIC2.ContactID = @ContactID)
  END
  ELSE 
  BEGIN
    IF @TPOperator = 'O'  
    BEGIN
      -- Stored Procedure does not allow something like XX IN (@LstInterestCategoryID)
      -- so do loop.
      INSERT INTO #TempCIC
             (TaggedPagePortletID, UseOR, ComponentCode, ComponentID, InterestCategoryID)
      SELECT TPP.TaggedPagePortletID, TPP.UseOR, 
             CIC.ComponentCode, CIC.ComponentID, CIC.InterestCategoryID
        FROM #TempTPP TPP WITH (UPDLOCK), Component_Interest_Category CIC  WITH (UPDLOCK)
       WHERE TPP.ComponentCode = CIC.ComponentCode
         AND CIC.ComponentID IN (SELECT CIC2.ComponentID 
                                   FROM Component_Interest_Category CIC2 WITH (UPDLOCK)
                                  WHERE CIC2.ComponentCode = CIC.ComponentCode
                                    AND CIC2.InterestCategoryID = SUBSTRING(@TempList, @LastStringPtr, @StringPtr - @LastStringPtr))
  
      SET @LastStringPtr = @StringPtr + 1
      SET @StringPtr = CHARINDEX(',', @TempList, @LastStringPtr)
 
      -- If more than one IC has been provided, loop through the rest of ICs to add
      WHILE @StringPtr > 0 
      BEGIN
        INSERT INTO #TempCIC
               (TaggedPagePortletID, UseOR, ComponentCode, ComponentID, InterestCategoryID)
        SELECT TPP.TaggedPagePortletID, TPP.UseOR, 
               CIC.ComponentCode, CIC.ComponentID, CIC.InterestCategoryID
          FROM #TempTPP TPP WITH (UPDLOCK), Component_Interest_Category CIC  WITH (UPDLOCK)
         WHERE TPP.ComponentCode = CIC.ComponentCode
           AND CIC.ComponentID IN (SELECT CIC2.ComponentID 
                                     FROM Component_Interest_Category CIC2
                                    WHERE CIC2.ComponentCode = CIC.ComponentCode
                                      AND CIC2.InterestCategoryID = SUBSTRING(@TempList, @LastStringPtr, @StringPtr - @LastStringPtr))
           AND CIC.ComponentID NOT IN (SELECT T2.ComponentID 
                                         FROM #TempCIC T2 WITH (UPDLOCK)
                                        WHERE T2.ComponentCode = CIC.ComponentCode
                                          AND T2.InterestCategoryID = SUBSTRING(@TempList, @LastStringPtr, @StringPtr - @LastStringPtr))
        SET @LastStringPtr = @StringPtr + 1
        SET @StringPtr = CHARINDEX(',', @TempList, @LastStringPtr)
      END
    END
    ELSE
    BEGIN
      INSERT INTO #TempCIC
             (TaggedPagePortletID, UseOR, ComponentCode, ComponentID, InterestCategoryID)
      SELECT TPP.TaggedPagePortletID, TPP.UseOR, 
             CIC.ComponentCode, CIC.ComponentID, CIC.InterestCategoryID
        FROM #TempTPP TPP WITH (UPDLOCK), Component_Interest_Category CIC  WITH (UPDLOCK)
       WHERE TPP.ComponentCode = CIC.ComponentCode
         AND CIC.ComponentID IN (SELECT CIC2.ComponentID 
                                   FROM Component_Interest_Category CIC2 WITH (UPDLOCK)
                                  WHERE CIC2.ComponentCode = CIC.ComponentCode
                                    AND CIC2.InterestCategoryID = SUBSTRING(@TempList, @LastStringPtr, @StringPtr - @LastStringPtr))
  
      SET @LastStringPtr = @StringPtr + 1
      SET @StringPtr = CHARINDEX(',', @TempList, @LastStringPtr)
 
      -- If more than one IC has been provided, loop through the rest of ICs to narrow the 
      -- results which match all the ICs
      WHILE @StringPtr > 0 
      BEGIN
        DELETE #TempCIC
         WHERE ComponentID NOT IN (SELECT CIC.ComponentID 
                                     FROM Component_Interest_Category CIC WITH (UPDLOCK)
                                    WHERE CIC.ComponentCode = #TempCIC.ComponentCode
                                      AND CIC.InterestCategoryID = SUBSTRING(@TempList, @LastStringPtr, @StringPtr - @LastStringPtr))
        SET @LastStringPtr = @StringPtr + 1
        SET @StringPtr = CHARINDEX(',', @TempList, @LastStringPtr)
      END
    END

 END
 

  -- Grab any important values passed into the script which can later be used to filter
  -- the result set.
  SET @UserDefinedDate1 = ''
  SET @TempList = @ExtraURLVar + '&'
  SET @LastStringPtr = 1
  SET @StringPtr = CHARINDEX('&', @TempList, @LastStringPtr)
 
  WHILE @StringPtr > 0 
  BEGIN
    SET @TempVar = SUBSTRING(@TempList, @LastStringPtr, @StringPtr - @LastStringPtr)
    IF (CHARINDEX('=',@TempVar) != 0 AND UPPER(SUBSTRING(@TempVar,1,CHARINDEX('=',@TempVar)-1)) = 'USERDEFINEDDATE1')
      SET @UserDefinedDate1 = SUBSTRING(@TempVar,CHARINDEX('=',@TempVar)+1,LEN(@TempVar)-CHARINDEX('=',@TempVar))
 
    SET @LastStringPtr = @StringPtr + 1
    SET @StringPtr = CHARINDEX(',', @TempList, @LastStringPtr)
  END
  
  
  /*
  ** IMPORTANT!!!!
  ** 
  ** Now #TempCIC table contains only and unique results from component_interest_category
  ** for each TaggedPagePortletID that matched the list of ICs passed into this 
  ** stored procedure via @LstInterestCategoryID
  **
  ** Next step is to match all ICs specfied for each TaggedPagePortlet. This is
  ** accomplished by first deleting ICs that are not part of the ICs of each 
  ** TaggedPagePortlet which will result in only the ICs that matched will remain.
  ** So at the end of this delete, there can NOT be more ICs per TaggedPagePortlet
  ** in the #TempCIC than the number of ICs specified for each TaggedPagePortlet.
  ** 
  ** So the logic is if after the delete, there are same number of IC for each
  ** TaggedPagePortlet in #TempCIC table as ICs specified for each TaggedPagePortlet in
  ** TaggedPagePortletIC table, then the condition for matching all ICs is met.
  **
  ** The last step is to select unique values from #TempCIC and save it for SELECT
  ** logic.
  **
  ** Addition: IK Delete on #TempCIC will not occurr if no entry in TPPIC.
  */

  DELETE #TempCIC
   WHERE NOT EXISTS (SELECT *
                       FROM Tagged_Page_PortletIC TPPIC WITH (UPDLOCK)
                      WHERE TPPIC.InterestCategoryID = #TempCIC.InterestCategoryID
                        AND TPPIC.TaggedPagePortletID = #TempCIC.TaggedPagePortletID)
         AND EXISTS (SELECT *
                       FROM Tagged_Page_PortletIC TPPIC2 WITH (UPDLOCK)
                      WHERE TPPIC2.TaggedPagePortletID = #TempCIC.TaggedPagePortletID)

  SELECT TaggedPagePortletID, ComponentID, ComponentCode
    INTO #TempCIC2
    FROM #TempCIC WITH (UPDLOCK)
   GROUP BY TaggedPagePortletID, ComponentID, ComponentCode
  HAVING Count(*) = (SELECT Count(*)
                       FROM Tagged_Page_PortletIC TPPIC WITH (UPDLOCK)
                      WHERE TPPIC.TaggedPagePortletID = #TempCIC.TaggedPagePortletID)

  DELETE #TempCIC
   WHERE NOT EXISTS (SELECT *
                       FROM #TempCIC2 T2 WITH (UPDLOCK)
                      WHERE T2.TaggedPagePortletID = #TempCIC.TaggedPagePortletID
                        AND T2.ComponentID = #TempCIC.ComponentID
                        AND T2.ComponentCode = #TempCIC.ComponentCode)
     AND UseOR = 'N'
     AND EXISTS (SELECT *
                   FROM Tagged_Page_PortletIC TPPIC2 WITH (UPDLOCK)
                  WHERE TPPIC2.TaggedPagePortletID = #TempCIC.TaggedPagePortletID)
 
  SELECT DISTINCT TaggedPagePortletID, ComponentCode, ComponentID
    INTO #Temp
    FROM #TempCIC WITH (UPDLOCK)

  -- Loop through each TaggedPagePortletID (component) in specified order to generate dynamic SQL to excute.
  -- Dynamic SQL is a must since we allow users to specify "Order By" columns

SET @DEBUG=GETDATE()
 
  DECLARE c_TPP CURSOR FAST_FORWARD FOR
    SELECT TPP.TaggedSectionID,
           TPP.TaggedPagePortletID,
           TPP.ComponentCode,
           TPP.MaxRows,
           TPP.PrimarySort,
           TPP.PrimarySortAscDescInd,
           TPP.SecondarySort,
           TPP.SecondarySortAscDescInd,
           TPP.OrderNum,
           TPP.SQLNumber,
           TPP.RangeFrom,
           TPP.RangeTo,
           TPP.RangeColumn,
           TPP.ColumnType
      FROM #TempTPP TPP WITH (NOLOCK)
     ORDER BY TPP.TaggedSectionID, TPP.OrderNum

  SET @CurrentDate = CONVERT(VARCHAR(2),MONTH(CURRENT_TIMESTAMP))+'/'+CONVERT(VARCHAR(2),DAY(CURRENT_TIMESTAMP))+'/'+CONVERT(VARCHAR(4),Year(CURRENT_TIMESTAMP))
  OPEN c_TPP
  
  WHILE (1 = 1) 
  BEGIN
    FETCH NEXT FROM c_TPP INTO
         @TaggedSectionID,
         @TaggedPagePortletID,
         @ComponentCode,
         @MaxRows,
         @PrimarySort,
         @PrimarySortAscDescInd,
         @SecondarySort,
         @SecondarySortAscDescInd,
         @OrderNum,
         @SQLNumber,
         @RangeFrom,
         @RangeTo,
         @RangeColumn,
         @ColumnType
 
    IF @@Fetch_Status <> 0
      BREAK
 
    SET @SQL = 'SELECT'
    IF (@TPPID = 0 AND @MaxRows IS NOT NULL)
      SET @SQL = @SQL + ' TOP ' + CONVERT(VARCHAR(10),@MaxRows)
    ELSE
      SET @MaxRows = 10000
 
    SET @TempStr1 = ''
    SET @TempStr2 = ''
 
    IF @RangeColumn IS NOT NULL
    BEGIN
      IF @ColumnType = 'Date'
      BEGIN
        IF @RangeFrom IS NOT NULL
        BEGIN
          IF ISDATE(@RangeFrom) = 1
          BEGIN
            SET @TempStr1 = ' AND ' + @RangeColumn + ' >= ''' + @RangeFrom + ''''
            SET @TempStr2 = ' AND ' + @RangeColumn + ' >= ''' + @RangeFrom + ''''
          END 
          ELSE IF ISNUMERIC(@RangeFrom) = 1
          BEGIN
            SET @TempStr1 = ' AND ' + @RangeColumn + ' >= DATEADD(d,' + @RangeFrom + ',''' + @CurrentDate + ''')'
            SET @TempStr2 = ' AND ' + @RangeColumn + ' >= DATEADD(d,' + @RangeFrom + ',''' + @CurrentDate + ''')'
          END
        END
        IF @RangeTo IS NOT NULL
        BEGIN
          IF ISDATE(@RangeTo) = 1
          BEGIN
            SET @TempStr1 = @TempStr1 + ' AND ' + @RangeColumn + ' <= ''' + @RangeTo + ' 23:59:59'''
            SET @TempStr2 = @TempStr2 + ' AND ' + @RangeColumn + ' <= ''' + @RangeTo + ' 23:59:59'''
          END 
          ELSE IF ISNUMERIC(@RangeTo) = 1
          BEGIN
            SET @TempStr1 = @TempStr1 + ' AND ' + @RangeColumn + ' <= DATEADD(d,' + @RangeTo + ',''' + @CurrentDate + ' 23:59:59'')'
            SET @TempStr2 = @TempStr2 + ' AND ' + @RangeColumn + ' <= DATEADD(d,' + @RangeTo + ',''' + @CurrentDate + ' 23:59:59'')'
          END
        END
      END
      ELSE IF @ColumnType = 'Numeric'
      BEGIN
        IF @RangeFrom IS NOT NULL AND ISNUMERIC(@RangeFrom) = 1
          BEGIN
            SET @TempStr1 = ' AND ' + @RangeColumn + ' >= ' + @RangeFrom
            SET @TempStr2 = ' AND ' + @RangeColumn + ' >= ' + @RangeFrom
          END
        IF @RangeTo IS NOT NULL AND ISNUMERIC(@RangeTo) = 1
          BEGIN
            SET @TempStr1 = @TempStr1 + ' AND ' + @RangeColumn + ' <= ' + @RangeTo
            SET @TempStr2 = @TempStr2 + ' AND ' + @RangeColumn + ' <= ' + @RangeTo
          END
      END
      ELSE
      BEGIN
        IF @RangeFrom IS NOT NULL
       BEGIN
            SET @TempStr1 = ' AND ' + @RangeColumn + ' >= ''' + @RangeFrom + ''''
            SET @TempStr2 = ' AND ' + @RangeColumn + ' >= ''' + @RangeFrom + ''''
          END
        IF @RangeTo IS NOT NULL
          BEGIN
            SET @TempStr1 = @TempStr1 + ' AND ' + @RangeColumn + ' <= ''' + @RangeTo + ''''
            SET @TempStr2 = @TempStr2 + ' AND ' + @RangeColumn + ' <= ''' + @RangeTo + ''''
          END
      END
    END
    IF @ComponentCode = 'CM'
    BEGIN
      -- Used to filter out any restricted content if the site is set to hide member only data from
      -- registered users.
      IF @HideMemberOnlyFlag = 1
        SET @TempVar = '(''N'','''')'
      ELSE
        SET @TempVar = '(''N'',''Y'','''')'
 
      -- If UserDefinedDate1 is provided, setup the temporary variables to plug into
      -- the SQL construct.
      IF @UserDefinedDate1 != ''
      BEGIN
        SET @TempStr1 = @TempStr1 + ' AND C.UserDefinedDate1 = ''' + @UserDefinedDate1 + ''''
        SET @TempStr2 = @TempStr2 + ' AND C2.UserDefinedDate1 = ''' + @UserDefinedDate1 + ''''
      END

	SET @tmpSQL='
	DECLARE @Flag INT
	SELECT @Flag= (CASE
	 WHEN Count(*) > ' + CONVERT(VARCHAR(10),@MaxRows) + ' THEN 1
	 ELSE 0 END)
	FROM #Temp T2 WITH (UPDLOCK)
	JOIN vContent_TemplatePath C2 on T2.ComponentID = C2.ContentID
	WHERE 
	ISNULL(C2.MembersOnlyFlag,''N'') IN ' + @TempVar + '
	AND T2.TaggedPagePortletID = ' + CONVERT(VARCHAR(10),@TaggedPagePortletID) + @TempStr2 + '  '


	    SET @SQL = @SQL + ' ' + CONVERT(VARCHAR(10),@TaggedSectionID) + ' TaggedSectionID, ' 
	                 + CONVERT(VARCHAR(10),@TaggedPagePortletID) + ' TaggedPagePortletID,  
	                   C.*, C.TemplatePath, @Flag  as MoreFlag
	                     FROM #Temp T WITH (UPDLOCK)
				Join vContent_TemplatePath C on T.ComponentID = C.ContentID
	                    WHERE 
	                     	ISNULL(C.MembersOnlyFlag,''N'') IN ' + @TempVar + ' 
	                      	AND 
				T.TaggedPagePortletID = ' + CONVERT(VARCHAR(10),@TaggedPagePortletID)
	                      + @TempStr1
    END

    ELSE IF @ComponentCode = 'CC'
    BEGIN
      SET @SQL = @SQL + ' ' + CONVERT(VARCHAR(10),@TaggedSectionID) + ' TaggedSectionID, ' 
                 + CONVERT(VARCHAR(10),@TaggedPagePortletID) + ' TaggedPagePortletID,
                   0 MoreFlag'  
    END
    
    IF @PrimarySort IS NOT NULL
    BEGIN
      SET @SQL = @SQL + ' ORDER BY ' + @PrimarySort
      IF @PrimarySortAscDescInd = 'D'
        SET @SQL = @SQL + ' DESC'
      ELSE
        SET @SQL = @SQL + ' ASC'
      IF @SecondarySort IS NOT NULL
      BEGIN
        SET  @SQL = @SQL + ', ' + @SecondarySort
        IF @SecondarySortAscDescInd = 'D'
          SET @SQL = @SQL + ' DESC'
        ELSE
          SET @SQL = @SQL + ' ASC'
      END
    END
 
--PRINT 'Query is: ' + @SQL
--Print '' 
SEt @DEBUG=Getdate()
-- D. Eliseev 03/01/2005 - Combine Final SQL string as SQLBatch String and Quert itself.
set @SQLString=@tmpSQL + @SQL

--PRINT 'Query is: ' + @SQL
--Print '' 

EXECUTE sp_executesql @SQLString

--PRINT 'Dynamic SQL Stime (ms) : ' + cast(datediff(ms,@DEBUG,Getdate()) as varchar(10)) 
  END
 
  CLOSE c_TPP
  DEALLOCATE c_TPP

END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_GetTagsWithHierarchy]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_GetTagsWithHierarchy]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This procedure retrieves all the associated tags for a given component.
-- For nested tags, it retrieves all ancestors leading up to the tag for a
-- more user friendly display. This procedure is currently called by Admin\
-- Admin\TaggedPage\TaggedPageCategories.cfm.
--
-- MODIFICATION HISTORY:
--   DATE        USER          ACTION
--   02/24/2004  C.Jewell      Created.
-- =============================================

Create  PROCEDURE amsp_GetTagsWithHierarchy
  @InComponentCode char(2),
  @InComponentID numeric

AS
BEGIN

CREATE TABLE #TagDisplay (
       InterestCategoryID numeric,
       ParentCategoryID numeric,
       Name varchar(255),
       SortOrder numeric,
       CategoryDepth numeric,
       SelectedFlag char(1))

-- First insert selected tags ...

INSERT INTO #TagDisplay (
       InterestCategoryID,
       ParentCategoryID,
       Name,
       SortOrder,
       CategoryDepth,
       SelectedFlag)
SELECT b.InterestCategoryID,
       b.ParentCategoryID,
       b.Name,
       b.SortOrder,
       b.CategoryDepth,
       'Y'
  FROM Component_Interest_Category a WITH (NOLOCK),
       Interest_Category b WITH (NOLOCK)
 WHERE a.InterestCategoryID = b.InterestCategoryID
   AND a.ComponentCode = @InComponentCode
   AND a.ComponentID = @InComponentID

-- Now add the ancestors ...

WHILE @@RowCount > 0
INSERT INTO #TagDisplay (
       InterestCategoryID,
       ParentCategoryID,
       Name,
       SortOrder,
       CategoryDepth)
SELECT DISTINCT a.InterestCategoryID,
       a.ParentCategoryID,
       a.Name,
       a.SortOrder,
       a.CategoryDepth
  FROM #TagDisplay t,
       Interest_Category a WITH (NOLOCK)
  LEFT OUTER JOIN #TagDisplay t2
    ON a.InterestCategoryID = t2.InterestCategoryID
 WHERE a.InterestCategoryID = t.ParentCategoryID
   AND t2.InterestCategoryID IS NULL

SELECT *
  FROM #TagDisplay
 ORDER BY SortOrder

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_ICFixTree]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_ICFixTree]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE    PROCEDURE amsp_ICFixTree
	@l_ParentCategoryID   Numeric=0 ,
	@l_SortOrder   Numeric(28,18) = 0 OUT, 
	@l_CategoryDepth  Numeric=0,
	@l_AncestorID Numeric=0
AS

  /*
  ** DESCRIPTION:
  ** ------------
  ** Walks the tree and sets the CategoryDepth, SortOrder, AncestorID, AncestorOrder based on the
  ** ParentID relationship.
  **
  ** INPUTS:
  ** -------
  **   none
  ** 
  ** OUTPUTS:
  ** -----------
  **   none
  **
  ** NOTES:
  ** ------
  **   Recursive so only supports 255 levels in the tree... should NOT be a problem.
  ** 
  ** HISTORY:
  ** --------
  **   04/23/2003	N.Malhotra	Initial Version Created
  **
  */

DECLARE @b CURSOR

SET @l_CategoryDepth=@l_CategoryDepth+1

IF @l_ParentCategoryID= 0
  BEGIN
    SET @b=CURSOR STATIC FOR
    SELECT InterestCategoryID
      FROM Interest_Category
     WHERE ParentCategoryID IS NULL
     ORDER BY SortOrder
  END
ELSE
  BEGIN
    SET @b=CURSOR STATIC FOR
    SELECT InterestCategoryID
      FROM Interest_Category
     WHERE ParentCategoryID=@l_ParentCategoryID
     ORDER BY SortOrder
END

DECLARE @l_IntrestID Numeric

OPEN @b
FETCH FROM @b INTO @l_IntrestID
IF NOT @@FETCH_STATUS=0 RETURN
  WHILE @@FETCH_STATUS=0 
    BEGIN
      IF @l_ParentCategoryID= 0
        SET @l_AncestorID=@l_IntrestID    

      SET @l_SortOrder=@l_SortOrder+1000
      SET @l_IntrestID = CAST(@l_IntrestID AS Numeric)

      UPDATE Interest_Category
         SET SortOrder=@l_SortOrder,
             CategoryDepth=@l_CategoryDepth,
             AncestorCategoryID=@l_AncestorID,
             AncestorOrder=@l_SortOrder
      WHERE InterestCategoryID=@l_IntrestID

      EXEC amsp_ICFixTree @l_IntrestID, @l_SortOrder OUT, @l_CategoryDepth, @l_AncestorID

      FETCH FROM @b INTO @l_IntrestID             
    END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_ICDemote]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_ICDemote]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE      procedure amsp_ICDemote
	@InSourceNodeID	numeric
AS
BEGIN

  /*
  ** DESCRIPTION:
  ** ------------
  ** Demotes a node in the Interest_Category tree (InSourceNodeID) to be a child of the next highest
  ** sibling node in the tree (same parent, and highest sort order less than the node being demoted).
  **
  ** INPUTS:
  ** -------
  **   @InSourceNodeID	Source node being demoted
  ** 
  ** OUTPUTS:
  ** -----------
  **   none
  **
  ** NOTES:
  ** ------
  ** 
  ** HISTORY:
  ** --------
  **   04/23/2003	N.Malhotra	Initial Version Created
  **
  */

  Declare  
    @DestSortOrder		numeric,
    @DestDepth			numeric,
    @DestID			numeric,
    @DestAncestorID		numeric,
    @SourceSortOrder		numeric,
    @SourceDepth		numeric,
    @SourceParentID		numeric

  BEGIN TRANSACTION

  /*
  ** Let's find out about our source node
  */

  SELECT 
    @SourceSortOrder  = SortOrder,
    @SourceDepth      = CategoryDepth,
    @SourceParentID   = ParentCategoryID
  FROM
    Interest_Category
  WHERE
    InterestCategoryID = @InSourceNodeID

  /*
  ** Confirm the node can be demoted.  The node being demoted must have a sibling node
  ** above it in the tree (lower sort order but same parent).
  */

  SELECT @DestID = InterestCategoryID,
         @DestAncestorID = AncestorCategoryID,
         @DestDepth = CategoryDepth
    FROM Interest_Category
   WHERE SortOrder = (SELECT Max(SortOrder)
                        FROM Interest_Category
                       WHERE SortOrder < @SourceSortOrder
                         AND IsNULL(ParentCategoryID,0) = IsNULL(@SourceParentID,0))
  
  IF @@RowCount = 1 BEGIN

    /*
    ** Everything's a go.  Let's do it.
    */
   
    UPDATE Interest_Category
       SET ParentCategoryID = @DestID,
           AncestorCategoryID = @DestAncestorID
     WHERE InterestCategoryID = @InSourceNodeID

    /*
    ** amsp_FixTree will set the AncestorID, SortOrder, CategoryDepth for the entire tree.
    */
    
    EXEC amsp_ICFixTree

  END

  COMMIT TRANSACTION

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_ICMove]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_ICMove]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE       procedure amsp_ICMove
	@InSourceNodeID	numeric,
	@InDestNodeID	numeric
AS
BEGIN

  /*
  ** DESCRIPTION:
  ** ------------
  ** Moves a node in the Interest_Category tree (InSourceNodeID) to be a sibling directly
  ** beneath the destination (InDestNodeID) node.
  **
  ** INPUTS:
  ** -------
  **   @InSourceNodeID	Source node being moved
  **   @InDestNodeID	Destination node being moved beneath
  ** 
  ** OUTPUTS:
  ** -----------
  **   none
  **
  ** NOTES:
  ** ------
  **   1) Interest_Category table has AncestorOrder but this stored procedure is wriiten to
  **      allow only SortOrder to be used to fully sort all interest categories (i.e. sort order
  **      covers all IC's, not just IC's for the same ancestor).  This will allow AncestorOrder to 
  **      be removed easily (in the future) so that IC tree and Nav_Menu tree follow the same structure.
  ** 
  ** HISTORY:
  ** --------
  **   03/21/2003	N.Malhotra	Initial Version Created
  **
  */

  Declare  
    @DestSortOrder		numeric,
    @DestDepth			numeric,
    @DestParentID		numeric,
    @DestAncestorID		numeric,
    @SourceSortOrder		numeric,
    @SourceDepth		numeric,
    @SourceParentID		numeric,
    @SourceAncestorID		numeric,
    @InvalidCount		int,
    @Counter			int

  /*
  ** After confirming there is something to move, begin processing 
  */

  IF @InSourceNodeID != @InDestNodeID BEGIN

    SET @InvalidCount = 0

    BEGIN TRANSACTION

    /*
    ** Let's find out about our destination node
    */

    SELECT
      @DestSortOrder  = SortOrder,
      @DestDepth      = CategoryDepth,
      @DestParentID   = ParentCategoryID,
      @DestAncestorID = AncestorCategoryID
    FROM
      Interest_Category
    WHERE
      InterestCategoryID = @InDestNodeID

    /*
    ** Let's find out about our source node
    */

    SELECT 
      @SourceSortOrder  = SortOrder,
      @SourceDepth      = CategoryDepth,
      @SourceParentID   = ParentCategoryID,
      @SourceAncestorID = AncestorCategoryID
    FROM
      Interest_Category
    WHERE
      InterestCategoryID = @InSourceNodeID

    IF @DestAncestorID = @SourceAncestorID BEGIN

      /* 
      ** We need to make sure the destination node is not a direct decendant of the source node.
      ** If it is, the move operation would create a circular relationship and so it is invalid
      */

      SET @Counter = 0

      CREATE TABLE #TEMP (ChildID numeric)

      INSERT INTO #TEMP
      SELECT InterestCategoryID
        FROM Interest_Category
       WHERE ParentCategoryID = @InSourceNodeID

      WHILE (@Counter < 50 AND @@ROWCOUNT > 0) BEGIN

        SET @Counter = @Counter + 1
   
        INSERT INTO #TEMP
        SELECT InterestCategoryID
          FROM Interest_Category
         WHERE ParentCategoryID IN (SELECT ChildID FROM #TEMP)
           AND InterestCategoryID NOT IN (SELECT ChildID FROM #TEMP)
      END

      SELECT @InvalidCount = Count(*)
        FROM #TEMP
       WHERE ChildID = @InDestNodeID

      IF @InvalidCount > 0  BEGIN
        RAISERROR ('You may not move nodes within the same level 1 hierarchy', 16, 1)
      END
    END

    IF @InvalidCount = 0 BEGIN

      /*
      ** Simply adjust the parent pointer
      */
  
      UPDATE 
        Interest_Category
      SET 
        ParentCategoryID   = @DestParentID,
	SortOrder = @DestSortOrder + 1
      WHERE 
        InterestCategoryID = @InSourceNodeID

      /*
      ** amsp_FixTree will set the AncestorID, SortOrder, CategoryDepth for the entire tree.
      */
    
      EXEC amsp_ICFixTree

    END

    COMMIT TRANSACTION

  END

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_ICPromote]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_ICPromote]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE     procedure amsp_ICPromote
	@InSourceNodeID	numeric
AS
BEGIN

  /*
  ** DESCRIPTION:
  ** ------------
  ** Promotes a node in the Interest_Category tree (InSourceNodeID) to be the last sibling of its parent node.
  **
  ** INPUTS:
  ** -------
  **   @InSourceNodeID	Source node being promoted
  ** 
  ** OUTPUTS:
  ** -----------
  **   none
  **
  ** NOTES:
  ** ------
  **   none 
  **
  ** HISTORY:
  ** --------
  **   04/23/2003	N.Malhotra	Initial Version Created
  **
  */

  Declare  
    @DestID			numeric,
    @SourceSortOrder		numeric,
    @SourceDepth		numeric,
    @SourceParentID		numeric


  BEGIN TRANSACTION

  /*
  ** Let's find out about our source node
  */

  SELECT 
    @SourceSortOrder  = SortOrder,
    @SourceDepth      = CategoryDepth,
    @SourceParentID   = ParentCategoryID
  FROM
    Interest_Category
  WHERE
    InterestCategoryID = @InSourceNodeID

  /* 
  ** Can't do anything if it is already a level 1
  */

  IF @SourceDepth > 1 BEGIN

    /*
    ** Get the parent's parent node (this will be the new parent)
    */

    SELECT @DestID = ParentCategoryID
      FROM Interest_Category
     WHERE InterestCategoryID = @SourceParentID

    IF @SourceDepth = 2 BEGIN

      /*
      ** Promoting to a level 1 is a special case scenario
      */

      UPDATE Interest_Category
         SET ParentCategoryID = NULL,
             AncestorCategoryID = InterestCategoryID,
             CategoryDepth = 1
       WHERE InterestCategoryID = @InSourceNodeID

    END
    ELSE BEGIN

      UPDATE Interest_Category
         SET ParentCategoryID = @DestID
       WHERE InterestCategoryID = @InSourceNodeID

    END


    /*
    ** amsp_FixTree will set the AncestorID, SortOrder, CategoryDepth for the entire tree.
    */
    
    EXEC amsp_ICFixTree


    COMMIT TRANSACTION

  END

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_ICRenum]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_ICRenum]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE   procedure amsp_ICRenum AS
BEGIN

/*
** 03/21/2003  N.Malhotra	Created from amsp_NavMenuRenum
*/

  DECLARE 
    @SortIncrement	integer,
    @NumICs		integer

  CREATE TABLE #temp (
    ID Numeric Identity not null,
    InterestCategoryID numeric,
    SortOrder numeric)

  BEGIN TRANSACTION
   
  INSERT INTO #temp (InterestCategoryID, SortOrder)
  SELECT InterestCategoryID, SortOrder
    FROM Interest_Category
   ORDER BY AncestorOrder, SortOrder

  SELECT @NumICs = count(*)
    FROM Interest_Category

  SET @SortIncrement = CEILING(999990000.0 / @NumICs) - 1

  UPDATE #Temp
     SET SortOrder = ID * @SortIncrement

  CREATE UNIQUE INDEX IDX_TEMP_1 ON #Temp(InterestCategoryID)

  UPDATE Interest_Category
     SET SortOrder = t.SortOrder
    FROM #temp t
   WHERE Interest_Category.InterestCategoryID = t.InterestCategoryID
 
  COMMIT TRANSACTION


END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_SCUpdateLoginInfo]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_SCUpdateLoginInfo]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- Procedure to update login info.
-- =============================================
CREATE PROCEDURE amsp_SCUpdateLoginInfo
  @InContactID numeric
AS
BEGIN
  print 'No update for now.'
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_TPGetTagsWithHierarchy]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_TPGetTagsWithHierarchy]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE  PROCEDURE amsp_TPGetTagsWithHierarchy
  @InComponentID numeric

AS
BEGIN

CREATE TABLE #TagDisplay (
       InterestCategoryID numeric,
       ParentCategoryID numeric,
       Name varchar(255),
       SortOrder numeric,
       CategoryDepth numeric,
       SelectedFlag char(1))

-- First insert selected tags ...

INSERT INTO #TagDisplay (
       InterestCategoryID,
       ParentCategoryID,
       Name,
       SortOrder,
       CategoryDepth,
       SelectedFlag)
SELECT b.InterestCategoryID,
       b.ParentCategoryID,
       b.Name,
       b.SortOrder,
       b.CategoryDepth,
       'Y'
  FROM Tagged_Page_Interest_Category a WITH (NOLOCK),
       Interest_Category b WITH (NOLOCK)
 WHERE a.InterestCategoryID = b.InterestCategoryID
   AND a.ContentID = @InComponentID

-- Now add the ancestors ...

WHILE @@RowCount > 0
INSERT INTO #TagDisplay (
       InterestCategoryID,
       ParentCategoryID,
       Name,
       SortOrder,
       CategoryDepth)
SELECT DISTINCT a.InterestCategoryID,
       a.ParentCategoryID,
       a.Name,
       a.SortOrder,
       a.CategoryDepth
  FROM #TagDisplay t,
       Interest_Category a WITH (NOLOCK)
  LEFT OUTER JOIN #TagDisplay t2
    ON a.InterestCategoryID = t2.InterestCategoryID
 WHERE a.InterestCategoryID = t.ParentCategoryID
   AND t2.InterestCategoryID IS NULL

SELECT *
  FROM #TagDisplay
 ORDER BY SortOrder

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_TreeMove]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_TreeMove]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE   procedure amsp_TreeMove 
	@InSourceNodeID	numeric,
	@InDestNodeID	numeric
AS
BEGIN

  /*
  ** DESCRIPTION:
  ** ------------
  ** Moves a node in a Nav Menu tree (InSourceNodeID) to be a sibling directly
  ** beneath the destination (InDestNodeID) node.
  **
  ** INPUTS:
  ** -------
  **   @InSourceNodeID	Source node being moved
  **   @InDestNodeID	Destination node being moved beneath
  ** 
  ** OUTPUTS:
  ** -----------
  **   none
  **
  ** NOTES:
  ** ------
  **   none
  ** 
  ** HISTORY:
  ** --------
  ** 06/26/2001		N.Malhotra	Initial Version Created
  **
  */

  Declare  
    @HighSortOrder		numeric,
    @LowSortOrder		numeric,
    @SortIncrement		numeric,
    @NewSortOrder		numeric,
    @DestSortOrder		numeric,
    @DestDepth			numeric,
    @DestParentID		numeric,
    @DestAncestorID		numeric,
    @SourceSortOrder		numeric,
    @SourceDepth		numeric,
    @SourceParentID		numeric,
    @SourceAncestorID		numeric,
    @MaxRelativeSort		numeric,
    @TotalSortSpace		numeric,
    @Counter			int

  IF @InSourceNodeID != @InDestNodeID BEGIN

    BEGIN TRANSACTION

    /*
    ** Let's find out about our destination
    */

    SELECT
      @DestSortOrder = SortOrder,
      @DestDepth = CategoryDepth,
      @DestParentID = ParentNavMenuID,
      @DestAncestorID = AncestorNavMenuID
    FROM
      Nav_Menu
    WHERE
      NavMenuID = @InDestNodeID

    /*
    ** First, let's grab and save the source attributes for use in calculating relative moves later
    */

    SELECT 
      @SourceSortOrder = SortOrder,
      @SourceParentID = ParentNavMenuID,
      @SourceAncestorID = AncestorNavMenuID,
      @SourceDepth = CategoryDepth
    FROM 
      Nav_Menu
    WHERE 
      NavMenuID = @InSourceNodeID

    IF @DestDepth > 1 BEGIN

      /*
      ** If the destination node has a depth > 1 then we simply set the 
      ** Ancestor and Parent to the destination's Ancestor and Parent
      */
  
      UPDATE 
        Nav_Menu
      SET 
        ParentNavMenuID = @DestParentID,
        AncestorNavMenuID = @DestAncestorID,
        CategoryDepth = @DestDepth
      WHERE 
        NavMenuID = @InSourceNodeID
    END
    ELSE BEGIN

      /*
      ** Otherwise, the destination node has a depth of 1 so both the 
      ** Ancestor and Parent need to be set to the node itself
      */
  
      UPDATE 
        Nav_Menu
      SET 
        ParentNavMenuID = @InSourceNodeID,
        AncestorNavMenuID = @DestAncestorID,
        CategoryDepth = @DestDepth
      WHERE 
        NavMenuID = @InSourceNodeID

    END

    /*
    ** Now, let's find the low and high end of our sort order range.
    */

    SELECT 
      @HighSortOrder = IsNULL(MIN(SortOrder), 0)
    FROM
      Nav_Menu
    WHERE
      CategoryDepth <= @DestDepth AND 
      SortOrder > @DestSortOrder

    IF @HighSortOrder = 0
      SELECT
        @HighSortOrder = MAX(SortOrder) + 10
      FROM
        Nav_Menu

    SELECT 
      @LowSortOrder = MAX(SortOrder)
    FROM
      Nav_Menu
    WHERE
      SortOrder < @HighSortOrder

    /*
    ** OK, with our low point and high point established, we can 
    ** easily establish a point in the middle.  It's somewhat arbitrary
    ** but we're going to insert in increments of 1/10 the distance between
    ** high and low because we know all decendants have to still be added.
    */

    SET @NewSortOrder = @LowSortOrder + .1 * (@HighSortOrder - @LowSortOrder)
 
    UPDATE 
      Nav_Menu
    SET
      SortOrder = @NewSortOrder
    WHERE
      NavMenuID = @InSourceNodeID

    /*
    ** Now, sort of a funny way to do this, but it is fast and efficient ...
    ** Were going to throw all of the descendants into a temp table with only
    ** their NavMenuID and their SortOrder relative to the Source Node we're
    ** moving and likewise, relative CategoryDepth.  
    */

    create table #temp (NavMenuID numeric, RelativeSort numeric, RelativeDepth numeric)

    /*
    ** First insert the Source Node
    */

    INSERT INTO #temp VALUES (@InSourceNodeID, 0, 0)
  
    /*
    ** As long as there are new children, keep adding them to #temp.
    ** To make sure a bad nav_menu relationship doesn't lock the server,
    ** we also limit this to 50 iterations (i.e. 50 levels).
    */

    SET @Counter = 0

    WHILE @@rowCount > 0 and @Counter < 50 BEGIN
      SET @Counter = @Counter + 1
      INSERT INTO #temp (NavMenuID, RelativeSort, RelativeDepth)
      SELECT a.NavMenuID, a.SortOrder - @SourceSortOrder, a.CategoryDepth - @SourceDepth
        FROM Nav_Menu a, #temp b
       WHERE a.ParentNavMenuID = b.NavMenuID
         and a.NavMenuID not in (SELECT NavMenuID FROM #temp)
    END

    /*
    ** Now that our table table has all descendants, a single update will
    ** set their values.  Only SortOrder is tricky, and we use the relative 
    ** offset to compute this.
    */
 
    SELECT @MaxRelativeSort = MAX(RelativeSort) from #temp
    SET @TotalSortSpace = @HighSortOrder - @NewSortOrder 
  
    UPDATE Nav_Menu
       SET AncestorNavMenuID = @SourceAncestorID,
           CategoryDepth = (select @DestDepth + t.RelativeDepth
                              from #temp t
                             where t.NavMenuID = NavMenu.NavMenuID),
           SortOrder = (select @NewSortOrder + ((t.RelativeSort / @MaxRelativeSort) * @TotalSortSpace)
                          from #temp t
                         where t.NavMenuID = NavMenu.NavMenuID)
     WHERE 
           NavMenuID in (select NavMenuID from #temp) AND
           NavMenuID != @InSourceNodeID
        
    COMMIT TRANSACTION

  END

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_AccessKeyDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_AccessKeyDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- Will check an access key, and delete all related access items if it's a local custom
-- access key, or do nothing, if it's a shared 'area' access key
CREATE PROCEDURE [dbo].[asi_AccessKeyDelete] 
    @accessKey uniqueidentifier
AS
BEGIN
    SET NOCOUNT ON
    DECLARE @scope nvarchar(20)
    SELECT @scope = [AccessScope] FROM [dbo].[AccessMain] WHERE [AccessKey] = @accessKey
    IF (@scope = 'Local')
    BEGIN
        DELETE FROM [dbo].[AccessItem] WHERE [AccessKey] = @accessKey
        DELETE FROM [dbo].[AccessMain] WHERE [AccessKey] = @accessKey
    END
    SET NOCOUNT OFF
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ActiveSourceCodeBySegment]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ActiveSourceCodeBySegment]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_ActiveSourceCodeBySegment    Script Date: 7/3/2003 4:58:02 PM ******/
CREATE PROCEDURE [dbo].[asi_ActiveSourceCodeBySegment]

@segmentKey uniqueidentifier

 AS

SELECT Count(*) 
FROM 
vBoSourceList sl INNER JOIN vBoSourceCode sc
	ON sl.SourceCodeKey = sc.SourceCodeKey
WHERE 
	CHARINDEX(CAST(@segmentKey AS varchar(36)), sl.OriginListKeys) <> 0
	AND sc.SourceCodeStatusCode=0

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ActiveSourceCodeBySegmentationJob]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ActiveSourceCodeBySegmentationJob]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_ActiveSourceCodeBySegmentationJob    Script Date: 7/3/2003 4:58:02 PM ******/
CREATE PROC [dbo].[asi_ActiveSourceCodeBySegmentationJob]

@jobKey uniqueidentifier

AS
SELECT Count(*)
FROM
	vBoSourceList sl INNER JOIN vBoSourceCode sc
	ON sl.SourceCodeKey = sc.SourceCodeKey
WHERE 
	EXISTS
		(SELECT 1 
		FROM SegmentDefinition sd INNER JOIN SegmentationJob sj
		ON sd.SegmentationJobKey = sj.SegmentationJobKey
		WHERE 
		CHARINDEX(CAST(sd.SegmentDefinitionKey AS varchar(36)), sl.OriginListKeys) <> 0
		AND sj.SegmentationJobKey = @jobKey)
	AND sc.SourceCodeStatusCode = 0

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_AddToPublishQueue]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_AddToPublishQueue]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


CREATE PROCEDURE [dbo].[asi_AddToPublishQueue]
    @publishedOn datetime,
    @publishedByUserKey uniqueidentifier,
    @type int, --The type of item being published [ex. 4 == content record, 5 == contact, etc]
    @minDate datetime = NULL,
    @maxDate datetime = NULL,
    @itemCode varchar(32) = NULL, --the item code [ex. If content record the DocumentVersionKey, if contact then ContactKey]
    @itemAction int = 0 --The type of action performed on item: new add (0), update (1), delete (2)
AS
BEGIN
    IF OBJECT_ID('tempdb..#publishTaskIds') IS NOT NULL DROP TABLE #publishTaskIds
    CREATE TABLE #publishTaskIds (TaskQueueId bigint, PublishServerCode nchar(1) COLLATE DATABASE_DEFAULT)

    -- Insert into TaskQueue for each PublishServerRef entry and capture the Id and PublishServerCode to use for the detail row  
    MERGE [dbo].[TaskQueue]
    USING (SELECT [PublishServerCode] FROM [dbo].[PublishServerRef]) AS src 
    ON (1 = 0) -- arbitrary join condition
    WHEN NOT MATCHED THEN
        INSERT ([TaskQueueTypeId], [RequestedOn])
        VALUES (1, @publishedOn)
        OUTPUT inserted.[TaskQueueId], src.[PublishServerCode]
        INTO #publishTaskIds;
     
    INSERT INTO [dbo].[TaskQueuePublishDetail] ([TaskQueueId], [PublishedOn], [PublishedByUserKey], [TaskQueueStatusId], [Type], [StatusUpdatedOn], [MinDate], [MaxDate], [ItemCode], [ItemAction], [PublishServerCode])
    SELECT [TaskQueueId], @publishedOn, @publishedByUserKey, 1, @type, NULL, @minDate, @maxDate, @itemCode, @itemAction, [PublishServerCode]
      FROM #publishTaskIds

    IF OBJECT_ID('tempdb..#publishTaskIds') IS NOT NULL DROP TABLE #publishTaskIds
END





GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_BuildNameAllView]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_BuildNameAllView]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:		Paul Bradshaw
-- Create date: Jan 30th, 2007
-- Description:	Create the Name_All View
-- =============================================
CREATE PROCEDURE [dbo].[asi_BuildNameAllView] 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @rowctr int
	DECLARE @sql1 varchar(max)
	DECLARE @sql2 varchar(max)
	DECLARE @sql3 varchar(max)
	DECLARE @tmpstr varchar(max)
	DECLARE @tmpstr2 varchar(max)
	DECLARE @temp_table table (table_name sysname, col_name sysname null)
	DECLARE @table_name sysname
	DECLARE @col_name sysname
	DECLARE @prev_col_name sysname
	DECLARE @CRLF varchar(3)
	SET @CRLF = char(13) + char(10)

	INSERT INTO @temp_table
		SELECT udf.TABLE_NAME, udf.FIELD_NAME 
		  FROM UD_Field udf  
		       INNER JOIN UD_Table udt ON udf.TABLE_NAME = udt.TABLE_NAME
	     WHERE udt.ALLOW_MULTIPLE_INSTANCES = 0 AND udt.NAME_ALL_TABLE = 1
	           AND EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = udf.TABLE_NAME AND COLUMN_NAME = udf.FIELD_NAME)
	           
	INSERT INTO @temp_table
		SELECT 'Name', COLUMN_NAME 
		  FROM INFORMATION_SCHEMA.COLUMNS 
		 WHERE TABLE_NAME = 'Name' and COLUMN_NAME <> 'TIME_STAMP'

	INSERT INTO @temp_table
		SELECT 'Name_Fin', COLUMN_NAME 
		  FROM INFORMATION_SCHEMA.COLUMNS 
		 WHERE TABLE_NAME = 'Name_Fin' and COLUMN_NAME <> 'ID' and COLUMN_NAME <> 'TIME_STAMP'

	-- should always be at least one column, so no error checking
	SELECT @sql1 = 'CREATE VIEW Name_All (' + @CRLF

	SELECT @tmpstr = ''
	SELECT @prev_col_name = ''
	 
	DECLARE col_cursor CURSOR FAST_FORWARD FOR SELECT table_name, col_name FROM @temp_table ORDER BY col_name
	OPEN col_cursor
	FETCH next FROM col_cursor INTO @table_name, @col_name 
	WHILE @@FETCH_STATUS = 0
		BEGIN	
		IF @col_name <> @prev_col_name
			BEGIN
				SELECT @sql1 = @sql1 +  @col_name + ', ' 
				SELECT @tmpstr = @tmpstr + @table_name + '.' + @col_name + ', ' 
			END
		SET @prev_col_name = @col_name
		FETCH next FROM col_cursor INTO @table_name, @col_name
		END
	CLOSE col_cursor
	DEALLOCATE col_cursor

	SELECT @sql1 = left(@sql1, datalength (@sql1) - 2)
	SELECT @tmpstr = left(@tmpstr, datalength (@tmpstr) - 2)

	SELECT @sql1 = @sql1 + @CRLF + ') AS ' + @CRLF 
	SELECT @sql2 = 'SELECT ' + @tmpstr + @CRLF 
	SELECT @sql3 = '  FROM ' 

	DELETE FROM @temp_table

	INSERT INTO @temp_table (table_name)
		SELECT DISTINCT udf.TABLE_NAME 
		  FROM UD_Field udf  
		       INNER JOIN UD_Table udt ON udf.TABLE_NAME = udt.TABLE_NAME
	     WHERE udt.NAME_ALL_TABLE = 1
	           AND EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = udf.TABLE_NAME AND COLUMN_NAME = udf.FIELD_NAME)

	SELECT @rowctr = count(1) FROM @temp_table
	IF @rowctr = 0  -- no UD Dues billing tables
		BEGIN
		SELECT @sql3 = @sql3 + 'Name, Name_Fin' + @CRLF + 'where Name.ID = Name_Fin.ID'
		END
	ELSE
		BEGIN
		SELECT @tmpstr = ''
		SELECT @tmpstr2 = ''
 
        DECLARE UD_cursor CURSOR FAST_FORWARD FOR SELECT table_name FROM @temp_table ORDER BY table_name
		OPEN UD_cursor
		FETCH next FROM UD_cursor INTO @table_name
		WHILE @@FETCH_STATUS = 0
			BEGIN	
			SELECT @tmpstr = @tmpstr + @table_name + ', '
			SELECT @tmpstr2 = @tmpstr2 + ' Name.ID = ' + @table_name + '.ID and '
			FETCH next FROM UD_cursor INTO @table_name
			END
		CLOSE UD_cursor
		DEALLOCATE UD_cursor
	
		SELECT @sql3 = @sql3 + 'Name, ' 
		SELECT @sql3 = @sql3 + @tmpstr
		SELECT @sql3 = @sql3 + 'Name_Fin' + @CRLF + 'where'
		SELECT @sql3 = @sql3 + @tmpstr2
		SELECT @sql3 = @sql3 + 'Name.ID = Name_Fin.ID'
		END

	EXEC (@sql1 + @sql2 + @sql3)
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_CancelPendingPublishRequest]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_CancelPendingPublishRequest]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_CancelPendingPublishRequest]
	@PublishRequestKey uniqueidentifier,
    @PublishServerCode nchar(1)AS
BEGIN
	UPDATE PublishRequestDetail
	   SET PublishRequestStatusCode = 2 --canceled
	 WHERE PublishRequestKey = @PublishRequestKey
       AND PublishServerCode = @PublishServerCode
       AND PublishRequestStatusCode = 0 -- New
END


SET ANSI_NULLS ON

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_CancelPendingPublishRequestForContent]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_CancelPendingPublishRequestForContent]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_CancelPendingPublishRequestForContent]
	@ContentDocumentKey uniqueidentifier
AS
BEGIN
	UPDATE PublishRequestDetail
	   SET PublishRequestStatusCode = 2 --canceled
	 WHERE ContentDocumentKey = @ContentDocumentKey
       AND (PublishRequestStatusCode = 0
        OR  (PublishRequestStatusCode = 1 AND Frequency > 0))
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_CheckImisNetPrivilegeLevel]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_CheckImisNetPrivilegeLevel]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE   PROC [dbo].[asi_CheckImisNetPrivilegeLevel]
	@userId as varchar(60),
	@systemKeyword as varchar(25)
	AS
BEGIN

set nocount on

declare @userKey as uniqueidentifier
declare @accessKey as uniqueidentifier
declare @permissions as int
declare @tmppermission as int

declare @LevelNet as int

declare @EveryoneRoleKey uniqueidentifier
select @EveryoneRoleKey = ParameterValue from SystemConfig 
	where ParameterName = 'Security.Token.EveryoneRoleKey'

select @userKey = UserKey from UserMain
where UserId = @userId

select @accessKey = ApplicationAccessKey
from SystemEntity
where SystemKeyword = @systemKeyword

CREATE TABLE #permission (permission int)

-- Add Self
INSERT	#permission(permission)
select Permission from AccessItem
where AccessKey = @accessKey
and UserKey = @userKey

-- Everyone Role
INSERT	#permission(permission)
select Permission from AccessItem
where AccessKey = @accessKey
and RoleKey = @EveryoneRoleKey

-- Assigned Roles
INSERT	#permission(permission)
select Permission from AccessItem
where AccessKey = @accessKey
and RoleKey in (SELECT RoleKey FROM UserRole WHERE UserKey = @userKey
    AND RoleKey <> @EveryoneRoleKey)

-- Effective Group Membership
INSERT	#permission(permission)
select Permission from AccessItem
where AccessKey = @accessKey
and GroupKey in (SELECT	DISTINCT GroupKey
 FROM	GroupMember
 WHERE	MemberContactKey = @userKey
   AND	(JoinDate <= getdate() OR JoinDate IS NULL)
   AND	(DropDate >= getdate() OR DropDate IS NULL))

set @permissions = 0
DECLARE Permission_Cursor CURSOR FOR
SELECT permission from #permission
OPEN Permission_Cursor
FETCH NEXT FROM Permission_Cursor
INTO @tmppermission
set @permissions = @permissions | @tmppermission
WHILE @@FETCH_STATUS = 0
BEGIN
	FETCH NEXT FROM Permission_Cursor
	INTO @tmppermission
	set @permissions = @permissions | @tmppermission
END
CLOSE Permission_Cursor
DEALLOCATE Permission_Cursor

IF (@permissions & 4096) > 0
begin
	select 3 as LevelNet
	set @LevelNet = 3
end
ELSE IF (@permissions & 2048) > 0
begin
	select 2 as LevelNet
	set @LevelNet = 2
end
ELSE IF (@permissions & 1024) > 0
begin
	select 1 as LevelNet
	set @LevelNet = 1
end
ELSE
begin
	select 0 as LevelNet
	set @LevelNet = 0
end

drop table #permission

return @LevelNet

set nocount off

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_CleanTaskLog]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_CleanTaskLog]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_CleanTaskLog]
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @now datetime;
    DECLARE @deleteSuccessLogsAfter int;
    DECLARE @deleteFailedLogsAfter int;
    DECLARE @deleteCompletedLogsAfter int;
    
    SELECT @now = dbo.asi_GetAppDatetime();
    SELECT @deleteSuccessLogsAfter = [ParameterValue] FROM [dbo].[SystemConfig] WHERE [ParameterName] = 'DeleteSuccessLogsAfter';
    SELECT @deleteFailedLogsAfter = [ParameterValue] FROM [dbo].[SystemConfig] WHERE [ParameterName] = 'DeleteFailedLogsAfter';
    SELECT @deleteCompletedLogsAfter = [ParameterValue] FROM [dbo].[SystemConfig] WHERE [ParameterName] = 'DeleteCompletedLogsAfter';
    
    --Set the default values in case config options don't exist
    IF @deleteSuccessLogsAfter IS NULL
    BEGIN
        SET @deleteSuccessLogsAfter = 30 
    END
    
    IF @deleteFailedLogsAfter IS NULL
    BEGIN
        SET @deleteFailedLogsAfter = 90
    END
    
    IF @deleteCompletedLogsAfter IS NULL
    BEGIN
        SET @deleteCompletedLogsAfter = 1
    END

    DELETE detail 
      FROM [dbo].[TaskLogDetail] detail 
           INNER JOIN [dbo].[TaskLog] tl ON detail.[TaskLogKey] = tl.[TaskLogKey]
     WHERE (tl.[Status] = '3' AND tl.[UpdatedOn] < DATEADD(DAY, -@deleteSuccessLogsAfter, @now)) --If status is successful and date is past the config value
           OR (tl.[Status] = '2' AND tl.[UpdatedOn] < DATEADD(DAY, -@deleteFailedLogsAfter, @now)) --If status is failed and date is past the config value
           OR (tl.[Status] = '1' AND tl.[UpdatedOn] < DATEADD(DAY, -@deleteCompletedLogsAfter, @now)) --If status is completed and date is past the config value
        
    DELETE FROM [dbo].[TaskLog] 
     WHERE ([Status] = '3' AND [UpdatedOn] < DATEADD(DAY, -@deleteSuccessLogsAfter, @now)) --If status is successful and date is past the config value
           OR ([Status] = '2' AND [UpdatedOn] < DATEADD(DAY, -@deleteFailedLogsAfter, @now)) --If status is failed and date is past the config value
           OR ([Status] = '1' AND [UpdatedOn] < DATEADD(DAY, -@deleteCompletedLogsAfter, @now)) --If status is completed and date is past the config value
END    

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_CleanupCalculatedEngagementScoreRollups]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_CleanupCalculatedEngagementScoreRollups]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_CleanupCalculatedEngagementScoreRollups]
    @engagementScoreKey uniqueidentifier
AS 
BEGIN
-----------------------------------------------------------------------------------------------------------------------------------------------
--  When we process engagement scores we insert into CalculatedEngagementScore using ROLLUP to get rolled up values for each month, 
--  year, and "forever" for each contact and component.  Whenever scores are processed we'll create some number of new rollups.  This procedure
--  collapses these as follows:
--     - Set the score for "forever" rollups (those with null year) to the sum of those rollups for the contact and component. 
--     - Set the score for the year rollups to the sum of those rollups for the contact, component and year.     
--     - Set the score for the month rollups to the sum of those rollups for the contact, component, year, and month.
--     - As a result of all this we'll have duplicates -- delete all but one of each type.  Probably there will be
--       two of each type (e.g. two for user x, component y, year 2016, month 5), so we'll just be deleting one.         
-----------------------------------------------------------------------------------------------------------------------------------------------

-- create a temporary table to hold all the component keys we are interested in -
-- those for this engagement score that are not sampled.
DECLARE @nonSampledComponents TABLE (ScoreComponentKey uniqueidentifier PRIMARY KEY);
INSERT INTO @nonSampledComponents
    SELECT [ScoreComponentKey]
      FROM [dbo].[ScoreComponent]
     WHERE [EngagementScoreKey] = @engagementScoreKey
       AND [IsSampled] = 0
       
-- first process rollup records with null year
UPDATE [dbo].[CalculatedEngagementScore]
   SET [Score] = (SELECT SUM([Score]) 
                    FROM [dbo].[CalculatedEngagementScore] existing
                   WHERE existing.[ScoreYear] IS NULL AND existing.[ScoreComponentKey] IS NOT NULL 
                     AND existing.[ScoreComponentKey] = [CalculatedEngagementScore].[ScoreComponentKey]
                     AND existing.[ContactKey] = [CalculatedEngagementScore].[ContactKey]
                     AND existing.[EngagementScoreKey] = @engagementScoreKey)
WHERE [ScoreYear] IS NULL 
   AND [ScoreComponentKey] IS NOT NULL 
   AND [ContactKey] IS NOT NULL  
   AND [ScoreComponentKey] IN (SELECT [ScoreComponentKey] FROM @nonSampledComponents)
         
         
-- next process rollup records with a year but null month
UPDATE [dbo].[CalculatedEngagementScore]
   SET [Score] = (SELECT SUM([Score]) 
                    FROM [dbo].[CalculatedEngagementScore] existing
                   WHERE existing.[ScoreYear] IS NOT NULL AND existing.[ScoreMonth] IS NULL AND existing.[ScoreComponentKey] IS NOT NULL 
                     AND existing.[ScoreComponentKey] = [CalculatedEngagementScore].ScoreComponentKey
                     AND existing.[ContactKey] = [CalculatedEngagementScore].ContactKey
                     AND existing.[EngagementScoreKey] = @engagementScoreKey
                     AND existing.[ScoreYear] = [CalculatedEngagementScore].[ScoreYear])
WHERE [ScoreYear] IS NOT NULL 
   AND [ScoreMonth] IS NULL 
   AND [ScoreComponentKey] IS NOT NULL 
   AND [ContactKey] IS NOT NULL  
   AND [ScoreComponentKey] IN (SELECT ScoreComponentKey FROM @nonSampledComponents)
       
 -- then process rollup records with a month but null week
UPDATE [dbo].[CalculatedEngagementScore]
    SET [Score] = (SELECT SUM([Score]) 
                     FROM [dbo].[CalculatedEngagementScore] existing
                    WHERE existing.[ScoreMonth] IS NOT NULL AND existing.[ScoreWeek] IS NULL AND existing.[ScoreComponentKey] IS NOT NULL 
                      AND existing.[ScoreComponentKey] = [CalculatedEngagementScore].[ScoreComponentKey]
                      AND existing.[ContactKey] = [CalculatedEngagementScore].[ContactKey]
                      AND existing.[EngagementScoreKey] = @engagementScoreKey
                      AND existing.[ScoreYear] = [CalculatedEngagementScore].[ScoreYear]
                      AND existing.[ScoreMonth] = [CalculatedEngagementScore].[ScoreMonth])
WHERE [ScoreMonth] IS NOT NULL 
   AND [ScoreWeek] IS NULL 
   AND [ScoreComponentKey] IS NOT NULL 
   AND [ContactKey] IS NOT NULL 
   AND [ScoreComponentKey] IN (SELECT [ScoreComponentKey] FROM @nonSampledComponents)
       ;  
-- finally, delete the duplicates we have created
WITH cte AS (
    SELECT [ScoreComponentKey], [ContactKey], [Score], [ScoreYear], [ScoreMonth], [ScoreWeek], 
           ROW_NUMBER() OVER(PARTITION BY [ScoreComponentKey], [ContactKey], [Score], [ScoreYear], [ScoreMonth], [ScoreWeek] ORDER BY [CalculatedEngagementScoreKey]) AS [rn]
      FROM [dbo].[CalculatedEngagementScore] WHERE [EngagementScoreKey] = @engagementScoreKey
)
DELETE cte WHERE [rn] > 1
              
-------------------------------------------------------------------------------------------------
--  This is sort of unrelated to the above.  We maintain overall summaries for each contact with
--  no ScoreComponentKey.  Recalculate those by deleting the old ones and inserting a new set.
-------------------------------------------------------------------------------------------------
-- first we delete the existing
DELETE [dbo].[CalculatedEngagementScore] 
 WHERE [ScoreComponentKey] IS NULL
   AND [EngagementScoreKey] = @engagementScoreKey
  
-- then insert the new ones
INSERT INTO [dbo].[CalculatedEngagementScore]
              ([CalculatedEngagementScoreKey], [EngagementScoreKey], [ScoreComponentKey], [ContactKey],[Score], [ScoreYear], [ScoreMonth], [ScoreWeek])
    (SELECT newid(), @engagementScoreKey, NULL AS [ScoreComponentKey], [ContactKey], SUM([Score]),[ScoreYear],[ScoreMonth],[ScoreWeek] 
       FROM [dbo].[CalculatedEngagementScore] ces
      WHERE [ContactKey] IS NOT NULL 
        AND [EngagementScoreKey] = @engagementScoreKey
      GROUP BY ces.[ContactKey],ces.[ScoreYear],ces.[ScoreMonth],ces.[ScoreWeek])
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_CleanupDatabaseAfterLegacyCertificationMigration]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_CleanupDatabaseAfterLegacyCertificationMigration]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


CREATE PROCEDURE [dbo].[asi_CleanupDatabaseAfterLegacyCertificationMigration] 
AS
BEGIN
    -- Delete tables that were used for processing
    
    IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[TempMigration_Cert_Register]') AND type in (N'U'))
    DROP TABLE [dbo].[TempMigration_Cert_Register];

    IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[TempMigration_Certification]') AND type in (N'U'))
    DROP TABLE [dbo].[TempMigration_Certification];

    IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[TempMigration_CertificationLocationOfferings]') AND type in (N'U'))
    DROP TABLE [dbo].[TempMigration_CertificationLocationOfferings];

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ClearOldQueryResults]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ClearOldQueryResults]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

---------------------------------------------------------------------
-- Deletes all the QueryResults older then the @lastTime.  Defaults
-- to the last 2 days if @lastTime is left null
---------------------------------------------------------------------
CREATE PROCEDURE dbo.asi_ClearOldQueryResults
     @lastTime datetime = NULL
AS 
BEGIN
    SET NOCOUNT ON;
    DECLARE @deleteTime datetime;

    SELECT @deleteTime = CASE WHEN @lastTime IS NULL THEN DATEADD(d, -2, dbo.asi_GetAppDatetime()) ELSE @lastTime END;

    WHILE (@@ROWCOUNT > 0)
    BEGIN
         DELETE QueryResultItem 
         FROM (
              SELECT TOP 500 QueryResultItem.QueryResultKey
                FROM QueryResultItem
                     LEFT OUTER JOIN QueryResultMain ON QueryResultItem.QueryResultKey = QueryResultMain.QueryResultKey
               WHERE QueryResultMain.CreatedOn < @deleteTime
              ) q1
         WHERE QueryResultItem.QueryResultKey = q1.QueryResultKey
    END

    SELECT @deleteTime = @deleteTime   --Reset rowcount counter
    WHILE (@@ROWCOUNT > 0)
    BEGIN
         DELETE QueryResultMain 
           FROM (
                SELECT TOP 500 QueryResultMain.QueryResultKey
                  FROM QueryResultMain
                 WHERE QueryResultMain.CreatedOn < @deleteTime
                ) q1
         WHERE QueryResultMain.QueryResultKey = q1.QueryResultKey
    END

    SELECT @deleteTime = @deleteTime; --Reset rowcount counter
    WHILE (@@ROWCOUNT > 0)
    BEGIN
         DELETE QueryResultItem 
           FROM ( SELECT TOP 500 QueryResultItem.QueryResultKey
                    FROM QueryResultItem
                         LEFT OUTER JOIN QueryResultMain ON QueryResultItem.QueryResultKey = QueryResultMain.QueryResultKey
                   WHERE QueryResultMain.QueryResultKey IS NULL
                ) q1
         WHERE QueryResultItem.QueryResultKey = q1.QueryResultKey
    END
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ComponentRegistryByInterface]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ComponentRegistryByInterface]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_ComponentRegistryByInterface    Script Date: 7/3/2003 4:58:02 PM ******/
CREATE   PROC asi_ComponentRegistryByInterface
@name varchar(50)
AS
BEGIN
	select ComponentKey, Description, InterfaceName, TypeName, AssemblyName, ConfigureWebUserControl, ConfigureWindowsControl from ComponentRegistry
where InterfaceName=@name;
	
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ComponentRegistryByKey]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ComponentRegistryByKey]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_ComponentRegistryByKey    Script Date: 7/3/2003 4:58:02 PM ******/
CREATE   PROC asi_ComponentRegistryByKey
@key uniqueidentifier	
AS
BEGIN
	select Name, Description, InterfaceName, TypeName, AssemblyName, ConfigureWebUserControl, ConfigureWindowsControl from ComponentRegistry
where ComponentKey=@key;
	
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ComponentRegistryByName]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ComponentRegistryByName]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_ComponentRegistryByName    Script Date: 7/3/2003 4:58:02 PM ******/
CREATE   PROC asi_ComponentRegistryByName
@name varchar(50)
AS
BEGIN
	select ComponentKey, Description, InterfaceName, TypeName, AssemblyName, ConfigureWebUserControl, ConfigureWindowsControl from ComponentRegistry
where Name=@name;
	
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ComponentRegistryByNameAndInterface]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ComponentRegistryByNameAndInterface]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE   PROC [dbo].[asi_ComponentRegistryByNameAndInterface]
@name varchar(50),
@interface varchar(100)
AS
BEGIN
	select ComponentKey, Description, InterfaceName, TypeName, AssemblyName, ConfigureWebUserControl, ConfigureWindowsControl from ComponentRegistry
where Name=@name and InterfaceName=@interface;
	
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ConfigureTableForMultiInstanceDataSource]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ConfigureTableForMultiInstanceDataSource]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


-- Procedure to generate an INSTEAD OF INSERT trigger on a table that will make it
-- compatible with multi-instance user defined panel editor sources. This trigger
-- will autmatically calculate the approprite "Ordinal", so that inserts work.
CREATE PROCEDURE [dbo].[asi_ConfigureTableForMultiInstanceDataSource]
    @tableName sysname
AS 
BEGIN
    -- If a BO was specified, translate to a view name
    IF NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = @tableName) -- not a valid table or view
       AND EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.VIEWS WHERE TABLE_NAME = N'vBo' + @tableName) -- a vBo view exists
    BEGIN
        SET @tableName = N'vBo' + @tableName; -- Translate BO object name to the underlying vBo view name
    END
    
    -- If a view was specified, try and grab the underlying table
    DECLARE @count int;
    IF @tableName IS NULL OR EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.VIEWS WHERE TABLE_NAME = @tableName)
    BEGIN
        -- Get the count of dependent tables
        SELECT @count = COUNT(1)  
          FROM sys.objects v
               INNER JOIN sys.sql_expression_dependencies d ON v.object_id = d.referencing_id
               INNER JOIN sys.objects t ON d.referenced_id = t.object_id
         WHERE v.type = 'V' AND t.type = 'U' AND v.name = @tableName;
        IF @count <> 1
        BEGIN
            RAISERROR ('Invalid view specified. View must be defined over exactly one table.', 16, 1);
            RETURN;
        END
        -- Get the underlying table name
        SELECT @tableName = t.name  
          FROM sys.objects v
               INNER JOIN sys.sql_expression_dependencies d ON v.object_id = d.referencing_id
               INNER JOIN sys.objects t ON d.referenced_id = t.object_id
         WHERE v.type = 'V' AND t.type = 'U' AND v.name = @tableName;
    END

    -- Validate parameter
    IF @tableName IS NULL OR NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = @tableName AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        RAISERROR ('Invalid table name specified', 16, 1);
        RETURN;
    END
    
    -- Validate table has a primary key
    IF NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS WHERE CONSTRAINT_TYPE = 'PRIMARY KEY' AND TABLE_NAME = @tableName)
    BEGIN
        RAISERROR ('Specified table does not have a primary key', 16, 1);
        RETURN;
    END
    
    -- Get info about the Primary Key columns
    DECLARE @pkcol1Name sysname;
    DECLARE @pkcol1Type sysname;
    DECLARE @pkcol1Length int;
    SELECT @pkcol1Name = c.COLUMN_NAME, @pkcol1Type = c.DATA_TYPE, @pkCol1Length = c.CHARACTER_MAXIMUM_LENGTH 
      FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc
           INNER JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu ON tc.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME
           INNER JOIN INFORMATION_SCHEMA.COLUMNS c ON kcu.TABLE_NAME = c.TABLE_NAME AND kcu.COLUMN_NAME = c.COLUMN_NAME
     WHERE tc.CONSTRAINT_TYPE = 'PRIMARY KEY' AND tc.TABLE_NAME = @tableName AND kcu.ORDINAL_POSITION = 1;

    DECLARE @pkcol2Name sysname;
    DECLARE @pkcol2Type sysname;
    SELECT @pkcol2Name = c.COLUMN_NAME, @pkcol2Type = c.DATA_TYPE 
      FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc
           INNER JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu ON tc.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME
           INNER JOIN INFORMATION_SCHEMA.COLUMNS c ON kcu.TABLE_NAME = c.TABLE_NAME AND kcu.COLUMN_NAME = c.COLUMN_NAME
     WHERE tc.CONSTRAINT_TYPE = 'PRIMARY KEY' AND tc.TABLE_NAME = @tableName AND kcu.ORDINAL_POSITION = 2;
    
    -- Validate the primary key meets specifications 
    IF (@pkcol2Name IS NULL) OR (@pkCol1Type <> 'varchar' AND @pkCol1Type <> 'nvarchar') OR (@pkcol2Type <> 'int') OR (@pkcol1Length < 10)
    BEGIN
        RAISERROR ('Specified table has an invalid primary key... must be a compound key of (varchar(10), int)', 16, 1);
        RETURN;
    END
    
    -- If either of the primary key columns is named "SEQN", then we don't need a trigger because SOA will do the work of populating that column
    IF (@pkcol1Name = 'SEQN' OR @pkcol2Name = 'SEQN')
    BEGIN
        RETURN;
    END
    
    -- Grab the names of all the remaining columns
    DECLARE @nonKeyColumns nvarchar(MAX);
    SELECT @nonKeyColumns = STUFF ( ( SELECT N'], [' + c.name
                FROM sys.columns c
                     INNER JOIN sys.types t ON c.system_type_id = t.system_type_id
               WHERE object_id = (select top 1 object_id FROM sys.objects where name = @tableName) 
                 AND c.name <> @pkcol1Name AND c.name <> @pkcol2Name AND t.[name] <> 'timestamp' 
               ORDER BY c.column_id
                 FOR XML PATH('')), 1, 2, '') + ']';
    
    -- Generate the trigger name
    DECLARE @triggerName sysname;
    SET @triggerName = N'asiUDMBO_' + @tableName + '_Insert';
    
    -- We have all the info we need now to generate the SQL to create the trigger
    DECLARE @triggerBody nvarchar(MAX);
    SET @triggerBody = N'
    SET NOCOUNT ON
    
    -- Create temp table to use in assigning a new ordinal    
    IF OBJECT_ID(''tempdb..#' + @tableName + N'_Insert'') IS NOT NULL DROP TABLE #' + @tableName + N'_Insert
    CREATE TABLE #' + @tableName + N'_Insert ([ContactKey] varchar(10) COLLATE DATABASE_DEFAULT NOT NULL PRIMARY KEY, [SequenceBase] int NOT NULL);
    
    -- Get the sequence base in case additional rows are being added
    INSERT INTO #' + @tableName + N'_Insert([ContactKey], [SequenceBase])
        SELECT i.[' + @pkCol1Name + N'], MAX(COALESCE(t.[' + @pkCol2Name + N'], 0))
          FROM inserted i
               LEFT OUTER JOIN [dbo].[' + @tableName + N'] t ON i.[' + @pkCol1Name + N'] = t.[' + @pkCol1Name + N']
         GROUP BY i.[' + @pkCol1Name + N']

    -- Grab inserted table and assign new sequence ordinals (primary keys MUST be specified by caller)
    INSERT INTO [dbo].[' + @tableName + N'] ([' + @pkCol1Name + N'], [' + @pkCol2Name + N'], ' + @nonKeyColumns + N')
        SELECT i.[' + @pkCol1Name + N'], s.[SequenceBase] + ROW_NUMBER() OVER (PARTITION BY i.[' + @pkCol1Name + N'] ORDER BY i.[' + @pkCol2Name + N']),
               ' + @nonKeyColumns + N'
          FROM inserted i
               INNER JOIN #' + @tableName + N'_Insert s ON i.[' + @pkCol1Name + N'] = s.[ContactKey]
         ORDER BY i.[' + @pkCol2Name + N']
';  

    -- Drop the trigger if it already exists
    DECLARE @dropTriggerSql nvarchar(MAX);
    SET @dropTriggerSql = N'IF  EXISTS (SELECT 1 FROM sys.triggers WHERE object_id = OBJECT_ID(N''[' + @triggerName + N']'')) DROP TRIGGER [dbo].[' + @triggerName + N']';
    --PRINT @dropTriggerSql;
    EXECUTE sp_executesql @dropTriggerSql;

    -- Build the final SQL and execute it
    DECLARE @triggerStatement nvarchar(MAX);
    SET @triggerStatement = N'
    CREATE TRIGGER [dbo].[' + @triggerName + N']
    ON [dbo].[' + @tableName + N']
    INSTEAD OF INSERT
    AS
    BEGIN
    ' + @triggerBody + N'
    END                
    ';
    --PRINT @triggerStatement;   
    EXECUTE sp_executesql @triggerStatement;
END;


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ConfigureTableForSingleInstanceDataSource]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ConfigureTableForSingleInstanceDataSource]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


-- Procedure to validate that a single-instance data source is of the correct format
CREATE PROCEDURE [dbo].[asi_ConfigureTableForSingleInstanceDataSource]
    @tableName sysname
AS 
BEGIN
    -- If a BO was specified, translate to a view name
    IF NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = @tableName) -- not a valid table or view
       AND EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.VIEWS WHERE TABLE_NAME = N'vBo' + @tableName) -- a vBo view exists
    BEGIN
        SET @tableName = N'vBo' + @tableName; -- Translate BO object name to the underlying vBo view name
    END;
    
    -- If a view was specified, try and grab the underlying table
    DECLARE @count int;
    IF @tableName IS NULL OR EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.VIEWS WHERE TABLE_NAME = @tableName)
    BEGIN
        -- Get the count of dependent tables
        SELECT @count = COUNT(1)  
          FROM sys.objects v
               INNER JOIN sys.sql_expression_dependencies d ON v.object_id = d.referencing_id
               INNER JOIN sys.objects t ON d.referenced_id = t.object_id
         WHERE v.type = 'V' AND t.type = 'U' AND v.name = @tableName
        IF @count <> 1
        BEGIN
            RAISERROR ('Invalid view specified. View must be defined over exactly one table.', 16, 1);
            RETURN;
        END
        -- Get the underlying table name
        SELECT @tableName = t.name  
          FROM sys.objects v
               INNER JOIN sys.sql_expression_dependencies d ON v.object_id = d.referencing_id
               INNER JOIN sys.objects t ON d.referenced_id = t.object_id
         WHERE v.type = 'V' AND t.type = 'U' AND v.name = @tableName
    END

    -- Validate parameter
    IF @tableName IS NULL OR NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = @tableName AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        RAISERROR ('Invalid table name specified', 16, 1);
        RETURN;
    END;
    
    -- Validate table has a primary key
    IF NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS WHERE CONSTRAINT_TYPE = 'PRIMARY KEY' AND TABLE_NAME = @tableName)
    BEGIN
        RAISERROR ('Specified table does not have a primary key', 16, 1);
        RETURN;
    END;
    
    -- Get info about the Primary Key columns
    DECLARE @pkcol1Name sysname;
    DECLARE @pkcol1Type sysname;
    DECLARE @pkcol1Length int;
    SELECT @pkcol1Name = c.COLUMN_NAME, @pkcol1Type = c.DATA_TYPE, @pkCol1Length = c.CHARACTER_MAXIMUM_LENGTH 
      FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc
           INNER JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu ON tc.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME
           INNER JOIN INFORMATION_SCHEMA.COLUMNS c ON kcu.TABLE_NAME = c.TABLE_NAME AND kcu.COLUMN_NAME = c.COLUMN_NAME
     WHERE tc.CONSTRAINT_TYPE = 'PRIMARY KEY' AND tc.TABLE_NAME = @tableName AND kcu.ORDINAL_POSITION = 1

    -- Validate the primary key meets specifications 
    IF (@pkCol1Type <> 'varchar' AND @pkCol1Type <> 'nvarchar') OR (@pkcol1Length < 10)
    BEGIN
        RAISERROR ('Specified table has an invalid primary key... must be a single-column key of varchar(10)', 16, 1);
        RETURN;
    END;
    
END;


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ContentAdministratorCheck]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ContentAdministratorCheck]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/*
Checks if the user is in any MasterAdmin CAG appart from the one passed in.  
If not the user will be removed from the Content Administrator role.
*/
CREATE PROC [dbo].[asi_ContentAdministratorCheck]
   @contactKey uniqueidentifier,
   @groupKey uniqueidentifier
AS
BEGIN

	DECLARE @count int
	DECLARE @cagRoleKey uniqueidentifier

	SELECT @count = COUNT(*)
	  FROM [dbo].[GroupMemberDetail] gmd INNER JOIN [dbo].[GroupMember] gm ON gmd.[GroupMemberKey] = gm.[GroupMemberKey]
			INNER JOIN [dbo].[ContentManagerAuthorityGroup] cmag ON gmd.[GroupKey] = cmag.[GroupKey]
	 WHERE cmag.[IsMasterAdmin] = 1
	   AND gm.[MemberContactKey] = @contactKey
	   AND gmd.[GroupKey] <> @groupKey

	IF @count = 0
	BEGIN

		-- Remove the user from the Content Administrator role
		SELECT @cagRoleKey = [RoleKey] FROM [dbo].[RoleMain] WHERE [Name] = 'Content Administrator'

		DELETE FROM [dbo].[UserRole] 
		WHERE [UserKey] = @contactKey
		  AND [RoleKey] = @cagRoleKey

	END


END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ContentListByOwnerContactKey]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ContentListByOwnerContactKey]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

----------------------------------------------------------------------------------------------------------------------------------
-- Retrieves a list of Content Records owned by the specified contact with the specified status. Security IS enforced.
-- 
-- Returns:
-- Everything from the DocumentMain table except the blob. Also includes ContentAuthorityGroupKey and OwnerGroupMemberKey 
-- from ContentWorkflowParameters if Workflow is being used and HierarchyKey from the Hierarchy element representing the document.
----------------------------------------------------------------------------------------------------------------------------------
CREATE PROC [dbo].[asi_ContentListByOwnerContactKey]
    @contentProducerKey uniqueidentifier,
    @userKey uniqueidentifier,
    @loggedInUserGroupKey uniqueidentifier = '00000000-0000-0000-0000-000000000000', -- if this is empty, we assume the user is not logged in
    @documentStatus int,
    @expiringSoon bit = 0,
    @documentTypeCode nvarchar(6)= 'CON'
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @conWarningDays1 int;
    SELECT @conWarningDays1 = CONVERT(int, ParameterValue) FROM SystemConfig WHERE ParameterName = 'CM.ExpirationWarningDays1';
    IF (@conWarningDays1 IS NULL)
    BEGIN
        SELECT @conWarningDays1 = CONVERT(int, ParameterValue) FROM SystemConfig WHERE ParameterName = 'CM.ExpirationWarningDays2';
    END
    IF (@conWarningDays1 IS NULL)
    BEGIN
        SET @conWarningDays1 = 10;
    END
    
    DECLARE @now datetime;
    SELECT @now = dbo.asi_GetAppDatetime();

    SELECT a.[HierarchyKey],
           b.[DocumentKey],
           b.[DocumentVersionKey],
           b.[DocumentStatusCode],
           b.[DocumentName],
           b.[AlternateName],
           b.[DocumentDescription],
           b.[DocumentTypeCode],
           b.[IsSystem],
           b.[ContainsChildrenFlag],
           b.[RelatedDocumentVersionKey],
           b.[AccessKey],
           b.[DefaultChildAccessKey],
           b.[StatusUpdatedOn],
           b.[StatusUpdatedByUserKey],
           b.[CreatedOn],
           b.[CreatedByUserKey],
           b.[UpdatedOn],
           b.[UpdatedByUserKey],
           c.[ContentAuthorityGroupKey],
           c.[OwnerGroupMemberKey]
      FROM [dbo].[Hierarchy] a INNER JOIN [dbo].[DocumentMain] b ON a.[UniformKey] = b.[DocumentVersionKey]
           INNER JOIN [dbo].[ContentWorkflowParameters] c ON b.[DocumentVersionKey] = c.[DocumentVersionKey]
           INNER JOIN [dbo].[GroupMember] d ON c.[ContentAuthorityGroupKey] = d.[GroupKey] 
      WHERE b.[DocumentStatusCode] = @documentStatus 
        AND b.[DocumentTypeCode] = @documentTypeCode
        AND ((CASE WHEN @documentStatus >= 40 THEN 1 ELSE 0 END) = c.[PublishedVersion])
        AND (@expiringSoon = 0 
             OR (DATEADD(DAY, -@conWarningDays1, c.[ExpirationDate]) <= CONVERT(datetime, CONVERT(char, @now, 103), 103)))
        AND d.[MemberContactKey] = @contentProducerKey
        AND EXISTS(SELECT 1 
                     FROM [dbo].[AccessItem] INNER JOIN [dbo].[UserToken] ON [AccessItem].[Grantee] = [UserToken].[Grantee]
                    WHERE [AccessItem].[AccessKey] = b.[AccessKey] 
                      AND [UserToken].[UserKey] = @userKey 
                      AND ([AccessItem].[Permission] & 3) > 0
            )
       AND (NOT EXISTS (SELECT 1 FROM [dbo].[UniformLicense] WHERE UniformKey = b.DocumentVersionKey)
             OR EXISTS (SELECT 1 
                          FROM [dbo].[UniformLicense] INNER JOIN [dbo].[LicenseLegacyList] l ON [UniformLicense].[LicenseKey] = l.[LicenseLegacyKey]
                         WHERE [UniformLicense].[UniformKey] = b.[DocumentVersionKey]
                        )
            )
      UNION
    SELECT a.[HierarchyKey],
           b.[DocumentKey],
           b.[DocumentVersionKey],
           b.[DocumentStatusCode],
           b.[DocumentName],
           b.[AlternateName],
           b.[DocumentDescription],
           b.[DocumentTypeCode],
           b.[IsSystem],
           b.[ContainsChildrenFlag],
           b.[RelatedDocumentVersionKey],
           b.[AccessKey],
           b.[DefaultChildAccessKey],
           b.[StatusUpdatedOn],
           b.[StatusUpdatedByUserKey],
           b.[CreatedOn],
           b.[CreatedByUserKey],
           b.[UpdatedOn],
           b.[UpdatedByUserKey],
           NULL,
           NULL
      FROM [dbo].[Hierarchy] a INNER JOIN [dbo].[DocumentMain] b ON a.[UniformKey] = b.[DocumentVersionKey]
     WHERE @documentStatus <> 40
       AND b.[DocumentVersionKey] NOT IN (SELECT [DocumentVersionKey] FROM [ContentWorkflowParameters])
       AND b.[DocumentStatusCode] = @documentStatus 
       AND b.[DocumentTypeCode] = @documentTypeCode
       AND EXISTS(SELECT 1 
                    FROM [dbo].[AccessItem] INNER JOIN [dbo].[UserToken] ON [AccessItem].[Grantee] = [UserToken].[Grantee]
                   WHERE [AccessItem].[AccessKey] = b.[AccessKey] 
                     AND [UserToken].[UserKey] = @userKey 
                     AND ([AccessItem].[Permission] & 3) > 0
                  )
       AND (NOT EXISTS (SELECT 1 FROM [dbo].[UniformLicense] WHERE UniformKey = b.DocumentVersionKey)
             OR EXISTS (SELECT 1 
                          FROM [dbo].[UniformLicense] INNER JOIN [dbo].[LicenseLegacyList] l ON [UniformLicense].[LicenseKey] = l.[LicenseLegacyKey]
                         WHERE [UniformLicense].[UniformKey] = b.[DocumentVersionKey]
                        )
           )
    ORDER BY [DocumentName]
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ConvertV1DynamicSourceToV2]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ConvertV1DynamicSourceToV2]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_ConvertV1DynamicSourceToV2] 
    @v1DynamicSourceName sysname
AS
BEGIN
    SET NOCOUNT ON;
    -- Validate that specified source name is indeed a valid source
    IF NOT EXISTS (SELECT 1 FROM [dbo].[ObjectMetaData] WHERE [ObjectName] = @v1DynamicSourceName AND ([Version] IS NULL OR [Version] = N'V1'))
    BEGIN
        RAISERROR ('Invalid Source: Specified dynamic source does not exist or is not V1.', 16, 1);
        RETURN;
    END
    DECLARE @viewName sysname;
    DECLARE @isMultiInstance bit;
    SELECT @isMultiInstance = (SELECT IsMultiInstance FROM [dbo].[ObjectMetaData] WHERE [ObjectName] = @v1DynamicSourceName)
    SELECT @viewName = N'vUD' + (SELECT CASE WHEN @isMultiInstance = 1 THEN N'M' ELSE N'' END) + N'BO' + @v1DynamicSourceName;
    -- Validate that associated view exists
    IF NOT EXISTS (SELECT 1 FROM [dbo].[ObjectMetaData] WHERE [ObjectName] = @v1DynamicSourceName AND ([Version] IS NULL OR [Version] = N'V1'))
    BEGIN
        RAISERROR ('Invalid Source: Could not find the associated view for the specified dynamic source.', 16, 1);
        RETURN;
    END
    -- Validate that specified source name hasn't already been converted
    IF EXISTS (SELECT 1 FROM [dbo].[UserDefinedTableStorage] WHERE [TableName] = @v1DynamicSourceName)
    BEGIN
        RAISERROR ('Invalid Source: Specified dynamic source has already been converted to V2 or source of same name exists as a V2 source.', 16, 1);
        RETURN;
    END
    -- Temporarily fail on multi-instance data... shallow development implements single-instance data first
    IF (@isMultiInstance = 1)
    BEGIN
        RAISERROR ('Invalid Source: Only single-instance dynamic sources are supported', 16, 1);
        RETURN;
    END
    
    -- Build the SQL fragments that will copy the data over from v1 schema to v2 schema
    DECLARE @sqlPreamble nvarchar(MAX);
    DECLARE @columnList nvarchar(MAX);
    SET @sqlPreamble = N'INSERT INTO [dbo].[UserDefinedTableStorage] ([TableName], [RowID], [RowKey], [RowSequence],' + NCHAR(10) +
N'            [CreatedOn], [CreateByUserKey], [UpdatedOn], [UpdatedByUserKey], ' + NCHAR(10);
    SET @columnList = N'';
    SELECT @columnList += N', [Value' + CAST(ORDINAL_POSITION - 1 AS nvarchar(4)) + N']'
      FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = @viewName AND ORDINAL_POSITION > 1
     ORDER BY ORDINAL_POSITION;
    SET @columnList = SUBSTRING(@columnList, 3, LEN(@columnList) - 2);
    SET @sqlPreamble += N'            ' + @columnList + N')' + NCHAR(10);
    SET @sqlPreamble += N'SELECT ''' + @v1DynamicSourceName + N''' AS [TableName], [ContactKey] AS [RowID], ''00000000-0000-0000-0000-000000000000'' AS [ContactKey], 0 AS [RowSequence], ' + NCHAR(10) +
N'       dbo.asi_GetAppDatetime() AS [CreatedOn], NULL AS [CreatedByUserKey], dbo.asi_GetAppDatetime() AS [UpdatedOn], NULL AS [UpdatedByUserKey], ' 

    DECLARE @sqlBody nvarchar(MAX);
    SET @sqlBody = N'';
    SELECT @sqlBody = @sqlBody + 
                      CASE WHEN LEN(@sqlBody) = 0 THEN N'' ELSE N',' + NCHAR(13) END + N'           CONVERT(nvarchar(MAX), [' + c.COLUMN_NAME + N']' +
                      CASE WHEN c.DATA_TYPE = N'datetime' THEN N', 126' ELSE N'' END + N') AS [' + c.COLUMN_NAME + N']'
      FROM INFORMATION_SCHEMA.COLUMNS c
     WHERE TABLE_NAME = @viewName AND ORDINAL_POSITION > 1
     ORDER BY ORDINAL_POSITION

    DECLARE @sqlPostscript nvarchar(MAX);
    SELECT @sqlPostscript = N'      FROM dbo.' + QUOTENAME(@viewName)
    
    DECLARE @sql nvarchar(MAX);
    SET @sql = @sqlPreamble + NCHAR(13) + @sqlBody + NCHAR(13) + @sqlPostscript;
    --PRINT @sql
    EXEC (@sql);
    
    -- Note that the BOD transition must be done in C# code, as well as cleaning up the old data, and updating ObjectMetaData
    
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ConvertV2DynamicSourceToV1]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ConvertV2DynamicSourceToV1]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_ConvertV2DynamicSourceToV1] 
    @v2DynamicSourceName sysname
AS
BEGIN
    SET NOCOUNT ON;
    -- Validate that specified source name is indeed a valid source
    IF NOT EXISTS (SELECT 1 FROM [dbo].[ObjectMetaData] WHERE [ObjectName] = @v2DynamicSourceName AND [Version] = N'V2')
    BEGIN
        RAISERROR ('Invalid Source: Specified dynamic source does not exist or is not V2.', 16, 1);
        RETURN;
    END
    DECLARE @viewName sysname;
    DECLARE @isMultiInstance bit;
    SELECT @isMultiInstance = (SELECT IsMultiInstance FROM [dbo].[ObjectMetaData] WHERE [ObjectName] = @v2DynamicSourceName)
    SELECT @viewName = N'vUD' + (SELECT CASE WHEN @isMultiInstance = 1 THEN N'M' ELSE N'' END) + N'BO' + @v2DynamicSourceName;
    -- Validate that associated view exists
    IF NOT EXISTS (SELECT 1 FROM [dbo].[ObjectMetaData] WHERE [ObjectName] = @v2DynamicSourceName AND [Version] = N'V2')
    BEGIN
        RAISERROR ('Invalid Source: Could not find the associated view for the specified dynamic source.', 16, 1);
        RETURN;
    END
    IF (@isMultiInstance = 0)
    BEGIN
        -- Validate that specified source name hasn't already been converted
        IF EXISTS (SELECT 1 FROM [dbo].[UserDefinedSingleInstanceProperty] WHERE [TableName] = @v2DynamicSourceName)
        BEGIN
            RAISERROR ('Invalid Source: Specified dynamic source has already been converted to V2 or source of same name exists as a V1 source.', 16, 1);
            RETURN;
        END
    END
    ELSE
    BEGIN
        -- Validate that specified source name hasn't already been converted
        IF EXISTS (SELECT 1 FROM [dbo].[UserDefinedMultiInstanceProperty] WHERE [TableName] = @v2DynamicSourceName)
        BEGIN
            RAISERROR ('Invalid Source: Specified dynamic source has already been converted to V2 or source of same name exists as a V1 source.', 16, 1);
            RETURN;
        END
    END
    
    -- Temporarily fail on multi-instance data... shallow development implements single-instance data first
    IF (@isMultiInstance = 1)
    BEGIN
        RAISERROR ('Invalid Source: Only single-instance dynamic sources are supported', 16, 1);
        RETURN;
    END
    
    -- Build the SQL fragments that will copy the data over from v1 schema to v2 schema
    DECLARE @ordinal int;
    DECLARE @columnName sysname;
    DECLARE @dataType sysname;
    DECLARE @dataLen int;
    DECLARE @dataPrecision int;
    DECLARE @dataScale int;
    DECLARE @sql nvarchar(MAX);
    SET @ordinal = 2;
    WHILE EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = N'vUDBOCultivatingFor' AND ORDINAL_POSITION = @ordinal)
    BEGIN
        SET @sql = N'';
        SELECT @columnName = COLUMN_NAME, @dataType = DATA_TYPE, @dataLen = CHARACTER_MAXIMUM_LENGTH, @dataPrecision = NUMERIC_PRECISION, @dataScale = NUMERIC_SCALE
          FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = N'vUDBOCultivatingFor' AND ORDINAL_POSITION = @ordinal;
        SELECT @sql = 'INSERT INTO dbo.UserDefinedSingleInstanceProperty ([TableName], [PropertyName], [RowID], [RowKey], ' + 
               CASE WHEN @dataType = N'nvarchar' THEN N'[PropertyStringValue]'
                    WHEN @dataType = N'datetime' THEN N'[PropertyDatetimeValue]'
                    WHEN @dataType = N'decimal' THEN N'[PropertyDecimalValue]'
                    WHEN @dataType = N'int' THEN N'[PropertyIntValue]'
                    WHEN @dataType = N'bit' THEN N'[PropertyBoolValue]'
                END + N')' + NCHAR(10) + N'    SELECT [TableName], ''' + @columnName + ''', [RowID], ''00000000-0000-0000-0000-000000000000'', ' +
                N'CAST(Value' + CAST(@ordinal - 1 AS nvarchar(4)) + N' AS ' + @dataType +
               CASE WHEN @dataType = N'nvarchar' THEN N'(' + CAST(@dataLen AS nvarchar(6)) + N')'
                    WHEN @dataType = N'decimal' THEN N'(' + CAST(@dataPrecision AS nvarchar(3)) + N',' + CAST(@dataScale AS nvarchar(3)) + N')'
                    ELSE N''
                END + N')' + NCHAR(10) + N'      FROM [dbo].[UserDefinedTableStorage] WHERE [TableName] = ''CultivatingFor''';
         --PRINT @sql
         EXEC (@sql);
         SET @ordinal += 1;
    END

    -- Note that the BOD transition must be done in C# code, as well as cleaning up the old data, and updating ObjectMetaData
    
END



GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_CreateGLExportDeferredIncomeItems]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_CreateGLExportDeferredIncomeItems]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_CreateGLExportDeferredIncomeItems]
    @glExportKey uniqueidentifier,
    @deferredAccount varchar(50),
    @beginningPeriod datetime,
    @term int,
    @incomeAccount varchar(50),
    @financialEntityId varchar(5),
    @originalAmount money,
    @amountTransferred money
AS 
BEGIN
    INSERT INTO [dbo].[GLExportDeferredIncomeItem] (GLExportKey, DeferredAccount, BeginningPeriod, Term, IncomeAccount, OrgCode, OriginalAmount, AmountTransferred)
    VALUES (@glExportKey, @deferredAccount, @beginningPeriod, @term, @incomeAccount, @financialEntityId, @originalAmount, @amountTransferred);
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_CreateGLExportItems]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_CreateGLExportItems]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_CreateGLExportItems]
    @glExportKey uniqueidentifier
AS 
BEGIN
    DECLARE @beginDate datetime;
    DECLARE @endDate datetime;
    DECLARE @now datetime;
    
    SELECT @now = dbo.asi_GetAppDatetime();

    --Get the filter variables from the GLExport record
    SELECT @beginDate = [BeginDate], @endDate = [EndDate] 
      FROM [dbo].[GLExport]
     WHERE [GLExportKey] = @glExportKey
          
    --Delete existing GLExportItems incase this is an update
    DELETE FROM [dbo].[GLExportItem] WHERE [GLExportKey] = @glExportKey

    BEGIN TRANSACTION

    UPDATE [dbo].[Trans]
       SET [POSTED] = 3
     WHERE [POSTED] = 2 
       AND DATEDIFF(DAY, [TRANSACTION_DATE], @endDate) >= 0 
       AND DATEDIFF(DAY, [TRANSACTION_DATE], @beginDate) <= 0 
       AND TRANS_NUMBER NOT IN (SELECT [TransactionId] FROM [dbo].[GLExportItem])   
        
    INSERT INTO GLExportItem (GLExportKey, TransactionId)
        SELECT DISTINCT @glExportKey AS [GLExportKey], [TRANS_NUMBER]
          FROM [dbo].[Trans]  
         WHERE [POSTED] = 3 
           AND DATEDIFF(DAY, [TRANSACTION_DATE], @endDate) >= 0 
           AND DATEDIFF(DAY, [TRANSACTION_DATE], @beginDate) <= 0 
           AND TRANS_NUMBER NOT IN (SELECT [TransactionId] FROM [dbo].[GLExportItem]) ORDER BY [TRANS_NUMBER]

    UPDATE [dbo].[Trans]
       SET [POSTED] = 4,
           [GL_EXPORT_DATE] = @now
     WHERE [POSTED] = 3 
       AND DATEDIFF(DAY, [TRANSACTION_DATE], @endDate) >= 0 
       AND DATEDIFF(DAY, [TRANSACTION_DATE], @beginDate) <= 0 
       AND TRANS_NUMBER IN (SELECT [TransactionId] FROM [dbo].[GLExportItem])   

    COMMIT TRANSACTION
END
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_CreateGLTransLine]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_CreateGLTransLine]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE  PROCEDURE [dbo].[asi_CreateGLTransLine]
@acctKey uniqueidentifier, 
@amount decimal(18,4), 
@invoiceKey uniqueidentifier, 
@paymentKey uniqueidentifier, 
@invoiceLineKey uniqueidentifier,
@description varchar(50), 
@prodKey uniqueidentifier,
@finEntityKey uniqueidentifier,
@transDate datetime,
@deferralTermsKey uniqueidentifier,
@deferredIncAcctKey uniqueidentifier,
@glEntryType nvarchar(50),
@journalType int


AS 
BEGIN
	INSERT #tmpTransLine(AccountKey, Amount, InvoiceKey, PaymentKey, Description, ProductKey, FinEntityKey, 
	TransDate, DeferralTermsKey, DeferredIncomeGLAccountKey, InvoiceLineKey, GLEntryType, JournalEntryTypeCode) 
	VALUES (@acctKey, @amount, @invoiceKey, @paymentKey, @description , @prodKey, @finEntityKey, 
	@transDate, @deferralTermsKey, @deferredIncAcctKey, @invoiceLineKey, @glEntryType, @journalType)
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GenerateSalutations]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GenerateSalutations]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROC [dbo].[asi_GenerateSalutations] (
	@contactKey uniqueidentifier
)
AS
BEGIN

-- This stored procedure inserts all the required ContactSalutation records for a given
-- contact.  This is useful for triggers that insert contacts and need to insert the
-- required contact salutations as well.

SET NOCOUNT ON

DECLARE @salutationKey uniqueidentifier
DECLARE @tempKey uniqueidentifier
DECLARE @sql nvarchar(2000)
DECLARE @individualFormula nvarchar(2000)
DECLARE @instituteFormula nvarchar(2000)
DECLARE @calcFormula nvarchar(2000) 
DECLARE @tempValue nvarchar(1000)
DECLARE @isInstitute bit
DECLARE @isOverridden bit

SELECT @isInstitute = IsInstitute FROM ContactMain where ContactKey = @contactKey
IF @@ROWCOUNT = 0
    RETURN

SELECT @individualFormula = IndividualFormula, @instituteFormula = InstituteFormula
	FROM SalutationRef
	WHERE SalutationRef.SalutationKey=@salutationKey AND AutoCreateFlag = 1
IF @@ROWCOUNT = 0
    RETURN

DECLARE theSalutationCursor CURSOR FAST_FORWARD FOR 
	SELECT SalutationKey, IndividualFormula, InstituteFormula
		FROM SalutationRef
		WHERE AutoCreateFlag = 1

OPEN theSalutationCursor
FETCH NEXT FROM theSalutationCursor INTO @salutationKey, @individualFormula, @instituteFormula

WHILE @@FETCH_STATUS = 0 -- spin through auto-create salutations
BEGIN

	SET @tempKey = newid()

	SELECT @sql =  
		CASE 
		WHEN @isInstitute = 1 THEN
			' asi_ProcessFormulaOutput ' 
				+ '''' + convert (nvarchar(100), @tempKey) + ''', '
				+ '''' + @instituteFormula + ''', '
				+ '''Institute'', ''ContactKey'', ' 
				+ '''' + convert (nvarchar(50), @contactKey) 
				+ ''''

		WHEN @isInstitute = 0 THEN
			' asi_ProcessFormulaOutput ' 
				+ '''' + convert (nvarchar(100), @tempKey) + ''', '
				+ '''' + @individualFormula + ''', '
				+ '''Individual'', ''ContactKey'', ' 
				+ '''' + convert (nvarchar(50), @contactKey) 
				+ ''''
		END
	FROM ContactMain WHERE ContactKey = @contactKey

	EXEC (@sql)

	SELECT @tempValue = tempValue 
		FROM tempFormula
		WHERE tempKey = @tempKey

	IF @tempValue IS NOT NULL AND datalength (@tempValue) > 0 
	BEGIN
		SELECT @isOverridden = IsOverridden FROM ContactSalutation
			WHERE ContactKey = @contactKey AND SalutationKey = @salutationKey
		IF @isOverridden IS NULL
		BEGIN
			INSERT ContactSalutation
				(ContactSalutationKey, IsOverridden, SalutationText, ContactKey, SalutationKey, IsDeletable)
			VALUES (@tempKey, 0, @tempValue, @contactKey, @salutationKey, 1)
		END
		ELSE
		BEGIN
			IF @isOverridden = 0
			BEGIN
				UPDATE ContactSalutation set IsDeletable = 1, SalutationText = @tempValue
				WHERE ContactKey = @contactKey AND SalutationKey = @salutationKey
			END
		END
	END

	DELETE FROM tempFormula WHERE tempKey = @tempKey

FETCH NEXT FROM theSalutationCursor INTO @salutationKey, @individualFormula, @instituteFormula
END  -- spin through Salutation entries

CLOSE theSalutationCursor
DEALLOCATE theSalutationCursor

SET NOCOUNT OFF

END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_CreateIndividual]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_CreateIndividual]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_CreateIndividual]
    @contactKey uniqueidentifier,
    @id nvarchar(20),
    @fullName nvarchar(110),
    @lastFirst nvarchar(110),
    @prefix nvarchar(25),
    @firstName nvarchar(20),
    @middleName nvarchar(20),
    @lastName nvarchar(30),
    @suffix nvarchar(10),
    @designation nvarchar(20),
    @informal nvarchar(20),
    @gender nvarchar(1),
    @noSolicitationFlag bit,
    @statusCode nvarchar(5),
    @birthdate datetime,
    @companyContactKey uniqueidentifier,
    @companyName nvarchar(80),
    @companyTitle nvarchar(80),
    @createdByUserKey uniqueidentifier
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @now datetime
    DECLARE @entityKey uniqueidentifier
    DECLARE @defaultOrganizationKey uniqueidentifier
    DECLARE @accessKey uniqueidentifier
    DECLARE @individualTypeKey uniqueidentifier
    DECLARE @registryKey uniqueidentifier

    SET @now = dbo.asi_GetAppDatetime();
    SELECT @entityKey = SystemEntityKey FROM SystemEntity WHERE SystemKeyword = 'Organization'
    SELECT @defaultOrganizationKey = OrganizationKey FROM OrganizationMain WHERE IsDefault = 1
    SELECT @accessKey = ParameterValue FROM SystemConfig WHERE ParameterName = 'Security.Token.EveryoneFullControlAccessKey'
              and SystemEntityKey = @entityKey and OrganizationKey = @defaultOrganizationKey
    SELECT @individualTypeKey = ContactTypeKey from ContactTypeRef where IsInstitute = 0

    -- Create UniformRegistry entry for individual
    SELECT @registryKey = ComponentKey FROM ComponentRegistry 
          WHERE Name = 'Individual' and InterfaceName = 'BusinessController'
    INSERT UniformRegistry (UniformKey, ComponentKey)
    VALUES (@contactKey, @registryKey)

    -- Create new contact
    INSERT INTO [ContactMain]
               ([ContactKey], [ContactStatusCode], [FullName], [SortName], [IsInstitute], [NoSolicitationFlag], 
                [SyncContactID], [ID], [IsIDEditable], [CreatedByUserKey], [CreatedOn], [UpdatedByUserKey], [UpdatedOn], [PreferredAddressCategoryCode], 
                [IsSortNameOverridden], [AccessKey], [TextOnlyEmailFlag], [ContactTypeKey], [OptOutFlag])
      VALUES (@contactKey, @statusCode, @fullName, @lastFirst, 0, @noSolicitationFlag, @id, @id, 0,
              @createdByUserKey, @now, @createdByUserKey, @now, '1', 0, @accessKey, 0, @individualTypeKey, 0)

     -- Create prefix and suffix if necessary
    IF @prefix = '' SET @prefix = NULL
    IF @prefix IS NOT NULL AND @prefix NOT IN (SELECT PrefixCode FROM PrefixRef)
        INSERT INTO [PrefixRef] (PrefixCode, PrefixDesc, SyncPrefixCode, PrefixKey)
        VALUES (@prefix, @prefix, @prefix, NEWID())
    IF @suffix = '' SET @suffix = NULL
    IF @suffix IS NOT NULL AND @suffix NOT IN (SELECT SuffixCode FROM SuffixRef)
        INSERT INTO [SuffixRef] (SuffixCode, SuffixDesc, SyncSuffixCode, SuffixKey)
        VALUES (@suffix, @suffix, @suffix, NEWID())

    -- Create new Individual
    INSERT INTO [Individual] 
                (ContactKey, PrefixCode, FirstName, MiddleName, LastName, SuffixCode, Designation, Informal, 
                 Gender, BirthDate, PrimaryInstituteContactKey, PrimaryInstituteName, PrimaryInstituteTitle)
    VALUES      (@contactKey, @prefix, @firstName, @middleName, @lastName, @suffix, @designation, @informal,
                 @gender, @birthdate, @companyContactKey, @companyName, @companyTitle)
    
     -- Generate default contact salutations for this new contact
     EXEC asi_GenerateSalutations @contactKey

     -- Generate empty FullAddress records and AddressToUse for this new contact
     -- TODO:  EXEC asi_GenerateFullAddresses
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_CreateInstitute]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_CreateInstitute]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_CreateInstitute]
    @contactKey uniqueidentifier,
    @id nvarchar(20),
    @instituteName nvarchar(80),
    @companysort nvarchar(110),
    @statusCode nvarchar(5),
    @noSolicitationFlag bit,
    @instituteTypeKey uniqueidentifier,
    @createdByUserKey uniqueidentifier
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @accessKey uniqueidentifier;
    DECLARE @groupKey uniqueidentifier;
    DECLARE @groupTypeKey uniqueidentifier;
    DECLARE @systemEntityKey uniqueidentifier;
    DECLARE @registryKey uniqueidentifier;
    DECLARE @now datetime;
    DECLARE @isInvitationOnly bit;
    DECLARE @isSimpleGroup bit;
    DECLARE @inheritRolesFlag bit;
    DECLARE @isSingleRole bit;
    DECLARE @instituteTypeName nvarchar(50);

    DECLARE @adminRoleKey uniqueidentifier;
    DECLARE @everyoneRoleKey uniqueidentifier;
    DECLARE @fullControlAccessKey uniqueidentifier;

    SELECT @adminRoleKey = ParameterValue FROM SystemConfig WHERE ParameterName = 'Security.Token.AdministratorsRoleKey';
    SELECT @everyoneRoleKey = ParameterValue FROM SystemConfig WHERE ParameterName = 'Security.Token.EveryoneRoleKey';
    SELECT @fullControlAccessKey = ParameterValue FROM SystemConfig WHERE ParameterName = 'Security.Token.EveryoneFullControlAccessKey';

    SELECT @instituteTypeName = ContactTypeDesc FROM ContactTypeRef WHERE ContactTypeKey = @instituteTypeKey;

    SELECT @now = dbo.asi_GetAppDatetime();
    SELECT @accessKey = [ProtectedAccessKey] FROM [dbo].[AccessArea] WHERE [Name] = 'Everyone Read';
    SELECT @groupKey = NEWID();

    -- Create UniformRegistry entry for institute group
    SELECT @registryKey = ComponentKey 
      FROM ComponentRegistry 
     WHERE Name = 'Group' and InterfaceName = 'BusinessController'; 
     
    INSERT UniformRegistry (UniformKey, ComponentKey)
    VALUES (@groupKey, @registryKey)

    -- Create a new group for the institute
    SELECT @groupTypeKey = [GroupTypeRef].GroupTypeKey,
           @isInvitationOnly = IsInvitationOnly,
           @isSimpleGroup = IsSimpleGroup,
           @inheritRolesFlag = InheritRolesFlag,
           @isSingleRole = IsSingleRole
    FROM [GroupTypeRef]
    INNER JOIN [ContactTypeRef]
    ON [GroupTypeRef].[GroupTypeKey] = [ContactTypeRef].[GroupTypeKey]
    AND [ContactTypeRef].[ContactTypeKey] = @instituteTypeKey

    SELECT @systemEntityKey = SystemEntityKey FROM [SystemEntity] 
        WHERE [IsDefault] = 1 AND [SystemKeyword] = 'Organization'    

    INSERT INTO [GroupMain] (GroupKey, [Name], Description, 
                             CreatedByUserKey, CreatedOn, UpdatedByUserKey, UpdatedOn, 
                             IsSystem, IsAutoGenerated, GroupTypeKey, AccessKey, SystemEntityKey, IsInvitationOnly,
                             GroupStatusCode, IsSimpleGroup, InheritRolesFlag, IsSingleRole, OwnerAccessKey)
    VALUES (@groupKey, @instituteName, 'Group for ' + @instituteName + ' ' + @instituteTypeName, 
            @createdByUserKey, @now, @createdByUserKey, @now, 
            0, 1, @groupTypeKey, @accessKey, @systemEntityKey, @isInvitationOnly, 'A', @isSimpleGroup,
            @inheritRolesFlag, @isSingleRole, NULL)

    -- Create UniformRegistry entry for institute itself
    SELECT @registryKey = ComponentKey FROM ComponentRegistry 
          WHERE Name = 'Institute' and InterfaceName = 'BusinessController'
    INSERT UniformRegistry (UniformKey, ComponentKey)
    VALUES (@contactKey, @registryKey)

    -- Create Contact entry
    INSERT INTO [ContactMain]
           ([ContactKey], [ContactStatusCode], [FullName], [SortName], [IsInstitute], [NoSolicitationFlag], 
            [SyncContactID], [ID], [IsIDEditable], [CreatedByUserKey], [CreatedOn], [UpdatedByUserKey], [UpdatedOn],
             [PreferredAddressCategoryCode], [IsSortNameOverridden], [AccessKey], [TextOnlyEmailFlag], [ContactTypeKey], [OptOutFlag])
    VALUES (@contactKey, @statusCode, @instituteName, @companysort, 1, @noSolicitationFlag, 
            @id, 'C' + @id, 0, @createdByUserKey, @now, @createdByUserKey, @now, '1', 
            0, @fullControlAccessKey, 0, @instituteTypeKey, 0)

    -- Create the new Institute record
    INSERT INTO [Institute] (ContactKey, InstituteName, InstituteGroupKey)
    VALUES (@contactKey, @instituteName, @groupKey)

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_CreateInstituteGroupMember]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_CreateInstituteGroupMember]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_CreateInstituteGroupMember]
    @contactKey uniqueidentifier,
     @companyGroupKey uniqueidentifier,
     @createdByUserKey uniqueidentifier,
     @primaryContact bit
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @groupMemberKey uniqueidentifier;
    DECLARE @groupRoleKey uniqueidentifier;
    DECLARE @defaultMemberStatusCode nvarchar(4);
    DECLARE @now datetime;

    SELECT @groupMemberKey = NEWID();
    SELECT @now = dbo.asi_GetAppDatetime();

    -- Get the default role and member status
    IF @primaryContact = 1
    BEGIN
         SELECT @groupRoleKey = GR.GroupRoleKey, @defaultMemberStatusCode = GTR.DefaultMemberStatusCode
         FROM GroupTypeRole GTR INNER JOIN GroupRoleRef GR ON GTR.GroupRoleKey = GR.GroupRoleKey
         WHERE GR.GroupRoleDesc = 'Primary Contact' AND GTR.IsSystem = 1
    END
    ELSE
    BEGIN
         SELECT @groupRoleKey = GTR.GroupRoleKey, @defaultMemberStatusCode = GTR.DefaultMemberStatusCode
         FROM GroupTypeRole GTR INNER JOIN GroupMain GM ON GM.GroupTypeKey = GTR.GroupTypeKey
         WHERE GM.GroupKey = @companyGroupKey AND GTR.IsDefault = 1
    END

    -- Create GroupMember record
    INSERT INTO [GroupMember] (GroupMemberKey, GroupKey, MemberContactKey, IsActive, CreatedByUserKey, CreatedOn, 
                               UpdatedByUserKey, UpdatedOn)
    VALUES (@groupMemberKey, @companyGroupKey, @contactKey, 1, @createdByUserKey, @now, @createdByUserKey, @now)

    -- Create GroupMemberDetail record
    INSERT INTO [GroupMemberDetail] (GroupMemberDetailKey, GroupMemberKey, GroupKey, GroupRoleKey, EffectiveDate, 
                                     CreatedByUserKey, CreatedOn, UpdatedByUserKey, UpdatedOn, GroupMemberStatusCode, IsActive)
    VALUES (NEWID(), @groupMemberKey, @companyGroupKey, @groupRoleKey, @now, @createdByUserKey, @now, @createdByUserKey, @now,
            @defaultMemberStatusCode, 1)

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_CreateOrRenamePK]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_CreateOrRenamePK]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_CreateOrRenamePK] @tablename sysname, @columns nvarchar(512) AS
BEGIN
	SET NOCOUNT ON;
	DECLARE @keyName sysname;

	-- get the name of the table's Primary Key
    SELECT @keyName = [name]
      FROM sys.objects
     WHERE [parent_object_id] = OBJECT_ID(@tablename)
       AND [type] = 'PK';

	-- if the key exists, but it not named according to our conventions, rename it
	IF @keyName IS NOT NULL AND @keyName <> (N'PK_' + @tablename)
		EXEC (N'sp_rename ''' + @keyName + N''', ''PK_' + @tablename + N''',''OBJECT''');

	-- if the key does not exist
	IF @keyName IS NULL
	BEGIN
		DECLARE @clustered nvarchar(12);
		SET @clustered = N'CLUSTERED';

		-- if a clustered index already exists, make this one non-clustered
		IF EXISTS (SELECT 1 FROM sys.indexes WHERE [object_id] = OBJECT_ID(@tablename) AND [type_desc] = N'CLUSTERED')
			SET @clustered = N'NONCLUSTERED';

		-- add the key
		EXEC (N'ALTER TABLE ' + @tablename + N' ADD CONSTRAINT PK_' + @tablename + N' PRIMARY KEY ' + @clustered + N' (' + @columns + N')');
	END
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_CreatePaymentSchedules]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_CreatePaymentSchedules]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE                            PROCEDURE [dbo].[asi_CreatePaymentSchedules]
AS
DECLARE @invKey uniqueidentifier
DECLARE @invLineKey uniqueidentifier
DECLARE @prevInvKey uniqueidentifier
DECLARE @prevInvLineKey uniqueidentifier
DECLARE @paymentTermsKey uniqueidentifier
DECLARE @prevPaymentTermsKey uniqueidentifier
DECLARE @ARAcctKey uniqueidentifier
DECLARE @scheduleLineKey uniqueidentifier
DECLARE @invDate datetime
DECLARE @prevInvDate datetime
DECLARE @termsCode nvarchar(50)
DECLARE @earlyDiscountDays int
DECLARE @earlyDiscountPercent decimal(18,4)
DECLARE @intSize int
DECLARE @prevIntSize int
DECLARE @intType int
DECLARE @prevIntType int
DECLARE @intCount int
DECLARE @prevIntCount int
DECLARE @payments int
DECLARE @fetchStatus int
DECLARE @firstIteration int
DECLARE @acctMethod nchar(1)
DECLARE @prevAcctMethod nchar(1)
DECLARE @extendedPrice decimal(18,4)
DECLARE @currentTotal decimal(18,4)
DECLARE @invoiceTotal decimal(18,4)
DECLARE @currentPayment int
DECLARE @tempARKey uniqueidentifier
DECLARE @acctTotal decimal(18,4)
DECLARE @acctAmount decimal(18,4)
DECLARE @share decimal(18,4)
DECLARE @paidToCurrentGL decimal(18,4)
DECLARE @priority int
DECLARE @paymentDate datetime
DECLARE @firstPaymentDate datetime
DECLARE @scheduledSoFarForInvoice decimal(18,4)
DECLARE @dueAmount decimal(18,4)
DECLARE @scheduledSoFarForInstallment decimal(18,4)
DECLARE @firstPaymentDateTypeCode int
DECLARE @prevFirstPaymentDateTypeCode int
DECLARE @firstPaymentDateOffset int
DECLARE @prevFirstPaymentDateOffset int
DECLARE @firstPaymentDueDate datetime
DECLARE @prevFirstPaymentDueDate datetime
DECLARE @payPriority int
declare @endOfNextMonth datetime

/* enums */
DECLARE @termsTypeYearly int
DECLARE @termsTypeQuarterly int
DECLARE @termsTypeMonthly int
DECLARE @termsTypeWeekly int
DECLARE @termsTypeDaily int
SET @termsTypeYearly = 0
SET @termsTypeQuarterly = 1
SET @termsTypeMonthly = 2
SET @termsTypeWeekly = 3
SET @termsTypeDaily = 4

DECLARE @firstPaymentDateTypeInvoiceDate int
DECLARE @firstPaymentDateTypeNextMonth int
DECLARE @firstPaymentDateTypeEndOfMonth int
DECLARE @firstPaymentDateTypeSpecificDate int
SET @firstPaymentDateTypeInvoiceDate = 0
SET @firstPaymentDateTypeNextMonth = 1
SET @firstPaymentDateTypeEndOfMonth = 2
SET @firstPaymentDateTypeSpecificDate = 3

/*  This stored procedure creates a payment schedule structure
    for each invoice in the #tmpInvoice table created by the caller.
    - Create a cursor on a left join of the tmpInvoice table and the 
      payment terms table.  The result has one line for every invoice 
      line being processed, ordered by the invoice key.  
    - Read through these lines, accumulating information
      about the current invoice until all  lines for that 
      invoice have been processed.  
    - For each payment required 
      (based on the payment terms) create a PaymentScheduleLine row.  
      There may be multiple PaymentScheduleLine rows based on the applicable GLAccounts.
    TBD: This procedure assumes that we round everything to two decimal places.
         Perhaps the real number ought to passed in as a parameter.
*/
-- invoiceTotal will hold the total amount for the current invoice
SET @invoiceTotal = 0
-- firstIteration is set to 1 initially; during the first iteration of the
-- enclosing cursor loop, it is set to 0
SET @firstIteration = 1

-- The Totals table variable accumulates information about each invoice in turn.
-- The key for this table designates the GLAccount being used by the distribution 
-- lines attached to this invoice.
DECLARE @Totals TABLE
	(GLAccountKey uniqueidentifier PRIMARY KEY, 
 	 Total decimal(18,4), 
	 Share decimal(18,4), 
	 Paid decimal(18,4),
	 Priority int)

-- Create a cursor on the temp table of all invoice distributions joined with the payment terms
DECLARE Get_Invoices CURSOR FOR 
SELECT InvoiceKey, InvoiceLineKey, AccountingMethodCode, PaymentTermsKey = CASE WHEN #tmpInvoice.PaymentTermsKey = '00000000-0000-0000-0000-000000000000' THEN null ELSE #tmpInvoice.PaymentTermsKey END, 
InvoiceDate, ExtendedPrice, PaymentTermsName, EarlyDiscountDays, EarlyDiscountPercent, PaymentIntervalSize, PaymentIntervalTypeCode, PaymentIntervalCount,
ARGLAccountKey, FirstPaymentDueDate, FirstPaymentDateTypeCode, FirstPaymentDateOffset, PayPriority
FROM #tmpInvoice
LEFT OUTER JOIN PaymentTerms ON #tmpInvoice.PaymentTermsKey = PaymentTerms.PaymentTermsKey
WHERE #tmpInvoice.InvoiceTypeCode = 'S'
AND ApplyingCredit = 0
AND ARGLAccountKey is not null
ORDER BY InvoiceKey, InvoiceLineKey
SET @prevInvKey = NEWID()
OPEN Get_Invoices
FETCH next from Get_Invoices into
	@invKey, @invLineKey, @acctMethod, @paymentTermsKey, @invDate, @extendedPrice, @termsCode, @earlyDiscountDays, @earlyDiscountPercent, @intSize, @intType, @intCount,
	@ARAcctKey, @firstPaymentDueDate, @firstPaymentDateTypeCode, @firstPaymentDateOffset, @payPriority
WHILE 1 = 1
BEGIN
	SET @fetchStatus = @@FETCH_STATUS
	IF @fetchStatus = -1 AND @firstIteration = 1
		BREAK
	/* we only want to use the date part; lose the time... */
	SET @invDate = convert(char(10), @invDate, 101)
	/*  We are finished with the most recent invoice IF:
		- we are finished reading all the invoice lines
		OR
		  - the current invoice key is different from the previous one
		  AND
		  - the firstIteration flag is not one.
	    If we are finished with an invoice, we need to use the associated
	    payment terms (if any) to create PaymentScheduleLines.
	 */
	IF ((@fetchStatus = -1)) OR ((@prevInvKey != @invKey) AND @firstIteration != 1)
	BEGIN
		
		/* Compute the shares of each of the accounts in this invoice */
		DECLARE FigureShares cursor for
		SELECT GLAccountKey, Total
		FROM @Totals
		OPEN FigureShares
		FETCH next from FigureShares into
			@tempARKey, @acctTotal
		WHILE @@FETCH_STATUS = 0
		BEGIN
			SET @share = ROUND(@acctTotal / @invoiceTotal, 2)
			UPDATE @Totals SET Share = @share WHERE GLAccountKey = @tempARKey
			FETCH next from FigureShares into
				@tempARKey, @acctTotal
		END
		CLOSE FigureShares
		DEALLOCATE FigureShares
		
		
		/* Next, write the schedule lines */
		/* If there are payment terms for this invoice, use the information in
		   the payment terms object to set the number of payments.  Otherwise, 
		   set it to one.
		*/
		IF @prevPaymentTermsKey IS NULL
			SET @payments = 1
		ELSE
			SET @payments = @prevIntCount
		IF @payments = 0
			SET @payments = 1
		SET @currentPayment = 0
		SET @scheduledSoFarForInvoice = 0
		SET @firstPaymentDate = @prevInvDate
		
		/* compute the first payment date */
		IF @prevPaymentTermsKey IS NOT NULL
		BEGIN
			SET @endOfNextMonth = dateadd(dd,-1,DateAdd(mm, DateDiff(mm, 0, @prevInvDate) + 2, 0)) 
			SET @firstPaymentDate =
				CASE @prevFirstPaymentDateTypeCode
					--  add the supplied offset (or zero if null) to the invoice date
					WHEN @firstPaymentDateTypeInvoiceDate THEN
						DATEADD(dd, ISNULL(@prevFirstPaymentDateOffset, 0), @prevInvDate)
					--  add the supplied offset (or zero if null) to the beginning of next month.
					--  if the result would be greater than the end of next month (e.g. the offset was 30 
					--  and next month February) then just return the end of next month.
					WHEN @firstPaymentDateTypeNextMonth THEN
						CASE WHEN DATEADD(d, ISNULL(@prevFirstPaymentDateOffset, 0), DateAdd(mm, DateDiff(mm, 0, @prevInvDate) + 1, -1)) > @endOfNextMonth 
							 THEN @endOfNextMonth
							 ELSE  DATEADD(d, ISNULL(@prevFirstPaymentDateOffset, 0), DATEADD(m, DATEDIFF(m, 0, @prevInvDate) + 1, -1))
						     END
					-- return the last day of the current month
					WHEN @firstPaymentDateTypeEndOfMonth THEN
						DATEADD(d, -1, DATEADD(m, 1 + DATEDIFF(m, 0, @prevInvDate), 0))
					-- return the indicated date (or the invoice date, if null)
					WHEN @firstPaymentDateTypeSpecificDate THEN
						ISNULL(@prevFirstPaymentDueDate, @firstPaymentDate)
				END
		END
		/* compute the amount */
		SET @dueAmount = ROUND(@invoiceTotal / @payments, 2)
		WHILE @currentPayment < @payments
		BEGIN
			SET @scheduledSoFarForInstallment = 0
			/* Compute the due date 
			   If there are no payment terms, we will just leave the
	                                 the payment date as the invoice date.*/
			IF @prevPaymentTermsKey IS NOT NULL
			BEGIN
				SET @paymentDate = 
					CASE @prevIntType
						WHEN @termsTypeYearly THEN DATEADD(yy, @prevIntSize * @currentPayment, @firstPaymentDate)
						WHEN @termsTypeQuarterly THEN DATEADD(qq, @prevIntSize * @currentPayment, @firstPaymentDate)
						WHEN @termsTypeMonthly THEN DATEADD(mm, @prevIntSize * @currentPayment, @firstPaymentDate)
						WHEN @termsTypeWeekly THEN DATEADD(wk, @prevIntSize * @currentPayment, @firstPaymentDate)
						WHEN @termsTypeDaily THEN DATEADD(dd, @prevIntSize * @currentPayment, @firstPaymentDate)
						/* TBD: what to do otherwise? */
					END
			END
			ELSE
				SET @paymentDate = @firstPaymentDate
			SET @currentPayment = @currentPayment + 1
			SET @scheduledSoFarForInvoice = @scheduledSoFarForInvoice + @dueAmount
			/*
				If we are working on the last payment for this invoice,
				we want to correct for round-off error.  If scheduledSoFar
				is not the same as the invoiceTotal, adjust this last
				payment.
			*/
			IF (@currentPayment = @payments) AND (@scheduledSoFarForInvoice != @invoiceTotal)
				SET @dueAmount = @dueAmount + (@invoiceTotal - @scheduledSoFarForInvoice)
			
			
			IF UPPER(@prevAcctMethod) = 'A'
			BEGIN
				/* For each AR in the invoice, create schedule lines to divide the 
				   installment amount according to the share for this AR */
				DECLARE Account_Info cursor for
				SELECT GLAccountKey, Total, Share, Paid, Priority
				FROM @Totals
				OPEN Account_Info
				FETCH next from Account_Info into
					@tempARKey, @acctTotal, @share, @paidToCurrentGL, @priority
				WHILE @@FETCH_STATUS = 0
				BEGIN
					SET @acctAmount = ROUND(@dueAmount * @share, 2)
					/*
						Round-off correction if this is the last payment
					*/
					if (@currentPayment = @payments) AND (@acctAmount + @paidToCurrentGL != @acctTotal)
						SET @acctAmount = @acctTotal - @paidToCurrentGL

					SET @paidToCurrentGL = @paidToCurrentGL + @acctAmount
					UPDATE @Totals SET Paid = @paidToCurrentGL WHERE GLAccountKey = @tempARKey					
	
					SET @scheduledSoFarForInstallment = @scheduledSoFarForInstallment + @acctAmount
				
					SET @scheduleLineKey = NEWID()
					INSERT PaymentScheduleLine(PaymentScheduleLineKey, InvoiceKey, PaymentNumber, DueDate, AmountDue, OutstandingBalance, GLAccountKey, PayPriority)
					VALUES(@scheduleLineKey, @prevInvKey, @currentPayment, @paymentDate, @acctAmount, @acctAmount, @tempARKey, @priority)
					FETCH next from Account_Info into
						@tempARKey, @acctTotal, @share, @paidToCurrentGL, @priority
				END
				CLOSE Account_Info
				DEALLOCATE Account_Info	
				/* If the total amount we added to the various accounts 
				   does not equal the amount due for this payment, we will
				   adjust the last line to account for the rounding error. */
				IF  @scheduledSoFarForInstallment != @dueAmount
				BEGIN
					SET @acctAmount = @acctAmount + (@dueAmount - @scheduledSoFarForInstallment)
					UPDATE PaymentScheduleLine SET AmountDue = @acctAmount WHERE PaymentScheduleLineKey = @scheduleLineKey
				END
				
			END
			ELSE -- Cash-based; set PayPriority to zero for now -- Revisit this
			BEGIN
				SET @scheduleLineKey = NEWID()
				INSERT PaymentScheduleLine (PaymentScheduleLineKey, InvoiceKey, PaymentNumber, DueDate, AmountDue, OutstandingBalance, PayPriority)
				VALUES (@scheduleLineKey, @prevInvKey, @currentPayment, @paymentDate, @dueAmount, @dueAmount, 0)
			END
				
		END
		/* We are finished processing the previous invoice.  If there are no more
		   lines (fetch status was -1) we are done.  Otherwise we 
		   re-initialize for the current, new, invoice.
		*/
		IF @fetchStatus = -1 BREAK
		IF @fetchStatus = -2 CONTINUE
		SET @invoiceTotal = 0;
		DELETE @Totals
	END
	IF (@prevInvKey != @invKey)
	BEGIN
		-- Starting a new invoice; set all the "prev" variables.
		SET @prevInvKey = @invKey
		SET @prevPaymentTermsKey = @paymentTermsKey
		SET @prevInvDate =  @invDate
		SET @prevIntSize = @intSize
		SET @prevIntType = @intType
		SET @prevIntCount = @intCount
		SET @prevAcctMethod = @acctMethod
		SET @prevFirstPaymentDateTypeCode =  @firstPaymentDateTypeCode
		SET @prevFirstPaymentDateOffset =  @firstPaymentDateOffset
		SET @prevFirstPaymentDueDate = @firstPaymentDueDate
	END
	SET @firstIteration = 0
	IF @prevInvLineKey is null OR @invLineKey != @prevInvLineKey
	BEGIN
		SET @invoiceTotal = @invoiceTotal + @extendedPrice
		/* Associate the invoice distribution amounts with different GLAccounts
		   depending on the accounting method. 
		*/
		IF UPPER(@acctMethod) = 'A'
		BEGIN
			/*
				Update the table variable Totals with information from this
				invoice distribution.  But first, insert into Totals if we have not encountered
				this GLAccount in this invoice yet.
				 
				Note that we run this code only once per invoice line.  Multiple distributions for 
				this invoice line will have the same ARAcctKey, and will share the same ExtendedPrice.
				If we run this for each distribution, we will count the ExtendedPrice multiple times.
			*/
			SET @currentTotal = null
			SELECT @currentTotal = Total, @priority = Priority from @Totals where GLAccountKey = @ARAcctKey
			IF @currentTotal IS NULL
			BEGIN
				INSERT @Totals(GLAccountKey, Total, Share, Paid, Priority)
				VALUES (@ARAcctKey, 0, 0, 0, @payPriority)
				SET @currentTotal = 0
				SET @priority = @payPriority
			END
			SET @currentTotal = @currentTotal + @extendedPrice
			if @payPriority < @priority
				SET @priority = @payPriority
			UPDATE @Totals SET Total = @currentTotal, Priority = @priority WHERE GLAccountKey = @ARAcctKey
		END
	END
	SET @prevInvLineKey = @invLineKey
	FETCH next from Get_Invoices into
		@invKey, @invLineKey, @acctMethod, @paymentTermsKey, @invDate, @extendedPrice, @termsCode, @earlyDiscountDays, @earlyDiscountPercent, @intSize, @intType, @intCount,
		@ARAcctKey, @firstPaymentDueDate, @firstPaymentDateTypeCode, @firstPaymentDateOffset, @payPriority
END
CLOSE Get_Invoices
DEALLOCATE Get_Invoices

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_CreateRebuildOrRenamePK]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_CreateRebuildOrRenamePK]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_CreateRebuildOrRenamePK] 
	@tablename sysname, 
	@columns nvarchar(512) 
AS
BEGIN
	SET NOCOUNT ON;
	DECLARE @keyName sysname;
	DECLARE @indexname sysname;

	-- get the name of the table's Primary Key
    SELECT @keyName = [name]
      FROM sys.objects
     WHERE [parent_object_id] = OBJECT_ID(@tablename)
       AND [type] = 'PK';

	SET @indexname = N'PK_' + @tablename;

	-- if the key exists...
	IF @keyName IS NOT NULL
	BEGIN
		IF @keyName <> @indexname
		BEGIN
			-- if it not named according to our conventions, rename it
			EXEC (N'sp_rename ''' + @keyName + N''', ''' + @indexname + N''', ''OBJECT''');
		END
		ELSE
		BEGIN
			-- otherwise rebuild it
			DBCC DBREINDEX (@tablename, @indexname) WITH NO_INFOMSGS;
		END
    END

	-- if the key does not exist
	IF @keyName IS NULL
	BEGIN
		DECLARE @clustered nvarchar(12);
		SET @clustered = N'CLUSTERED';

		-- if a clustered index already exists, make this one non-clustered
		IF EXISTS (SELECT 1 FROM sys.indexes WHERE [object_id] = OBJECT_ID(@tablename) AND [type_desc] = N'CLUSTERED')
			SET @clustered = N'NONCLUSTERED';

		-- add the key
		EXEC (N'ALTER TABLE ' + @tablename + N' ADD CONSTRAINT PK_' + @tablename + N' PRIMARY KEY ' + @clustered + N' (' + @columns + N')');
	END
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_CreateRFMStatsAuto]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_CreateRFMStatsAuto]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_CreateRFMStatsAuto]
     @rfmKey UNIQUEIDENTIFIER,
     @numGroupsRecency INT,
     @numGroupsFrequency INT,
     @numGroupsMonetary INT
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @now datetime;
    SELECT @now = dbo.asi_GetAppDatetime();

    -- new code
    SELECT ContactKey, 
           COUNT(1) as CT,
           SUM ([Amount]) as [AMT],
           MIN ([Amount]) as [LOW],
           MAX ([Amount]) as [HIGH],
           MIN ([TransactionDate]) as [FIRST],
           MAX ([TransactionDate]) as [LAST],
           CONVERT (datetime, '1/1/90') as [HIGHCONT],
           10000000.0000 as FIRSTAMT,
           10000000.0000 as LASTAMT
      INTO #tmpTransWork
      FROM #tmpTrans
     GROUP BY ContactKey

    UPDATE #tmpTransWork
       SET HIGHCONT = #tmpTrans.TransactionDate from #tmpTrans
     WHERE #tmpTransWork.ContactKey = #tmpTrans.ContactKey
       AND #tmpTransWork.HIGH = #tmpTrans.Amount

     
    UPDATE #tmpTransWork
       SET FIRSTAMT = #tmpTrans.Amount from #tmpTrans
     WHERE #tmpTransWork.ContactKey = #tmpTrans.ContactKey
       AND #tmpTransWork.FIRST = #tmpTrans.TransactionDate

     
    UPDATE #tmpTransWork
       SET LASTAMT = #tmpTrans.Amount from #tmpTrans
     WHERE #tmpTransWork.ContactKey = #tmpTrans.ContactKey
       AND #tmpTransWork.LAST = #tmpTrans.TransactionDate

     
    -- existing code, updated statement
    -- Update the RFMMain Table, set initial values for all columns
    UPDATE RFMMain
       SET NumContacts = T1.CT,
           TotalAmount = T1.AMT,
           LowAmount = T1.LOW,
           HighAmount = T1.HIGH,
           FirstContact = T1.FIRST,
           LastContact = T1.LAST,
           HighContact = T1.HIGHCONT,
           FirstContactAmount = T1.FIRSTAMT,
           LastContactAmount = T1.LASTAMT,
           NumDays = DATEDIFF(DAY, T1.LAST, @now),
           Frequency = 0,
           Recency = 0,
           Monetary = 0,
           Combined = 0,
           Total = 0
     FROM (SELECT ContactKey, 
                  CT, 
                  AMT, 
                  LOW, 
                  HIGH, 
                  FIRST, 
                  LAST,
                  HIGHCONT,
                  FIRSTAMT,
                  LASTAMT
             FROM #tmpTransWork) AS T1
            WHERE RFMMain.RFMKey = @rfmKey AND RFMMain.ContactKey = T1.ContactKey
     
    --DELETE from RFMMain WHERE RFMMain.RFMKey = @rfmKey AND RFMMain.NumContacts = 0  
     
    DECLARE @numGroups INT
    DECLARE @group_size INT
    DECLARE @total_count INT
    DECLARE @n INT
    DECLARE @sql VARCHAR(500)

    IF (@numGroupsRecency > 0)
    BEGIN
         -- Do the Recency Rankings
         SET @numGroups = @numGroupsRecency

         -- Get the Total Count
         -- Only choose records that have numdays
         select @total_count = COUNT(1) FROM RFMMain WHERE RFMMain.RFMKey = @rfmKey AND NumDays IS NOT NULL
         
         IF (@total_count > 0)
         BEGIN 
              PRINT 'Recency Total Count = ' + str(@total_count) + ' Num Groups = ' + str(@numGroups)
              SET @group_size = ROUND(CAST(@total_count AS FLOAT) / @numGroups, 0)

              PRINT 'Recency Group Size = ' + str(@group_size)

              IF (@group_size = 0)
                   SET @group_size = 1
                   
              SET @n = 1

              WHILE (@n <= @numGroups)
              BEGIN
                   -- Build the SQL dynamically. We have to do this in order to use
                   -- the TOP clause with a variable
                   IF (@n < @numGroups)
                   BEGIN
                        SELECT @sql = 'UPDATE RFMMain SET Recency = ' + str(@n) +
                             ' FROM ( SELECT TOP ' + str(@group_size) + ' * FROM RFMMain ' +
                             ' WHERE NumDays IS NOT NULL AND Recency = 0' +
                             ' ORDER BY NumDays DESC) AS T1' +
                             ' WHERE RFMMain.RFMKey = T1.RFMKey AND RFMMain.ContactKey = T1.ContactKey';
                   END
                   ELSE
                   BEGIN
                        SELECT @sql = 'UPDATE RFMMain SET Recency = ' + str(@n) +
                             ' FROM ( SELECT * FROM RFMMain ' +
                             ' WHERE NumDays IS NOT NULL AND Recency = 0' +
                             ' ) AS T1' +
                             ' WHERE RFMMain.RFMKey = T1.RFMKey AND RFMMain.ContactKey = T1.ContactKey';
                   END
                   
                   PRINT 'Sql = ' + @sql
                   -- Execute the SQL
                   EXEC (@sql)
                                  
                   SET @n = @n+1
              END
         END
    END

    if (@numGroupsFrequency > 0)
    BEGIN
         -- Do the Frequency Rankings
         SET @numGroups = @numGroupsFrequency

         -- Get the Total Count
         select @total_count = count(*) from RFMMain WHERE RFMMain.RFMKey = @rfmKey AND NumContacts IS NOT NULL AND NumContacts != 0
         
         IF (@total_count > 0)
         BEGIN
              PRINT 'Frequency Total Count = ' + str(@total_count) + ' Num Groups = ' + str(@numGroups)
              SET @group_size = ROUND(CAST(@total_count AS FLOAT) / @numGroups, 0)

              PRINT 'Frequency Group Size = ' + str(@group_size)
                   
              SET @n = 1

              IF (@group_size = 0)
                   SET @group_size = 1

              WHILE (@n <= @numGroups)
              BEGIN
                   -- Build the SQL dynamically. We have to do this in order to use
                   -- the TOP clause with a variable
                   IF (@n < @numGroups)
                   BEGIN
                        SELECT @sql = 'UPDATE RFMMain SET Frequency = ' + str(@n) +
                             ' FROM ( SELECT TOP ' + str(@group_size) + ' * FROM RFMMain ' +
                             ' WHERE NumContacts IS NOT NULL AND NumContacts != 0 AND Frequency = 0' +
                             ' ORDER BY NumContacts ASC) AS T1' +
                             ' WHERE RFMMain.RFMKey = T1.RFMKey AND RFMMain.ContactKey = T1.ContactKey';
                   END
                   ELSE
                   BEGIN
                        SELECT @sql = 'UPDATE RFMMain SET Frequency = ' + str(@n) +
                             ' FROM ( SELECT * FROM RFMMain ' +
                             ' WHERE NumContacts IS NOT NULL AND NumContacts != 0 AND Frequency = 0' +
                             ' ) AS T1' +
                             ' WHERE RFMMain.RFMKey = T1.RFMKey AND RFMMain.ContactKey = T1.ContactKey';
                   END
                   
                   -- Execute the SQL
                   EXEC (@sql)
                                  
                   SET @n = @n+1
              END
         END
    END

    if (@numGroupsMonetary > 0)
    BEGIN
         -- Do the Monetary Rankings
         SET @numGroups = @numGroupsMonetary

         -- Get the Total Count
         select @total_count = count(*) from RFMMain WHERE RFMMain.RFMKey = @rfmKey AND TotalAmount IS NOT NULL AND TotalAmount != 0

         IF (@total_count > 0)
         BEGIN
              PRINT 'Monetary Total Count = ' + str(@total_count) + ' Num Groups = ' + str(@numGroups)
              SET @group_size = ROUND(CAST(@total_count AS FLOAT) / @numGroups, 0)

              PRINT 'Monetary Group Size = ' + str(@group_size)
              IF (@group_size = 0)
                   SET @group_size = 1
                   
              SET @n = 1

              WHILE (@n <= @numGroups)
              BEGIN
                   -- Build the SQL dynamically. We have to do this in order to use
                   -- the TOP clause with a variable
                   IF (@n < @numGroups)
                   BEGIN
                        SELECT @sql = 'UPDATE RFMMain SET Monetary = ' + str(@n) +
                             ' FROM ( SELECT TOP ' + str(@group_size) + ' * FROM RFMMain ' +
                             ' WHERE TotalAmount IS NOT NULL AND TotalAmount != 0 AND Monetary = 0' +
                             ' ORDER BY TotalAmount ASC) AS T1' +
                             ' WHERE RFMMain.RFMKey = T1.RFMKey AND RFMMain.ContactKey = T1.ContactKey';
                   END
                   ELSE
                   BEGIN
                        SELECT @sql = 'UPDATE RFMMain SET Monetary = ' + str(@n) +
                             ' FROM ( SELECT * FROM RFMMain ' +
                             ' WHERE TotalAmount IS NOT NULL AND TotalAmount != 0 AND Monetary = 0' +
                             ' ) AS T1' +
                             ' WHERE RFMMain.RFMKey = T1.RFMKey AND RFMMain.ContactKey = T1.ContactKey';
                   END
                   
                   -- Execute the SQL
                   EXEC (@sql)
                                  
                   SET @n = @n+1
              END
         END
    END

    -- Set the combined and total rankings
    UPDATE dbo.RFMMain
       SET Combined = Recency * 10000 + Frequency * 100 + Monetary,
           Total = Recency + Frequency + Monetary
     WHERE RFMMain.RFMKey = @rfmKey

    DROP TABLE #tmpTrans;
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_CreateRFMStatsManual]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_CreateRFMStatsManual]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_CreateRFMStatsManual]
    @rfmKey uniqueidentifier
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @now datetime;
    SET @now = dbo.asi_GetAppDatetime();

    SELECT [ContactKey],
           COUNT(1) AS [CT],
           SUM([Amount]) AS [AMT],
           MIN([Amount]) AS [LOW],
           MAX([Amount]) AS [HIGH],
           MIN([TransactionDate]) AS [FIRST],
           MAX([TransactionDate]) AS [LAST],
           CONVERT(datetime, '1/1/90') AS [HIGHCONT],
           10000000.0000 AS [FIRSTAMT],
           10000000.0000 AS [LASTAMT]
      INTO [#tmpTransWork]
      FROM [#tmpTrans]
     GROUP BY [ContactKey];
     
    UPDATE [#tmpTransWork]
       SET [HIGHCONT] = [#tmpTrans].[TransactionDate]
      FROM [#tmpTrans]
     WHERE [#tmpTransWork].[ContactKey] = [#tmpTrans].[ContactKey] AND [#tmpTransWork].[HIGH] = [#tmpTrans].[Amount];
     
    UPDATE [#tmpTransWork]
       SET [FIRSTAMT] = [#tmpTrans].[Amount]
      FROM [#tmpTrans]
     WHERE [#tmpTransWork].[ContactKey] = [#tmpTrans].[ContactKey] AND [#tmpTransWork].[FIRST] = [#tmpTrans].[TransactionDate];
     
    UPDATE [#tmpTransWork]
       SET [LASTAMT] = [#tmpTrans].[Amount]
      FROM [#tmpTrans]
     WHERE [#tmpTransWork].[ContactKey] = [#tmpTrans].[ContactKey] AND [#tmpTransWork].[LAST] = [#tmpTrans].[TransactionDate];
 
    -- existing code, updated statement
    -- Update the RFMMain Table, set initial values for all columns
    UPDATE [RFMMain]
       SET [NumContacts] = [T1].[CT],
           [TotalAmount] = [T1].[AMT],
           [LowAmount] = [T1].[LOW],
           [HighAmount] = [T1].[HIGH],
           [FirstContact] = [T1].[FIRST],
           [LastContact] = [T1].[LAST],
           [HighContact] = [T1].[HIGHCONT],
           [FirstContactAmount] = [T1].[FIRSTAMT],
           [LastContactAmount] = [T1].[LASTAMT],
           [NumDays] = DATEDIFF(DAY, [T1].[LAST], @now),
           [Frequency] = 0,
           [Recency] = 0,
           [Monetary] = 0,
           [Combined] = 0,
           [Total] = 0
      FROM (SELECT [ContactKey],
                   [CT],
                   [AMT],
                   [LOW],
                   [HIGH],
                   [FIRST],
                   [LAST],
                   [HIGHCONT],
                   [FIRSTAMT],
                   [LASTAMT]
              FROM [#tmpTransWork]
            ) AS [T1]
     WHERE [RFMMain].[RFMKey] = @rfmKey AND [RFMMain].[ContactKey] = [T1].[ContactKey];

    -- Update the Recency Rankings
    UPDATE [RFMMain]
       SET [Recency] = [S1].[Ranking]
      FROM (SELECT [RFMMain].[ContactKey],
                   [#tmpRanking].[Ranking]
              FROM [RFMMain],
                   [#tmpRanking]
             WHERE [RFMMain].[NumDays] IS NOT NULL AND [RFMMain].[NumDays] BETWEEN [#tmpRanking].[RecencyStart] AND [#tmpRanking].[RecencyEnd]
            ) AS [S1]
     WHERE [RFMMain].[RFMKey] = @rfmKey AND [RFMMain].[ContactKey] = [S1].[ContactKey];
     
    -- Update the Frequency Rankings
    UPDATE [RFMMain]
       SET [Frequency] = [S1].[Ranking]
      FROM (SELECT [RFMMain].[ContactKey],
                   [#tmpRanking].[Ranking]
              FROM [RFMMain],
                   [#tmpRanking]
             WHERE [RFMMain].[NumContacts] IS NOT NULL AND [NumContacts] != 0 AND [RFMMain].[NumContacts] BETWEEN [#tmpRanking].[FrequencyStart] AND [#tmpRanking].[FrequencyEnd]
            ) AS [S1]
     WHERE [RFMMain].[RFMKey] = @rfmKey AND [RFMMain].[ContactKey] = [S1].[ContactKey];

    -- Update the Monetary Rankings
    UPDATE [RFMMain]
       SET [Monetary] = [S1].[Ranking]
      FROM (SELECT [RFMMain].[ContactKey],
                   [#tmpRanking].[Ranking]
              FROM [RFMMain],
                   [#tmpRanking]
             WHERE [RFMMain].[TotalAmount] IS NOT NULL AND [TotalAmount] != 0 AND [RFMMain].[TotalAmount] BETWEEN [#tmpRanking].[MonetaryStart] AND [#tmpRanking].[MonetaryEnd]
            ) AS [S1]
     WHERE [RFMMain].[RFMKey] = @rfmKey AND [RFMMain].[ContactKey] = [S1].[ContactKey];

    -- Set the combined and total rankings
    UPDATE [RFMMain]
       SET [Combined] = [Recency] * 10000 + [Frequency] * 100 + [Monetary],
           [Total] = [Recency] + [Frequency] + [Monetary]
     WHERE [RFMMain].[RFMKey] = @rfmKey;
     
    DROP TABLE [#tmpTrans];
    DROP TABLE [#tmpRanking];
END;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_CreateSalesHistory]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_CreateSalesHistory]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_CreateSalesHistory]
       @amount                    decimal(18, 4),
       @transDate                 datetime,
       @sourceCodeKey             uniqueidentifier,
       @orderTypeKey              uniqueidentifier,
       @orderNumber               nvarchar(50),
       @responseMediaCode         nvarchar(20),
       @priceSheetKey             uniqueidentifier,
       @extendedCost              decimal(18, 4),
       @warehouseKey              uniqueidentifier,
       @invType                   char(1),
       @billToContactKey          uniqueidentifier,
       @shipToContactKey          uniqueidentifier,
       @soldToContactKey          uniqueidentifier,
       @orderDate                 datetime,
       @productKey                uniqueidentifier,
       @qtySold                   decimal(18, 4),
       @undiscountedExtendedPrice decimal(18, 4),
       @uomKey                    uniqueidentifier,
       @userKey                   uniqueidentifier,
       @systemKey                 uniqueidentifier,
       @accessKey                 uniqueidentifier,
       @commissionPlanKey         uniqueidentifier,
       @salesTeamGroupKey         uniqueidentifier,
       @salesLocationKey          uniqueidentifier, -- 11/30/04 - pjr
       @isPledge                  bit,
       @invoiceLineNumber         int,
       @invoiceNumber             nvarchar(50)
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @salesHistoryKey uniqueidentifier;
    DECLARE @glTypeDistribution int;
    SET @salesHistoryKey = NEWID();
    INSERT INTO [SalesHistory] ([SalesHistoryKey],
                                [TransactionDate],
                                [OrderNumber],
                                [OrderTypeKey],
                                [OrderDate],
                                [InvoiceTypeCode],
                                [BillToContactKey],
                                [ShipToContactKey],
                                [SoldToContactKey],
                                [ProductKey],
                                [WarehouseKey],
                                [QuantitySold],
                                [ExtendedPrice],
                                [UndiscountedExtendedPrice],
                                [ExtendedCost],
                                [UomKey],
                                [SourceCodeKey],
                                [ResponseMediaCode],
                                [PriceSheetKey],
                                [CommissionPlanKey],
                                [SalesTeamGroupKey],
                                [SalesLocationKey],
                                [AccessKey],
                                [CreatedOn],
                                [CreatedByUserKey],
                                [SystemEntityKey],
                                [IsPledge],
                                [InvoiceLineNumber],
                                [InvoiceNumber]
                               )
    VALUES (@salesHistoryKey,
            @transDate,
            @orderNumber,
            @orderTypeKey,
            @orderDate,
            @invType,
            @billToContactKey,
            @shipToContactKey,
            @soldToContactKey,
            @productKey,
            @warehouseKey,
            @qtySold,
            -1 * @amount,
            @undiscountedExtendedPrice,
            @extendedCost,
            @uomKey,
            @sourceCodeKey,
            @responseMediaCode,
            @priceSheetKey,
            @commissionPlanKey,
            @salesTeamGroupKey,
            @salesLocationKey,
            @accessKey,
            dbo.asi_GetAppDatetime(),
            @userKey,
            @systemKey,
            @isPledge,
            @invoiceLineNumber,
            @invoiceNumber
           );
END;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_CreateTempGL]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_CreateTempGL]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_CreateTempGL]
@accountKey uniqueidentifier,
@amount decimal(18,4),
@invoiceKey uniqueidentifier,
@paymentKey uniqueidentifier,
@productKey uniqueidentifier,
@finEntityKey uniqueidentifier,
@transDate datetime,
@journalType int,
@fiscalPeriod int,
@glEntryType nvarchar(50),
@description nvarchar(20),
@invoiceLineKey uniqueidentifier,
@defTermsKey uniqueidentifier,
@targetAcctKey uniqueidentifier,
@sequenceNumber int,
@originatingBatchNumber nvarchar(50),
@finalBatchNumber nvarchar(50),
@billToContactKey uniqueidentifier, 
@journalEntryDescription nvarchar(50),
@invoiceLineNumber int
AS
DECLARE @salesHistoryKey uniqueidentifier
DECLARE @glTypeDistribution int
SET @glTypeDistribution = 1
INSERT #tmpTransLine(AccountKey, Amount, InvoiceKey, PaymentKey, Description, ProductKey, 
FinEntityKey, TransDate, GLEntryType, JournalEntryTypeCode, FiscalPeriod,
InvoiceLineKey, DeferralTermsKey, TargetGLAccountKey, TransactionSequenceNumber, OriginatingBatchNumber,
FinalBatchNumber, BillToContactKey, JournalEntryDescription, InvoiceLineNumber) 
VALUES (@accountKey, @amount, @invoiceKey, @paymentKey, @description , @productKey,
@finEntityKey, @transDate, @glEntryType, @journalType, @fiscalPeriod, 
@invoiceLineKey, @defTermsKey, @targetAcctKey, @sequenceNumber,
@originatingBatchNumber, @finalBatchNumber, @billToContactKey, @journalEntryDescription, @invoiceLineNumber)

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_CreateUpdateAppealParticipation]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_CreateUpdateAppealParticipation]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- Create or update AppealParticipation records for each contact in the input list
CREATE PROCEDURE [dbo].[asi_CreateUpdateAppealParticipation]
    @listKey          uniqueidentifier,
    @appealKey        uniqueidentifier,
    @solicitationKey  uniqueidentifier,
    @sourceCodeKey    uniqueidentifier,
    @responseTypeCode int,
    @userKey          uniqueidentifier
AS
BEGIN
    SET NOCOUNT ON;
    BEGIN TRAN;
    DECLARE @returnCount int;
    SET @returnCount = 0;
    DECLARE @now datetime;
    SELECT @now = dbo.asi_GetAppDatetime();

    -- Update AppealParticipation for source code + contacts combos
    -- that are already in appeal
    UPDATE [vBoAppealParticipation]
       SET
           [SolicitationKey] = @solicitationKey,
           [UpdatedByUserKey] = @userKey,
           [UpdatedOn] = @now
      FROM [vBoAppealParticipation] [ap]
           INNER JOIN [vBoListElement] [le] ON [ap].[RespondentUserKey] = [le].[ObjectKey]
     WHERE [ap].[AppealKey] = @appealKey AND [le].[ListKey] = @listKey AND [ap].[SourceCodeKey] = @sourceCodeKey;
    SET @returnCount = @returnCount + @@ROWCOUNT;

    -- Insert into AppealParticipation for contacts entering appeal
    -- for a particular source code
    INSERT INTO [vBoAppealParticipation] ([AppealParticipationKey],
                                          [AppealKey],
                                          [SolicitationKey],
                                          [SourceCodeKey],
                                          [ResponseTypeCode],
                                          [CreatedByUserKey],
                                          [CreatedOn],
                                          [UpdatedByUserKey],
                                          [UpdatedOn],
                                          [RespondentUserKey]
                                         )
           SELECT NEWID(),
                  @appealKey,
                  @solicitationKey,
                  @sourceCodeKey,
                  @responseTypeCode,
                  @userKey,
                  @now,
                  @userKey,
                  @now,
                  [le].[ObjectKey]
             FROM [vBoListElement] AS [le]
            WHERE [le].[ListKey] = @listKey AND NOT EXISTS (
                                                            SELECT 1
                                                              FROM [vBoAppealParticipation] AS [ap]
                                                             WHERE [ap].[AppealKey] = @appealKey AND [ap].[RespondentUserKey] = [le].[ObjectKey] AND [ap].[SourceCodeKey] = @sourceCodeKey
           );
    SET @returnCount = @returnCount + @@ROWCOUNT;
    SELECT @returnCount AS [ReturnCount];
    COMMIT TRAN;
END;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetOrderResponseStart]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetOrderResponseStart]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_GetOrderResponseStart    ******/

CREATE  PROCEDURE [dbo].[asi_GetOrderResponseStart]

@userKey uniqueidentifier,
@rangeBegin float output,
@rangeEnd float output
AS
DECLARE @newGuid as uniqueidentifier 
declare @EveryoneFullControlAccessKey uniqueidentifier
select @EveryoneFullControlAccessKey = ParameterValue from SystemConfig 
	where ParameterName = 'Security.Token.EveryoneFullControlAccessKey'
set @rangeBegin = 0
set @rangeEnd = 0
BEGIN TRAN 
-- Get the ending value
SELECT	@rangeEnd =  max(ORDER_NUMBER)
 FROM	Orders
-- Check to make sure the counter exists - create it if not
IF NOT EXISTS(SELECT 1 FROM SystemConfig WHERE ParameterName='OrderResponseRangeStart')
BEGIN
	SELECT @newGuid = newid()
	INSERT SystemConfig (SystemConfigKey, ParameterName, ParameterValue, Description)
	VALUES(	@newGuid, 
		'OrderResponseRangeStart', 
		CAST(@rangeEnd As nvarchar(100)), 
		'Ending point in the Orders table already processed by response acquisition.')
END
-- Get the beginning value
SELECT	@rangeBegin = CAST(ParameterValue As float)
 FROM	SystemConfig
 WHERE	ParameterName = 'OrderResponseRangeStart'
 IF @rangeBegin is NULL
	SET @rangeBegin = 0
-- Set the ending value
UPDATE	SystemConfig
 SET	ParameterValue = CAST(@rangeEnd As nvarchar(100))
 WHERE	ParameterName = 'OrderResponseRangeStart'
COMMIT TRAN

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetTransResponseStart]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetTransResponseStart]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_GetTransResponseStart] 
    @userKey uniqueidentifier,
    @rangeBegin int output,
    @rangeEnd int output
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @newGuid uniqueidentifier;
    DECLARE @everyoneFullControlAccessKey uniqueidentifier;
    DECLARE @now datetime;
    SELECT @everyoneFullControlAccessKey = [ParameterValue] 
      FROM [dbo].[SystemConfig]
     WHERE [ParameterName] = 'Security.Token.EveryoneFullControlAccessKey'
    SELECT @now = dbo.asi_GetAppDatetime();

    SET @rangeBegin = 0
    SET @rangeEnd = 0

    BEGIN TRANSACTION; 

    -- Get the ending value
    SELECT @rangeEnd = MAX(TRANS_NUMBER)
      FROM Trans

    -- Check to make sure the counter exists - create it if not
    IF NOT EXISTS(SELECT 1 FROM SystemConfig WHERE ParameterName='TransResponseRangeStart')
    BEGIN
         SELECT @newGuid = NEWID()
         INSERT INTO [dbo].[SystemConfig] ([SystemConfigKey], [ParameterName], [ParameterValue], [Description], 
                                           [OrganizationKey], [SystemEntityKey], [CreatedByUserKey], [CreatedOn])
         VALUES (@newGuid, 
              'TransResponseRangeStart', 
              CAST(@rangeEnd As nvarchar(100)), 
              'Ending point in the Trans table already processed by response acquisition.',
              '00000000-0000-0000-0000-000000000000',
              NULL,
              @userKey, 
              @now)
    END

    -- Get the beginning value
    SELECT @rangeBegin = CAST([ParameterValue] AS int)
      FROM [dbo].[SystemConfig]
     WHERE [ParameterName] = 'TransResponseRangeStart'

    -- Set the ending value
    UPDATE [dbo].[SystemConfig]
       SET [ParameterValue] = CAST(@rangeEnd AS nvarchar(100))
     WHERE [ParameterName] = 'TransResponseRangeStart'

    COMMIT TRANSACTION;
END


GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_CsUpdateCampaignResponses]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_CsUpdateCampaignResponses]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_CsUpdateCampaignResponses]
    @useImplicit bit, 
    @userKey uniqueidentifier
AS
BEGIN
    SET NOCOUNT ON;
    --The following values were used during testing
    --set @useImplicit = 1 
    --set @userKey = '00000000-0000-0000-0000-000000000001' 
    -- updated 15 Feb 2007 RRK to add some Seco stuff; ServiceCentral in particular.
    -- updated 16 Feb 2007 RRK DT19614 -- fix problem with auto-mapped Dues
    DECLARE @firstTransNumber int;
    DECLARE @lastTransNumber int;
    DECLARE @firstOrderNumber float;
    DECLARE @lastOrderNumber float;
    DECLARE @now datetime;
    DECLARE @debug bit;
    SET @debug = 1;
    --Get the last TRANS row used in a response update and update the number to the current max
    IF @debug = 1
    BEGIN
        PRINT 'Get the last TRANS row used in a response update and update the number to the current max';
    END;
    EXECUTE asi_GetTransResponseStart @userKey, @firstTransNumber OUTPUT, @lastTransNumber OUTPUT;
    IF @debug = 1
    BEGIN
        PRINT 'First Trans Number:' + CONVERT(varchar(10), @firstTransNumber) + '; Last Tans Number ' + CONVERT(varchar(10), @lastTransNumber);
    END;
    --Get the last ORDERS row used in a response update and update the number to the current max
    IF @debug = 1
    BEGIN
        PRINT 'Get the last ORDERS row used in a response update and update the number to the current max';
    END;
    EXECUTE asi_GetOrderResponseStart @userKey, @firstOrderNumber OUTPUT, @lastOrderNumber OUTPUT;
    IF @debug = 1
    BEGIN
        PRINT 'First Order: ' + CONVERT(varchar(10), @firstOrderNumber) + '; Last Order:' + CONVERT(varchar(10), @lastOrderNumber);
    END;

    -- HACK-- this must be removed to prevent duplicate responses 
    --select @firstOrderNumber = 0,@lastOrderNumber = 10000,@firstTransNumber=0,@lastTransNumber =100000
    -- END HACK

    SET @now = dbo.asi_GetAppDatetime();
    IF OBJECT_ID('tempdb..#tmpResponse') IS NOT NULL DROP TABLE #tmpResponse
    CREATE TABLE #tmpResponse(SourceTable char(1),
                              TransNumber int,
                              LineSub decimal(18, 4),
                              TransDate datetime,
                              Id varchar(20) COLLATE DATABASE_DEFAULT,
                              UserKey uniqueidentifier,
                              ProductCode varchar(31) COLLATE DATABASE_DEFAULT,
                              SourceCode varchar(60) COLLATE DATABASE_DEFAULT,
                              TotalRevenue decimal(18, 4),
                              WasSolicited tinyint NOT NULL
                                                   DEFAULT 1,
                              InvoiceReferenceNum int DEFAULT-1);

    -- Dues Trans records with matching source code
    -- bp 6/6/05 - We want to recognize separate responses for separate source codes, even
    -- if trans number is the same, so add t.SOURCE_CODE to 'group by' clause
    IF @debug = 1
    BEGIN
        PRINT 'Due Trans records with matching source code';
    END;
    INSERT INTO #tmpResponse(SourceTable,
                             TransNumber,
                             SourceCode,
                             Id,
                             TransDate)
    SELECT 'D',
           t.TRANS_NUMBER,
           MIN(t.SOURCE_CODE),
           MAX(t.BT_ID),
           MIN(t.TRANSACTION_DATE)
      FROM Trans AS t
           INNER JOIN SourceCode AS sg ON t.SOURCE_CODE = sg.Code
     WHERE t.TRANS_NUMBER > @firstTransNumber AND t.TRANS_NUMBER <= @lastTransNumber AND t.TRANSACTION_TYPE = 'DIST' AND t.SOURCE_SYSTEM IN('DUES', 'SC') AND t.JOURNAL_TYPE = 'PAY' AND t.SOURCE_CODE > ' ' AND t.SOURCE_CODE <> 'WEB' AND sg.SourceCodeStatusCode = 0 -- 0 is Active
     GROUP BY t.TRANS_NUMBER,
              t.SOURCE_CODE;
    -- FR Trans records with matching source code
    IF @debug = 1
    BEGIN
        PRINT 'FR Trans records with matching source code';
    END;
    INSERT INTO #tmpResponse(SourceTable,
                             TransNumber,
                             SourceCode,
                             Id,
                             TransDate)
    SELECT 'T',
           t.TRANS_NUMBER,
           MIN(t.SOURCE_CODE),
           MAX(t.BT_ID),
           MIN(t.TRANSACTION_DATE)
      FROM Trans AS t
           INNER JOIN SourceCode AS sg ON t.SOURCE_CODE = sg.Code
     WHERE t.TRANS_NUMBER > @firstTransNumber AND t.TRANS_NUMBER <= @lastTransNumber AND t.TRANSACTION_TYPE = 'DIST' AND t.SOURCE_SYSTEM = 'FR' AND t.JOURNAL_TYPE = 'IN' AND t.SOURCE_CODE > ' ' AND t.SOURCE_CODE <> 'WEB' AND sg.SourceCodeStatusCode = 0 -- 0 is Active
     GROUP BY t.TRANS_NUMBER;
    IF @debug = 1
    BEGIN
        PRINT 'Meeting Trans records with matching source code';
    END;
    -- Meeting Trans records with matching source code
    -- DT16091 - Include INVOICE_REFERENCE_NUM in #tmpResponse. We'll need this to filter out
    -- past responses to the same event, and to filter out duplicate responses to the same event.
    INSERT INTO #tmpResponse(SourceTable,
                             TransNumber,
                             SourceCode,
                             Id,
                             TransDate,
                             InvoiceReferenceNum)
    SELECT 'T',
           t.TRANS_NUMBER,
           t.SOURCE_CODE,
           MAX(t.BT_ID),
           MIN(t.TRANSACTION_DATE),
           t.INVOICE_REFERENCE_NUM
      FROM Trans AS t
           INNER JOIN SourceCode AS sg ON t.SOURCE_CODE = sg.Code
     WHERE t.TRANS_NUMBER > @firstTransNumber AND t.TRANS_NUMBER <= @lastTransNumber AND t.TRANSACTION_TYPE = 'DIST' AND t.SOURCE_SYSTEM = 'MEETING' AND t.JOURNAL_TYPE = 'IN' AND t.SOURCE_CODE > ' ' AND t.SOURCE_CODE <> 'WEB' AND sg.SourceCodeStatusCode = 0 -- 0 is Active
     GROUP BY t.TRANS_NUMBER,
              t.SOURCE_CODE,
              t.INVOICE_REFERENCE_NUM;
    IF @debug = 1
    BEGIN
        PRINT 'Orders and Expo transactions with matching source code';
    END;
    --Orders and Expo transactions with matching source code
    INSERT INTO #tmpResponse(SourceTable,
                             TransNumber,
                             SourceCode,
                             Id,
                             TransDate,
                             TotalRevenue)
    SELECT 'O',
           o.ORDER_NUMBER,
           o.SOURCE_CODE,
           o.BT_ID,
           o.ORDER_DATE,
           o.LINE_TOTAL
      FROM Orders AS o
           INNER JOIN SourceCode AS sg ON o.SOURCE_CODE = sg.Code
     WHERE ORDER_NUMBER > @firstOrderNumber AND ORDER_NUMBER <= @lastOrderNumber AND o.SOURCE_CODE > ' ' AND o.SOURCE_CODE <> 'WEB' AND sg.SourceCodeStatusCode = 0 -- 0 is Active
           -- bp 6/6/05 - Meetings tranactions will be handled separately
           AND o.SOURCE_SYSTEM <> 'MEETING'
           -- Don't include premium donation orders
           AND NOT EXISTS(SELECT 1
                            FROM Donation_Premium
                           WHERE ORDER_NUMBER = o.ORDER_NUMBER) AND (o.SOURCE_CODE IN(SELECT Code
                                                                                        FROM SourceCode
                                                                                       WHERE SourceCodeStatusCode = 0));
    IF @useImplicit = 1
    BEGIN
        IF @debug = 1
        BEGIN
            PRINT 'Dues Trans records with matching product and no explicit source code'
        END;
        --Dues Trans records with matching product and no explicit source code
        INSERT INTO #tmpResponse(SourceTable,
                                 TransNumber,
                                 LineSub,
                                 ProductCode,
                                 Id,
                                 TransDate)
        SELECT DISTINCT 'D',
                        t.TRANS_NUMBER,
                        (t.LINE_NUMBER + t.SUB_LINE_NUMBER / 1000),
                        t.PRODUCT_CODE,
                        t.BT_ID,
                        t.TRANSACTION_DATE
          FROM Trans AS t
               INNER JOIN AppealProduct AS ap ON t.PRODUCT_CODE = ap.ProductCode
               INNER JOIN AppealMain AS am ON ap.AppealKey = am.AppealKey
         WHERE t.TRANS_NUMBER > @firstTransNumber AND t.TRANS_NUMBER <= @lastTransNumber AND t.TRANSACTION_TYPE = 'DIST' AND t.SOURCE_SYSTEM IN('DUES', 'SC') AND t.JOURNAL_TYPE = 'PAY' AND (t.SOURCE_CODE = '' OR t.SOURCE_CODE = 'WEB') AND am.AppealStatusCode = 0 -- 0 is Active
               AND NOT EXISTS(SELECT 1
                                FROM #tmpResponse
                               WHERE TransNumber = t.TRANS_NUMBER AND LineSub IS NULL AND SourceTable = 'T');
        --Keep only the lowest Line/SubLine for each transaction number
        DELETE tr
          FROM #tmpResponse tr
         WHERE(SourceTable = 'T' OR SourceTable = 'D') AND LineSub > (SELECT MIN(LineSub)
                                                                        FROM #tmpResponse
                                                                       WHERE TransNumber = tr.TransNumber AND (SourceTable = 'T' OR SourceTable = 'D'));
        --FR Trans records with matching product and no explicit source code
        IF @debug = 1
        BEGIN
            PRINT 'FR Trans records with matching product and no explicit source code';
        END;
        INSERT INTO #tmpResponse(SourceTable,
                                 TransNumber,
                                 LineSub,
                                 ProductCode,
                                 Id,
                                 TransDate)
        SELECT DISTINCT 'T',
                        t.TRANS_NUMBER,
                        (t.LINE_NUMBER + t.SUB_LINE_NUMBER / 1000),
                        t.PRODUCT_CODE,
                        t.BT_ID,
                        t.TRANSACTION_DATE
          FROM Trans AS t
               INNER JOIN AppealProduct AS ap ON t.PRODUCT_CODE = ap.ProductCode
               INNER JOIN AppealMain AS am ON ap.AppealKey = am.AppealKey
         WHERE t.TRANS_NUMBER > @firstTransNumber AND t.TRANS_NUMBER <= @lastTransNumber AND t.TRANSACTION_TYPE = 'DIST' AND t.SOURCE_SYSTEM = 'FR' AND t.JOURNAL_TYPE = 'IN' AND (t.SOURCE_CODE = '' OR t.SOURCE_CODE = 'WEB') AND am.AppealStatusCode = 0 -- 0 is Active
               AND NOT EXISTS(SELECT 1
                                FROM #tmpResponse
                               WHERE TransNumber = t.TRANS_NUMBER AND LineSub IS NULL AND SourceTable = 'T');
        --Keep only the lowest Line/SubLine for each transaction number
        DELETE tr
          FROM #tmpResponse tr
         WHERE SourceTable = 'T' AND LineSub > (SELECT MIN(LineSub)
                                                  FROM #tmpResponse
                                                 WHERE TransNumber = tr.TransNumber AND SourceTable = 'T');

        --Meeting Trans records with matching product and no explicit source code
        IF @debug = 1
        BEGIN
            PRINT 'Meeting Trans records with matching product and no explicit source code';
        END;
        INSERT INTO #tmpResponse(SourceTable,
                                 TransNumber,
                                 LineSub,
                                 ProductCode,
                                 Id,
                                 TransDate,
                                 InvoiceReferenceNum)
        SELECT DISTINCT 'T',
                        t.TRANS_NUMBER,
                        (t.LINE_NUMBER + t.SUB_LINE_NUMBER / 1000),
                        t.PRODUCT_CODE,
                        t.BT_ID,
                        t.TRANSACTION_DATE,
                        t.INVOICE_REFERENCE_NUM
          FROM Trans AS t
               INNER JOIN AppealProduct AS ap ON t.PRODUCT_CODE = ap.ProductCode
               INNER JOIN AppealMain AS am ON ap.AppealKey = am.AppealKey
         WHERE t.TRANS_NUMBER > @firstTransNumber AND t.TRANS_NUMBER <= @lastTransNumber AND t.TRANSACTION_TYPE = 'DIST' AND t.SOURCE_SYSTEM = 'MEETING' AND t.JOURNAL_TYPE = 'IN' AND (t.SOURCE_CODE = '' OR t.SOURCE_CODE = 'WEB') AND am.AppealStatusCode = 0 -- 0 is Active
               AND NOT EXISTS(SELECT 1
                                FROM #tmpResponse
                               WHERE TransNumber = t.TRANS_NUMBER AND LineSub IS NULL AND SourceTable = 'T');
        --Keep only the lowest Line/SubLine for each transaction number
        DELETE tr
          FROM #tmpResponse tr
         WHERE SourceTable = 'T' AND LineSub > (SELECT MIN(LineSub)
                                                  FROM #tmpResponse
                                                 WHERE TransNumber = tr.TransNumber AND SourceTable = 'T');
        IF @debug = 1
        BEGIN
            PRINT 'Order and Expo transactions with matching products and no explicit source code';
        END;
        --Order and Expo transactions with matching products and no explicit source code
        INSERT INTO #tmpResponse(SourceTable,
                                 TransNumber,
                                 LineSub,
                                 ProductCode,
                                 Id,
                                 TransDate,
                                 TotalRevenue)
        SELECT DISTINCT 'O',
                        ol.ORDER_NUMBER,
                        ol.LINE_NUMBER,
                        ol.PRODUCT_CODE,
                        o.BT_ID,
                        o.ORDER_DATE,
                        o.LINE_TOTAL
          FROM Orders AS o
               INNER JOIN Order_Lines AS ol ON o.ORDER_NUMBER = ol.ORDER_NUMBER
               INNER JOIN AppealProduct AS ap ON ol.PRODUCT_CODE = ap.ProductCode
               INNER JOIN AppealMain AS am ON ap.AppealKey = am.AppealKey
         WHERE o.ORDER_NUMBER > @firstOrderNumber AND o.ORDER_NUMBER <= @lastOrderNumber AND (o.SOURCE_CODE = '' OR o.SOURCE_CODE = 'WEB') AND am.AppealStatusCode = 0 -- 0 is Active
               -- bp 6/6/05 - Meetings tranactions will be handled separately
               AND o.SOURCE_SYSTEM <> 'MEETING' AND NOT EXISTS(SELECT 1
                                                                 FROM #tmpResponse
                                                                WHERE TransNumber = o.ORDER_NUMBER AND LineSub IS NULL AND SourceTable = 'O')
               -- Don't include premium donation orders
               AND NOT EXISTS(SELECT 1
                                FROM Donation_Premium
                               WHERE ORDER_NUMBER = o.ORDER_NUMBER);
        --Keep only the lowest Line for each order number
        DELETE tr
          FROM #tmpResponse tr
         WHERE SourceTable = 'O' AND LineSub > (SELECT MIN(LineSub)
                                                  FROM #tmpResponse
                                                 WHERE TransNumber = tr.TransNumber AND SourceTable = 'O');
    END;
    IF @debug = 1
    BEGIN
        PRINT 'Set the UserKey value';
    END;
    --Set the UserKey value
    -- EO 09-20-06 Unified Login changed this from UserMain to ContactMain
    UPDATE tr SET UserKey = cm.ContactKey
      FROM #tmpResponse tr
           INNER JOIN ContactMain cm ON tr.Id = cm.SyncContactID;

    -- Treat 'WEB' SourceCode as we would if no SourceCode was entered
    UPDATE #tmpResponse SET SourceCode = NULL
     WHERE SourceCode = 'WEB';

    IF @debug = 1
    BEGIN
        PRINT 'Attempt to find a match using the product and user';
    END;
    --Attempt to find a match using the product and user
    UPDATE tr SET SourceCode = (SELECT TOP 1 sc.Code
                                  FROM AppealProduct AS ap
                                       INNER JOIN vBoSolicitation AS s ON ap.AppealKey = s.AppealKey
                                       INNER JOIN vBoSourceCode AS sc ON s.SolicitationKey = sc.SolicitationKey
                                 WHERE ap.ProductCode = tr.ProductCode AND EXISTS(SELECT 1
                                                                                    FROM ListItem
                                                                                   WHERE ListKey = sc.SourceCodeKey AND ObjectKey = tr.UserKey) AND sc.LastDropDate = (SELECT MAX(sc2.LastDropDate)
                                                                                                                                                                         FROM AppealProduct AS ap2
                                                                                                                                                                              INNER JOIN vBoSolicitation AS s2 ON ap2.AppealKey = s2.AppealKey
                                                                                                                                                                              INNER JOIN vBoSourceCode AS sc2 ON s2.SolicitationKey = sc2.SolicitationKey
                                                                                                                                                                        WHERE ap2.ProductCode = tr.ProductCode))
      FROM #tmpResponse tr
     WHERE tr.SourceCode IS NULL;

    IF @debug = 1
    BEGIN
        PRINT 'Attempt to find a match just using the product';
    END;
    --Attempt to find a match just using the product
    -- use  the SourceCode with the Latest Drop Doate
    UPDATE tr SET SourceCode = (SELECT TOP 1 sc.Code
                                  FROM AppealProduct AS ap
                                       INNER JOIN vBoSolicitation AS s ON ap.AppealKey = s.AppealKey
                                       INNER JOIN vBoSourceCode AS sc ON s.SolicitationKey = sc.SolicitationKey
                                 WHERE ap.ProductCode = tr.ProductCode
                                 -- E0 09-21-06 
                                 -- I'm not sure how the following ever worked      
                                 --   and  sc.LastDropDate = (select max(sc2.LastDropDate)
                                 --   from AppealProduct ap2
                                 --   inner join vBoSolicitation s2 on ap2.AppealKey = s2.AppealKey
                                 --   inner join vBoSourceCode sc2 on s2.SolicitationKey = sc2.SolicitationKey
                                 --   where ap2.ProductCode = tr.ProductCode)
                                 -- changing it to this
                                 ORDER BY sc.LastDropDate),
                  WasSolicited = 0
      FROM #tmpResponse tr
     WHERE tr.SourceCode IS NULL;
    IF @debug = 1
    BEGIN
        PRINT 'Remove records without a source code';
    END;
    --Remove records without a source code
    DELETE #tmpResponse
     WHERE SourceCode IS NULL;
    PRINT 'Calculate revenue on records that originated from Trans (non-Dues)';
    --Calculate revenue on records that originated from Trans (non-Dues)
    UPDATE #tmpResponse SET TotalRevenue = (SELECT SUM(ISNULL(INVOICE_CHARGES, 0))
                                              FROM Trans
                                             -- DT16015 - If source code is explicitly associated with the Trans entry, make sure revenue
                                             --  is not attributed to another source code
                                             WHERE TRANS_NUMBER = #tmpResponse.TransNumber AND (SOURCE_CODE = #tmpResponse.SourceCode))
     WHERE SourceTable = 'T';
    IF @debug = 1
    BEGIN
        PRINT 'Calculate revenue on records that originated from Trans (Dues)'
    END;
    --Calculate revenue on records that originated from Trans (Dues)
    -- BP 6/9/05 - When calculating revenue, group Trans lines based on
    --       TRANS_NUMBER and SOURCE_CODE 
    -- BP 9/29/05 - DT 14640 - When calculating revenue, rather than using ABS(), multiply by -1, so negative payments are treated as negative revenue.
    UPDATE #tmpResponse SET TotalRevenue = (SELECT(SUM(AMOUNT)) * -1
                                              FROM Trans
                                             WHERE TRANS_NUMBER = #tmpResponse.TransNumber AND (SOURCE_CODE = #tmpResponse.SourceCode OR SOURCE_CODE = '') AND TRANSACTION_TYPE = 'DIST' AND SOURCE_SYSTEM IN('DUES', 'SC') AND JOURNAL_TYPE = 'PAY')
     WHERE SourceTable = 'D';

    IF OBJECT_ID('tempdb..#bySourceCode') IS NOT NULL DROP TABLE #bySourceCode
    CREATE TABLE #bySourceCode(SourceCode nvarchar(60) COLLATE DATABASE_DEFAULT,
                               TotalRevenue decimal(18, 4),
                               FirstResponse datetime,
                               LastResponse datetime,
                               LowResponse decimal(18, 4),
                               HighResponse decimal(18, 4),
                               TotalResponses int);

    -- BP 9/30/05 Modify source code aggregation so negative revenue rows are handled properly

    --Aggregate the responses by source code

    -- When calculating TotalRevenue we want to include negative revenue responses
    IF @debug = 1
    BEGIN
        PRINT 'Aggregate the responses by source code';
    END;
    INSERT INTO #bySourceCode
    SELECT SourceCode,
           SUM(ISNULL(TotalRevenue, 0)), -- TotalRevenue
           NULL, -- FirstResponse
           NULL, -- LastResponse
           NULL, -- LowResponse
           NULL, -- HighResponse
           0  -- TotalResponses
      FROM #tmpResponse
     GROUP BY SourceCode;

    -- BP 9/30/05 Remove negative revenue responses so that they aren't seen as responses
    -- when calculating FirstResponse, LastResponse, LowResponse HighResponse, and TotalResponses
    -- and creating/updating campaign and appeal participation records
    IF @debug = 1
    BEGIN
        PRINT 'Remove negative revenue responses so that they aren''t seen as responses';
    END;
    DELETE #tmpResponse
     WHERE TotalRevenue < 0;

    UPDATE #bySourceCode SET FirstResponse = (SELECT MIN(TransDate)
                                                FROM #tmpResponse
                                               WHERE #tmpResponse.SourceCode = #bySourceCode.SourceCode),
                             LastResponse = (SELECT MAX(TransDate)
                                               FROM #tmpResponse
                                              WHERE #tmpResponse.SourceCode = #bySourceCode.SourceCode),
                             LowResponse = (SELECT MIN(TotalRevenue)
                                              FROM #tmpResponse
                                             WHERE #tmpResponse.SourceCode = #bySourceCode.SourceCode),
                             HighResponse = (SELECT MAX(TotalRevenue)
                                               FROM #tmpResponse
                                              WHERE #tmpResponse.SourceCode = #bySourceCode.SourceCode)
      FROM #bySourceCode, #tmpResponse;

    -- BP 11/14/05 DT 16091
    -- When calculating TotalResponses we don't want to include past responses to 
    -- the same event by the same contact for the same SourceCode. Also, for multiple registrations to the same
    -- event by the same contact for the same SourceCode, we want to count as one response.
    --
    -- Remove past responses
    IF @debug = 1
    BEGIN
        PRINT 'Remove past responses';
    END;
    DELETE #tmpResponse
     WHERE EXISTS(SELECT *
                    FROM Trans
                   WHERE INVOICE_REFERENCE_NUM = #tmpResponse.InvoiceReferenceNum AND SOURCE_CODE = #tmpResponse.SourceCode AND TRANS_NUMBER <= @firstTransNumber);
    -- Calculate TotalResponses. Entries with the same InvoiceReferenceNum should
    -- be grouped together and only count as one response. Entries with 
    -- InvoiceReferenceNum = -1 are each counted as a response.
    UPDATE #bySourceCode SET TotalResponses = (SELECT COUNT(DISTINCT InvoiceReferenceNum)
                                                 FROM #tmpResponse
                                                WHERE #tmpResponse.SourceCode = #bySourceCode.SourceCode AND InvoiceReferenceNum <> -1) + (SELECT COUNT(*)
                                                                                                                                             FROM #tmpResponse
                                                                                                                                            WHERE #tmpResponse.SourceCode = #bySourceCode.SourceCode AND InvoiceReferenceNum = -1)
      FROM #bySourceCode, #tmpResponse;

    IF OBJECT_ID('tempdb..#byAppeal') IS NOT NULL DROP TABLE #byAppeal
    CREATE TABLE #byAppeal(CampaignKey uniqueidentifier,
                           AppealKey uniqueidentifier,
                           SolicitationKey uniqueidentifier,
                           SolicitationGroupKey uniqueidentifier,
                           UserKey uniqueidentifier,
                           WasSolicited tinyint);
    IF @debug = 1
    BEGIN
        PRINT 'Aggregate the responses by appeal and user';
    END;
    --Aggregate the responses by appeal and user
    INSERT INTO #byAppeal
    SELECT DISTINCT c.CampaignKey,
                    a.AppealKey,
                    s.SolicitationKey,
                    sc.SourceCodeKey,
                    tr.UserKey,
                    tr.WasSolicited
      FROM #tmpResponse AS tr
           INNER JOIN vBoSourceCode AS sc ON tr.SourceCode = sc.Code
           INNER JOIN vBoSolicitation AS s ON sc.SolicitationKey = s.SolicitationKey
           INNER JOIN vBoAppeal AS a ON s.AppealKey = a.AppealKey
           INNER JOIN vBoCampaign AS c ON a.CampaignKey = c.CampaignKey;

    --Allow only one record per Appeal and User combination
    SET ROWCOUNT 1;

    DECLARE @appealKey uniqueidentifier;
    DECLARE @campaignKey uniqueidentifier;
    DECLARE @respondentUserKey uniqueidentifier;

    SELECT @appealKey = AppealKey,
           @campaignKey = CampaignKey,
           @respondentUserKey = UserKey
      FROM #byAppeal
     GROUP BY CampaignKey,
              AppealKey,
              UserKey
     HAVING COUNT(*) > 1;
    WHILE @@ROWCOUNT > 0
    BEGIN
        DELETE #byAppeal
         WHERE AppealKey = @appealKey AND CampaignKey = @campaignKey AND UserKey = @respondentUserKey;
        SELECT @appealKey = AppealKey,
               @campaignKey = CampaignKey,
               @respondentUserKey = UserKey
          FROM #byAppeal
         GROUP BY CampaignKey,
                  AppealKey,
                  UserKey
         HAVING COUNT(*) > 1;
    END;

    SET ROWCOUNT 0;

    BEGIN TRANSACTION;

    --Update SourceCode
    IF @debug = 1
    BEGIN
        PRINT 'Update SourceCOde';
    END;

    UPDATE sg SET TotalRevenue = sg.TotalRevenue + bsc.TotalRevenue,
                  FirstResponseDate = CASE WHEN sg.FirstResponseDate IS NULL
                                           THEN bsc.FirstResponse WHEN bsc.FirstResponse IS NULL
                                           THEN sg.FirstResponseDate WHEN bsc.FirstResponse < sg.FirstResponseDate
                                           THEN bsc.FirstResponse
                                           ELSE sg.FirstResponseDate
                                      END,
                  LastResponseDate = CASE WHEN sg.LastResponseDate IS NULL
                                          THEN bsc.LastResponse WHEN bsc.LastResponse IS NULL
                                          THEN sg.LastResponseDate WHEN bsc.LastResponse > sg.LastResponseDate
                                          THEN bsc.LastResponse
                                          ELSE sg.LastResponseDate
                                     END,
                  LowResponseAmount = CASE WHEN sg.LowResponseAmount < 0
                                           THEN bsc.LowResponse WHEN bsc.LowResponse < 0
                                           THEN sg.LowResponseAmount WHEN bsc.LowResponse < sg.LowResponseAmount
                                           THEN bsc.LowResponse
                                           ELSE sg.LowResponseAmount
                                      END,
                  HighResponseAmount = CASE WHEN bsc.HighResponse > sg.HighResponseAmount
                                            THEN bsc.HighResponse
                                            ELSE sg.HighResponseAmount
                                       END,
                  TotalPositiveResponse = sg.TotalPositiveResponse + bsc.TotalResponses,
                  ResponsesTotalledOn = @now,
                  UpdatedOn = @now,
                  UpdatedByUserKey = @userKey
      FROM SourceCode sg
           INNER JOIN #bySourceCode bsc ON sg.Code = bsc.SourceCode;

    -- DT 16091 - Don't attempt to create appeal or campaign participation entries if the User is unknown. This can happen when a new contact
    -- is registered for an event and is not added to the db.
    DELETE FROM #byAppeal
     WHERE UserKey IS NULL;
    --Create campaign opt-in
    IF @debug = 1
    BEGIN
        PRINT 'Create campaign opt-in';
    END;
    INSERT INTO CampaignParticipation(CampaignParticipationKey,
                                      CampaignKey,
                                      RespondentUserKey,
                                      ResponseTypeCode,
                                      CreatedByUserKey,
                                      CreatedOn,
                                      UpdatedByUserKey,
                                      UpdatedOn)
    SELECT NEWID(),
           CampaignKey,
           UserKey,
           1,
           @userKey,
           @now,
           @userKey,
           @now -- UnsolicitedResponse = Opt-In = ResponseStatus of one (1)
      FROM #byAppeal AS ba
     WHERE NOT EXISTS(SELECT 1
                        FROM CampaignParticipation
                       WHERE CampaignKey = ba.CampaignKey AND RespondentUserKey = ba.UserKey);

    IF @debug = 1
    BEGIN
        PRINT 'Update appeal participation';
    END;
    --Update appeal participation
    UPDATE ap SET SolicitationKey = ba.SolicitationKey,
                  AppealKey = ba.AppealKey,
                  ResponseTypeCode = CASE WHEN WasSolicited = 1
                                          THEN 0
                                          ELSE 1
                                     END,
                  UpdatedOn = @now,
                  UpdatedByUserKey = @userKey
      FROM AppealParticipation ap
           INNER JOIN #byAppeal ba ON ap.AppealKey = ba.AppealKey AND ap.RespondentUserKey = ba.UserKey;
    IF @debug = 1
    BEGIN
        PRINT 'Create appeal participation';
    END;
    --Create appeal participation
    INSERT INTO AppealParticipation(AppealParticipationKey,
                                    AppealKey,
                                    RespondentUserKey,
                                    SolicitationKey,
                                    ResponseTypeCode,
                                    CreatedByUserKey,
                                    CreatedOn,
                                    UpdatedByUserKey,
                                    UpdatedOn,
                                    SourceCodeKey)
    SELECT NEWID(),
           ba.AppealKey,
           ba.UserKey,
           ba.SolicitationKey,
           CASE WHEN WasSolicited = 1
                THEN 0
                ELSE 1
           END,
           @userKey,
           @now,
           @userKey,
           @now,
           SolicitationGroupKey --SolicitedResponse = Responded = ResponseStatus of zero (0)
      FROM #byAppeal AS ba
     --INNER JOIN SourceCode SC ON SC.Code = ba.SourceCode
     WHERE NOT EXISTS(SELECT 1
                        FROM AppealParticipation
                       WHERE AppealKey = ba.AppealKey AND RespondentUserKey = ba.UserKey);

    COMMIT TRANSACTION;

    IF OBJECT_ID('tempdb..#byAppeal') IS NOT NULL DROP TABLE #byAppeal;
    IF OBJECT_ID('tempdb..#bySourceCode') IS NOT NULL DROP TABLE #bySourceCode;
    IF OBJECT_ID('tempdb..#tmpResponse') IS NOT NULL DROP TABLE #tmpResponse;
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentGetLatestKey]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentGetLatestKey]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- gets the "latest" document key given a DocumentKey or a DocumentVersionKey.  If key is DocumentKey
-- that same DocumentKey is returned.  If key is a DocumentVersionKey, returns the DocumentKey of the
-- document with the lowest status (e.g., prefers working over published, published over archived, etc.)
-- and the most recent date
CREATE PROCEDURE [dbo].[asi_DocumentGetLatestKey] 
    @key uniqueidentifier, 
    @documentKey uniqueidentifier OUT 
AS
BEGIN
   SELECT TOP 1 @documentKey = DocumentKey
     FROM DocumentMain
    WHERE DocumentKey = @key OR DocumentVersionKey = @key
    ORDER BY DocumentStatusCode ASC, UpdatedOn DESC
END


GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_HierarchyResort2]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_HierarchyResort2]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- Resets the SortOrder column on all records within a given Root Hierarchy so that each is a multiple
-- of 1024.  This allows for 12 worst case inserts before a resort is needed.
CREATE PROCEDURE [dbo].[asi_HierarchyResort2] @rootHierarchyKey uniqueidentifier 
AS
BEGIN
    DECLARE @NewSortOrder int
    DECLARE @RootHierarchyKeyVal uniqueidentifier

    SET NOCOUNT ON

    DECLARE @hierarchy TABLE (HierarchyKey uniqueidentifier, OldSortOrder int, NewSortOrder int IDENTITY(1024, 1024))

    INSERT INTO @hierarchy (HierarchyKey, OldSortOrder)
        SELECT HierarchyKey, SortOrder
          FROM Hierarchy
         WHERE RootHierarchyKey = @rootHierarchyKey
      ORDER BY SortOrder

    UPDATE h
       SET h.[SortOrder] = h2.[NewSortOrder]
      FROM [dbo].[Hierarchy] h INNER JOIN @hierarchy h2 ON h.[HierarchyKey] = h2.[HierarchyKey]
     WHERE h.[SortOrder] = h2.[OldSortOrder]
        

    SET NOCOUNT OFF
END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_HierarchyGetFolderSortOut]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_HierarchyGetFolderSortOut]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


-- Given the HierarchyKey of the parent folder, gets a sort order that will put the new folder in alphabetical order.
-- if the parent folder does not exist in the db (i.e., it is only in memory at this point) rootHierarchyKey and
-- parentFolderSortOrder will be used to determine the new sort order.
CREATE PROCEDURE [dbo].[asi_HierarchyGetFolderSortOut] 
   @parentFolderHierarchyKey uniqueidentifier, 
   @rootHierarchyKey uniqueidentifier, 
   @parentFolderSortOrder int, 
   @parentFolderDepth int,
   @newFolderName nvarchar(100), 
   @newSort int OUTPUT 
AS
BEGIN
    DECLARE @lowSort int
    DECLARE @highSort int
    DECLARE @lowDocumentName nvarchar(100)
    DECLARE @Run int

    SET @Run = 0
    WHILE @Run < 2
    BEGIN
        -- find the top end of the sort range.  Which is from the next folder up in the tree from where we want to be
        SELECT @highSort = Min(SortOrder)
          FROM Hierarchy a INNER JOIN DocumentMain b
            ON a.UniformKey = b.DocumentVersionKey AND b.DocumentStatusCode = 40
         WHERE (a.ParentHierarchyKey = @parentFolderHierarchyKey
           AND b.DocumentName > @newFolderName
           AND b.DocumentTypeCode = 'FOL')
            OR (a.ParentHierarchyKey = @parentFolderHierarchyKey
           AND a.SortOrder > @parentFolderSortOrder
           AND a.Depth <= @parentFolderDepth)

        -- if there is nothing higher (i.e., this is at the very end of the tree), just get the tree's max + 1024
        IF @highSort IS NULL
            SELECT @highSort = IsNull(Max(SortOrder),0) + 1024
              FROM Hierarchy
             WHERE RootHierarchyKey = @rootHierarchyKey

        -- find the highest sort order below our high.  That will be the low
        SELECT @lowSort = IsNull(Max(SortOrder),0)
          FROM Hierarchy
         WHERE RootHierarchyKey = @rootHierarchyKey
           AND SortOrder < @highSort

        IF @lowSort < @parentFolderSortOrder
        BEGIN
            IF @Run = 0
                SET @lowSort = @parentFolderSortOrder
            ELSE
            BEGIN
                SET @lowSort = @parentFolderSortOrder
                IF @highSort - @lowSort < 2
                    SET @highSort = @lowSort + 2
            END
        END

        -- if there is no room between the low and the high, need to redo the sort order for this root
        IF @highSort - @lowSort < 2
        BEGIN
            EXEC asi_HierarchyResort2 @rootHierarchyKey

            -- get the sort again in case it has changed
            SELECT @parentFolderSortOrder = SortOrder FROM Hierarchy WHERE HierarchyKey = @parentFolderHierarchyKey
            SET @Run = @Run + 1
        END
        ELSE
            SET @Run = 2
    END
    SET @newSort = ((@highSort - @lowSort) / 2) + @lowSort
END


GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentLinkDocumentOut]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentLinkDocumentOut]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- links a document into a folder using the hierarchy.  The FolderHierarchyKey points to the parent folder
CREATE PROCEDURE [dbo].[asi_DocumentLinkDocumentOut]
   @folderHierarchyKey uniqueidentifier,
   @documentVersionKey uniqueidentifier,
   @hierarchyKey uniqueidentifier OUTPUT
AS
DECLARE 
   @sortOrder int,
   @documentTypeCode nvarchar(3),
   @documentName nvarchar(100),
   @rootHierarchyKey uniqueidentifier,
   @parentFolderSortOrder int,
   @parentFolderDepth int
BEGIN
   -- first check to see if such a link already exists, if not, then build it
   SELECT @hierarchyKey = HierarchyKey
     FROM Hierarchy
    WHERE ParentHierarchyKey = @folderHierarchyKey
      AND UniformKey = @documentVersionKey

   IF @hierarchyKey IS NULL
   BEGIN
      SET @sortOrder = null
      SET @hierarchyKey = NewID()

      -- see if the doc to be linked is a folder.  If so, it needs a new sort order
      SELECT TOP 1 @documentTypeCode = DocumentTypeCode,
             @documentName = DocumentName
        FROM DocumentMain
       WHERE DocumentVersionKey = @documentVersionKey
       ORDER BY UpdatedOn DESC

      IF @documentTypeCode IN ('FOL','CFL','NAV')
      BEGIN
         SELECT @rootHierarchyKey = RootHierarchyKey,
                @parentFolderSortOrder = SortOrder,
                @parentFolderDepth = Depth
           FROM Hierarchy
          WHERE HierarchyKey = @folderHierarchyKey

          exec asi_HierarchyGetFolderSortOut @folderHierarchyKey, @rootHierarchyKey, @parentFolderSortOrder, @parentFolderDepth, @documentName, @sortOrder OUT
      END

      INSERT INTO Hierarchy (
             HierarchyKey, 
             RootHierarchyKey, 
             ParentHierarchyKey, 
             SortOrder, 
             Depth, 
             UniformType,
             UniformKey,
             IsChildAMemberOfParent)
      SELECT @hierarchyKey,
             RootHierarchyKey,
             HierarchyKey, 
             ISNULL(@sortOrder,SortOrder), 
             Depth + 1, 
             UniformType,
             @documentVersionKey,
             IsChildAMemberOfParent
        FROM Hierarchy
       WHERE HierarchyKey = @folderHierarchyKey

      IF @@ROWCOUNT = 0
         SET @hierarchyKey = NULL
   END
END


GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentLinkDocument]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentLinkDocument]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- links a document into a folder using the hierarchy.  The FolderHierarchyKey points to the parent folder
CREATE PROCEDURE [dbo].[asi_DocumentLinkDocument]
   @folderHierarchyKey uniqueidentifier,
   @documentVersionKey uniqueidentifier
AS
DECLARE 
   @hierarchyKey uniqueidentifier
BEGIN
   exec asi_DocumentLinkDocumentOut @folderHierarchyKey, @documentVersionKey, @hierarchyKey output
   -- return the key found or created
   SELECT @hierarchyKey AS HierarchyKey
END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentCreateCopy]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentCreateCopy]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

----------------------------------------------------------------------------------------------------------------------------------
-- Creates a copy of the document given by key in the folder given by FolderHierarchyKey
-- Key can be either a DocumentKey or a DocumentVersionKey.  If the latter, copies the 
-- latest version available
-- IsSystem is defaulted to false when creating a copy even if copying an IsSystem=true item.
----------------------------------------------------------------------------------------------------------------------------------
CREATE PROCEDURE [dbo].[asi_DocumentCreateCopy]
    @folderHierarchyKey uniqueidentifier,
    @key uniqueidentifier,
    @userKey uniqueidentifier,
    @loggedInUserGroupKey uniqueidentifier = '00000000-0000-0000-0000-000000000000', -- if this is empty, we assume the user is not logged in
    @documentName nvarchar(100) = null
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @newDocumentKey uniqueidentifier;
    DECLARE @newDocumentVersionKey uniqueidentifier;
    DECLARE @newAccessKey uniqueidentifier;
    DECLARE @documentKey uniqueidentifier
    DECLARE @accessKey uniqueidentifier;
    DECLARE @now datetime;

    SET @now = dbo.asi_GetAppDatetime();
    SET @newDocumentKey = NEWID();
    SET @newDocumentVersionKey = NEWID();

    -- create the UniformRegistry entry first
    INSERT INTO UniformRegistry (UniformKey, ComponentKey)
        SELECT @newDocumentKey, ComponentKey
          FROM ComponentRegistry
         WHERE Name = N'Document'
           AND InterfaceName = N'BusinessController';

    -- then the UniformRegistry entry for the version key
    INSERT INTO UniformRegistry (UniformKey, ComponentKey)
        SELECT @newDocumentVersionKey, ComponentKey
          FROM ComponentRegistry
         WHERE Name = N'DocumentVersion'
           AND InterfaceName = N'BusinessController';

    -- get the latest document key
    EXEC dbo.asi_DocumentGetLatestKey @key, @documentKey OUT;

    -- copy the AccessKeys if necessary
    SELECT @accessKey = [AccessKey] FROM [dbo].[DocumentMain] WHERE [DocumentKey] = @documentKey;
    SET @newAccessKey = @accessKey;
    IF EXISTS (SELECT 1 FROM [dbo].[AccessMain] WHERE [AccessKey] = @accessKey AND [AccessScope] = N'Local') 
    BEGIN
        -- We have custom/local security, so we need to copy the access keys first before copying the document
        SET @newAccessKey = NEWID();
        -- Copy the AccessMain Row
        INSERT INTO [dbo].[AccessMain] (AccessKey, AccessScope, CreatedByUserKey, CreatedOn, UpdatedByUserKey, UpdatedOn)
            SELECT @newAccessKey, [AccessScope], @userKey, @now, @userKey, @now 
              FROM [dbo].[AccessMain] WHERE [AccessKey] = @accessKey;
        -- Copy all AccessItem Rows
        INSERT INTO [dbo].[AccessItem] (AccessKey, Grantee, Permission, GroupKey, RoleKey, UserKey)
            SELECT @newAccessKey, [Grantee], [Permission], [GroupKey], [RoleKey], [UserKey] 
              FROM [dbo].[AccessItem] WHERE [AccessKey] = @accessKey;
    END

    -- then create the copy
    INSERT INTO [dbo].[DocumentMain] (
          DocumentKey,
          DocumentTypeCode,
          DocumentName,
          DocumentVersionKey,
          DocumentStatusCode,
          DocumentCode,
          AlternateName,
          Blob,
          IsSystem,
          AccessKey,
          DefaultChildAccessKey,
          DocumentDescription,
          ContainsChildrenFlag,
          BranchedFromDocumentKey,
          RelatedDocumentVersionKey,
          StatusUpdatedByUserKey,
          StatusUpdatedOn,
          UpdatedByUserKey,
          UpdatedOn,
          CreatedByUserKey,
          CreatedOn)
    SELECT @newDocumentKey,
           a.DocumentTypeCode,
           ISNULL(@documentName, a.DocumentName),
           @newDocumentVersionKey,
           CASE b.TrackVersionsFlag WHEN 0 THEN 40 ELSE 10 END,
           a.DocumentCode,
           a.AlternateName,
           a.Blob,
           0, -- a.IsSystem, -- Creating a copy of a system item should not be automatically set to IsSystem=true
           @newAccessKey,
           a.DefaultChildAccessKey,
           a.DocumentDescription,
           a.ContainsChildrenFlag,
           a.DocumentKey,
           a.RelatedDocumentVersionKey,
           @userKey,
           @now,
           @userKey,
           @now,
           @userKey,
           @now
      FROM [dbo].[DocumentMain] a 
           INNER JOIN [dbo].[DocumentTypeRef] b ON a.[DocumentTypeCode] = b.[DocumentTypeCode]
     WHERE a.DocumentKey = @documentKey
       AND EXISTS(SELECT 1 
                    FROM AccessItem INNER JOIN UserToken ON AccessItem.Grantee = UserToken.Grantee
                   WHERE AccessItem.AccessKey = a.AccessKey 
                     AND UserToken.UserKey = @userKey 
                     AND (AccessItem.Permission & 3) > 0
                  )

    -- link the new copy into the specified folder
    EXEC dbo.asi_DocumentLinkDocument @folderHierarchyKey, @newDocumentVersionKey
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentCreateCopyWithAlternateName]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentCreateCopyWithAlternateName]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

----------------------------------------------------------------------------------------------------------------------------------
-- Creates a copy of the document given by key in the folder given by FolderHierarchyKey
-- Key can be either a DocumentKey or a DocumentVersionKey.  If the latter, copies the 
-- latest version available
-- IsSystem is defaulted to false when creating a copy even if copying an IsSystem=true item.
----------------------------------------------------------------------------------------------------------------------------------
CREATE PROCEDURE [dbo].[asi_DocumentCreateCopyWithAlternateName]
    @folderHierarchyKey uniqueidentifier,
    @key uniqueidentifier,
    @userKey uniqueidentifier,
    @loggedInUserGroupKey uniqueidentifier = '00000000-0000-0000-0000-000000000000', -- if this is empty, we assume the user is not logged in
    @documentName nvarchar(100) = null,
    @alternateName nvarchar(100) = null
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @newDocumentKey uniqueidentifier;
    DECLARE @newDocumentVersionKey uniqueidentifier;
    DECLARE @newAccessKey uniqueidentifier;
    DECLARE @documentKey uniqueidentifier;
    DECLARE @accessKey uniqueidentifier;
    DECLARE @now datetime;

    SET @now = dbo.asi_GetAppDatetime();
    SET @newDocumentKey = NEWID();
    SET @newDocumentVersionKey = NEWID();

    -- create the UniformRegistry entry first
    INSERT INTO UniformRegistry (UniformKey, ComponentKey)
        SELECT @newDocumentKey, ComponentKey
          FROM ComponentRegistry
         WHERE Name = N'Document'
           AND InterfaceName = N'BusinessController';

    -- then the UniformRegistry entry for the version key
    INSERT INTO UniformRegistry (UniformKey, ComponentKey)
        SELECT @newDocumentVersionKey, ComponentKey
          FROM ComponentRegistry
         WHERE Name = N'DocumentVersion'
           AND InterfaceName = N'BusinessController';
      
    -- get the latest document key
    EXEC dbo.asi_DocumentGetLatestKey @key, @documentKey OUT;

    -- copy the AccessKeys if necessary
    SELECT @accessKey = [AccessKey] FROM [dbo].[DocumentMain] WHERE [DocumentKey] = @documentKey;
    SET @newAccessKey = @accessKey;
    IF EXISTS (SELECT 1 FROM [dbo].[AccessMain] WHERE [AccessKey] = @accessKey AND [AccessScope] = N'Local') 
    BEGIN
        -- We have custom/local security, so we need to copy the access keys first before copying the document
        SET @newAccessKey = NEWID();
        -- Copy the AccessMain Row
        INSERT INTO [dbo].[AccessMain] (AccessKey, AccessScope, CreatedByUserKey, CreatedOn, UpdatedByUserKey, UpdatedOn)
            SELECT @newAccessKey, [AccessScope], @userKey, @now, @userKey, @now 
              FROM [dbo].[AccessMain] WHERE [AccessKey] = @accessKey;
        -- Copy all AccessItem Rows
        INSERT INTO [dbo].[AccessItem] (AccessKey, Grantee, Permission, GroupKey, RoleKey, UserKey)
            SELECT @newAccessKey, [Grantee], [Permission], [GroupKey], [RoleKey], [UserKey] 
              FROM [dbo].[AccessItem] WHERE [AccessKey] = @accessKey;
    END

    -- then create the copy
    INSERT INTO [dbo].[DocumentMain] (
          DocumentKey,
          DocumentTypeCode,
          DocumentName,
          DocumentVersionKey,
          DocumentStatusCode,
          DocumentCode,
          AlternateName,
          Blob,
          IsSystem,
          AccessKey,
          DefaultChildAccessKey,
          DocumentDescription,
          ContainsChildrenFlag,
          BranchedFromDocumentKey,
          RelatedDocumentVersionKey,
          StatusUpdatedByUserKey,
          StatusUpdatedOn,
          UpdatedByUserKey,
          UpdatedOn,
          CreatedByUserKey,
          CreatedOn)
    SELECT @newDocumentKey,
           a.DocumentTypeCode,
           ISNULL(@documentName, a.DocumentName),
           @newDocumentVersionKey,
           CASE b.TrackVersionsFlag WHEN 0 THEN 40 ELSE 10 END,
           a.DocumentCode,
           ISNULL(@alternateName, a.AlternateName),
           a.Blob,
           0, -- a.IsSystem, -- Creating a copy of a system item should not be automatically set to IsSystem=true
           @newAccessKey,
           a.DefaultChildAccessKey,
           a.DocumentDescription,
           a.ContainsChildrenFlag,
           a.DocumentKey,
           a.RelatedDocumentVersionKey,
           @userKey,
           @now,
           @userKey,
           @now,
           @userKey,
           @now
      FROM [dbo].[DocumentMain] a 
           INNER JOIN [dbo].[DocumentTypeRef] b ON a.[DocumentTypeCode] = b.[DocumentTypeCode]
     WHERE a.DocumentKey = @documentKey
       AND EXISTS(SELECT 1 
                    FROM AccessItem INNER JOIN UserToken ON AccessItem.Grantee = UserToken.Grantee
                   WHERE AccessItem.AccessKey = a.AccessKey 
                     AND UserToken.UserKey = @userKey 
                     AND (AccessItem.Permission & 3) > 0
                  )

    -- link the new copy into the specified folder
    EXEC dbo.asi_DocumentLinkDocument @folderHierarchyKey, @newDocumentVersionKey
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentCreateShortcut]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentCreateShortcut]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- creates a shortcut to the document given by DocumentVersionKey
-- in the folder given by FolderHierarchyKey
CREATE PROCEDURE [dbo].[asi_DocumentCreateShortcut]
   @folderHierarchyKey uniqueidentifier,
   @documentVersionKey uniqueidentifier,
   @userKey uniqueidentifier
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @newDocumentKey uniqueidentifier;
    DECLARE @newDocumentVersionKey uniqueidentifier;
    DECLARE @documentKey uniqueidentifier;
    DECLARE @now datetime;

    SELECT @newDocumentKey = NEWID();
    SELECT @newDocumentVersionKey = NEWID();

    -- create the UniformRegistry entry first
    INSERT INTO UniformRegistry (UniformKey, ComponentKey)
        SELECT @newDocumentKey, ComponentKey
          FROM ComponentRegistry
         WHERE Name = 'Document'
           AND InterfaceName = 'BusinessController';

    -- then the UniformRegistry entry for the version key
    INSERT INTO UniformRegistry (UniformKey, ComponentKey)
    SELECT @newDocumentVersionKey, ComponentKey
      FROM ComponentRegistry
     WHERE Name = 'DocumentVersion'
       AND InterfaceName = 'BusinessController';

    -- make sure we get the latest one to shortcut to
    EXEC asi_DocumentGetLatestKey @documentVersionKey, @documentKey OUT;

    SELECT @now = dbo.asi_GetAppDatetime();

    -- then create the shortcut document
    INSERT INTO DocumentMain (
          DocumentKey,
          DocumentTypeCode,
          DocumentName,
          DocumentVersionKey,
          DocumentStatusCode,
          AlternateName,
          IsSystem,
          AccessKey,
          ContainsChildrenFlag,
          RelatedDocumentVersionKey,
          StatusUpdatedByUserKey,
          StatusUpdatedOn,
          UpdatedByUserKey,
          UpdatedOn,
          CreatedByUserKey,
          CreatedOn)
    SELECT @newDocumentKey,
          'SRT',
          DocumentName,
          @newDocumentVersionKey,
          40,
          AlternateName,
          0,
          AccessKey,
          0,
          @documentVersionKey,
          @userKey,
          @now,
          @userKey,
          @now,
          @userKey,
          @now
     FROM [dbo].[DocumentMain]
    WHERE DocumentKey = @documentKey

    -- if it worked, link it in.  If not, return null
    IF @@ROWCOUNT = 1
        EXEC asi_DocumentLinkDocument @folderHierarchyKey, @newDocumentVersionKey;
    ELSE
        SELECT NULL;
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentDeleteDocument]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentDeleteDocument]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- Deletes a document that is either a leaf node in a hierarchy, or a document not participating
-- in a hierarchy (a stand alone document).  This procedure takes into account any custom access
-- control, as well as whether the document is versioned or not.  This Stored Procedure should not
-- be called directly; it is called by asi_DocumentDelete or asi_DocumentDeleteHierarchy.
CREATE PROCEDURE [dbo].[asi_DocumentDeleteDocument] 
    @documentVersionKey uniqueidentifier,
    @purgeVersions bit = 0
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @documentKey uniqueidentifier;
    DECLARE @accessKey uniqueidentifier;
    DECLARE @isVersioned bit;
    DECLARE @publishedVersionExists bit;
    DECLARE @now datetime;
    
    SELECT @now = dbo.asi_GetAppDatetime();

    SET @publishedVersionExists = 1;
    
    SELECT @documentKey = d.[DocumentKey], @accessKey = d.[AccessKey], @isVersioned = t.[TrackVersionsFlag]
      FROM [dbo].[DocumentMain] d INNER JOIN [dbo].[DocumentTypeRef] t ON d.[DocumentTypeCode] = t.[DocumentTypeCode]
     WHERE d.[DocumentVersionKey] = @documentVersionKey AND d.[DocumentStatusCode] IN (40,60);

    IF @documentKey IS NULL -- Could not find a published version
    BEGIN
        SET @publishedVersionExists = 0
        IF EXISTS (SELECT 1 FROM [dbo].[DocumentMain] d WHERE d.[DocumentVersionKey] = @documentVersionKey)
        BEGIN
            SET @isVersioned = 1;
        END
    END

    IF @isVersioned = 1
    BEGIN
        IF @purgeVersions = 0
        BEGIN
            -- Versioned document... just Recycle it
            UPDATE [dbo].[DocumentMain] 
               SET [DocumentStatusCode] = 80,
                   [StatusUpdatedOn] = @now
             WHERE [DocumentKey] = @documentKey;
        END
        ELSE
        BEGIN
            -- Versioned document... purge all versions
            DECLARE @documents TABLE (DocumentKey uniqueidentifier NOT NULL);
            INSERT INTO @documents
                SELECT [DocumentKey] FROM [dbo].[DocumentMain] d WHERE d.[DocumentVersionKey] = @documentVersionKey;
                
            DELETE FROM [dbo].[Hierarchy] WHERE [UniformKey] = @documentVersionKey;
            DELETE prd FROM @documents d INNER JOIN [dbo].[PublishRequestDetail] prd ON d.[DocumentKey] = prd.[ContentDocumentKey];
            DELETE dm FROM @documents d INNER JOIN [dbo].[DocumentMain] dm ON d.[DocumentKey] = dm.[DocumentKey];
            EXEC [dbo].[asi_AccessKeyDelete] @accessKey;
            DELETE FROM [dbo].[UniformTag] WHERE [UniformKey] = @documentVersionKey;
            DELETE FROM [dbo].[UniformRegistry] WHERE [UniformKey] = @documentVersionKey;
            DELETE u FROM @documents d INNER JOIN [dbo].[UniformRegistry] u ON d.[DocumentKey] = u.[UniformKey];
            DELETE FROM [dbo].[UniformLicense] WHERE [UniformKey] = @documentVersionKey;
        END
    END
    ELSE IF @documentKey IS NOT NULL
    BEGIN
        -- Non-versioned document... delete all references
        DELETE FROM [dbo].[Hierarchy] WHERE [UniformKey] = @documentVersionKey;
        EXEC [dbo].[asi_AccessKeyDelete] @accessKey;
        DELETE FROM [dbo].[PublishRequestDetail] WHERE [ContentDocumentKey] = @documentKey;
        DELETE FROM [dbo].[DocumentMain] WHERE [DocumentVersionKey] = @documentVersionKey;
        DELETE FROM [dbo].[UniformTag] WHERE [UniformKey] = @documentVersionKey;
        DELETE FROM [dbo].[UniformRegistry] WHERE [UniformKey] = @documentKey;
        DELETE FROM [dbo].[UniformRegistry] WHERE [UniformKey] = @documentVersionKey;
        DELETE FROM [dbo].[UniformLicense] WHERE [UniformKey] = @documentVersionKey;
    END
    
    SET NOCOUNT OFF
END


GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentDeleteHierarchy]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentDeleteHierarchy]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- Recursively deletes all children of the specified hierarchy key.  After this function returns,
-- all child documents, along with all associated hierarchy keys, will be deleted, resulting
-- in just a leaf-node, which can then be deleted by asi_DocumentDeleteDocument.
CREATE PROCEDURE [dbo].[asi_DocumentDeleteHierarchy] 
    @hierarchyKey uniqueidentifier,
    @purgeVersions bit = 0
AS
BEGIN
    SET NOCOUNT ON
    DECLARE @ChildrenTable TABLE
    (
        [HierarchyKey] uniqueidentifier,
        [DocumentVersionKey] uniqueidentifier
    )

    INSERT INTO @ChildrenTable
        SELECT h.[HierarchyKey], d.[DocumentVersionKey]
          FROM [dbo].[Hierarchy] h 
               INNER JOIN [dbo].[DocumentMain] d ON h.UniformKey = d.[DocumentVersionKey] 
         WHERE h.[ParentHierarchyKey] = @hierarchyKey

    DECLARE @childHierarchyKey uniqueidentifier
    DECLARE @documentVersionKey uniqueidentifier

    WHILE EXISTS (SELECT 1 FROM @ChildrenTable)
    BEGIN
        SELECT TOP 1 @childHierarchyKey = HierarchyKey, @documentVersionKey = DocumentVersionKey FROM @ChildrenTable
        EXEC [asi_DocumentDeleteHierarchy] @childHierarchyKey, @purgeVersions
        EXEC [asi_DocumentDeleteDocument] @documentVersionKey, @purgeVersions
        DELETE FROM @ChildrenTable WHERE HierarchyKey = @childHierarchyKey
    END
    SET NOCOUNT OFF
END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- Deletes the specified document (and potentially all child documents if the document is involved
-- in a hierarchy).  
CREATE PROCEDURE [dbo].[asi_DocumentDelete] 
    @documentVersionKey uniqueidentifier, 
    @purgeVersions bit = 0
AS
BEGIN
    SET NOCOUNT ON
    DECLARE @hierarchyKey uniqueidentifier

    -- Get the hierarchy key
    SELECT @hierarchyKey = HierarchyKey FROM [dbo].[Hierarchy] 
     WHERE UniformKey = @documentVersionKey

    IF (@hierarchyKey IS NOT NULL)
        EXEC [dbo].[asi_DocumentDeleteHierarchy] @hierarchyKey, @purgeVersions
    EXEC [dbo].[asi_DocumentDeleteDocument] @documentVersionKey, @purgeVersions
    SET NOCOUNT OFF
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentDescendantKeys]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentDescendantKeys]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

----------------------------------------------------------------------------------------------------------------------------------
-- Retrieves a list of all of the DocumentVersionKeys for all documents that are descendants of the provided folder key 
-- (i.e. its children, children's children, etc).
----------------------------------------------------------------------------------------------------------------------------------
CREATE PROCEDURE [dbo].[asi_DocumentDescendantKeys]
(
    @hierarchyKey uniqueidentifier,
    @userKey uniqueidentifier,
    @loggedInUserGroupKey uniqueidentifier = '00000000-0000-0000-0000-000000000000', -- if this is empty, we assume the user is not logged in
    @publishedOnly bit = 1,
    @ignoreLicensing bit = 0
)
AS
BEGIN
    DECLARE @descendants TABLE
    (
        [RootHierarchyKey] uniqueidentifier,
        [HierarchyKey] uniqueidentifier,
        [DocumentVersionKey] uniqueidentifier,
        [DocumentKey] uniqueidentifier,
        [AccessKey] uniqueidentifier
    )

    INSERT INTO @descendants
        SELECT h.[RootHierarchyKey], h.[HierarchyKey], d.[DocumentVersionKey], d.[DocumentKey], d.[AccessKey]
          FROM [dbo].[Hierarchy] h
               INNER JOIN [dbo].[DocumentMain] d ON h.[UniformKey] = d.[DocumentVersionKey]
         WHERE h.[ParentHierarchyKey] = @hierarchyKey
           AND ((@publishedOnly = 1 AND d.[DocumentStatusCode] IN (40,60)) 
                OR
                (@publishedOnly = 0 AND d.DocumentKey IN (SELECT TOP 1 [DocumentKey] FROM [dbo].[DocumentMain] WHERE [DocumentVersionKey] = d.[DocumentVersionKey] AND [DocumentStatusCode] IN (10,20,30,40,60) ORDER BY [DocumentStatusCode]))
                )

    WHILE (@@ROWCOUNT > 0)
    BEGIN
        INSERT INTO @descendants
            SELECT h.[RootHierarchyKey], h.[HierarchyKey], d.[DocumentVersionKey], d.[DocumentKey], d.[AccessKey]
              FROM [dbo].[Hierarchy] h
                   INNER JOIN [dbo].[DocumentMain] d ON h.[UniformKey] = d.[DocumentVersionKey]
                   INNER JOIN @descendants d1 ON h.[ParentHierarchyKey] = d1.HierarchyKey
                   LEFT OUTER JOIN @descendants d2 ON h.[HierarchyKey] = d2.[HierarchyKey]
             WHERE d2.[HierarchyKey] IS NULL
               AND ((@publishedOnly = 1 AND d.[DocumentStatusCode] IN (40,60)) 
                    OR
                    (@publishedOnly = 0 AND d.DocumentKey IN (SELECT TOP 1 [DocumentKey] FROM [dbo].[DocumentMain] WHERE [DocumentVersionKey] = d.[DocumentVersionKey] AND [DocumentStatusCode] IN (10,20,30,40,60) ORDER BY [DocumentStatusCode]))
                   )
    END
    
    SELECT [RootHierarchyKey], [HierarchyKey], [DocumentVersionKey], [DocumentKey]
      FROM @descendants d
           INNER JOIN [dbo].[AccessItem] ai ON d.[AccessKey] = ai.[AccessKey]
           INNER JOIN [dbo].[UserToken] ut ON ai.[Grantee] = ut.[Grantee] AND ut.[UserKey] = @userKey
           LEFT OUTER JOIN [dbo].[UniformLicense] ul ON d.[DocumentVersionKey] = ul.[UniformKey]
           LEFT OUTER JOIN [dbo].[LicenseLegacyList] ll ON ul.[LicenseKey] = ll.[LicenseLegacyKey] 
     WHERE (@ignoreLicensing = 1 OR (ul.[LicenseKey] IS NULL OR ll.[LicenseLegacyKey] IS NOT NULL))   
     GROUP BY [RootHierarchyKey], [HierarchyKey], [DocumentVersionKey], [DocumentKey]
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentDescendantKeysByType]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentDescendantKeysByType]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

----------------------------------------------------------------------------------------------------------------------------------
-- Retrieves a list of all of the DocumentVersionKeys for all documents with a DocumentTypeCode = @documentTypeCode
-- that are descendants of the provided folder key (i.e. its children, children's children, etc).
----------------------------------------------------------------------------------------------------------------------------------
CREATE PROCEDURE [dbo].[asi_DocumentDescendantKeysByType]
(
    @hierarchyKey uniqueidentifier,
    @userKey uniqueidentifier,
    @loggedInUserGroupKey uniqueidentifier = '00000000-0000-0000-0000-000000000000', -- if this is empty, we assume the user is not logged in
    @publishedOnly bit = 1,
    @ignoreLicensing bit = 0,
    @documentTypeCode nvarchar(6)
)
AS
BEGIN
    DECLARE @descendants TABLE (
        [DocumentName] nvarchar(200),
        [DocumentTypeCode] varchar(6),
        [RootHierarchyKey] uniqueidentifier,
        [HierarchyKey] uniqueidentifier,
        [DocumentVersionKey] uniqueidentifier,
        [DocumentKey] uniqueidentifier,
        [AccessKey] uniqueidentifier
    )

    INSERT INTO @descendants
        SELECT d.[DocumentName], d.[DocumentTypeCode], h.[RootHierarchyKey], h.[HierarchyKey], d.[DocumentVersionKey], d.[DocumentKey], d.[AccessKey]
          FROM [dbo].[Hierarchy] h
               INNER JOIN [dbo].[DocumentMain] d ON h.[UniformKey] = d.[DocumentVersionKey]
         WHERE h.[ParentHierarchyKey] = @hierarchyKey
           AND ((@publishedOnly = 1 AND d.[DocumentStatusCode] IN (40,60)) 
                OR
                (@publishedOnly = 0 AND d.DocumentKey IN (SELECT TOP 1 [DocumentKey] FROM [DocumentMain] WHERE [DocumentVersionKey] = d.[DocumentVersionKey] AND [DocumentStatusCode] IN (10,20,30,40,60) ORDER BY [DocumentStatusCode]))
               )

    WHILE (@@ROWCOUNT > 0)
    BEGIN
        INSERT INTO @descendants
            SELECT d.[DocumentName], d.[DocumentTypeCode], h.[RootHierarchyKey], h.[HierarchyKey], d.[DocumentVersionKey], d.[DocumentKey], d.[AccessKey]
              FROM [dbo].[Hierarchy] h
                   INNER JOIN [dbo].[DocumentMain] d ON h.[UniformKey] = d.[DocumentVersionKey]
                   INNER JOIN @descendants d1 ON h.[ParentHierarchyKey] = d1.HierarchyKey
                   LEFT OUTER JOIN @descendants d2 ON h.[HierarchyKey] = d2.[HierarchyKey]
             WHERE d2.[HierarchyKey] IS NULL
               AND ((@publishedOnly = 1 AND d.[DocumentStatusCode] IN (40,60)) 
                    OR
                    (@publishedOnly = 0 AND d.DocumentKey IN (SELECT TOP 1 [DocumentKey] FROM [DocumentMain] WHERE [DocumentVersionKey] = d.[DocumentVersionKey] AND [DocumentStatusCode] IN (10,20,30,40,60) ORDER BY [DocumentStatusCode]))
                   )
    END

    SELECT [DocumentName], [DocumentTypeCode], [RootHierarchyKey], [HierarchyKey], [DocumentVersionKey], [DocumentKey]
      FROM @descendants d
           INNER JOIN [dbo].[AccessItem] ai ON d.[AccessKey] = ai.[AccessKey]
           INNER JOIN [dbo].[UserToken] ut ON ai.[Grantee] = ut.[Grantee] AND ut.[UserKey] = @userKey
           LEFT OUTER JOIN [dbo].[UniformLicense] ul ON d.[DocumentVersionKey] = ul.[UniformKey]
           LEFT OUTER JOIN [dbo].[LicenseLegacyList] ll ON ul.[LicenseKey] = ll.[LicenseLegacyKey] 
     WHERE (@ignoreLicensing = 1 OR (ul.[LicenseKey] IS NULL OR ll.[LicenseLegacyKey] IS NOT NULL))
       AND [DocumentTypeCode] = @documentTypeCode
     GROUP BY [DocumentName], [DocumentTypeCode], [RootHierarchyKey], [HierarchyKey], [DocumentVersionKey], [DocumentKey]
    END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentEnsureFolder]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentEnsureFolder]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

----------------------------------------------------------------------------------------------------------------------------------
-- Given a document tree path containing only folders, starting with the root, makes sure the folder path exists by
-- creating any folder in the path that does not.  If all goes well, the HierarchyKey of the end folder is returned.
-- Null is returned if the root does not exist (it won't ALTER  roots) or if the user does not have ALTER  permission
-- anywhere along the way. The parts of the path must be separated by the forward slash (/) 
----------------------------------------------------------------------------------------------------------------------------------
CREATE PROC [dbo].[asi_DocumentEnsureFolder]
    @documentPath nvarchar(2000),
    @organizationKey uniqueidentifier,
    @userKey uniqueidentifier,
    @loggedInUserGroupKey uniqueidentifier = '00000000-0000-0000-0000-000000000000', -- if this is empty, we assume the user is not logged in
    @rootHierarchyKey uniqueidentifier = null
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @parent uniqueidentifier;
    DECLARE @documentRootName nvarchar(100);
    DECLARE @documentName nvarchar(100);
    DECLARE @ptr int;
    DECLARE @newSort int;
    DECLARE @documentKey uniqueidentifier;
    DECLARE @documentVersionKey uniqueidentifier;
    DECLARE @accessKey uniqueidentifier;
    DECLARE @hierarchyKey uniqueidentifier;
    DECLARE @parentFolderDepth int;
    DECLARE @parentFolderSortOrder int;
    DECLARE @tmp int;
    DECLARE @now datetime;

    -- default accesskey to everyone full control
    SELECT @accessKey = CONVERT(uniqueidentifier,ParameterValue)
      FROM [dbo].[SystemConfig]
     WHERE [ParameterName] = 'Security.Token.EveryoneFullControlAccessKey'
       AND [OrganizationKey] = @organizationKey;

    SET @ptr = CHARINDEX(N'/', @documentPath);
    IF @ptr > 0
    BEGIN
        --First segment contains the root name, the rest is the path
        SET @documentRootName = SUBSTRING(@documentPath, 1, @ptr - 1);
        SET @documentPath = SUBSTRING(@documentPath, @ptr + 1, LEN(@documentPath) - @ptr);
    END
    ELSE
    BEGIN
        --No root specified so use absolute root name
        SET @documentRootName = N'$';
        IF @documentPath = N'$'
            SET @documentPath = N'';
    END
    -- check to make sure the root exists and the user has rights to it
    IF @rootHierarchyKey IS NULL
    BEGIN
        SELECT @rootHierarchyKey = [RootHierarchyKey]
          FROM [dbo].[HierarchyRoot] hr
         WHERE hr.[HierarchyRootName] = @documentRootName
           AND hr.[OrganizationKey] = @organizationKey
           AND EXISTS (SELECT 1 
                         FROM [dbo].[AccessItem] ai
                              INNER JOIN [dbo].[UserToken] ut ON ai.[Grantee] = ut.[Grantee]
                        WHERE ai.[AccessKey] = hr.[AccessKey] 
                          AND ut.[UserKey] = @userKey 
                          AND (ai.[Permission] & 3) > 0)
    END
    ELSE
    BEGIN
        SELECT @rootHierarchyKey = [RootHierarchyKey]
          FROM [dbo].[HierarchyRoot] hr
         WHERE hr.[RootHierarchyKey] = @rootHierarchyKey
           AND hr.[OrganizationKey] = @organizationKey
           AND EXISTS(SELECT 1 
                        FROM [dbo].[AccessItem] ai
                             INNER JOIN [dbo].[UserToken] ut ON ai.[Grantee] = ut.[Grantee]
                       WHERE ai.[AccessKey] = hr.[AccessKey] 
                         AND ut.[UserKey] = @userKey 
                         AND (ai.[Permission] & 3) > 0)
    END
    
    -- if we can get to the root, lets go inside the path
    IF @rootHierarchyKey IS NOT NULL
    BEGIN
        SET @hierarchyKey = @rootHierarchyKey;
        SET @parent = @rootHierarchyKey;
        SET @parentFolderDepth = 0;
        SET @parentFolderSortOrder = 0;

        -- loop thru the path components
        WHILE LEN(@documentPath) > 0
        BEGIN
            -- separate the next part of the path from the rest
            SET @ptr = CHARINDEX(N'/', @documentPath)
            IF @ptr > 0
            BEGIN
                SET @documentName = SUBSTRING(@documentPath, 1, @ptr - 1);
                SET @documentPath = SUBSTRING(@documentPath, @ptr + 1, LEN(@documentPath) - @ptr);
            END
            ELSE
            BEGIN
                SET @documentName = @documentPath;
                SET @documentPath = N'';
            END

            -- if there is still path parts left, documentName contains a folder name. Get its HierarchyKey
            IF LEN(@documentPath) > 0
            BEGIN
                SET @documentKey = null;

                SELECT @parent = h.[ParentHierarchyKey],
                       @hierarchyKey = h.[HierarchyKey],
                       @parentFolderDepth = h.[Depth],
                       @parentFolderSortOrder = h.[SortOrder],
                       @documentKey = d.[DocumentKey],
                       @accessKey = d.[AccessKey]
                  FROM [dbo].[Hierarchy] h
                       INNER JOIN [dbo].[DocumentMain] d ON h.[UniformKey] = d.[DocumentVersionKey] AND d.[DocumentStatusCode] IN (10,20,30,40,60)
                 WHERE h.[RootHierarchyKey] = @rootHierarchyKey
                   AND h.[ParentHierarchyKey] = @parent
                   AND d.[DocumentName] = @documentName
                   
                IF @@ROWCOUNT = 0
                -- its not there.  Since we had control permission at the higher level, create it.
                BEGIN
                    SET @documentKey = NewID()
                    SET @documentVersionKey = NewID()

                    -- create the UniformRegistry entry first
                    INSERT INTO [dbo].[UniformRegistry] ([UniformKey], [ComponentKey])
                        SELECT @documentKey, [ComponentKey]
                          FROM [dbo].[ComponentRegistry]
                         WHERE [Name] = 'Document'
                           AND [InterfaceName] = 'BusinessController'

                    -- then the UniformRegistry entry for the version key
                    INSERT INTO [dbo].[UniformRegistry] ([UniformKey], [ComponentKey])
                        SELECT @documentVersionKey, ComponentKey
                          FROM [dbo].[ComponentRegistry]
                         WHERE [Name] = 'DocumentVersion'
                           AND [InterfaceName] = 'BusinessController'
                           
                    SELECT @now = dbo.asi_GetAppDatetime();

                    -- then create the folder document
                    INSERT INTO [dbo].[DocumentMain] (
                          DocumentKey,
                          DocumentTypeCode,
                          DocumentName,
                          DocumentVersionKey,
                          DocumentStatusCode,
                          AlternateName,
                          IsSystem,
                          AccessKey,
                          ContainsChildrenFlag,
                          StatusUpdatedByUserKey,
                          StatusUpdatedOn,
                          UpdatedByUserKey,
                          UpdatedOn,
                          CreatedByUserKey,
                          CreatedOn)
                    VALUES (
                          @documentKey,
                          'FOL',
                          @documentName,
                          @documentVersionKey,
                          40,
                          @documentName,
                          0,
                          @accessKey,
                          0,
                          @userKey,
                          @now,
                          @userKey,
                          @now,
                          @userKey,
                          @now
                          )

                    -- then create the hierarchy element
                    SET @hierarchyKey = NEWID();

                    EXEC asi_HierarchyGetFolderSortOut @parent, @rootHierarchyKey, @parentFolderSortOrder, @parentFolderDepth, @documentName, @newSort OUTPUT;

                    INSERT INTO [dbo].[Hierarchy] (HierarchyKey, RootHierarchyKey, ParentHierarchyKey, SortOrder, Depth, UniformType, UniformKey, IsChildAMemberOfParent)
                        SELECT @hierarchyKey, RootHierarchyKey, HierarchyKey, @newSort, Depth + 1, UniformType, @documentVersionKey, IsChildAMemberOfParent
                          FROM [dbo].[Hierarchy]
                         WHERE HierarchyKey = @parent

                    SET @parent = @hierarchyKey;
                    SET @parentFolderSortOrder = @newSort;
                    SET @parentFolderDepth = @parentFolderDepth + 1;
                END
                -- it is there, check the security
                ELSE
                BEGIN
                    SELECT @tmp = COUNT(1) 
                      FROM [dbo].[AccessItem] ai
                           INNER JOIN [dbo].[UserToken] ut ON ai.[Grantee] = ut.[Grantee]
                     WHERE ai.[AccessKey] = @accessKey 
                       AND ut.[UserKey] = @userKey 
                       AND (ai.[Permission] & 3) > 0
                       
                    IF @tmp > 0 AND @hierarchyKey IS NOT NULL
                    BEGIN
                        SET @parent = @hierarchyKey;
                    END
                    ELSE
                    BEGIN
                        SET @parent = NULL;
                        SET @documentPath = NULL;
                        SET @hierarchyKey = NULL;
                    END
                END
            END
        END -- WHILE LEN(@documentPath) > 0
        
        SELECT @hierarchyKey;
        
    END -- IF @rootHierarchyKey IS NOT NULL
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentGetLatestVersionDocumentKey]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentGetLatestVersionDocumentKey]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- gets the "latest" document key given a DocumentKey or a DocumentVersionKey.  If key is DocumentKey
-- it looks at all versions of that Document (same DocumentVersionKey)  If key is a DocumentVersionKey, 
-- returns the DocumentKey of the document with the lowest status (e.g., prefers working over published, 
-- published over archived, etc.) and the most recent date
CREATE PROCEDURE [dbo].[asi_DocumentGetLatestVersionDocumentKey] @key uniqueidentifier, @documentKey uniqueidentifier OUT AS
BEGIN
    SELECT @documentKey = a.DocumentKey
      FROM DocumentMain a 
           INNER JOIN DocumentMain b ON a.DocumentVersionKey = b.DocumentVersionKey
     WHERE (b.DocumentKey = @key OR b.DocumentVersionKey = @key)
       AND a.CreatedOn = (SELECT TOP 1 CreatedOn
                            FROM DocumentMain
                           WHERE DocumentVersionKey = a.DocumentVersionKey
                           ORDER BY DocumentStatusCode, UpdatedOn DESC)
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentHierarchyKeyByKey]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentHierarchyKeyByKey]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- Finds the first (should be only for documents) hierarchy key associated
-- with the DocumentKey or DocumentVersionKey sent in the key parameter.
-- We make sure that we do not include results from the UniformItem hierarchy
-- rooted at '.'
CREATE PROC [dbo].[asi_DocumentHierarchyKeyByKey] @key uniqueidentifier AS
BEGIN
   DECLARE @documentKey uniqueidentifier

   EXEC asi_DocumentGetLatestKey @key, @documentKey OUT

   SELECT TOP 1 h.HierarchyKey 
     FROM Hierarchy h 
          INNER JOIN DocumentMain d ON h.UniformKey = d.DocumentVersionKey 
          INNER JOIN HierarchyRoot r ON h.RootHierarchyKey = r.RootHierarchyKey
    WHERE d.DocumentKey = @documentKey AND r.HierarchyRootName <> N'.'
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentImport]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentImport]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/*
Creates or upates the document described by the parameters.  Since the import could be coming from a 
database that does not have the same key values for certain things, these keys may or may not be preserved.

The rules are:
1. If the document does not already exists in the target database, in any version, it will be created
2. If the document does already exist in the target database it may be imported or updated according to specific rules outlined below.

Preserving Keys (e.g., for Dev -> Test -> Production environments)

3. For Insert/Create only: if the user who created the document being imported does not exist in the import database, the default user key (that of the person doing the import) will be used.  Otherwise the CreatedByUserKey from the import record will be preserved.
4. If the user who last updated the document does not exist in the import database, the default user key (that of the person doing the import) will be used.  Otherwise the UpdatedByUserKey from the import record will be preserved.
5. If the user who last updated the status does not exist in the import database, the default user key (that of the person doing the import) will be used.  Otherwise the StatusUpdatedByUserKey from the import record will be preserved.
6. If the security AccessKey on the document being imported does not exist in the import database:
   a. and the document is only being imported into one folder and that folder has a DefaultChildAccessKey, the folders DefaultChildAccessKey will be used
   b. and the document is being imported into more than one folder or the only folder into which it is being imported has no DefaultChildAccessKey, the default access key (supplied at the start of the import process) will be used.  
Otherwise, the AccessKey from the import record will be preserved.
7. If the security DefaultChildAccessKey on the document being imported does not exist in the import database, NULL will be substituted.  Otherwise, the DefaultChildAccessKey from the import record will be preserved.
*/
CREATE PROCEDURE [dbo].[asi_DocumentImport]
   @DocumentKey uniqueidentifier,
   @DocumentName nvarchar(100),
   @DocumentDescription nvarchar(250),
   @DocumentVersionKey uniqueidentifier,
   @DocumentTypeCode nvarchar(3),
   @DocumentStatusCode int,
   @DocumentCode nvarchar(100),
   @AlternateName nvarchar(100),
   @IsSystem bit,
   @Blob image,
   @AccessKey uniqueidentifier,
   @DefaultChildAccessKey uniqueidentifier,
   @ContainsChildrenFlag bit,
   @BranchedFromDocumentKey uniqueidentifier,
   @RelatedDocumentVersionKey uniqueidentifier,
   @StatusUpdatedOn datetime,
   @StatusUpdatedByUserKey uniqueidentifier,
   @UpdatedOn datetime,
   @UpdatedByUserKey uniqueidentifier,
   @CreatedOn datetime,
   @CreatedByUserKey uniqueidentifier,
   @DefaultUserKey uniqueidentifier,
   @DefaultAccessKey uniqueidentifier,
   @Overwrite bit
AS
DECLARE
   @check int, @currentDocumentStatusCode int, @lockedOn datetime, @trackVersionsFlag bit
BEGIN
   -- some of the keys may not exist in the import database.  Check each and if they do not, use the default
   -- if the user who last updated the status does not exist in this database, use the default user key (person doing the import)
   SELECT @check = Count(*)
     FROM UserMain
    WHERE UserKey = @StatusUpdatedByUserKey

   IF @check = 0 SET @StatusUpdatedByUserKey = @DefaultUserKey
      
   -- if the user who last updated the document does not exist in this database, use the default user key (person doing the import)
   SELECT @check = Count(*)
     FROM UserMain
    WHERE UserKey = @UpdatedByUserKey

   IF @check = 0 SET @UpdatedByUserKey = @DefaultUserKey

   -- if the user who created the document does not exist in this database, use the default user key (person doing the import)
   SELECT @check = Count(*)
     FROM UserMain
    WHERE UserKey = @CreatedByUserKey

   IF @check = 0 SET @CreatedByUserKey = @DefaultUserKey

   -- if the AccessKey on the document does not exist, use the default access key
   SELECT @check = Count(*)
     FROM AccessMain
    WHERE AccessKey = @AccessKey

   IF @check = 0 SET @AccessKey = @DefaultAccessKey

   -- if the DefaultChildAccessKey on the document does not exist, set it to null
   IF @DefaultChildAccessKey IS NOT NULL
   BEGIN
      SELECT @check = Count(*)
        FROM AccessMain
       WHERE AccessKey = @DefaultChildAccessKey

      IF @check = 0 SET @DefaultChildAccessKey = null
   END

   -- if the RelatedDocumentVersionKey does not exists (it is a shortcut to nowhere)
   IF @RelatedDocumentVersionKey IS NOT NULL
   BEGIN
      SELECT @check = Count(*)
        FROM UniformRegistry
       WHERE UniformKey = @RelatedDocumentVersionKey

      IF @check = 0
      BEGIN
         RAISERROR ('Unable to import %s. Shortcut references a document that does not exist',11,1, @DocumentName)
         RETURN
      END
   END

   -- check to see if documents of this type track versions so we know if we need to follow any version tracking rules
   SELECT @trackVersionsFlag = TrackVersionsFlag
     FROM DocumentTypeRef
    WHERE DocumentTypeCode = @DocumentTypeCode

   -- next, check to see if this is an insert or an update and grab the DocumentStatusCode for later if update
   SELECT @currentDocumentStatusCode = DocumentStatusCode, @lockedOn = LockedOn
     FROM DocumentMain
    WHERE DocumentKey = @DocumentKey

   -- if there is not one there already, it is an insert
   IF @currentDocumentStatusCode IS NULL
   BEGIN
      INSERT INTO UniformRegistry (UniformKey, ComponentKey) 
      SELECT @DocumentKey, ComponentKey
        FROM ComponentRegistry
       WHERE Name = 'Document'
         AND InterfaceName = 'BusinessController'

      -- check to see if the version key is already there
      SELECT @check = Count(*)
        FROM UniformRegistry
       WHERE UniformKey = @DocumentVersionKey

      -- if the DocumentVersionKey does not exist, add it
      IF @check = 0
         INSERT INTO UniformRegistry (UniformKey, ComponentKey)
         SELECT @DocumentVersionKey, ComponentKey
           FROM ComponentRegistry
          WHERE Name = 'DocumentVersion'
            AND InterfaceName = 'BusinessController'
      -- if the DocumentVersionKey DOES exists, we need to make sure the status rules are applied
      ELSE
      BEGIN
         -- If the incoming document's status is Working, make sure that if there is another working version
         -- it gets archived.  If the incoming document's status is Published, make sure that if there is another
         -- Published version, it gets archived
         IF (@DocumentStatusCode = 10 OR @DocumentStatusCode = 40) AND @trackVersionsFlag = 1
            UPDATE DocumentMain
               SET DocumentStatusCode = 50
             WHERE DocumentVersionKey = @DocumentVersionKey
               AND DocumentStatusCode = @DocumentStatusCode
      END

      INSERT INTO DocumentMain (
             DocumentKey,
             DocumentName,
             DocumentDescription,
             DocumentVersionKey,
             DocumentTypeCode,
             DocumentStatusCode,
			 DocumentCode,
             AlternateName,
             IsSystem,
             Blob,
             AccessKey,
             DefaultChildAccessKey,
             ContainsChildrenFlag,
             BranchedFromDocumentKey,
             RelatedDocumentVersionKey,
             StatusUpdatedOn,
             StatusUpdatedByUserKey,
             UpdatedOn,
             UpdatedByUserKey,
             CreatedOn,
             CreatedByUserKey)
      VALUES (
             @DocumentKey,
             @DocumentName,
             @DocumentDescription,
             @DocumentVersionKey,
             @DocumentTypeCode,
             @DocumentStatusCode,
             @DocumentCode,
             @AlternateName,
             @IsSystem,
             @Blob,
             @AccessKey,
             @DefaultChildAccessKey,
             @ContainsChildrenFlag,
             @BranchedFromDocumentKey,
             @RelatedDocumentVersionKey,
             @StatusUpdatedOn,
             @StatusUpdatedByUserKey,
             @UpdatedOn,
             @UpdatedByUserKey,
             @CreatedOn,
             @CreatedByUserKey)
   END
   -- there is already one there, it is an update
   ELSE
   BEGIN
      IF @Overwrite = 1
      BEGIN
         -- if the existing document's status is Publish Requested, PublishPending, RecycleRequested, or RecyclePending
         -- or the document is Locked, we can't import.  Raise an error
         IF @currentDocumentStatusCode IN (20,30,60,70)
         BEGIN
            DECLARE @DocumentStatusDesc nvarchar(30)
            SELECT @DocumentStatusDesc = DocumentStatusDesc FROM DocumentStatusRef WHERE DocumentStatusCode = @currentDocumentStatusCode

            RAISERROR ('Unable to import %s. The exact version of the document already exists in the target database with a status of %s.',11,1, @DocumentName, @DocumentStatusDesc)
            RETURN
         END

         IF @lockedOn IS NOT NULL
         BEGIN
            RAISERROR ('Unable to import %s. The exact version of the document already exists in the target database and is Locked for editing.',11,1, @DocumentName)
            RETURN
         END

         -- if the status of the doc being imported does not match the one that exists, we need to apply
         -- some special rules.
         IF @currentDocumentStatusCode <> @DocumentStatusCode AND @trackVersionsFlag = 1
         BEGIN
            -- if source is Published and Target is Working, need to archive existing published version first
            IF @DocumentStatusCode = 40 AND @currentDocumentStatusCode = 10
               UPDATE DocumentMain
                  SET DocumentStatusCode = 50
                WHERE DocumentVersionKey = @DocumentVersionKey
                  AND DocumentStatusCode = @DocumentStatusCode

            -- for all other combinations we have not yet covered except Source is Archived, Target is Working
            -- leave the status unchanged
            IF (@DocumentStatusCode = 10 AND @currentDocumentStatusCode IN (40,50)) OR
               (@DocumentStatusCode = 40 AND @currentDocumentStatusCode = 50) OR
               (@DocumentStatusCode = 50 AND @currentDocumentStatusCode = 40)
               SET @DocumentStatusCode = @currentDocumentStatusCode
         END

         UPDATE DocumentMain 
            SET DocumentName = @DocumentName,
                DocumentDescription = @DocumentDescription,
                DocumentTypeCode = @DocumentTypeCode,
                DocumentStatusCode = @DocumentStatusCode,
				DocumentCode = @DocumentCode,
                AlternateName = @AlternateName,
                IsSystem = @IsSystem,
                Blob = @Blob,
                DefaultChildAccessKey = @DefaultChildAccessKey,
                ContainsChildrenFlag = @ContainsChildrenFlag,
                BranchedFromDocumentKey = @BranchedFromDocumentKey,
                RelatedDocumentVersionKey  = @RelatedDocumentVersionKey,
                StatusUpdatedOn = @StatusUpdatedOn,
                StatusUpdatedByUserKey = @StatusUpdatedByUserKey,
                UpdatedOn = @UpdatedOn,
                UpdatedByUserKey = @UpdatedByUserKey
          WHERE DocumentKey = @DocumentKey
      END
   END
   SELECT @DocumentKey
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentInheritLicenseRestrictions]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentInheritLicenseRestrictions]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
--  PARAMETER USAGE NOTES
--	@documentVersionKey: Required parameter. Needed to know which Document we're applying the license restrictions to
--	@parentHierarchyKey: Optional parameter. License restrictions can still be copied from parent folder before the hierarchy
--						 has been created if the parent hierarchy key is passes in

CREATE PROCEDURE dbo.asi_DocumentInheritLicenseRestrictions
	(@documentVersionKey uniqueidentifier,
	@parentHierarchyKey uniqueidentifier = '00000000-0000-0000-0000-000000000000')
AS
BEGIN

	DECLARE @parentDocumentVersionKey uniqueidentifier

	IF @parentHierarchyKey = '00000000-0000-0000-0000-000000000000'
	BEGIN

		SELECT @parentDocumentVersionKey = parent.[UniformKey]
		FROM [dbo].[Hierarchy] parent INNER JOIN [dbo].[Hierarchy] child ON parent.[HierarchyKey] = child.[ParentHierarchyKey]
		WHERE child.[UniformKey] = @documentVersionKey

	END
	ELSE
	BEGIN

		SELECT @parentDocumentVersionKey = [Hierarchy].[UniformKey]
		FROM [dbo].[Hierarchy]
		WHERE [Hierarchy].[HierarchyKey] = @parentHierarchyKey

	END

	INSERT INTO [dbo].[UniformLicense] ([LicenseKey], [UniformKey])
	SELECT [UniformLicense].[LicenseKey], @documentVersionKey
	FROM [dbo].[UniformLicense]
	WHERE [UniformLicense].[UniformKey] = @parentDocumentVersionKey
	AND [UniformLicense].[LicenseKey] NOT IN
		(SELECT [UniformLicense].[LicenseKey] FROM [dbo].[UniformLicense] WHERE [UniformLicense].[UniformKey] = @documentVersionKey)

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentKeysByCode]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentKeysByCode]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

----------------------------------------------------------------------------------------------------------------------------------
-- Given a document code and RootHierarchyKey returns the HierarchyKey, DocumentVersionKey and DocumentKey of the document if it 
-- is found within the given hierarchy. Security IS checked. NOTE: The documentKey returned will be that of the latest version
----------------------------------------------------------------------------------------------------------------------------------
CREATE PROC [dbo].[asi_DocumentKeysByCode]
    @documentCode nvarchar(100),
    @rootHierarchyKey uniqueidentifier,
    @userKey uniqueidentifier,
    @loggedInUserGroupKey uniqueidentifier = '00000000-0000-0000-0000-000000000000' -- if this is empty, we assume the user is not logged in
AS
BEGIN
    SELECT h.[HierarchyKey],
           d.[DocumentVersionKey],
           d.[DocumentKey]
      FROM [dbo].[Hierarchy] h 
           INNER JOIN [dbo].[DocumentMain] d ON h.[UniformKey] = d.[DocumentVersionKey] AND d.[DocumentStatusCode] IN (10,20,30,40,60)
     WHERE h.[RootHierarchyKey] = @rootHierarchyKey
       AND d.[DocumentCode] = @documentCode
       AND EXISTS(SELECT 1 
                    FROM [dbo].[AccessItem] ai 
                         INNER JOIN [dbo].[UserToken] ut ON ai.[Grantee] = ut.[Grantee] 
                   WHERE ai.[AccessKey] = d.[AccessKey] 
                     AND ut.[UserKey] = @userKey 
                     AND (ai.[Permission] & 3) > 0)
     ORDER BY d.[DocumentStatusCode] DESC
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentKeysByPath]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentKeysByPath]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO



----------------------------------------------------------------------------------------------------------------------------------
-- Given a document tree path, starting with the root, returns the RootHierarchyKey, HierarchyKey and DocumentKey of the
-- end node as out parameters. Security IS checked. The parts of the path must be separated by the forward slash (/).
-- NOTE: The documentKey returned will be that of the latest version
----------------------------------------------------------------------------------------------------------------------------------
CREATE PROC [dbo].[asi_DocumentKeysByPath]
    @documentPath nvarchar(2000),
    @organizationKey uniqueidentifier,
    @userKey uniqueidentifier,
    @loggedInUserGroupKey uniqueidentifier = '00000000-0000-0000-0000-000000000000', -- if this is empty, we assume the user is not logged in
    @ignoreLicensing bit = 0,
    @rootHierarchyKey uniqueidentifier OUT,
    @hierarchyKey uniqueidentifier OUT,
    @documentVersionKey uniqueidentifier OUT,
    @documentKey uniqueidentifier OUT
AS
BEGIN
    DECLARE @parent uniqueidentifier;
    DECLARE @relatedDocumentVersionKey uniqueidentifier;
    DECLARE @relatedDocumentKey uniqueidentifier;
    DECLARE @relatedHierarchyKey uniqueidentifier;
    DECLARE @documentRootName nvarchar(100);
    DECLARE @documentName nvarchar(100);
    DECLARE @ptr int;
    DECLARE @documentPathWorking nvarchar(2000);
      
    SET @ptr = CHARINDEX(N'/', @documentPath)
    IF @ptr > 0
    BEGIN
        --First segment contains the root name
        SET @documentRootName = SUBSTRING(@documentPath, 1, @ptr - 1);
        SET @documentPath = SUBSTRING(@documentPath, @ptr + 1, LEN(@documentPath) - @ptr);
    END
    ELSE
    BEGIN
        -- See if it's the name of a root; if not, default to $
        IF EXISTS (SELECT 1 FROM HierarchyRoot WHERE HierarchyRootName = @documentPath)
        BEGIN
            SET @documentRootName = @documentPath;
            SET @documentPath = '';
        END
        ELSE
        BEGIN
            --No root specified so use absolute root name
            SET @documentRootName = N'$';
            IF @documentPath = N'$'
               SET @documentPath = N'';
        END
    END
    
    -- check to make sure the root exists and the user has rights to it
    -- Updated to handle multiple roots with the same name
    DECLARE @HierarchyRoots TABLE (
       [RootHierarchyKey] uniqueidentifier,
       [HierarchyKey] uniqueidentifier,
       [UniformKey] uniqueidentifier,
       [DocumentKey] uniqueidentifier,
       [Checked] bit
    )
    INSERT INTO @HierarchyRoots
        SELECT hr.RootHierarchyKey,
               h.HierarchyKey,
               h.UniformKey,
               d.DocumentKey,
               0
          FROM [dbo].[HierarchyRoot] hr 
               INNER JOIN [dbo].[Hierarchy] h on hr.[RootHierarchyKey] = h.[HierarchyKey]
               LEFT OUTER JOIN [dbo].[DocumentMain] d ON h.[UniformKey] = d.[DocumentVersionKey] AND d.[DocumentStatusCode] IN (40,60)
         WHERE hr.[HierarchyRootName] = @documentRootName
           AND hr.[OrganizationKey] = @organizationKey
           AND (@rootHierarchyKey IS NULL OR @rootHierarchyKey = '00000000-0000-0000-0000-000000000000' OR hr.[RootHierarchyKey] = @rootHierarchyKey)
           AND EXISTS(SELECT 1
                        FROM [AccessItem] ai
                             INNER JOIN [UserToken] ut ON ai.[Grantee] = ut.[Grantee]
                       WHERE ai.[AccessKey] = hr.[AccessKey]
                         AND ut.[UserKey] = @userKey
                         AND (ai.[Permission] & 3) > 0
                     )

    WHILE @hierarchyKey IS NULL AND @documentVersionKey IS NULL AND @documentKey IS NULL AND EXISTS (SELECT 1 FROM @HierarchyRoots WHERE Checked = 0)
    BEGIN
       SET @documentPathWorking = @documentPath

         SELECT @rootHierarchyKey = RootHierarchyKey,
                    @hierarchyKey = HierarchyKey,
                    @documentVersionKey = UniformKey,
                    @documentKey = DocumentKey
             FROM @HierarchyRoots
            WHERE Checked = 0

         -- if we can get to the root, lets go inside the path
         IF @rootHierarchyKey IS NOT NULL
         BEGIN
             UPDATE @HierarchyRoots SET Checked = 1 WHERE RootHierarchyKey = @rootHierarchyKey

             SET @hierarchyKey = @rootHierarchyKey
             SET @parent = @rootHierarchyKey
             -- loop thru the path components
             WHILE LEN(@documentPathWorking) > 0
             BEGIN
                -- separate the next part of the path from the rest
                SET @ptr = CHARINDEX(N'/', @documentPathWorking)
                IF @ptr > 0
                BEGIN
                     SET @documentName = SUBSTRING(@documentPathWorking, 1, @ptr - 1)
                     SET @documentPathWorking = SUBSTRING(@documentPathWorking, @ptr + 1, LEN(@documentPathWorking) - @ptr)
                END
                ELSE
                BEGIN
                     SET @documentName = @documentPathWorking
                     SET @documentPathWorking = N''
                END

                -- if there is still path parts left, documentName contains a folder name. Get its HierarchyKey
                IF LEN(@documentName) > 0
                BEGIN
                     SET @documentKey = null
                     SET @documentVersionKey = null
                     SET @hierarchyKey = null

                     DECLARE @t1 TABLE (
                           ParentHierarchyKey uniqueidentifier,
                           HierarchyKey uniqueidentifier,
                           DocumentVersionKey uniqueidentifier,
                           DocumentKey uniqueidentifier,
                           RelatedDocumentVersionKey uniqueidentifier,
                           AccessKey uniqueidentifier,
                           UpdatedOn datetime,
                           DocumentStatusCode int
                     )
                     DELETE FROM @t1
                     INSERT INTO @t1 (ParentHierarchyKey, HierarchyKey, DocumentVersionKey, DocumentKey, RelatedDocumentVersionKey, AccessKey, UpdatedOn, DocumentStatusCode)
                     SELECT
                              Hierarchy.ParentHierarchyKey,
                              Hierarchy.HierarchyKey,
                              DocumentMain.DocumentVersionKey,
                              DocumentMain.DocumentKey,
                              DocumentMain.RelatedDocumentVersionKey,
                              DocumentMain.AccessKey,
                              DocumentMain.UpdatedOn,
                              DocumentMain.DocumentStatusCode
                       FROM Hierarchy INNER JOIN DocumentMain ON Hierarchy.UniformKey = DocumentMain.DocumentVersionKey
                      WHERE Hierarchy.RootHierarchyKey = @rootHierarchyKey
                        AND Hierarchy.ParentHierarchyKey = @parent
                        AND DocumentMain.DocumentName = @documentName
                      ORDER BY DocumentMain.DocumentStatusCode ASC, DocumentMain.UpdatedOn DESC

                     SELECT TOP 1 @parent = a.ParentHierarchyKey,
                            @hierarchyKey = a.HierarchyKey,
                            @documentVersionKey = a.DocumentVersionKey,
                            @documentKey = a.DocumentKey,
                            @relatedDocumentVersionKey = a.RelatedDocumentVersionKey
                       FROM @t1 AS a
                      WHERE EXISTS (SELECT 1
                                      FROM [dbo].[AccessItem] ai 
                                           INNER JOIN [dbo].[UserToken] ut ON ai.[Grantee] = ut.[Grantee]
                                     WHERE ai.[AccessKey] = a.[AccessKey]
                                       AND ut.[UserKey] = @userKey
                                       AND (ai.[Permission] & 3) > 0)
                        AND (@ignoreLicensing = 1
                             OR NOT EXISTS (SELECT 1 FROM [dbo].[UniformLicense] WHERE [UniformKey] = a.[DocumentVersionKey])
                             OR EXISTS (SELECT 1
                                          FROM [dbo].[UniformLicense] ul
                                               INNER JOIN [dbo].[LicenseLegacyList] l ON ul.[LicenseKey] = l.[LicenseLegacyKey]
                                         WHERE ul.[UniformKey] = a.[DocumentVersionKey]
                                        )
                             )
                      ORDER BY a.[DocumentStatusCode] ASC, a.[UpdatedOn] DESC

                     IF @@ROWCOUNT = 0
                     BEGIN
                         SET @parent = NULL;
                         SET @documentPathWorking = NULL;
                     END
                     ELSE
                     BEGIN
                        IF (@hierarchyKey IS NOT NULL)
                             SET @parent = @hierarchyKey;
                             
                        -- get related document info if there
                        IF (@relatedDocumentVersionKey IS NOT NULL)
                        BEGIN
                            SELECT TOP 1 @relatedHierarchyKey = [HierarchyKey], @relatedDocumentKey = d.[DocumentKey]
                              FROM [Hierarchy] h
                                   INNER JOIN [DocumentMain] d ON h.[UniformKey] = d.[DocumentVersionKey]
                             WHERE h.RootHierarchyKey = @rootHierarchyKey
                               AND d.DocumentVersionKey = @relatedDocumentVersionKey
                               AND EXISTS(SELECT 1
                                            FROM [AccessItem] ai
                                                 INNER JOIN [UserToken] ut ON ai.[Grantee] = ut.[Grantee]
                                           WHERE ai.[AccessKey] = d.[AccessKey]
                                             AND ut.[UserKey] = @userKey
                                             AND (ai.[Permission] & 3) > 0)
                                AND (@ignoreLicensing = 1
                                     OR NOT EXISTS (SELECT 1 FROM [UniformLicense] WHERE [UniformKey] = d.[DocumentVersionKey])
                                     OR EXISTS(SELECT 1
                                                 FROM [dbo].[UniformLicense] ul
                                                      INNER JOIN [dbo].[LicenseLegacyList] l ON ul.LicenseKey = l.LicenseLegacyKey
                                                WHERE ul.UniformKey = d.DocumentVersionKey
                                              )
                                    )
                             ORDER BY d.DocumentStatusCode ASC, d.UpdatedOn DESC

                            IF @@ROWCOUNT = 1 AND @relatedHierarchyKey IS NOT NULL
                            BEGIN
                                SET @parent = @relatedHierarchyKey;
                                SET @documentKey = @relatedDocumentKey;
                            END
                        END
                    END
                END
            END -- WHILE LEN(@documentPathWorking) > 0
        END -- IF @rootHierarchyKey IS NOT NULL
    END -- WHILE Checked = 0 
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentMainByHierarchyKey]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentMainByHierarchyKey]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/*
Given a hierarchy key, returns everything from DocumentMain except the blob (for security and performance reasons)
for the Document associated with that Hierarchy element.  Also includes the DocumentTypeName, DocumentTypeDesc, 
and DocumentIconURL from the associated DocumentTypeRef record.

If publishedOnly = 1 it will only get published documents.  Otherwise, it gets the latest version, published or working.
It won't get documents with any other status

NOTE: Security is bypassed since the call requires the key (e.g., a reference from an object to which the user
has access) and the sensitive part, the blob, is not returned.
*/
CREATE PROC [dbo].[asi_DocumentMainByHierarchyKey]
   @hierarchyKey uniqueidentifier,
   @publishedOnly bit = 0
AS
BEGIN
   SELECT a.DocumentKey,
          a.DocumentVersionKey,
          a.DocumentStatusCode,
          a.DocumentName,
          a.AlternateName,
          a.DocumentDescription,
          a.DocumentTypeCode,
          a.IsSystem,
          a.ContainsChildrenFlag,
          a.AccessKey,
          a.DefaultChildAccessKey,
          a.StatusUpdatedOn,
          a.StatusUpdatedByUserKey,
          a.CreatedOn,
          a.CreatedByUserKey,
          a.UpdatedOn,
          a.UpdatedByUserKey,
          b.DocumentTypeName, 
          b.DocumentTypeDesc,
          b.DocumentIconURL
     FROM [dbo].[DocumentMain] a INNER JOIN [dbo].[DocumentTypeRef] b on a.DocumentTypeCode = b.DocumentTypeCode
          INNER JOIN [dbo].[Hierarchy] c ON a.DocumentVersionKey = c.UniformKey
    WHERE c.HierarchyKey = @hierarchyKey
      AND ((a.DocumentStatusCode IN (10,20,30,70) AND @publishedOnly = 0)
       OR (a.DocumentStatusCode IN (40,60) 
      AND (@publishedOnly = 1
       OR NOT EXISTS (
          SELECT 1
            FROM [dbo].[DocumentMain] d
           WHERE d.DocumentVersionKey = a.DocumentVersionKey
             AND d.DocumentStatusCode IN (10,20,30,70)))))
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentMainByKey]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentMainByKey]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/*
Given the document key, returns everything from DocumentMain except the blob (for security and performance reasons)
plus DocumentTypeName, DocumentTypeDesc, and DocumentIconURL from the associated DocumentTypeRef record.

NOTE: Security is bypassed since the call requires the key (e.g., a reference from an object to which the user
has access) and the sensitive part, the blob, is not returned.
*/
CREATE PROC [dbo].[asi_DocumentMainByKey]
   @key uniqueidentifier
AS
BEGIN
   DECLARE @documentKey uniqueidentifier

   EXEC asi_DocumentGetLatestKey @key, @documentKey OUT

   SELECT a.DocumentKey,
          a.DocumentVersionKey,
          a.DocumentStatusCode,
          a.DocumentName,
          a.AlternateName,
          a.DocumentDescription,
          a.DocumentTypeCode,
          a.IsSystem,
          a.ContainsChildrenFlag,
          a.RelatedDocumentVersionKey,
          a.AccessKey,
          a.DefaultChildAccessKey,
          a.StatusUpdatedOn,
          a.StatusUpdatedByUserKey,
          a.CreatedOn,
          a.CreatedByUserKey,
          a.UpdatedOn,
          a.UpdatedByUserKey,
          b.DocumentTypeName, 
          b.DocumentTypeDesc,
          b.DocumentIconURL,
          c.DocumentKey AS RelatedDocumentKey,
          c.DocumentTypeCode AS RelatedDocumentTypeCode,
          c.DocumentStatusCode AS RelatedDocumentStatusCode,
          c.DocumentName AS RelatedDocumentName,
          c.AlternateName AS RelatedAlternateName,
          c.DocumentDescription AS RelatedDocumentDescription,
          c.CreatedOn AS RelatedCreatedOn,
          c.CreatedByUserKey AS RelatedCreatedByUserKey,
          c.UpdatedOn AS RelatedUpdatedOn,
          c.UpdatedByUserKey AS RelatedUpdatedByUserKey,
          d.DocumentTypeName AS RelatedDocumentTypeName, 
          d.DocumentTypeDesc AS RelatedDocumentTypeDesc,
          d.DocumentIconURL AS RelatedDocumentIconURL,
          d.ShortcutIconURL AS RelatedShortcutIconURL
     FROM DocumentMain a INNER JOIN DocumentTypeRef b ON a.DocumentTypeCode = b.DocumentTypeCode
          LEFT OUTER JOIN DocumentMain c ON a.RelatedDocumentVersionKey = c.DocumentVersionKey AND c.DocumentStatusCode IN (40,60)
          LEFT OUTER JOIN DocumentTypeRef d ON c.DocumentTypeCode = d.DocumentTypeCode
    WHERE a.DocumentKey = @documentKey
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentMainByPath]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentMainByPath]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


----------------------------------------------------------------------------------------------------------------------------------
-- Gets the document data for the document at the given path INCLUDING the blob. Security IS checked. The first 
-- segment of the documentPath should be the DocumentRoot name. The last segment should be the DocumentName
-- Individual segments are separated by the forward slash (/) 
----------------------------------------------------------------------------------------------------------------------------------
CREATE PROC [dbo].[asi_DocumentMainByPath]
    @documentPath nvarchar(2000),
    @organizationKey uniqueidentifier,
    @userKey uniqueidentifier,
    @loggedInUserGroupKey uniqueidentifier = '00000000-0000-0000-0000-000000000000', -- if this is empty, we assume the user is not logged in
    @publishedOnly bit = 0,
    @ignoreLicensing bit = 0
AS
BEGIN
    DECLARE @rootHierarchyKey uniqueidentifier;
    DECLARE @hierarchyKey uniqueidentifier;
    DECLARE @documentVersionKey uniqueidentifier;
    DECLARE @documentKey uniqueidentifier;

    EXEC asi_DocumentKeysByPath @documentPath, @organizationKey, @userKey, @loggedInUserGroupKey, @ignoreLicensing, @rootHierarchyKey out, @hierarchyKey out, @documentVersionKey out, @documentKey out

    IF @documentVersionKey IS NOT NULL
        SELECT TOP 1
               d.Blob,
               d.DocumentKey,
               d.DocumentVersionKey,
               d.DocumentStatusCode,
               d.DocumentName,
               d.AlternateName,
               d.DocumentDescription,
               d.DocumentTypeCode,
               d.IsSystem,
               d.ContainsChildrenFlag,
               d.AccessKey,
               d.DefaultChildAccessKey,
               d.StatusUpdatedOn,
               d.StatusUpdatedByUserKey,
               d.CreatedOn,
               d.CreatedByUserKey,
               d.UpdatedOn,
               d.UpdatedByUserKey,
               t.DocumentTypeName, 
               t.DocumentTypeDesc,
               t.DocumentIconURL,
               @hierarchyKey AS HierarchyKey
          FROM [dbo].[DocumentMain] d 
               INNER JOIN [dbo].[DocumentTypeRef] t on d.DocumentTypeCode = t.DocumentTypeCode
         WHERE d.DocumentVersionKey = @documentVersionKey
           AND (d.DocumentStatusCode IN (40,60) OR @publishedOnly = 0)
           AND EXISTS (SELECT 1 
                         FROM [dbo].[AccessItem] ai
                              INNER JOIN [dbo].[UserToken] ut ON ai.[Grantee] = ut.[Grantee]
                        WHERE ai.[AccessKey] = d.[AccessKey] 
                          AND ut.[UserKey] = @userKey
                      )
       ORDER BY d.[UpdatedOn] DESC, d.[DocumentStatusCode] ASC
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentMainGetPublishedWebsites]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentMainGetPublishedWebsites]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_DocumentMainGetPublishedWebsites]
AS
BEGIN
    SELECT [AlternateName], [DocumentVersionKey]
    FROM [dbo].[DocumentMain]
    WHERE [DocumentTypeCode] = N'WEB'
    AND [DocumentStatusCode] = 40
    ORDER BY [AlternateName]
END
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentMainListByParentHierarchyKey]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentMainListByParentHierarchyKey]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

----------------------------------------------------------------------------------------------------------------------------------
-- Retrieves a list of Documents under a particular folder by the folder's HierarchyKey. Security IS enforced.
-- 
-- Returns:
-- Everything from the DocumentMain table except the blob. Also includes DocumentTypeName, DocumentTypeDesc, 
-- and DocumentIconURL from DocumentTypeRef and HierarchyKey from the Hierarchy element representing the document.
----------------------------------------------------------------------------------------------------------------------------------
CREATE PROC [dbo].[asi_DocumentMainListByParentHierarchyKey]
    @parentHierarchyKey uniqueidentifier,
    @userKey uniqueidentifier,
    @loggedInUserGroupKey uniqueidentifier = '00000000-0000-0000-0000-000000000000', -- if this is empty, we assume the user is not logged in
    @publishedOnly bit = 0,
    @ignoreLicensing bit = 0
AS
BEGIN
    DECLARE @parentHierarchyKeyCopy uniqueidentifier;
    SET @parentHierarchyKeyCopy = @parentHierarchyKey;

    DECLARE @t1 TABLE(
        HierarchyKey uniqueidentifier,
        DocumentKey uniqueidentifier,
        DocumentVersionKey uniqueidentifier,
        DocumentStatusCode int,
        DocumentName nvarchar(100),
        AlternateName nvarchar(100),
        DocumentDescription nvarchar(250),
        DocumentTypeCode nvarchar(3),
        IsSystem bit,
        ContainsChildrenFlag bit,
        RelatedDocumentVersionKey uniqueidentifier,
        AccessKey uniqueidentifier,
        DefaultChildAccessKey uniqueidentifier,
        StatusUpdatedOn datetime,
        StatusUpdatedByUserKey uniqueidentifier,
        CreatedOn datetime,
        CreatedByUserKey uniqueidentifier,
        UpdatedOn datetime,
        UpdatedByUserKey uniqueidentifier,
        DocumentTypeName nvarchar(255), 
        DocumentTypeDesc nvarchar(100),
        DocumentIconURL nvarchar(256),
        RelatedDocumentKey uniqueidentifier,
        RelatedDocumentTypeCode nvarchar(3),
        RelatedDocumentName nvarchar(100),
        RelatedAlternateName nvarchar(100),
        RelatedDocumentDescription nvarchar(250),
        RelatedDocumentTypeName nvarchar(255), 
        RelatedDocumentTypeDesc nvarchar(100),
        RelatedDocumentIconURL nvarchar(256),
        RelatedShortcutIconURL nvarchar(256),
        RelatedDocumentStatusCode int,
        SortOrder int
    )

    INSERT INTO @t1
        SELECT a.HierarchyKey,
               b.DocumentKey,
               b.DocumentVersionKey,
               b.DocumentStatusCode,
               b.DocumentName,
               b.AlternateName,
               b.DocumentDescription,
               b.DocumentTypeCode,
               b.IsSystem,
               b.ContainsChildrenFlag,
               b.RelatedDocumentVersionKey,
               b.AccessKey,
               b.DefaultChildAccessKey,
               b.StatusUpdatedOn,
               b.StatusUpdatedByUserKey,
               b.CreatedOn,
               b.CreatedByUserKey,
               b.UpdatedOn,
               b.UpdatedByUserKey,
               c.DocumentTypeName, 
               c.DocumentTypeDesc,
               c.DocumentIconURL,
               d.DocumentKey AS RelatedDocumentKey,
               d.DocumentTypeCode AS RelatedDocumentTypeCode,
               d.DocumentName AS RelatedDocumentName,
               d.AlternateName AS RelatedAlternateName,
               d.DocumentDescription AS RelatedDocumentDescription,
               e.DocumentTypeName AS RelatedDocumentTypeName, 
               e.DocumentTypeDesc AS RelatedDocumentTypeDesc,
               e.DocumentIconURL AS RelatedDocumentIconURL,
               e.ShortcutIconURL AS RelatedShortcutIconURL,
               d.DocumentStatusCode AS RelatedDocumentStatusCode,
               a.SortOrder
          FROM [dbo].[Hierarchy] a 
               INNER JOIN [dbo].[DocumentMain] b ON a.UniformKey = b.DocumentVersionKey
               INNER JOIN [dbo].[DocumentTypeRef] c ON b.DocumentTypeCode = c.DocumentTypeCode
               LEFT OUTER JOIN [dbo].[DocumentMain] d ON b.RelatedDocumentVersionKey = d.DocumentVersionKey
               LEFT OUTER JOIN [dbo].[DocumentTypeRef] e ON d.DocumentTypeCode = e.DocumentTypeCode
         WHERE a.ParentHierarchyKey = @parentHierarchyKeyCopy

    SELECT HierarchyKey,
           DocumentKey,
           DocumentVersionKey,
           DocumentStatusCode,
           DocumentName,
           AlternateName,
           DocumentDescription,
           DocumentTypeCode,
           IsSystem,
           ContainsChildrenFlag,
           RelatedDocumentVersionKey,
           AccessKey,
           DefaultChildAccessKey,
           StatusUpdatedOn,
           StatusUpdatedByUserKey,
           CreatedOn,
           CreatedByUserKey,
           UpdatedOn,
           UpdatedByUserKey,
           DocumentTypeName, 
           DocumentTypeDesc,
           DocumentIconURL,
           RelatedDocumentKey,
           RelatedDocumentTypeCode,
           RelatedDocumentName,
           RelatedAlternateName,
           RelatedDocumentDescription,
           RelatedDocumentTypeName, 
           RelatedDocumentTypeDesc,
           RelatedDocumentIconURL,
           RelatedShortcutIconURL
      FROM @t1 t
     WHERE ((t.DocumentStatusCode IN (10,20,30,70) AND @publishedOnly = 0)
            OR (t.DocumentStatusCode IN (40,60) 
                AND (@publishedOnly = 1
                     OR NOT EXISTS (SELECT 1
                                      FROM [dbo].[DocumentMain] f
                                     WHERE f.DocumentVersionKey = t.DocumentVersionKey
                                       AND f.DocumentStatusCode IN (10,20,30,70)
                                   )
                    )
                )
           )
      AND ((t.RelatedDocumentStatusCode IN (10,20,30,70) AND @publishedOnly = 0)
           OR t.RelatedDocumentStatusCode IS NULL
           OR (t.RelatedDocumentStatusCode IN (40,60) 
               AND (@publishedOnly = 1
                    OR NOT EXISTS (SELECT 1
                                     FROM [dbo].[DocumentMain] g
                                    WHERE g.DocumentVersionKey = t.RelatedDocumentVersionKey
                                      AND g.DocumentStatusCode IN (10,20,30,70)
                                  )
                   )
              )
          )
      AND EXISTS(SELECT 1 
                   FROM [dbo].[AccessItem] 
                        INNER JOIN [dbo].[UserToken] ON AccessItem.Grantee = UserToken.Grantee
                  WHERE AccessItem.AccessKey = t.AccessKey 
                    AND UserToken.UserKey=@userKey 
                    AND (AccessItem.Permission & 3) > 0)
      AND (@ignoreLicensing = 1
           OR NOT EXISTS (SELECT 1 FROM UniformLicense WHERE UniformKey = DocumentVersionKey)
           OR EXISTS(SELECT 1 
                       FROM [dbo].[UniformLicense] 
                            INNER JOIN [dbo].[LicenseLegacyList] l ON UniformLicense.LicenseKey = l.LicenseLegacyKey
                      WHERE UniformLicense.UniformKey = DocumentVersionKey
                    )
          )
    ORDER BY SortOrder, DocumentName
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentMainListByParentPath]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentMainListByParentPath]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

----------------------------------------------------------------------------------------------------------------------------------
-- Given a path to a folder, returns all documents in that folder. Security IS checked. The first 
-- segment of the documentPath should be the DocumentRoot name. The last segment should be the DocumentName of the folder
-- for which contents are desired. Individual segments are separated by the forward slash (/) 
-- 
-- Returns:
-- Everything from the DocumentMain table except the blob. Also includes DocumentTypeName, DocumentTypeDesc, 
-- and DocumentIconURL from DocumentTypeRef and HierarchyKey from the Hierarchy element representing the document.
----------------------------------------------------------------------------------------------------------------------------------
CREATE PROC [dbo].[asi_DocumentMainListByParentPath]
    @documentPath nvarchar(2000),
    @organizationKey uniqueidentifier,
    @userKey uniqueidentifier,
    @loggedInUserGroupKey uniqueidentifier = '00000000-0000-0000-0000-000000000000', -- if this is empty, we assume the user is not logged in
    @publishedOnly bit = 0,
    @ignoreLicensing bit = 0
AS
BEGIN
    DECLARE @rootHierarchyKey uniqueidentifier;
    DECLARE @hierarchyKey uniqueidentifier;
    DECLARE @documentVersionKey uniqueidentifier;
    DECLARE @documentKey uniqueidentifier;

    EXEC asi_DocumentKeysByPath @documentPath, @organizationKey, @userKey, @loggedInUserGroupKey, @ignoreLicensing, @rootHierarchyKey out, @hierarchyKey out, @documentVersionKey out, @documentKey out;

    EXEC asi_DocumentMainListByParentHierarchyKey @hierarchyKey, @userKey, @loggedInUserGroupKey, @publishedOnly, @ignoreLicensing;
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentMove]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentMove]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- moves the document given by key into the folder given by FolderHierarchyKey
-- Key is either a documentVersionKey for documents, or a HierarchyKey for folders.
CREATE PROCEDURE [dbo].[asi_DocumentMove]
   @folderHierarchyKey uniqueidentifier,
   @key uniqueidentifier
AS
BEGIN
   DECLARE 
      @documentVersionKey uniqueidentifier,
      @newHierarchyKey uniqueidentifier,
      @oldHierarchyKey uniqueidentifier,
      @childDocumentVersionKey uniqueidentifier,
      @documentTypeCode nchar(3)

   -- get the HierarchyKey to where it is currently linked, should be only one.  Also grab
   -- document type.  For folders, the key sent will be a hierarchy key
   SELECT TOP 1
          @oldHierarchyKey = a.HierarchyKey, 
          @documentTypeCode = b.DocumentTypeCode, 
          @documentVersionKey = b.DocumentVersionKey
     FROM Hierarchy a INNER JOIN DocumentMain b ON a.UniformKey = b.DocumentVersionKey
    WHERE b.DocumentVersionKey = @key
       OR a.HierarchyKey = @key
    ORDER BY b.UpdatedOn DESC, b.DocumentStatusCode ASC

   -- link the document into its new position
   exec asi_DocumentLinkDocumentOut @folderHierarchyKey, @documentVersionKey,@newHierarchyKey OUTPUT

   -- put out the new HierarchyKey so caller can get it
   SELECT @newHierarchyKey AS HierarchyKey

   -- if it is a folder, loop thru all of the children and move them as well, recursively
   IF @documentTypeCode = 'FOL'
   BEGIN
      SET ROWCOUNT 1
      SELECT @childDocumentVersionKey = UniformKey FROM Hierarchy WHERE ParentHierarchyKey = @oldHierarchyKey
      WHILE @@ROWCOUNT = 1
      BEGIN
         SET ROWCOUNT 0
         exec asi_DocumentMove @newHierarchyKey, @childDocumentVersionKey

         SET ROWCOUNT 1
         SELECT @childDocumentVersionKey = UniformKey FROM Hierarchy WHERE ParentHierarchyKey = @oldHierarchyKey
      END
      SET ROWCOUNT 0
   END

   -- remove the link to where is used to be
   DELETE FROM Hierarchy WHERE HierarchyKey = @oldHierarchyKey
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentPathByHierarchyKeyOut]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentPathByHierarchyKeyOut]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- Given a HierarchyKey returns the full path to the document starting with the root name.  The path is in
-- slash notation.  Like $/Common/Business Objects/DocumentType
CREATE PROCEDURE [dbo].[asi_DocumentPathByHierarchyKeyOut]
   @hierarchyKey uniqueidentifier,
   @path nvarchar(4000) OUT,
   @excludeDocument bit = 0,
   @publishedOnly bit = 0
AS
BEGIN
DECLARE 
   @rootHierarchyKey uniqueidentifier,
   @documentFound bit,
   @continue int

   SET NOCOUNT ON

   SET @path = ''
   SET @documentFound = 0
   SET @continue = 1

   SELECT @rootHierarchyKey = RootHierarchyKey
     FROM Hierarchy
    WHERE HierarchyKey = @hierarchyKey

   WHILE @hierarchyKey is not null AND @hierarchyKey <> @rootHierarchyKey AND @continue > 0
   BEGIN
      SELECT TOP 1
             @path = DocumentMain.DocumentName + CASE WHEN LEN(@path) > 0 THEN '/' + @path ELSE '' END,
             @hierarchyKey = Hierarchy.ParentHierarchyKey,
             @rootHierarchyKey = Hierarchy.RootHierarchyKey
        FROM Hierarchy INNER JOIN DocumentMain on Hierarchy.UniformKey = DocumentMain.DocumentVersionKey
       WHERE Hierarchy.HierarchyKey = @hierarchyKey
         AND (DocumentMain.DocumentStatusCode IN (40,60) OR @publishedOnly = 0)
       ORDER BY DocumentMain.DocumentStatusCode ASC, DocumentMain.UpdatedOn DESC

      SET @continue = @@ROWCOUNT

      IF @documentFound = 0 AND @excludeDocument = 1
      BEGIN
         SET @documentFound = 1
         SET @path = ''
      END
   END

   SET NOCOUNT OFF

   SELECT @path = HierarchyRootName + CASE WHEN LEN(@path) > 0 THEN '/' + @path ELSE '' END
     FROM HierarchyRoot
    WHERE RootHierarchyKey = @rootHierarchyKey
END


GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentPathByHierarchyKey]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentPathByHierarchyKey]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- Given a HierarchyKey returns the full path to the document starting with the root name.  The path is in
-- slash notation.  Like $/Common/Business Objects/DocumentType
CREATE PROCEDURE [dbo].[asi_DocumentPathByHierarchyKey]
   @hierarchyKey uniqueidentifier,
   @publishedOnly bit = 0
AS
BEGIN
DECLARE 
   @path nvarchar(4000)

   EXEC asi_DocumentPathByHierarchyKeyOut @hierarchyKey, @path OUT, 0, @publishedOnly

   SELECT @path AS Path
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentPathByKey]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentPathByKey]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_DocumentPathByKey]
   @key uniqueidentifier,
   @organizationKey uniqueidentifier OUT,
   @publishedOnly bit = 0
AS
BEGIN
   DECLARE @hierarchyKey uniqueidentifier, @rootHierarchyKey uniqueidentifier, @documentName nvarchar(100), @path nvarchar(4000)

   SELECT TOP 1 @hierarchyKey = HierarchyKey, @organizationKey = OrganizationKey,
          @documentName = DocumentName, @rootHierarchyKey = RootHierarchyKey
     FROM (
     SELECT Hierarchy.HierarchyKey, HierarchyRoot.OrganizationKey, HierarchyRoot.HierarchyRootName, DocumentMain.DocumentName,
            Hierarchy.RootHierarchyKey, DocumentMain.DocumentStatusCode, DocumentMain.UpdatedOn
     FROM Hierarchy 
          INNER JOIN HierarchyRoot on Hierarchy.RootHierarchyKey = HierarchyRoot.RootHierarchyKey
          INNER JOIN DocumentMain on Hierarchy.UniformKey = DocumentMain.DocumentVersionKey
          WHERE DocumentMain.DocumentKey = @key
     UNION
     SELECT Hierarchy.HierarchyKey, HierarchyRoot.OrganizationKey, HierarchyRoot.HierarchyRootName, DocumentMain.DocumentName,
          Hierarchy.RootHierarchyKey, DocumentMain.DocumentStatusCode, DocumentMain.UpdatedOn
     FROM Hierarchy inner join HierarchyRoot on Hierarchy.RootHierarchyKey = HierarchyRoot.RootHierarchyKey
          inner join DocumentMain on Hierarchy.UniformKey = DocumentMain.DocumentVersionKey
          WHERE Hierarchy.UniformKey = @key
     ) a
    WHERE (DocumentStatusCode IN (40,60) OR @publishedOnly = 0)
          AND HierarchyRootName <> '.'
    ORDER BY UpdatedOn DESC, DocumentStatusCode ASC

   IF @@ROWCOUNT > 0
   BEGIN
      exec asi_DocumentPathByHierarchyKeyOut @hierarchyKey, @path OUT, 1, @publishedOnly
      IF @hierarchyKey <> @rootHierarchyKey
         SET @path = @path + '/' + @documentName     
   END

   SELECT @path AS Path
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentPurgeArchivedVersions]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentPurgeArchivedVersions]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


-- Purge all archived versions of a specified document (or of all documents)
CREATE PROCEDURE [dbo].[asi_DocumentPurgeArchivedVersions] 
    @documentVersionKey uniqueidentifier,
    @allDocuments bit = 0 -- Pass any GUID if this is set to 1, as the document version key is ignored
AS
BEGIN
    SET NOCOUNT ON
    DECLARE @documentsToDelete TABLE (DocumentKey uniqueidentifier, 
                                      DocumentVersionKey uniqueidentifier, 
                                      AccessKey uniqueidentifier, 
                                      PublishedVersionExists bit)
    INSERT INTO @documentsToDelete
    SELECT d.DocumentKey, d.DocumentVersionKey, d.AccessKey, 0
      FROM DocumentMain d
     WHERE DocumentStatusCode IN (50, 80)
           AND NOT EXISTS (SELECT 1 FROM DocumentTypeRef WHERE PublishWorkflowDocumentKey = d.DocumentKey)
           AND NOT EXISTS (SELECT 1 FROM DocumentTypeRef WHERE RecycleWorkflowDocumentKey = d.DocumentKey)
           AND NOT EXISTS (SELECT 1 FROM GroupTypeRef WHERE MemberQueryFolderKey = d.DocumentKey)
           AND NOT EXISTS (SELECT 1 FROM PackageQueue WHERE QueueReleaseWorkflowKey = d.DocumentKey)
           AND NOT EXISTS (SELECT 1 FROM RFMDefinition WHERE TransactionDocumentKey = d.DocumentKey)
           AND NOT EXISTS (SELECT 1 FROM RFMDefinition WHERE UserDocumentKey = d.DocumentKey)
           AND NOT EXISTS (SELECT 1 FROM WorkItem WHERE ProcessEngineKey = d.DocumentKey)
           AND NOT EXISTS (SELECT 1 FROM WorkItem WHERE WorkflowDefinitionKey = d.DocumentKey)
    AND (@allDocuments = 1 OR d.DocumentVersionKey = @documentVersionKey)

    UPDATE d
       SET PublishedVersionExists = 1
      FROM @documentsToDelete d
    WHERE EXISTS (SELECT 1 FROM DocumentMain x WHERE d.DocumentVersionKey = x.DocumentVersionKey AND x.DocumentStatusCode = 40)

    -- Delete unpublished documents from the PublishRequest and PublishRequestDetail tables
    DELETE p 
      FROM PublishRequest p
           INNER JOIN @documentsToDelete dtd ON p.DocumentKey = dtd.DocumentKey
    DELETE p 
      FROM PublishRequestDetail p
           INNER JOIN @documentsToDelete dtd ON p.ContentDocumentKey = dtd.DocumentKey 

    -- Delete the unpublished documents
    DELETE d
      FROM [dbo].[DocumentMain] d
           INNER JOIN @documentsToDelete dtd ON d.DocumentKey = dtd.DocumentKey
           
    -- Delete any unused hierarchy and access keys
    DELETE h
      FROM Hierarchy h 
           INNER JOIN @documentsToDelete dtd ON h.UniformKey = dtd.DocumentVersionKey AND h.UniformType = 'DocumentVersion'
    WHERE h.UniformKey NOT IN (SELECT DocumentVersionKey FROM DocumentMain) 
           AND h.HierarchyKey NOT IN (SELECT ParentHierarchyKey FROM Hierarchy)
    DELETE ai
      FROM [dbo].[AccessItem] ai
           INNER JOIN [dbo].[AccessMain] am ON ai.AccessKey = am.AccessKey 
           INNER JOIN @documentsToDelete dtd ON ai.AccessKey = dtd.AccessKey 
     WHERE dtd.PublishedVersionExists = 0 AND am.AccessScope = 'Local'
           AND NOT EXISTS (SELECT 1 FROM DocumentMain WHERE AccessKey = am.AccessKey AND DocumentKey != dtd.DocumentKey)
    DELETE am
      FROM [dbo].[AccessMain] am
           INNER JOIN @documentsToDelete dtd ON am.AccessKey = dtd.AccessKey 
     WHERE dtd.PublishedVersionExists = 0 AND am.AccessScope = 'Local'
           AND NOT EXISTS (SELECT 1 FROM DocumentMain WHERE AccessKey = am.AccessKey AND DocumentKey != dtd.DocumentKey)
END



GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DropNameAllView]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DropNameAllView]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_DropNameAllView] 
AS
BEGIN
	SET NOCOUNT ON;

	IF EXISTS (SELECT 1 FROM sys.objects WHERE [name] = N'Name_All' AND [type] = 'V')
		DROP VIEW Name_All;
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DuplicateEngineCandidateMapper]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DuplicateEngineCandidateMapper]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- ========================================================
-- Used by the ASI contact duplicates process
-- to weed out unwanted candidates and map remainder to
-- report tables.  Would require tailoring to use with
-- any third party solution. 
-- ========================================================
CREATE PROCEDURE [dbo].[asi_DuplicateEngineCandidateMapper]
       @weightThreshold int
AS
BEGIN
    SET NOCOUNT ON;
    --remove records not meeting weight threshold
    DELETE [dbo].[DuplicateEngineCandidate]
     WHERE [Weight] > @weightThreshold;

    --remove records already existing in DuplicateParty table
    DELETE [dbo].[DuplicateEngineCandidate]
      FROM [dbo].[DuplicateEngineCandidate] [c]
           INNER JOIN [dbo].[DuplicateParty] [p] ON [p].[PartyId] = [c].[ContactID];
    IF EXISTS (SELECT 1 FROM [dbo].[DuplicateEngineCandidate])
    BEGIN
        --create a new rule entry as needed
        INSERT INTO [dbo].[DuplicateRuleSet] ([DuplicateRuleSetCode],
                                              [DuplicateRuleSetName]
                                             )
               SELECT DISTINCT
                      [c].[DuplicateEngineRuleSetCode],
                      [c].[DuplicateEngineRuleSetCode]
                 FROM [dbo].[DuplicateEngineRuleSet] AS [c]
                      LEFT JOIN [dbo].[DuplicateRuleSet] AS [r] ON [c].[DuplicateEngineRuleSetCode] = [r].[DuplicateRuleSetCode]
                WHERE [r].[DuplicateRuleSetCode] IS NULL;

        --transfer records
        INSERT INTO [dbo].[DuplicateParty] ([DuplicatePartyGroupCode],
                                            [DuplicateRuleSetCode],
                                            [PartyId],
                                            [MatchDate]
                                           )
               SELECT [DuplicateGroupKey],
                      [DuplicateRuleSetCode],
                      [ContactID],
                      DATEADD([dd], 0, DATEDIFF([dd], 0, dbo.asi_GetAppDatetime()))
                 FROM [dbo].[DuplicateEngineCandidate];
    END;
END;

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DuplicateEngineCreateKeys]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DuplicateEngineCreateKeys]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


-- ==================================================================
-- Used exclusively by the in-house duplicate contact engine to find
-- contacts based on the rule code 
-- ==================================================================
CREATE PROC [dbo].[asi_DuplicateEngineCreateKeys] 
    @RuleCode nvarchar(3)
AS
  BEGIN
    
    IF OBJECT_ID('tempdb..#WorkTable') IS NOT NULL DROP TABLE #WorkTable;
    IF OBJECT_ID('tempdb..#DuplicateTable') IS NOT NULL DROP TABLE #DuplicateTable;

    CREATE TABLE #WorkTable(
        WeightValue nvarchar(150) COLLATE DATABASE_DEFAULT, 
        GroupKey nvarchar(150) COLLATE DATABASE_DEFAULT, 
        ContactID varchar(10) COLLATE DATABASE_DEFAULT);

    CREATE TABLE #DuplicateTable(
        MatchKey nvarchar(150) COLLATE DATABASE_DEFAULT);

    CREATE INDEX IX_DuplicateTable_MatchKey ON #DuplicateTable (MatchKey);

    DECLARE @sql AS nvarchar(max);
    
    --retrieve the rule which will be an entire select statement
    SET @sql = ( SELECT pref.value('(text())[1]','varchar(max)') AS GroupRule 
                    FROM [dbo].[DuplicateEngineRuleSet]  
                    CROSS APPLY [DuplicateEngineRuleSetRule].nodes('Root/Rule') AS Rules(pref) 
                    WHERE [DuplicateEngineRuleSetCode] = @RuleCode);
    
    SET @sql = 'INSERT INTO #WorkTable ' + @sql;
    EXEC(@sql);
    
    CREATE INDEX IX_WorkTable_GroupKey ON #WorkTable (GroupKey) INCLUDE (WeightValue, ContactID);

    --find dupicate keys
    INSERT INTO #DuplicateTable ([MatchKey])
        SELECT  GroupKey 
            FROM #WorkTable
            GROUP BY GroupKey
            HAVING COUNT(1) > 1;

    TRUNCATE TABLE [dbo].[DuplicateEngineCandidate];

     --load to results table
    INSERT INTO [dbo].[DuplicateEngineCandidate] ([ContactID],[DuplicateRuleSetCode],[DuplicateGroupKey],[DuplicateGroupKeyValue],[Weight])
        SELECT t.ContactID, 
            @RuleCode,
            t.GroupKey, 
            t.WeightValue, 0
            FROM #WorkTable t 
                INNER JOIN #DuplicateTable d ON d.MatchKey = t.GroupKey;
    
    IF OBJECT_ID('tempdb..#WorkTable') IS NOT NULL DROP TABLE #WorkTable;
    IF OBJECT_ID('tempdb..#DuplicateTable') IS NOT NULL DROP TABLE #DuplicateTable;
  END;



GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DuplicateEngineWeighCandidates]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DuplicateEngineWeighCandidates]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- ==================================================================
-- Used exclusively by the in-house duplicate contact engine to weigh
-- previously found duplicate contact records 
-- ==================================================================
CREATE PROC [dbo].[asi_DuplicateEngineWeighCandidates]
AS
BEGIN
    --clear any previous weights
    UPDATE [dbo].[DuplicateEngineCandidate] SET [Weight] = 0;

    IF OBJECT_ID('tempdb..#WeightTemp') IS NOT NULL DROP TABLE #WeightTemp;
    IF OBJECT_ID('tempdb..#DifferenceTemp') IS NOT NULL DROP TABLE #DifferenceTemp;

    -- create a table of duplicate key values with row numbers by duplicate key groups 
    -- ====================================================================================
    -- Row  DuplicateGroupKey   DuplicateGroupKeyValue  ContactKey
    -- 1    B65210001           BrownJ10001             F3B2499C-DE92-4994-9BD7-06054B07696C
    -- 2    B65210001           BrownC10001             8D3596DC-A5E5-41B3-B330-64F93A8EC28A
    -- 1    C55292138           CummingsJ92138          6149A21B-7CDE-4911-BD35-D8C06F5EB141
    -- 2    C55292138           CummingsE92138          5AD11B0D-9447-4885-BD41-C23843FD85E8

    WITH WeightTemp_CTE AS (
        SELECT ROW_NUMBER() OVER (PARTITION BY [DuplicateGroupKey] ORDER BY [DuplicateGroupKey]) AS [Row],
            [DuplicateGroupKey], 
            [DuplicateGroupKeyValue], 
            [ContactID] 
        FROM  [dbo].[DuplicateEngineCandidate] 
        )
     SELECT [Row],[DuplicateGroupKey],[DuplicateGroupKeyValue],[ContactID] 
        INTO #WeightTemp 
        FROM WeightTemp_CTE ;
     CREATE INDEX IX_WeightTemp_DuplicateGroupKey ON #WeightTemp (DuplicateGroupKey ASC) INCLUDE ([Row], [DuplicateGroupKeyValue], [ContactID]);

     --now use those row numbers to flatten out records so we can use Edit_Distance function - note source can be repeated of more than one match
     -- ========================================================================================================================
     --   SourceValue     SourceContactKey                        CompareValue    CompareContactKey                       Weight       
     --   BrownJ10001     F3B2499C-DE92-4994-9BD7-06054B07696C    BrownC10001     8D3596DC-A5E5-41B3-B330-64F93A8EC28A    0

     SELECT a.[DuplicateGroupKeyValue] AS [SourceValue], 
        a.[ContactID] AS [SourceContactID], 
        b.[DuplicateGroupKeyValue] AS [CompareValue], 
        b.[ContactID] AS [CompareContactID], 
        0 AS [Weight]
        INTO #DifferenceTemp
        FROM #WeightTemp a 
            INNER JOIN #WeightTemp b ON b.[DuplicateGroupKey] = a.[DuplicateGroupKey] AND b.[Row] > 1
        WHERE a.[Row] = 1

     --now generate the difference
     UPDATE #DifferenceTemp 
        SET [Weight] = [dbo].[asi_Edit_Distance]([SourceValue],[CompareValue]);

     --assign weights to DuplicateEngineCandidate, first using source contact and then compare contact
     -- note that we must only assign source contact once - it could have multiple rows and we don't want overwrite
     CREATE INDEX IX_DifferenceTemp_SourceContactKey ON #DifferenceTemp (SourceContactID ASC) INCLUDE ([Weight]);
     CREATE INDEX IX_DifferenceTemp_CompareContactKey ON #DifferenceTemp (CompareContactID ASC) INCLUDE ([Weight]);

     UPDATE d 
        SET [Weight] = t.[Weight]
            FROM  [dbo].[DuplicateEngineCandidate] d
                INNER JOIN #DifferenceTemp t ON t.[SourceContactID] = d.[ContactID]
            WHERE d.[Weight] = 0;

     UPDATE d 
        SET [Weight] = t.[Weight]
            FROM  [dbo].[DuplicateEngineCandidate] d
                INNER JOIN #DifferenceTemp t ON t.[CompareContactID] = d.[ContactID];

     --house cleaning
     IF OBJECT_ID('tempdb..#WeightTemp') IS NOT NULL DROP TABLE #WeightTemp;
     IF OBJECT_ID('tempdb..#DifferenceTemp') IS NOT NULL DROP TABLE #DifferenceTemp;

END;

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DuplicateEngineBatchRun]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DuplicateEngineBatchRun]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- Launches the Duplicate Contact search engine
-- Populates DuplicateParty and associated tables
-- =============================================
CREATE PROCEDURE asi_DuplicateEngineBatchRun
AS
BEGIN
    BEGIN TRANSACTION;
	SET NOCOUNT ON;
    DECLARE @result int;
    EXEC @result = sp_getapplock @Resource = 'asi_DuplicateEngineBatchRun', 
               @LockMode = 'Exclusive';

    IF @Result < 0
       BEGIN
           ROLLBACK TRANSACTION;
           RAISERROR ('Batch process already running', 16, 1);
           RETURN;
       END

    EXEC [dbo].[asi_DuplicateEngineCreateKeys] @RuleCode = N'ASI';
    EXEC [dbo].[asi_DuplicateEngineWeighCandidates]
    EXEC [dbo].[asi_DuplicateEngineCandidateMapper]	@weightThreshold = 1

    EXEC @result = sp_releaseapplock @Resource = 'asi_DuplicateEngineBatchRun';
    COMMIT TRANSACTION
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_EnsurePublishQueueAndServiceBroker]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_EnsurePublishQueueAndServiceBroker]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


-----------------------------------------------
-- Create Publish Queue and enable the Broker
-----------------------------------------------
CREATE PROCEDURE [dbo].[asi_EnsurePublishQueueAndServiceBroker]
AS
BEGIN
    DECLARE @dbname sysname;
    DECLARE @sql nvarchar(500);
    SELECT @dbname = DB_NAME();
    IF (SELECT is_broker_enabled FROM sys.databases WHERE name = @dbname) <> 1
    BEGIN
        BEGIN TRY
            SET @sql = N'ALTER DATABASE ' + @dbname + N' SET ENABLE_BROKER WITH ROLLBACK IMMEDIATE';
            EXEC sp_executesql @sql;
        END TRY
        BEGIN CATCH
            SET @sql = N'ALTER DATABASE ' + @dbname + N' SET NEW_BROKER WITH ROLLBACK IMMEDIATE';
            EXEC sp_executesql @sql;
        END CATCH;
    END

    IF NOT EXISTS (SELECT * FROM sys.services WHERE name = N'iMISPublishService')
    BEGIN
        CREATE QUEUE iMISPublishQueue;
    END

    IF NOT EXISTS (SELECT * FROM sys.service_queues WHERE name = N'iMISPublishQueue')
    BEGIN
        CREATE SERVICE iMISPublishService 
            ON QUEUE iMISPublishQueue ([http://schemas.microsoft.com/SQL/Notifications/PostQueryNotification]);
    END
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ExportTypeByKey]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ExportTypeByKey]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_ExportTypeByKey    Script Date: 7/3/2003 4:58:03 PM ******/
CREATE   PROC [dbo].[asi_ExportTypeByKey]
	@typeKey uniqueidentifier
	AS
BEGIN
	SET ROWCOUNT 1
	SELECT	e.Name as ExportTypeName ,e.ExportType, e.NavMarker, e.ProcessEngineTypeKey, p.Name

	 FROM	ExportType e, ProcessEngineType p
			
	 WHERE	e.ExportTypeKey = @typeKey 
		and e.ProcessEngineTypeKey = p.ProcessEngineTypeKey
	SET ROWCOUNT 0
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ExportTypes]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ExportTypes]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_ExportTypes    Script Date: 7/3/2003 4:58:03 PM ******/
CREATE   PROC asi_ExportTypes
	AS
BEGIN
	select ExportTypeKey, ExportType, Name, NavMarker, ProcessEngineTypeKey from ExportType
	
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_FindLastReceiptDateForContact]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_FindLastReceiptDateForContact]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_FindLastReceiptDateForContact]
@contactKey uniqueidentifier

 AS

SELECT TOP 1 r.IssuedOn FROM ReceiptMain r
 WHERE r.IssuedToContactKey = @contactKey
 ORDER BY r.IssuedOn DESC

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_FindUnreceiptedPayments]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_FindUnreceiptedPayments]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_FindUnreceiptedPayments]
@contactKey uniqueidentifier

 AS

SELECT * FROM PaymentMain p
 LEFT OUTER JOIN ReceiptLine rl on p.PaymentKey = rl.PaymentKey
 WHERE p.PayorContactKey = @contactKey
 AND  rl.ReceiptLineKey is null

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_FixDuplicateIndividualRows]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_FixDuplicateIndividualRows]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_FixDuplicateIndividualRows]
AS
BEGIN
    SET NOCOUNT ON;
    BEGIN TRANSACTION;
    
    -- Fix up the problem caused by converting a "CM" record with two ContactMain records
    -- to a "M" record, which leaves two Individual records associated with the same Name record
    DECLARE @cleanupTable TABLE (ContactKey uniqueidentifier);
    DECLARE @udpateTable TABLE (ContactKey uniqueidentifier);

    INSERT INTO @cleanupTable  -- Get a list of extraneous individual records
        SELECT a.ContactKey 
          FROM ContactMain a 
               INNER JOIN ContactMain b ON a.SyncContactID = b.SyncContactID
         WHERE a.ContactKey != b.ContactKey AND a.IsInstitute = 0 AND b.IsInstitute = 0 AND a.SyncContactID != b.ID;

    INSERT INTO @udpateTable  -- Get a list of individual record IDs that need to be updated
        SELECT a.ContactKey 
          FROM ContactMain a 
               INNER JOIN ContactMain b ON a.SyncContactID = b.SyncContactID
         WHERE a.ContactKey != b.ContactKey AND a.IsInstitute = 0 AND b.IsInstitute = 0 AND a.ID != b.SyncContactID;

    DECLARE @now datetime;
    SELECT @now = dbo.asi_GetAppDatetime();
    
     -- Delete extraneous Individual record
    IF EXISTS (SELECT 1 FROM @cleanupTable)
    BEGIN
        UPDATE a
           SET ContactStatusCode = d.ContactStatusCode,
               UpdatedByUserKey = c.UserKey,
               UpdatedOn = @now,
               SyncContactID = NULL, 
               ID = NULL
          FROM ContactMain a INNER JOIN @cleanupTable b ON a.ContactKey = b.ContactKey
                             INNER JOIN UserMain c ON c.UserId = 'MANAGER'
                             INNER JOIN ContactStatusRef d ON d.ContactStatusDesc = 'Delete' AND d.IsSystem = 1
    END

    -- Correct the ID on the remaining Individual record
    IF EXISTS (SELECT 1 FROM @udpateTable)
    BEGIN
        UPDATE a
           SET a.ID = a.SyncContactID
          FROM ContactMain a 
               INNER JOIN @udpateTable b ON a.ContactKey = b.ContactKey;
    END

    COMMIT TRANSACTION;
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_FixDuplicateIndividualRowsById]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_FixDuplicateIndividualRowsById]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_FixDuplicateIndividualRowsById]
     @id varchar(10)
AS
BEGIN
    SET NOCOUNT ON;
    BEGIN TRANSACTION;
    -- Fix up the problem caused by converting a "CM" record with two ContactMain records
    -- to a "M" record, which leaves two Individual records associated with the same Name record
    DECLARE @cleanupTable TABLE (ContactKey uniqueidentifier);
    DECLARE @udpateTable TABLE (ContactKey uniqueidentifier);

    INSERT INTO @cleanupTable  -- Get a list of extraneous individual records
        SELECT a.ContactKey FROM ContactMain a INNER JOIN ContactMain b ON a.SyncContactID = b.SyncContactID
         WHERE a.ContactKey != b.ContactKey AND a.IsInstitute = 0 AND b.IsInstitute = 0 AND a.SyncContactID != b.ID
               AND (a.SyncContactID = @id OR a.ID = @id);

    INSERT INTO @udpateTable  -- Get a list of individual record IDs that need to be updated
        SELECT a.ContactKey FROM ContactMain a INNER JOIN ContactMain b ON a.SyncContactID = b.SyncContactID
         WHERE a.ContactKey != b.ContactKey AND a.IsInstitute = 0 AND b.IsInstitute = 0 AND a.ID != b.SyncContactID 
               AND (a.SyncContactID = @id OR a.ID = @id);

    DECLARE @now datetime;
    SELECT @now = dbo.asi_GetAppDatetime();
    
     -- Delete extraneous Individual record
    IF EXISTS (SELECT 1 FROM @cleanupTable)
    BEGIN
        UPDATE a
           SET ContactStatusCode = d.ContactStatusCode,
               UpdatedByUserKey = c.UserKey,
               UpdatedOn = @now,
               SyncContactID = NULL, 
               ID = NULL
          FROM ContactMain a INNER JOIN @cleanupTable b ON a.ContactKey = b.ContactKey
                             INNER JOIN UserMain c ON c.UserId = 'MANAGER'
                             INNER JOIN ContactStatusRef d ON d.ContactStatusDesc = 'Delete' AND d.IsSystem = 1
    END

    -- Correct the ID on the remaining Individual record
    IF EXISTS (SELECT 1 FROM @udpateTable)
    BEGIN
        UPDATE a
           SET a.ID = a.SyncContactID
          FROM ContactMain a 
               INNER JOIN @udpateTable b ON a.ContactKey = b.ContactKey
    END

    COMMIT TRANSACTION;
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_RecalculateGiftHistorySummary]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_RecalculateGiftHistorySummary]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_RecalculateGiftHistorySummary]
    @DonorId varchar(10) = NULL, @RebuildAll bit = 0
AS
BEGIN
    SET NOCOUNT ON;
    
    -- Just in case process was interrupted, ensure temp tables are deleted
    IF OBJECT_ID('tempdb..#TblGifts') IS NOT NULL
        DROP TABLE #TblGifts;
    IF OBJECT_ID('tempdb..#GiftHistory') IS NOT NULL
        DROP TABLE #GiftHistory;
    IF OBJECT_ID('tempdb..#Years') IS NOT NULL
        DROP TABLE #Years;
    IF OBJECT_ID('tempdb..#ConsecutiveYears') IS NOT NULL
        DROP TABLE #ConsecutiveYears;

    -- Declare a table variable to store a summarization of gift-related transaction information
    CREATE TABLE #TblGifts (DonorId varchar(10) COLLATE DATABASE_DEFAULT,
                            OriginalTransNum int,
                            Amount money,
                            TransactionDate datetime,
                            GiftCalendarYear int,
                            Appeal varchar(40) COLLATE DATABASE_DEFAULT,
                            PRIMARY KEY (DonorId, OriginalTransNum)
                            );

    -- Declare a table variable to store details about first gift transactions
    DECLARE @FirstTrans      TABLE ( DonorId varchar(10) NOT NULL,
                                     OriginalTransNum int NOT NULL,
                                     TransactionDate datetime NOT NULL,
                                     Amount money NOT NULL,
                                     Appeal varchar(40) NULL
                                    );
    -- Declare a table variable to store details about next-to-last gift transactions
    DECLARE @NextToLastTrans TABLE ( DonorId varchar(10) NOT NULL,
                                     OriginalTransNum int NOT NULL,
                                     TransactionDate datetime NOT NULL,
                                     Amount money NOT NULL,
                                     Appeal varchar(40) NULL
                                    );
    -- Declare a table variable to store details about last gift transactions
    DECLARE @LastTrans       TABLE ( DonorId varchar(10) NOT NULL,
                                     OriginalTransNum int NOT NULL,
                                     TransactionDate datetime NOT NULL,
                                     Amount money NOT NULL,
                                     Appeal varchar (40) NULL
                                    );

    -- Populate a table variable with one row summarizing gift-related transactions for the donor(s) being updated
    IF @DonorId IS NULL AND @RebuildAll = 1
    BEGIN
        INSERT #TblGifts(OriginalTransNum ,DonorId, Amount,TransactionDate ,GiftCalendarYear, Appeal)
        SELECT gr.OriginalTransaction,
               gr.ID,
               SUM(gr.Amount) AS Amount,
               MIN(gr.TransactionDate) AS MinTransDate,
               YEAR(MIN(gr.TransactionDate)) AS GiftCalendarYear,
               MAX(gr.AppealCode) AS AppealCode
          FROM [dbo].[GiftReport] gr 
         GROUP BY gr.OriginalTransaction, gr.ID
        HAVING SUM(gr.Amount) <> 0
    END
    ELSE
    BEGIN
        INSERT #TblGifts(OriginalTransNum ,DonorId, Amount,TransactionDate ,GiftCalendarYear, Appeal)
        SELECT gr.OriginalTransaction ,
               gr.ID ,
               SUM(gr.Amount) AS Amount,
               MIN(gr.TransactionDate) AS MinTransDate,
               YEAR(MIN (gr.TransactionDate)) AS GiftCalendarYear,
               MAX(gr.AppealCode) AS AppealCode
          FROM [dbo].[GiftReport] gr 
         WHERE gr.ID = @DonorId
         GROUP BY gr.OriginalTransaction, gr.ID
        HAVING SUM(gr.Amount) <> 0
    END

    -- Before proceeding, check to be sure that there is still at least one row of giving history for the specified Donor
    -- If there are no rows of giving history, then delete any existing rows from GiftHistorySummary for the specified Donor and exit
    IF (SELECT COUNT(1) FROM #TblGifts WHERE DonorId = @DonorId AND @RebuildAll = 0) = 0
    BEGIN
        DELETE FROM [dbo].[GiftHistorySummary]
         WHERE [DonorId] = @DonorId
        RETURN
    END
      

    -- Populate a table variable with one row of details about the first gift transaction for the donor(s) being updated
    IF @DonorId IS NULL
    BEGIN
        INSERT INTO @FirstTrans (DonorId ,OriginalTransNum, TransactionDate,Amount ,Appeal)
        SELECT g.DonorId,
               g.OriginalTransNum,
               g.TransactionDate,
               g.Amount,
               g.Appeal
          FROM #TblGifts g
         WHERE g.OriginalTransNum = (SELECT MIN (a.OriginalTransaction)
                                        FROM [dbo].[GiftReport] a
                                             INNER JOIN (SELECT MIN(r.DateReceived) AS DateReceived
                                                           FROM [dbo].[GiftReport] r
                                                          WHERE r.ID = g.DonorId AND r.DateReceived IS NOT NULL) b
                                             ON a.DateReceived = b.DateReceived AND a.ID = g.DonorId
                                       WHERE a.OriginalTransaction IS NOT NULL
                                      )
    END
    ELSE
    BEGIN
        INSERT INTO @FirstTrans (DonorId ,OriginalTransNum, TransactionDate,Amount ,Appeal)
        SELECT g.DonorId,
               g.OriginalTransNum,
               g.TransactionDate,
               g.Amount,
               g.Appeal
          FROM #TblGifts g
         WHERE (g.DonorId = @DonorId)
           AND g.OriginalTransNum = (SELECT MIN (a.OriginalTransaction)
                                        FROM [dbo].[GiftReport] a
                                            INNER JOIN (SELECT MIN(r.DateReceived) AS DateReceived
                                                          FROM [dbo].[GiftReport] r
                                                         WHERE r.ID = g.DonorId AND r.DateReceived IS NOT NULL) b
                                            ON a.DateReceived = b.DateReceived AND a.ID = g.DonorId
                                       WHERE a.OriginalTransaction IS NOT NULL
                                      )
    END

    -- Populate a table variable with one row of details about the most recent gift transaction for the donor(s) being updated
    IF @DonorId IS NULL
    BEGIN
        INSERT @LastTrans(DonorId, OriginalTransNum, TransactionDate, Amount, Appeal)
        SELECT g.DonorId,
               g.OriginalTransNum,
               g.TransactionDate,
               g.Amount,
               g.Appeal
          FROM #TblGifts g
         WHERE g.OriginalTransNum = (SELECT MAX(a.OriginalTransaction)
                                       FROM [dbo].[GiftReport] a
                                            INNER JOIN (SELECT MAX(r.DateReceived) AS DateReceived
                                                          FROM [dbo].[GiftReport] r
                                                         WHERE r.ID = g.DonorId AND r.DateReceived IS NOT NULL) b
                                            ON a.DateReceived = b.DateReceived AND a.ID = g.DonorId
                                      WHERE a.OriginalTransaction IS NOT NULL
                                     )
    END
    ELSE
    BEGIN
        INSERT @LastTrans(DonorId, OriginalTransNum, TransactionDate, Amount, Appeal)
        SELECT g.DonorId,
               g.OriginalTransNum,
               g.TransactionDate,
               g.Amount,
               g.Appeal
          FROM #TblGifts g
         WHERE (g.DonorId = @DonorId )
           AND g.OriginalTransNum = (SELECT MAX(a.OriginalTransaction)
                                       FROM [dbo].[GiftReport] a
                                            INNER JOIN (SELECT MAX(r.DateReceived) AS DateReceived
                                                          FROM [dbo].[GiftReport] r
                                                         WHERE r.ID = g.DonorId AND r.DateReceived IS NOT NULL) b
                                            ON a.DateReceived = b.DateReceived AND a.ID = g.DonorId
                                      WHERE a.OriginalTransaction IS NOT NULL
                                     )
    END
    
    -- Populate a table variable with one row of details about the next-to-last gift transaction for the donor(s) being updated
    IF @DonorId IS NULL
    BEGIN
        INSERT @NextToLastTrans(DonorId ,OriginalTransNum, TransactionDate,Amount ,Appeal)
            SELECT g.DonorId,
                   g.OriginalTransNum,
                   g.TransactionDate,
                   g.Amount,
                   g.Appeal
              FROM #TblGifts g
             WHERE g.OriginalTransNum = (SELECT MAX(g1.OriginalTransNum)
                                           FROM #TblGifts g1
                                                LEFT OUTER JOIN @LastTrans l ON g1.OriginalTransNum = l.OriginalTransNum
                                          WHERE g1.DonorId = g.DonorId AND l.OriginalTransNum IS NULL
                                        )
    END
    ELSE
    BEGIN
        INSERT @NextToLastTrans(DonorId ,OriginalTransNum, TransactionDate,Amount ,Appeal)
        SELECT g.DonorId ,
               g.OriginalTransNum ,
               g.TransactionDate ,
               g.Amount ,
               g.Appeal
          FROM #TblGifts g
         WHERE (g.DonorId = @DonorId)
           AND g.OriginalTransNum = (SELECT MAX (g1.OriginalTransNum)
                                       FROM #TblGifts g1
                                            LEFT OUTER JOIN @LastTrans l ON g1.OriginalTransNum = l.OriginalTransNum
                                      WHERE g1.DonorId = g.DonorId AND l.OriginalTransNum IS NULL
                                    )
    END

    -- Declare a table variable for identifying date ranges for evaluating consecutive years
    CREATE TABLE #Years ( DonorId varchar (10) COLLATE DATABASE_DEFAULT NOT NULL,
                          Seqn int NOT NULL,
                          CalendarYear int NOT NULL,
                          BeginDate datetime NOT NULL,
                          EndDate datetime NOT NULL,
                          PrevYr int NOT NULL,
                          NextYr int NOT NULL,
                          ConsecutiveYr bit,
                          PRIMARY KEY (DonorId, Seqn)
                         );
                                
    -- Populate a table variable for identifying date ranges for evaluating consecutive years
    INSERT INTO #Years(Seqn, DonorId, CalendarYear, BeginDate, EndDate, PrevYr, NextYr, ConsecutiveYr)
        SELECT ROW_NUMBER() OVER (ORDER BY g.DonorId asc, YEAR(g.TransactionDate) asc),
               g.DonorId ,
               YEAR(g.TransactionDate),
               CAST(CAST(YEAR(g.TransactionDate ) AS varchar(4)) + '0101' AS datetime),
               CAST(CAST(YEAR(g.TransactionDate ) AS varchar(4)) + '1231' AS datetime),
               YEAR(g.TransactionDate)- 1,
               YEAR(g.TransactionDate)+ 1,
               0
          FROM #TblGifts g
         GROUP BY g.DonorId, YEAR( g.TransactionDate )
   
    CREATE TABLE #ConsecutiveYears (DonorId varchar(10) COLLATE DATABASE_DEFAULT NOT NULL, 
                                    Amount int NOT NULL,
                                    PRIMARY KEY (DonorId)
                                    );

    -- Use a CTE to calculate the largest group of consecutive years
    ;WITH consecutiveYears AS
       (
        SELECT t1.DonorId,
               t1.CalendarYear AS startOfGroup,
               MIN(t2.CalendarYear) AS endOfGroup,
               MIN(t2.CalendarYear) - t1.CalendarYear + 1 AS sizeOfGroup
          FROM ( SELECT DonorId,
                        CalendarYear
                   FROM #Years tbl1
                  WHERE NOT EXISTS
                       (SELECT 1
                          FROM #Years tbl2
                         WHERE tbl1.DonorId = tbl2.DonorId
                           AND tbl1.CalendarYear = tbl2.CalendarYear + 1
                        )
                ) t1
            INNER JOIN
               ( SELECT DonorId,
                        CalendarYear
                   FROM #Years tbl1
                  WHERE NOT EXISTS
                       (SELECT 1
                          FROM #Years tbl2
                         WHERE tbl2.DonorId = tbl1.DonorId
                           AND tbl2.CalendarYear = tbl1.CalendarYear + 1
                        )
                ) t2
             ON t1.DonorId = t2.DonorId
            AND t1.CalendarYear <= t2.CalendarYear
        GROUP BY t1.DonorId, t1.CalendarYear
       )
    INSERT INTO #ConsecutiveYears (DonorId, Amount)
        SELECT DonorId, MAX(sizeOfGroup)
          FROM consecutiveYears c
         WHERE endOfGroup = (SELECT MAX(y.endOfGroup)          -- Added 20130311 by JHS to ensure ConsecutiveYear resets correctly
                               FROM consecutiveYears y
                              WHERE c.DonorId = y.DonorId)
        GROUP BY DonorId
        ORDER BY DonorId -- was ORDER BY CAST(DonorId AS int)

    -- Populate a table variable with one row of lifetime aggregate values for each of the donors being updated
    CREATE TABLE #GiftHistory(DonorId varchar(10) COLLATE DATABASE_DEFAULT NOT NULL,
                              LowestGiftAmount money NOT NULL,
                              HighestGiftAmount money NOT NULL,
                              AverageGiftAmount money NOT NULL,
                              LifetimeGiftAmount money NOT NULL,
                              LifetimeNumberOfGifts int NOT NULL,
                              ConsecutiveYearsOfGiving int NOT NULL,
                              LastTransProcessed int NOT NULL,
                              PRIMARY KEY (DonorId)
                              );
    INSERT INTO #GiftHistory(DonorId ,LowestGiftAmount, HighestGiftAmount, AverageGiftAmount, LifetimeGiftAmount,
                             LifetimeNumberOfGifts, ConsecutiveYearsOfGiving, LastTransProcessed)
        SELECT DISTINCT(g.DonorId),
               MIN(g.Amount), MAX(g.Amount), AVG(g.Amount), SUM(g.Amount), 
               COUNT(DISTINCT(g.OriginalTransNum)),
               (SELECT Amount FROM #ConsecutiveYears cy WHERE cy.DonorId = g.DonorId),
               (SELECT MAX(DISTINCT(gr.TransactionNumber)) FROM [dbo].[GiftReport] gr WHERE gr.ID = g.DonorId)
          FROM #TblGifts g
         GROUP BY g.DonorId
              
    -- Now we begin the process of updating the repository for Gift History Summary data
    -- Delete rows for any existing Donors who are about to be updated
    DELETE GiftHistorySummary
      FROM GiftHistorySummary ghs  
           LEFT OUTER JOIN #GiftHistory gh ON ghs.DonorId = gh.DonorId
     WHERE gh.DonorId IS NOT NULL;
     
SET ANSI_WARNINGS OFF; -- The following cte necessarily aggregates rows with NULL values to collapse rows to one;
                       -- The resulting row has no NULL values, yielding the correct results, so ignore the warning.

    DECLARE @now datetime;
    SELECT @now = dbo.asi_GetAppDatetime();

    ;WITH cteGiftHistorySummary AS (
        SELECT gh.DonorId AS DonorId,
               NULL AS FirstGiftDate,
               NULL AS FirstGiftAmount,
               NULL AS FirstGiftAppeal,
               NULL AS NextLastGiftDate,
               NULL AS NextLastGiftAmount,
               NULL AS NextLastGiftAppeal,
               NULL AS LastGiftDate,
               NULL AS LastGiftAmount,
               NULL AS LastGiftAppeal,
               gh.LowestGiftAmount AS LowestGiftAmount,
               gh.HighestGiftAmount AS HighestGiftAmount,
               gh.AverageGiftAmount AS AverageGiftValue,
               gh.LifetimeGiftAmount AS LifetimeGiftValue,
               gh.LifetimeNumberOfGifts AS NumberOfGifts,
               gh.ConsecutiveYearsOfGiving AS ConsecutiveYearsGiving,
               gh.LastTransProcessed AS HighestTransNumProcessed
          FROM #GiftHistory gh
       UNION
        SELECT ft.DonorId AS DonorId,
               ft.TransactionDate AS FirstGiftDate,
               ft.Amount AS FirstGiftAmount,
               ft.Appeal AS FirstGiftAppeal,
               NULL AS NextLastGiftDate,
               NULL AS NextLastGiftAmount,
               NULL AS NextLastGiftAppeal,
               NULL AS LastGiftDate,
               NULL AS LastGiftAmount,
               NULL AS LastGiftAppeal,
               NULL AS LowestGiftAmount,
               NULL AS HighestGiftAmount,
               NULL AS AverageGiftValue,
               NULL AS LifetimeGiftValue,
               NULL AS NumberOfGifts,
               NULL AS ConsecutiveYearsGiving,
               NULL AS HighestTransNumProcessed
          FROM @FirstTrans ft
       UNION
        SELECT nt.DonorId AS DonorId,
               NULL AS FirstGiftDate,
               NULL AS FirstGiftAmount,
               NULL AS FirstGiftAppeal,
               nt.TransactionDate AS NextLastGiftDate,
               nt.Amount AS NextLastGiftAmount,
               nt.Appeal AS NextLastGiftAppeal,
               NULL AS LastGiftDate,
               NULL AS LastGiftAmount,
               NULL AS LastGiftAppeal,
               NULL AS LowestGiftAmount,
               NULL AS HighestGiftAmount,
               NULL AS AverageGiftValue,
               NULL AS LifetimeGiftValue,
               NULL AS NumberOfGifts,
               NULL AS ConsecutiveYearsGiving,
               NULL AS HighestTransNumProcessed
          FROM @NextToLastTrans nt
       UNION
        SELECT lt.DonorId AS DonorId ,
               NULL AS FirstGiftDate,
               NULL AS FirstGiftAmount,
               NULL AS FirstGiftAppeal,
               NULL AS NextLastGiftDate,
               NULL AS NextLastGiftAmount,
               NULL AS NextLastGiftAppeal,
               lt.TransactionDate AS LastGiftDate,
               lt.Amount AS LastGiftAmount,
               lt.Appeal AS LastGiftAppeal,
               NULL AS LowestGiftAmount,
               NULL AS HighestGiftAmount,
               NULL AS AverageGiftValue,
               NULL AS LifetimeGiftValue,
               NULL AS NumberOfGifts,
               NULL AS ConsecutiveYearsGiving,
               NULL AS HighestTransNumProcessed
          FROM @LastTrans lt
        )
    -- Insert new rows for any Donors being updated
    INSERT GiftHistorySummary(DonorId,
                              FirstGiftDate,
                              FirstGiftAmount,
                              FirstGiftAppeal,
                              NextLastGiftDate,
                              NextLastGiftAmount,
                              NextLastGiftAppeal,
                              LastGiftDate,
                              LastGiftAmount,
                              LastGiftAppeal,
                              LowestGiftAmount,
                              HighestGiftAmount,
                              AverageGiftValue,
                              LifetimeGiftValue,
                              NumberOfGifts,
                              ConsecutiveYearsGiving,
                              HighestTransNumProcessed,
                              LastUpdatedOn
                             )
    SELECT DonorId,
           MAX(FirstGiftDate),
           MAX(FirstGiftAmount),
           MAX(FirstGiftAppeal),
           MAX(NextLastGiftDate),
           MAX(NextLastGiftAmount),
           MAX(NextLastGiftAppeal),
           MAX(LastGiftDate),
           MAX(LastGiftAmount),
           MAX(LastGiftAppeal),
           MAX(LowestGiftAmount),
           MAX(HighestGiftAmount),
           MAX(AverageGiftValue),
           MAX(LifetimeGiftValue),
           MAX(NumberOfGifts),
           MAX(ConsecutiveYearsGiving),
           MAX(HighestTransNumProcessed),
           @now
      FROM cteGiftHistorySummary
    GROUP BY DonorId
    
    SET ANSI_WARNINGS ON; -- Restore ANSI warnings now that we're done

    IF OBJECT_ID('tempdb..#TblGifts') IS NOT NULL
        DROP TABLE #TblGifts;
    IF OBJECT_ID('tempdb..#GiftHistory') IS NOT NULL
        DROP TABLE #GiftHistory;
    IF OBJECT_ID('tempdb..#Years') IS NOT NULL
        DROP TABLE #Years;
    IF OBJECT_ID('tempdb..#ConsecutiveYears') IS NOT NULL
        DROP TABLE #ConsecutiveYears;

END


GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_UpdateFundraisingViewTables_DUES]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_UpdateFundraisingViewTables_DUES]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


CREATE PROCEDURE [dbo].[asi_UpdateFundraisingViewTables_DUES] 
    @TransRangeBegin int = NULL, @TransRangeEnd int = NULL
AS
BEGIN

-- If No TransRange parameters are passed in and there is no #FRTransTemp table, then this is a complete rebuild
IF (@TransRangeBegin IS NULL AND @TransRangeEnd IS NULL AND (SELECT COUNT(*) FROM #FRTransTemp) = 0)
BEGIN
    RETURN  -- Not yet implemented. This will need to truncate the three Report tables. Very dangerous!
END

-- Cache related [dbo].[Activity] info
DECLARE @ActivityTemp TABLE (ID varchar(10) NOT NULL, SEQN int NOT NULL, ORIGINATING_TRANS_NUM int NOT NULL, 
                            SOURCE_SYSTEM varchar(10) NOT NULL, TRANSACTION_DATE datetime NULL, EFFECTIVE_DATE datetime NULL, 
                            AMOUNT money NOT NULL, TAXABLE_VALUE money NOT NULL, ORG_CODE varchar(5) NOT NULL, SOURCE_CODE varchar(40) NOT NULL, 
                            SOLICITOR_ID varchar(10) NOT NULL, CAMPAIGN_CODE varchar(10) NOT NULL, ACTION_CODES varchar(255) NOT NULL, 
                            UF_4 numeric(15,4) NOT NULL, ACTIVITY_TYPE varchar(10) NOT NULL, PRODUCT_CODE varchar(31) NOT NULL);
INSERT INTO @ActivityTemp 
SELECT ID, SEQN, ORIGINATING_TRANS_NUM, SOURCE_SYSTEM, TRANSACTION_DATE, EFFECTIVE_DATE, AMOUNT, TAXABLE_VALUE,
       ORG_CODE, SOURCE_CODE, SOLICITOR_ID, CAMPAIGN_CODE, ACTION_CODES, UF_4, ACTIVITY_TYPE, PRODUCT_CODE 
  FROM (
    SELECT a.ID, a.SEQN, a.ORIGINATING_TRANS_NUM, a.SOURCE_SYSTEM, a.TRANSACTION_DATE, a.EFFECTIVE_DATE, a.AMOUNT, a.TAXABLE_VALUE,
           a.ORG_CODE, a.SOURCE_CODE, a.SOLICITOR_ID, a.CAMPAIGN_CODE, a.ACTION_CODES, a.UF_4, a.ACTIVITY_TYPE, a.PRODUCT_CODE
      FROM #FRTransTemp tt
           INNER JOIN [dbo].[Activity] a ON a.ORIGINATING_TRANS_NUM = tt.TransNum
    UNION
    SELECT a.ID, a.SEQN, a.ORIGINATING_TRANS_NUM, a.SOURCE_SYSTEM, a.TRANSACTION_DATE, a.EFFECTIVE_DATE, a.AMOUNT, a.TAXABLE_VALUE,
           a.ORG_CODE, a.SOURCE_CODE, a.SOLICITOR_ID, a.CAMPAIGN_CODE, a.ACTION_CODES, a.UF_4, a.ACTIVITY_TYPE, a.PRODUCT_CODE
      FROM #FRTransTemp tt
           INNER JOIN [dbo].[Trans] t ON tt.TransNum = t.TRANS_NUMBER
           INNER JOIN [dbo].[Activity] a ON a.SEQN = t.ACTIVITY_SEQN
) subActivity;

-- BEGIN GiftReport
-- Delete any existing rows from the [dbo].[GiftReport] table for transactions being updated
DELETE gr
  FROM [dbo].[GiftReport] gr
       INNER JOIN #FRTransTemp t ON gr.[TransactionNumber] = t.[TransNum]
                              AND gr.[InvoiceReferenceNumber] = t.[InvoiceNum]
 WHERE gr.[SourceSystem] IN ('DUES','SC')

-- Insert new rows into the [dbo].[GiftReport] table for transactions being updated
INSERT INTO [dbo].[GiftReport] ( ID, 
                                 OriginalTransaction, 
                                 TransactionNumber, 
                                 SourceSystem, 
                                 TransactionDate, 
                                 DateReceived, 
                                 Amount, 
                                 FairMktValue, 
                                 Fund, 
                                 AppealCode, 
                                 SolicitorID, 
                                 CheckNumber, 
                                 PaymentType, 
                                 CampaignCode, 
                                 FiscalYear, 
                                 FiscalMonth, 
                                 GiftType, 
                                 InvoiceReferenceNumber, 
                                 ReceiptID, 
                                 MatchingTransaction, 
                                 IsMatchingGift, 
                                 MemorialID, 
                                 PledgeID, 
                                 ListAs, 
                                 RequestNumber, 
                                 InstallmentDate, 
                                 MemorialNameText
                               )
     -------------- Segment DUES1 -- CASH DUES PAYMENT/PMT ON CASH DUES RENEWAL (SOURCE SYSTEM = DUES OR SC)
     SELECT a.ID,
            a.ORIGINATING_TRANS_NUM,
            a.ORIGINATING_TRANS_NUM,
            MAX(a.SOURCE_SYSTEM),
            MAX(a.TRANSACTION_DATE),
            MAX(CASE WHEN a.SOURCE_SYSTEM = 'FR' THEN a.EFFECTIVE_DATE ELSE a.TRANSACTION_DATE END),
            SUM(a.AMOUNT) Amount,  
            SUM(a.TAXABLE_VALUE),
            MAX(a.ORG_CODE),
            MAX(a.SOURCE_CODE),
            MAX(a.SOLICITOR_ID),
            MAX(c.CHECK_NUMBER),
            CASE MAX(COALESCE(ca.ACCOUNT_TYPE, 99))
                WHEN 1 THEN 'Credit Card'
                WHEN 2 THEN 'In Kind' 
                WHEN 3 THEN 'Debit Card' 
                ELSE 'Cash' 
            END,
            MAX(a.CAMPAIGN_CODE),
            CONVERT(int,SUBSTRING(CONVERT(char(6),MAX(c.FISCAL_PERIOD)),1,4)),
            CONVERT(int,SUBSTRING(CONVERT(char(6),MAX(c.FISCAL_PERIOD)),5,2)),
            'GIFT',
            MAX(c.INVOICE_REFERENCE_NUM),
            MAX(c.RECEIPT_ID),
            MAX(c.MATCH_GIFT_TRANS_NUM),
            MAX(c.IS_MATCH_GIFT),
            MAX(c.MEM_TRIB_ID),
            '',
            MAX(a.ACTION_CODES),
            MAX(a.UF_4),
            NULL,
            MAX(c.MEM_TRIB_NAME_TEXT)
       FROM @ActivityTemp a
            INNER JOIN [dbo].[Trans] c on a.ORIGINATING_TRANS_NUM = c.TRANS_NUMBER
            INNER JOIN #FRTransTemp t ON c.TRANS_NUMBER = t.TransNum AND c.INVOICE_REFERENCE_NUM = t.InvoiceNum
            LEFT OUTER JOIN [dbo].[Cash_Accounts] ca ON c.CHECK_NUMBER = ca.CASH_ACCOUNT_CODE 
      WHERE a.ACTIVITY_TYPE = 'GIFT' AND a.ID = c.ST_ID 
        AND a.SOURCE_SYSTEM IN ('SC', 'DUES') 
        AND c.TRANSACTION_TYPE = 'DIST' 
        AND c.PRODUCT_CODE = a.PRODUCT_CODE
      GROUP BY a.ID, a.ORIGINATING_TRANS_NUM,  a.ORG_CODE, a.CAMPAIGN_CODE, a.SOURCE_CODE
   UNION
     -------------- Segment DUES2  -- PAYMENT ON ACCRUAL DUES BILING (SOURCE SYSTEM = DUES)
     SELECT CASE 
                WHEN il.ST_ID IS NULL THEN i.BT_ID 
                ELSE il.ST_ID 
            END,
            p.TRANS_NUMBER,
            c.TRANS_NUMBER,
            MAX(p.SOURCE_SYSTEM),
            MAX(c.TRANSACTION_DATE),
            MAX(c.TRANSACTION_DATE),
            CASE
                WHEN MAX(c.JOURNAL_TYPE) = 'IN' THEN SUM(c.AMOUNT) 
                ELSE -SUM(c.AMOUNT) 
            END,
            SUM(c.TAXABLE_VALUE),
            CASE
                WHEN MAX(c.JOURNAL_TYPE) = 'IN' THEN MAX(c.OWNER_ORG_CODE) 
                ELSE MAX(c.GL_ACCT_ORG_CODE) 
            END,
            MAX(p.SOURCE_CODE),
            MAX(p.SOLICITOR_ID),
            MAX(c.CHECK_NUMBER),
            CASE MAX(COALESCE(ca.ACCOUNT_TYPE, 99))
                WHEN 1 THEN 'Credit Card' 
                WHEN 2 THEN 'In Kind' 
                WHEN 3 THEN 'Debit Card' 
                ELSE 'Cash' 
            END,
            MAX(a.CAMPAIGN_CODE),
            CONVERT(int,SUBSTRING(CONVERT(char(6),MAX(c.FISCAL_PERIOD)),1,4)),
            CONVERT(int,SUBSTRING(CONVERT(char(6),MAX(c.FISCAL_PERIOD)),5,2)),
            'Pledge Payment',
            MAX(c.INVOICE_REFERENCE_NUM),
            MAX(c.RECEIPT_ID),
            MAX(p.MATCH_GIFT_TRANS_NUM),
            MAX(p.IS_MATCH_GIFT),
            MAX(p.MEM_TRIB_ID),
            CASE 
                WHEN MAX(c.BT_ID)= MAX(c.ST_ID) THEN '' 
                ELSE MAX(c.BT_ID) 
            END,
            MAX(a.ACTION_CODES),
            MAX(a.UF_4),
            MAX(i.INSTALL_BILL_DATE),
            MAX(p.MEM_TRIB_NAME_TEXT)
       FROM [dbo].[Invoice] i
            INNER JOIN [dbo].[Trans] p ON i.ORIGINATING_TRANS_NUM = p.TRANS_NUMBER
            INNER JOIN [dbo].[Activity] a ON p.ACTIVITY_SEQN = a.SEQN
            INNER JOIN [dbo].[Trans] c ON i.REFERENCE_NUM = c.INVOICE_REFERENCE_NUM
            INNER JOIN #FRTransTemp t ON c.TRANS_NUMBER = t.TransNum
                                   AND c.INVOICE_REFERENCE_NUM = t.InvoiceNum
            LEFT OUTER JOIN [dbo].[Cash_Accounts] ca ON c.CHECK_NUMBER = ca.CASH_ACCOUNT_CODE
            LEFT OUTER JOIN [dbo].[Invoice_Lines] il ON c.INVOICE_REFERENCE_NUM = il.REFERENCE_NUM 
                                                    AND c.INVOICE_LINE_NUM = il.LINE_NUM
      WHERE p.TRANSACTION_TYPE = 'DIST' 
        AND c.IS_FR_ITEM = 1 
        AND a.ACTIVITY_TYPE = 'PLEDGE' 
        AND i.SOURCE_SYSTEM = 'DUES' 
        AND p.PRODUCT_CODE = c.PRODUCT_CODE 
        AND c.JOURNAL_TYPE = 'PAY' 
        AND c.TRANSACTION_TYPE = 'AR' 
        AND p.INVOICE_LINE_NUM = c.INVOICE_LINE_NUM
        GROUP BY il.ST_ID, i.BT_ID, c.TRANS_NUMBER, c.INVOICE_REFERENCE_NUM, c.OWNER_ORG_CODE, c.GL_ACCT_ORG_CODE, a.CAMPAIGN_CODE, p.SOURCE_CODE, p.TRANS_NUMBER

-- BEGIN PledgeReport
-- Delete any existing rows from the PledgeReport table for transactions being updated
DELETE pr
  FROM PledgeReport pr
       INNER JOIN (SELECT DISTINCT InvoiceNum FROM #FRTransTemp) invoices
           ON pr.InvoiceReferenceNumber = invoices.InvoiceNum
 WHERE pr.[SourceSystem] IN ('DUES','SC') 

--Insert new rows into the PledgeReport table for transactions being updated
INSERT INTO PledgeReport( ID, 
                          TransactionType, 
                          TransactionNumber, 
                          InvoiceReferenceNumber, 
                          TransactionDate, 
                          DateReceived, 
                          FiscalYear, 
                          FiscalMonth, 
                          AppealCode, 
                          CampaignCode, 
                          Fund, 
                          SolicitorID, 
                          SourceSystem, 
                          MatchingTransaction, 
                          IsMatchingGift, 
                          MemorialID, 
                          ListAs, 
                          RequestNumber, 
                          InstallmentDate, 
                          LastPaymentDate, 
                          PledgeAmount, 
                          AdjustmentsAmount, 
                          PaymentsAmount, 
                          PledgeFairMarketValue, 
                          MemorialNameText
                        )
       SELECT pd.ID, 
              pd.TransactionType, 
              pd.TransactionNumber, 
              pd.InvoiceReferenceNumber, 
              pd.TransactionDate, 
              pd.DateReceived, 
              pd.FiscalYear, 
              pd.FiscalMonth, 
              pd.AppealCode, 
              pd.CampaignCode, 
              pd.Fund, 
              pd.SolicitorID, 
              pd.SourceSystem, 
              pd.MatchingTransaction, 
              pd.IsMatchingGift, 
              pd.MemorialID, 
              pd.ListAs, 
              pd.RequestNumber, 
              pd.InstallmentDate, 
              pd.LastPaymentDate, 
              pd.PledgeAmount, 
              pd.AdjustmentsAmount, 
              pd.PaymentsAmount, 
              pd.PledgeFairMarketValue, 
              pd.MemorialNameText
       FROM (
    --- Segment DUES3  -- ACCRUAL DUES BILLING (SOURCE SYSTEM = DUES)
             SELECT a.ID,
                    'Pledge' AS TransactionType,
                    MAX(p.TRANS_NUMBER) AS TransactionNumber,
                    MAX(p.INVOICE_REFERENCE_NUM) AS InvoiceReferenceNumber,
                    MAX(p.TRANSACTION_DATE) AS TransactionDate,
                    MAX(a.EFFECTIVE_DATE) AS DateReceived,
                    CONVERT(int,substring(CONVERT(char(6),MAX(p.FISCAL_PERIOD)),1,4)) AS FiscalYear,
                    CONVERT(int,substring(CONVERT(char(6),MAX(p.FISCAL_PERIOD)),5,2)) AS FiscalMonth,
                    MAX(a.SOURCE_CODE) AS AppealCode,
                    MAX(a.CAMPAIGN_CODE) AS CampaignCode,
                    MAX(a.ORG_CODE) AS Fund,
                    MAX(a.SOLICITOR_ID) AS SolicitorID,
                    MAX(p.SOURCE_SYSTEM) AS SourceSystem,
                    MAX(p.MATCH_GIFT_TRANS_NUM) AS MatchingTransaction,
                    MAX(p.IS_MATCH_GIFT) AS IsMatchingGift,
                    MAX(p.MEM_TRIB_ID) AS MemorialID,
                    MAX(a.ACTION_CODES) AS ListAs,
                    MAX(a.UF_4) AS RequestNumber,
                    MAX(p.INSTALL_BILL_DATE) AS InstallmentDate,
                    NULL AS LastPaymentDate,
                    SUM(p.AMOUNT) * -1 AS PledgeAmount,
                    0 AS AdjustmentsAmount,
                    0 AS PaymentsAmount,
                    SUM(p.TAXABLE_VALUE) AS PledgeFairMarketValue,
                    MAX(p.MEM_TRIB_NAME_TEXT) AS MemorialNameText
               FROM [dbo].[Trans] p 
                    INNER JOIN (SELECT DISTINCT TransNum FROM #FRTransTemp) t ON t.TransNum = p.TRANS_NUMBER
--                  INNER JOIN [dbo].[Invoice] i ON p.INVOICE_REFERENCE_NUM = i.REFERENCE_NUM
                    INNER JOIN [dbo].[Activity] a ON p.ACTIVITY_SEQN = a.SEQN
              WHERE p.TRANSACTION_TYPE = 'DIST' 
                AND p.JOURNAL_TYPE = 'IN' 
                AND p.POSTED >= 2 
--              AND i.ORIGINATING_TRANS_NUM = p.TRANS_NUMBER 
                AND p.SOURCE_SYSTEM = 'DUES' 
                AND a.ACTIVITY_TYPE = 'PLEDGE' 
              GROUP BY a.ID, p.INVOICE_REFERENCE_NUM, a.ORG_CODE,a.CAMPAIGN_CODE,a.SOURCE_CODE
       UNION ALL
    --- Segment DUES4  -- CM/DM ACCRUAL DUES (SOURCE SYSTEM = DUES)
             SELECT CASE 
                    WHEN il.ST_ID IS NULL THEN i.BT_ID 
                    ELSE il.ST_ID 
                    END,
                    'Adjustment',
                    0,
                    MAX(adj.INVOICE_REFERENCE_NUM),
                    NULL,
                    NULL,
                    0,
                    0,
                    MAX(P.SOURCE_CODE),
                    MAX(P.CAMPAIGN_CODE),
                    MAX(adj.OWNER_ORG_CODE),
                    '',
                    MAX(i.SOURCE_SYSTEM),
                    0,
                    0,
                    '',
                    '',
                    0,
                    NULL,
                    NULL,
                    0,
                    SUM(adj.AMOUNT) * -1,
                    0,
                    0,
                    ''
               FROM [dbo].[Trans] adj 
                    INNER JOIN (SELECT DISTINCT InvoiceNum FROM #FRTransTemp) t ON t.InvoiceNum = adj.INVOICE_REFERENCE_NUM
                    INNER JOIN [dbo].[Invoice] i ON adj.INVOICE_REFERENCE_NUM = i.REFERENCE_NUM
                    INNER JOIN [dbo].[Trans] p ON p.TRANS_NUMBER = i.ORIGINATING_TRANS_NUM
                    INNER JOIN [dbo].[Activity] a ON a.SEQN = p.ACTIVITY_SEQN
                    LEFT OUTER JOIN [dbo].[Invoice_Lines] il ON il.REFERENCE_NUM = adj.INVOICE_REFERENCE_NUM 
                                                            AND il.LINE_NUM = adj.INVOICE_LINE_NUM
              WHERE adj.TRANSACTION_TYPE = 'DIST' 
                AND adj.JOURNAL_TYPE IN ('CM','DM')
                AND adj.POSTED >= 2 
                AND i.SOURCE_SYSTEM='DUES' 
                AND P.PRODUCT_CODE = adj.PRODUCT_CODE 
                AND P.INVOICE_LINE_NUM = adj.INVOICE_LINE_NUM
              GROUP BY i.BT_ID, il.ST_ID, adj.INVOICE_REFERENCE_NUM, adj.OWNER_ORG_CODE,P.CAMPAIGN_CODE, P.SOURCE_CODE
       UNION ALL
    --- Segment DUES2  -- PAYMENT ON ACCRUAL DUES BILLLING (SOURCE SYSTEM = DUES)
             SELECT CASE 
                       WHEN il.ST_ID IS NULL THEN i.BT_ID 
                       ELSE il.ST_ID 
                    END,
                    'Payment',
                    0,
                    MAX(Pay.INVOICE_REFERENCE_NUM),
                    NULL,
                    NULL,
                    0,
                    0,
                    P.SOURCE_CODE,
                    P.CAMPAIGN_CODE,
                    CASE
                        WHEN MAX(Pay.TRANSACTION_TYPE) = 'AR' THEN MAX(Pay.GL_ACCT_ORG_CODE) 
                        ELSE MAX(Pay.OWNER_ORG_CODE) 
                    END,
                    '',
                    MAX(i.SOURCE_SYSTEM),
                    0,
                    0,
                    '',
                    '',
                    0,
                    NULL,
                    MAX(Pay.TRANSACTION_DATE),
                    0,
                    0,
                    SUM(Pay.INVOICE_CREDITS),
                    0,
                    '' 
               FROM [dbo].[Trans] Pay
                        INNER JOIN (SELECT DISTINCT InvoiceNum FROM #FRTransTemp) t ON t.InvoiceNum = Pay.INVOICE_REFERENCE_NUM
                        INNER JOIN [dbo].[Invoice] i ON i.REFERENCE_NUM = Pay.INVOICE_REFERENCE_NUM
                        INNER JOIN [dbo].[Trans] p ON P.TRANS_NUMBER = i.ORIGINATING_TRANS_NUM
                        INNER JOIN [dbo].[Activity] a ON a.SEQN = P.ACTIVITY_SEQN
                        LEFT OUTER JOIN [dbo].[Invoice_Lines] il ON il.REFERENCE_NUM = Pay.INVOICE_REFERENCE_NUM 
                                                     AND il.LINE_NUM = Pay.INVOICE_LINE_NUM
             WHERE P.TRANSACTION_TYPE = 'DIST' 
               AND Pay.POSTED >= 2 AND Pay.IS_FR_ITEM=1 
               AND a.ACTIVITY_TYPE='PLEDGE' 
               AND i.SOURCE_SYSTEM='DUES' 
               AND P.PRODUCT_CODE = Pay.PRODUCT_CODE 
               AND Pay.JOURNAL_TYPE = 'PAY' 
               AND Pay.TRANSACTION_TYPE = 'AR' 
               AND P.INVOICE_LINE_NUM = Pay.INVOICE_LINE_NUM
            GROUP BY i.BT_ID, il.ST_ID, Pay.INVOICE_REFERENCE_NUM, Pay.OWNER_ORG_CODE,Pay.GL_ACCT_ORG_CODE, P.CAMPAIGN_CODE, P.SOURCE_CODE
            ) pd  
            INNER JOIN (SELECT DISTINCT InvoiceNum FROM #FRTransTemp) invoices
                   ON pd.InvoiceReferenceNumber = invoices.InvoiceNum

-- BEGIN DonationReport 
-- Delete any existing rows from the DonationReport table for transactions being updated
DELETE FROM [dbo].[DonationReport]
 WHERE [OriginalTransaction] IN (SELECT t.TransNum FROM #FRTransTemp t )
   AND [SourceSystem] IN ('DUES','SC')

;WITH
TempPledgeData AS (
    SELECT v.ID, v.InvoiceReferenceNumber, v.Fund, v.Campaign, v.Appeal, 
           v.TransactionNumber   AS TransactionNumber, 
           v.TransactionDate     AS TransactionDate,
           v.DateReceived        AS DateReceived,
           v.SourceSystem        AS SourceSystem,
           v.SolicitorID         AS SolicitorID,
           v.FiscalMonth         AS FiscalMonth,
           v.FiscalYear          AS FiscalYear,
           v.MatchingTransaction AS MatchingTransaction,
           v.IsMatchingGift      AS IsMatchingGift,
           v.MemorialID          AS MemorialID,
           v.ListAs              AS ListAs,
           v.RequestNumber       AS RequestNumber,
           v.MemorialNameText    AS MemorialNameText, 
           v.PledgeAmount        AS PledgeAmount,  
                 v.AdjustmentsAmount   AS AdjustmentsAmount
      FROM vPledgeData v
     WHERE v.SourceSystem = 'DUES' AND
           v.TransactionNumber IN (SELECT DISTINCT TransNum FROM #FRTransTemp WHERE Transnum > 0)
     UNION
    SELECT v.ID, v.InvoiceReferenceNumber, v.Fund, v.Campaign, v.Appeal, 
           v.TransactionNumber   AS TransactionNumber, 
           v.TransactionDate     AS TransactionDate,
           v.DateReceived        AS DateReceived,
           v.SourceSystem        AS SourceSystem,
           v.SolicitorID         AS SolicitorID,
           v.FiscalMonth         AS FiscalMonth,
           v.FiscalYear          AS FiscalYear,
           v.MatchingTransaction AS MatchingTransaction,
           v.IsMatchingGift      AS IsMatchingGift,
           v.MemorialID          AS MemorialID,
           v.ListAs              AS ListAs,
           v.RequestNumber       AS RequestNumber,
           v.MemorialNameText    AS MemorialNameText, 
           v.PledgeAmount        AS PledgeAmount,  
                 v.AdjustmentsAmount   AS AdjustmentsAmount
      FROM vPledgeData v
     WHERE v.SourceSystem = 'DUES' AND
           v.ID IN (SELECT DISTINCT DonorId FROM #FRTransTemp)
),
NetPledgeInfo AS (
    SELECT v.ID, v.InvoiceReferenceNumber, v.Fund, v.Campaign, v.Appeal, 
           MAX(v.TransactionNumber)   AS TransactionNumber,
           MAX(v.TransactionDate)     AS TransactionDate,
           MAX(v.DateReceived)        AS DateReceived,
           MAX(v.FiscalYear)          AS FiscalYear,
           MAX(v.FiscalMonth)         AS FiscalMonth,
           MAX(v.SolicitorID)         AS SolicitorID,
           MAX(v.SourceSystem)        AS SourceSystem,
           MAX(v.MatchingTransaction) AS MatchingTransaction,
           MAX(v.IsMatchingGift)      AS IsMatchingGift,
           MAX(v.MemorialID)          AS MemorialID,
           MAX(v.ListAs)              AS ListAs,
           MAX(v.RequestNumber)       AS RequestNumber,
           MAX(v.MemorialNameText)    AS MemorialNameText, 
           SUM(v.PledgeAmount)  +  SUM(v.AdjustmentsAmount) AS NetPledgeAmount
      FROM TempPledgeData v
     GROUP BY v.ID, v.InvoiceReferenceNumber, v.Fund, v.Campaign, v.Appeal
)      -- Insert new rows into the DonationReport table for transactions being updated
INSERT INTO DonationReport( ID, 
                            OriginalTransaction, 
                            InvoiceRefNum, 
                            SourceSystem, 
                            TransactionDate, 
                            DateReceived, 
                            Amount, 
                            SolicitorID, 
                            CheckNumber, 
                            PaymentType, 
                            FiscalMonth, 
                            FiscalYear, 
                            GiftType, 
                            MatchingTransaction, 
                            IsMatchingGift, 
                            MemorialID, 
                            ListAs, 
                            RequestNumber, 
                            MemorialNameText
                          )
       --- Segment DUES3  -- ACCRUAL DUES BILLING (SOURCE SYSTEM = DUES)
       --- AMOUNT IS NET PLEDGE AFTER CM/DM
       SELECT MAX(npi.ID),
              MAX(npi.TransactionNumber),
              MAX(npi.InvoiceReferenceNumber),
              MAX(npi.SourceSystem),
              MAX(npi.TransactionDate),
              MAX(npi.DateReceived),
              SUM(npi.NetPledgeAmount),
              MAX(npi.SolicitorID),
              '',
              '',
              MAX(npi.FiscalMonth),
              MAX(npi.FiscalYear),
              'Pledge',
              MAX(npi.MatchingTransaction),
              MAX(npi.IsMatchingGift),
              MAX(npi.MemorialID),
              MAX(npi.ListAs),
              MAX(npi.RequestNumber),
              MAX(npi.MemorialNameText) 
         FROM NetPledgeInfo npi 
           WHERE npi.TransactionNumber IN (SELECT DISTINCT TransNum FROM #FRTransTemp)
        GROUP BY npi.ID, npi.TransactionNumber
    UNION 
       --- Segment DUES1 -- CASH DUES PAYMENT/PMT ON CASH DUES RENEWAL (SOURCE SYSTEM = DUES OR SC)
      SELECT MAX(g.ID),
             MAX(g.OriginalTransaction) ,
             0,
             MAX(g.SourceSystem),
             MAX(g.TransactionDate),
             MAX(g.DateReceived),
             SUM(g.Amount),
             '',
             '',
             MAX(g.PaymentType),
             MAX(g.FiscalMonth),
             MAX(g.FiscalYear),
             'Gift',
             0,
             0,
             '',
             '',
             0,
             ''
        FROM [dbo].GiftReport g
             INNER JOIN (SELECT DISTINCT TransNum FROM #FRTransTemp) t ON g.OriginalTransaction = t.TransNum 
       WHERE g.SourceSystem IN ('DUES','SC') AND g.GiftType = 'GIFT'
       GROUP BY g.ID, g.OriginalTransaction

END



GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_UpdateFundraisingViewTables_FR]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_UpdateFundraisingViewTables_FR]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO



CREATE PROCEDURE [dbo].[asi_UpdateFundraisingViewTables_FR] 
    @TransRangeBegin int = NULL, @TransRangeEnd int = NULL
AS
BEGIN

-- If No TransRange parameters are passed in and there is no #FRTransTemp table, then this is a complete rebuild
IF (@TransRangeBegin IS NULL AND @TransRangeEnd IS NULL AND (SELECT COUNT(*) FROM #FRTransTemp) = 0)
BEGIN
    RETURN  -- Not yet implemented. This will need to truncate the three Report tables. Very dangerous!
END

-- Cache related [dbo].[Activity] info
DECLARE @ActivityTemp TABLE (ID varchar(10) NOT NULL, SEQN int NOT NULL, ORIGINATING_TRANS_NUM int NOT NULL, 
                            SOURCE_SYSTEM varchar(10) NOT NULL, TRANSACTION_DATE datetime NULL, EFFECTIVE_DATE datetime NULL, 
                            AMOUNT money NOT NULL, TAXABLE_VALUE money NOT NULL, ORG_CODE varchar(5) NOT NULL, SOURCE_CODE varchar(40) NOT NULL, 
                            SOLICITOR_ID varchar(10) NOT NULL, CAMPAIGN_CODE varchar(10) NOT NULL, ACTION_CODES varchar(255) NOT NULL, 
                            UF_4 numeric(15,4) NOT NULL, ACTIVITY_TYPE varchar(10) NOT NULL, PRODUCT_CODE varchar(31) NOT NULL);
INSERT INTO @ActivityTemp 
SELECT ID, SEQN, ORIGINATING_TRANS_NUM, SOURCE_SYSTEM, TRANSACTION_DATE, EFFECTIVE_DATE, AMOUNT, TAXABLE_VALUE,
       ORG_CODE, SOURCE_CODE, SOLICITOR_ID, CAMPAIGN_CODE, ACTION_CODES, UF_4, ACTIVITY_TYPE, PRODUCT_CODE 
  FROM (
    SELECT a.ID, a.SEQN, a.ORIGINATING_TRANS_NUM, a.SOURCE_SYSTEM, a.TRANSACTION_DATE, a.EFFECTIVE_DATE, a.AMOUNT, a.TAXABLE_VALUE,
           a.ORG_CODE, a.SOURCE_CODE, a.SOLICITOR_ID, a.CAMPAIGN_CODE, a.ACTION_CODES, a.UF_4, a.ACTIVITY_TYPE, a.PRODUCT_CODE
      FROM #FRTransTemp tt
           INNER JOIN [dbo].[Activity] a ON a.ORIGINATING_TRANS_NUM = tt.TransNum
    UNION
    SELECT a.ID, a.SEQN, a.ORIGINATING_TRANS_NUM, a.SOURCE_SYSTEM, a.TRANSACTION_DATE, a.EFFECTIVE_DATE, a.AMOUNT, a.TAXABLE_VALUE,
           a.ORG_CODE, a.SOURCE_CODE, a.SOLICITOR_ID, a.CAMPAIGN_CODE, a.ACTION_CODES, a.UF_4, a.ACTIVITY_TYPE, a.PRODUCT_CODE
      FROM #FRTransTemp tt
           INNER JOIN [dbo].[Trans] t ON tt.TransNum = t.TRANS_NUMBER
           INNER JOIN [dbo].[Activity] a ON a.SEQN = t.ACTIVITY_SEQN
) subActivity;

-- BEGIN GiftReport
-- Delete any existing rows from the [dbo].[GiftReport] table for transactions being updated
DELETE gr
  FROM [dbo].[GiftReport] gr
       INNER JOIN #FRTransTemp t ON gr.[TransactionNumber] = t.[TransNum]
                              AND gr.[InvoiceReferenceNumber] = t.[InvoiceNum]
 WHERE gr.[SourceSystem] = 'FR'
 
-- Insert new rows into the [dbo].[GiftReport] table for transactions being updated
INSERT INTO [dbo].[GiftReport] ( ID, 
                                 OriginalTransaction, 
                                 TransactionNumber, 
                                 SourceSystem, 
                                 TransactionDate, 
                                 DateReceived, 
                                 Amount, 
                                 FairMktValue, 
                                 Fund, 
                                 AppealCode, 
                                 SolicitorID, 
                                 CheckNumber, 
                                 PaymentType, 
                                 CampaignCode, 
                                 FiscalYear, 
                                 FiscalMonth, 
                                 GiftType, 
                                 InvoiceReferenceNumber, 
                                 ReceiptID, 
                                 MatchingTransaction, 
                                 IsMatchingGift, 
                                 MemorialID, 
                                 PledgeID, 
                                 ListAs, 
                                 RequestNumber, 
                                 InstallmentDate, 
                                 MemorialNameText
                         )
    -------------- Segment FR1 -- SINGLE GIFT (SOURCE SYSTEM = FR)
     SELECT a.ID,
            a.ORIGINATING_TRANS_NUM,
            a.ORIGINATING_TRANS_NUM,
            MAX(a.SOURCE_SYSTEM),
            MAX(a.TRANSACTION_DATE),
            MAX(CASE WHEN a.SOURCE_SYSTEM = 'FR' THEN a.EFFECTIVE_DATE ELSE a.TRANSACTION_DATE END),
            SUM(a.AMOUNT) Amount,  
            SUM(a.TAXABLE_VALUE),
            MAX(a.ORG_CODE),
            MAX(a.SOURCE_CODE),
            MAX(a.SOLICITOR_ID),
            MAX(c.CHECK_NUMBER),
            CASE MAX(COALESCE(ca.ACCOUNT_TYPE, 99))
                WHEN 1 THEN 'Credit Card'
                WHEN 2 THEN 'In Kind' 
                WHEN 3 THEN 'Debit Card' 
                ELSE 'Cash' 
            END,
            MAX(a.CAMPAIGN_CODE),
            CONVERT(int,SUBSTRING(CONVERT(char(6),MAX(c.FISCAL_PERIOD)),1,4)),
            CONVERT(int,SUBSTRING(CONVERT(char(6),MAX(c.FISCAL_PERIOD)),5,2)),
            'GIFT',
            MAX(c.INVOICE_REFERENCE_NUM),
            MAX(c.RECEIPT_ID),
            MAX(c.MATCH_GIFT_TRANS_NUM),
            MAX(c.IS_MATCH_GIFT),
            MAX(c.MEM_TRIB_ID),
            '',
            MAX(a.ACTION_CODES),
            MAX(a.UF_4),
            NULL,
            MAX(c.MEM_TRIB_NAME_TEXT)
       FROM @ActivityTemp a
            INNER JOIN [dbo].[Trans] c on a.ORIGINATING_TRANS_NUM = c.TRANS_NUMBER
            INNER JOIN #FRTransTemp t ON c.TRANS_NUMBER = t.TransNum AND c.INVOICE_REFERENCE_NUM = t.InvoiceNum
            LEFT OUTER JOIN [dbo].[Cash_Accounts] ca ON c.CHECK_NUMBER = ca.CASH_ACCOUNT_CODE 
      WHERE a.ACTIVITY_TYPE = 'GIFT' 
        AND a.ID = c.ST_ID 
        AND a.SOURCE_SYSTEM = 'FR' 
        AND c.TRANSACTION_TYPE = 'PAY' 
        AND c.JOURNAL_TYPE = 'IN' 
        AND c.SUB_LINE_NUMBER = 1
     GROUP BY a.ID, a.ORIGINATING_TRANS_NUM,  a.ORG_CODE, a.CAMPAIGN_CODE, a.SOURCE_CODE
   UNION
     -------------- Segment FR2  -- PAYMENT ON FR INSTALLMENT/PAYMENT ON SINGLE PLEDGE (SOURCE SYSTEM = FR)
     SELECT CASE 
                WHEN il.ST_ID IS NULL THEN i.BT_ID 
                ELSE il.ST_ID 
            END,
            p.TRANS_NUMBER,
            c.TRANS_NUMBER,
            MAX(p.SOURCE_SYSTEM),
            MAX(c.TRANSACTION_DATE),
            MAX(c.TRANSACTION_DATE),
            CASE
                WHEN MAX(c.JOURNAL_TYPE) = 'IN' THEN SUM(c.AMOUNT) 
                ELSE -SUM(c.AMOUNT) 
            END,
            SUM(c.TAXABLE_VALUE),
            CASE
                WHEN MAX(c.JOURNAL_TYPE) = 'IN' THEN MAX(c.OWNER_ORG_CODE) 
                ELSE MAX(c.GL_ACCT_ORG_CODE) 
            END,
            MAX(p.SOURCE_CODE),
            MAX(p.SOLICITOR_ID),
            MAX(c.CHECK_NUMBER),
            CASE MAX(COALESCE(ca.ACCOUNT_TYPE, 99))
                WHEN 1 THEN 'Credit Card' 
                WHEN 2 THEN 'In Kind' 
                WHEN 3 THEN 'Debit Card' 
                ELSE 'Cash' 
            END,
            MAX(a.CAMPAIGN_CODE),
            CONVERT(int,SUBSTRING(CONVERT(char(6),MAX(c.FISCAL_PERIOD)),1,4)),
            CONVERT(int,SUBSTRING(CONVERT(char(6),MAX(c.FISCAL_PERIOD)),5,2)),
            'Pledge Payment',
            MAX(c.INVOICE_REFERENCE_NUM),
            MAX(c.RECEIPT_ID),
            MAX(p.MATCH_GIFT_TRANS_NUM),
            MAX(p.IS_MATCH_GIFT),
            MAX(p.MEM_TRIB_ID),
            CASE 
                WHEN MAX(c.BT_ID)= MAX(c.ST_ID) THEN '' 
                ELSE MAX(c.BT_ID) 
            END,
            MAX(a.ACTION_CODES),
            MAX(a.UF_4),
            MAX(i.INSTALL_BILL_DATE),
            MAX(p.MEM_TRIB_NAME_TEXT)
       FROM [dbo].[Invoice] i
            INNER JOIN [dbo].[Trans] p ON i.ORIGINATING_TRANS_NUM = p.TRANS_NUMBER
            INNER JOIN [dbo].[Activity] a ON p.ACTIVITY_SEQN = a.SEQN
            INNER JOIN [dbo].[Trans] c ON i.REFERENCE_NUM = c.INVOICE_REFERENCE_NUM
            INNER JOIN #FRTransTemp t ON c.TRANS_NUMBER = t.TransNum
                                   AND c.INVOICE_REFERENCE_NUM = t.InvoiceNum
            LEFT OUTER JOIN [dbo].[Cash_Accounts] ca ON c.CHECK_NUMBER = ca.CASH_ACCOUNT_CODE
            LEFT OUTER JOIN [dbo].[Invoice_Lines] il ON c.INVOICE_REFERENCE_NUM = il.REFERENCE_NUM 
                                                    AND c.INVOICE_LINE_NUM = il.LINE_NUM
      WHERE p.TRANSACTION_TYPE = 'DIST' 
        AND c.IS_FR_ITEM = 1 
        AND a.ACTIVITY_TYPE = 'PLEDGE' 
        AND p.LINE_NUMBER = 1 
        AND p.SUB_LINE_NUMBER = 1 
        AND i.SOURCE_SYSTEM = 'FR' 
        AND c.JOURNAL_TYPE = 'PAY' 
        AND c.TRANSACTION_TYPE = 'AR'
        GROUP BY il.ST_ID, i.BT_ID, c.TRANS_NUMBER, c.INVOICE_REFERENCE_NUM, c.OWNER_ORG_CODE, c.GL_ACCT_ORG_CODE, a.CAMPAIGN_CODE, p.SOURCE_CODE, p.TRANS_NUMBER
   UNION
     -------------- Segment FR3  -- DOWNPAYMENT ON FR INSTALLMENT (SOURCE SYSTEM = FR)
     SELECT CASE 
                WHEN c.ST_ID IS NULL THEN c.BT_ID 
                ELSE c.ST_ID 
            END,
            p.TRANS_NUMBER,
            c.TRANS_NUMBER,
            MAX(p.SOURCE_SYSTEM),
            MAX(c.TRANSACTION_DATE),
            MAX(c.TRANSACTION_DATE),
            SUM(c.AMOUNT),
            SUM(c.TAXABLE_VALUE),
            MAX(c.OWNER_ORG_CODE),
            MAX(p.SOURCE_CODE),
            MAX(p.SOLICITOR_ID),
            MAX(c.CHECK_NUMBER),
            CASE MAX(COALESCE(ca.ACCOUNT_TYPE, 99))
                WHEN 1 THEN 'Credit Card' 
                WHEN 2 THEN 'In Kind' 
                WHEN 3 THEN 'Debit Card' 
                ELSE 'Cash' 
            END,
            MAX(a.CAMPAIGN_CODE),
            CONVERT(int,SUBSTRING(CONVERT(char(6),MAX(c.FISCAL_PERIOD)),1,4)),
            CONVERT(int,SUBSTRING(CONVERT(char(6),MAX(c.FISCAL_PERIOD)),5,2)),
            'Pledge Payment',
            MAX(c.INVOICE_REFERENCE_NUM),
            MAX(c.RECEIPT_ID),
            MAX(p.MATCH_GIFT_TRANS_NUM),
            MAX(p.IS_MATCH_GIFT),
            MAX(p.MEM_TRIB_ID),
            CASE 
                WHEN MAX(c.BT_ID)= MAX(c.ST_ID) THEN '' 
                ELSE MAX(c.BT_ID) 
            END,
            MAX(a.ACTION_CODES),
            MAX(a.UF_4),
            MAX(p.INSTALL_BILL_DATE),
            MAX(p.MEM_TRIB_NAME_TEXT)
       FROM [dbo].[Trans] p
            INNER JOIN [dbo].[Activity] a ON p.ACTIVITY_SEQN = a.SEQN
            INNER JOIN [dbo].[Trans] c ON p.TRANS_NUMBER = c.TRANS_NUMBER
            INNER JOIN #FRTransTemp t ON c.TRANS_NUMBER = t.TransNum
                                   AND c.INVOICE_REFERENCE_NUM = t.InvoiceNum
            LEFT OUTER JOIN [dbo].[Cash_Accounts] ca ON c.CHECK_NUMBER = ca.CASH_ACCOUNT_CODE

      WHERE p.TRANSACTION_TYPE = 'DIST' 
        AND c.IS_FR_ITEM = 1 
        AND a.ACTIVITY_TYPE = 'PLEDGE' 
        AND p.LINE_NUMBER = 1 
        AND p.SUB_LINE_NUMBER = 1 
        AND p.SOURCE_SYSTEM = 'FR' 
        AND c.JOURNAL_TYPE = 'IN' 
        AND c.TRANSACTION_TYPE = 'PAY'
        GROUP BY c.ST_ID, c.BT_ID, c.TRANS_NUMBER, c.INVOICE_REFERENCE_NUM, c.OWNER_ORG_CODE, c.GL_ACCT_ORG_CODE, a.CAMPAIGN_CODE, p.SOURCE_CODE, p.TRANS_NUMBER
   UNION
     -------------- Segment FR4  -- ANY PAYMENT (+/-) ON SINGLE GIFT THRU CASH RECEIPTS (SOURCE SYSTEM = FR)
     SELECT CASE 
                WHEN il.ST_ID IS NULL THEN i.BT_ID 
                ELSE il.ST_ID 
            END,
            p.TRANS_NUMBER,
            c.TRANS_NUMBER,
            MAX(p.SOURCE_SYSTEM),
            MAX(c.TRANSACTION_DATE),
            MAX(c.TRANSACTION_DATE),
            CASE
                WHEN MAX(c.JOURNAL_TYPE) = 'IN' THEN SUM(c.AMOUNT) 
                ELSE -SUM(c.AMOUNT) 
            END,
            SUM(c.TAXABLE_VALUE),
            CASE
                WHEN MAX(c.JOURNAL_TYPE) = 'IN' THEN MAX(c.OWNER_ORG_CODE) 
                ELSE MAX(c.GL_ACCT_ORG_CODE) 
            END,
          MAX(p.SOURCE_CODE),
            MAX(p.SOLICITOR_ID),
            MAX(c.CHECK_NUMBER),
            CASE MAX(COALESCE(ca.ACCOUNT_TYPE, 99))
                WHEN 1 THEN 'Credit Card' 
                WHEN 2 THEN 'In Kind' 
                WHEN 3 THEN 'Debit Card' 
                ELSE 'Cash' 
            END,
            MAX(a.CAMPAIGN_CODE),
            CONVERT(int,SUBSTRING(CONVERT(char(6),MAX(c.FISCAL_PERIOD)),1,4)),
            CONVERT(int,SUBSTRING(CONVERT(char(6),MAX(c.FISCAL_PERIOD)),5,2)),
            'Pledge Payment',
            MAX(c.INVOICE_REFERENCE_NUM),
            MAX(c.RECEIPT_ID),
            MAX(p.MATCH_GIFT_TRANS_NUM),
            MAX(p.IS_MATCH_GIFT),
            MAX(p.MEM_TRIB_ID),
            CASE 
                WHEN MAX(c.BT_ID)= MAX(c.ST_ID) THEN '' 
                ELSE MAX(c.BT_ID) 
            END,
            MAX(a.ACTION_CODES),
            MAX(a.UF_4),
            MAX(i.INSTALL_BILL_DATE),
            MAX(p.MEM_TRIB_NAME_TEXT)
       FROM [dbo].[Invoice] i
            INNER JOIN [dbo].[Trans] p ON i.ORIGINATING_TRANS_NUM = p.TRANS_NUMBER
            INNER JOIN [dbo].[Activity] a ON p.ACTIVITY_SEQN = a.SEQN
            INNER JOIN [dbo].[Trans] c ON i.REFERENCE_NUM = c.INVOICE_REFERENCE_NUM
            INNER JOIN #FRTransTemp t ON c.TRANS_NUMBER = t.TransNum
                                   AND c.INVOICE_REFERENCE_NUM = t.InvoiceNum
            LEFT OUTER JOIN [dbo].[Cash_Accounts] ca ON c.CHECK_NUMBER = ca.CASH_ACCOUNT_CODE
            LEFT OUTER JOIN [dbo].[Invoice_Lines] il ON c.INVOICE_REFERENCE_NUM = il.REFERENCE_NUM 
                                                    AND c.INVOICE_LINE_NUM = il.LINE_NUM
      WHERE p.TRANSACTION_TYPE = 'DIST' 
        AND c.IS_FR_ITEM = 1 
        AND a.ACTIVITY_TYPE = 'GIFT' 
        AND p.LINE_NUMBER = 1 AND p.SUB_LINE_NUMBER = 1 
        AND i.SOURCE_SYSTEM = 'FR' 
        AND c.JOURNAL_TYPE = 'PAY' AND c.TRANSACTION_TYPE = 'AR'
        GROUP BY il.ST_ID, i.BT_ID, c.TRANS_NUMBER, c.INVOICE_REFERENCE_NUM, c.OWNER_ORG_CODE, c.GL_ACCT_ORG_CODE, a.CAMPAIGN_CODE, p.SOURCE_CODE, p.TRANS_NUMBER
   UNION
     --- Segment *TAB1  -- OPEN CREDIT APPLICATION - IN/TR (SOURCE SYSTEM = FR)
     SELECT MAX(p.ST_ID),
            MAX(p.TRANS_NUMBER),
            MAX(c.TRANS_NUMBER),
            MAX(p.SOURCE_SYSTEM),
            MAX(c.TRANSACTION_DATE),
            MAX(c.TRANSACTION_DATE),
            -SUM(c.AMOUNT) Amount,
            SUM(p.TAXABLE_VALUE),
            CASE
                WHEN MAX(c.JOURNAL_TYPE) = 'IN' 
                THEN MAX(c.OWNER_ORG_CODE) 
                ELSE MAX(c.GL_ACCT_ORG_CODE)
            END,
            MAX(p.SOURCE_CODE),
            MAX(p.SOLICITOR_ID),
            MAX(c.CHECK_NUMBER),
            CASE MAX(ca.ACCOUNT_TYPE)
                WHEN 1 THEN 'Credit Card' 
                WHEN 2 THEN 'In Kind' 
                WHEN 3 THEN 'Debit Card' 
                ELSE 'Cash' 
            END,
            MAX(a.CAMPAIGN_CODE),
            CONVERT(int,SUBSTRING(CONVERT(char(6),MAX(c.FISCAL_PERIOD)),1,4)),
            CONVERT(int,SUBSTRING(CONVERT(char(6),MAX(c.FISCAL_PERIOD)),5,2)),
            'Asterisk Tab Adjustment',
            MAX(c.INVOICE_REFERENCE_NUM),
            MAX(c.RECEIPT_ID),
            MAX(p.MATCH_GIFT_TRANS_NUM),
            MAX(p.IS_MATCH_GIFT),
            MAX(p.MEM_TRIB_ID),
            CASE 
                WHEN MAX(c.BT_ID)= MAX(c.ST_ID) THEN '' 
                ELSE MAX(c.BT_ID)
            END,
            '',
            0,
            MAX(i.INSTALL_BILL_DATE),
            MAX(p.MEM_TRIB_NAME_TEXT)
       FROM [dbo].[Invoice] i
            INNER JOIN [dbo].[Trans] c ON i.REFERENCE_NUM = c.INVOICE_REFERENCE_NUM 
            INNER JOIN #FRTransTemp t ON c.TRANS_NUMBER = t.TransNum
                                   AND c.INVOICE_REFERENCE_NUM = t.InvoiceNum
            INNER JOIN [dbo].[Trans] p ON i.ORIGINATING_TRANS_NUM = p.TRANS_NUMBER
            INNER JOIN [dbo].[Activity] a on p.ACTIVITY_SEQN = a.SEQN
            LEFT OUTER JOIN [dbo].[Cash_Accounts] ca on c.CHECK_NUMBER = ca.CASH_ACCOUNT_CODE
      WHERE p.LINE_NUMBER = 1  
        AND p.SUB_LINE_NUMBER = 1 
        AND p.JOURNAL_TYPE = 'IN' 
        AND p.TRANSACTION_TYPE = 'DIST' 
        AND i.SOURCE_SYSTEM='FR' 
        AND c.JOURNAL_TYPE = 'IN' 
        AND c.TRANSACTION_TYPE = 'TR'
     GROUP BY p.ST_ID, c.TRANS_NUMBER, p.INVOICE_REFERENCE_NUM
   UNION 
     --- Segment *TAB2  -- OPEN CREDIT APPLICATION - PAY/PAY OR PAY/TR (SOURCE SYSTEM = FR)
     SELECT MAX(p.ST_ID),
            MAX(p.TRANS_NUMBER),
            MAX(c.TRANS_NUMBER),
            MAX(p.SOURCE_SYSTEM),
            MAX(c.TRANSACTION_DATE),
            MAX(c.TRANSACTION_DATE),
            -SUM(c.AMOUNT) Amount,
            SUM(p.TAXABLE_VALUE),
            CASE
                WHEN MAX(c.JOURNAL_TYPE) = 'IN' 
                THEN MAX(c.OWNER_ORG_CODE) 
                ELSE MAX(c.GL_ACCT_ORG_CODE)
            END,
            MAX(p.SOURCE_CODE),
            MAX(p.SOLICITOR_ID),
            MAX(c.CHECK_NUMBER),
            CASE MAX(COALESCE(ca.ACCOUNT_TYPE, 99))
                WHEN 1 THEN 'Credit Card' 
                WHEN 2 THEN 'In Kind' 
                WHEN 3 THEN 'Debit Card' 
                ELSE 'Cash' 
            END,
            MAX(a.CAMPAIGN_CODE),
            CONVERT(int,SUBSTRING(CONVERT(char(6),MAX(c.FISCAL_PERIOD)),1,4)),
            CONVERT(int,SUBSTRING(CONVERT(char(6),MAX(c.FISCAL_PERIOD)),5,2)),
            'Asterisk Tab Adjustment',
            MAX(c.INVOICE_REFERENCE_NUM),
            MAX(c.RECEIPT_ID),
            MAX(p.MATCH_GIFT_TRANS_NUM),
            MAX(p.IS_MATCH_GIFT),
            MAX(p.MEM_TRIB_ID),
            CASE 
                WHEN MAX(c.BT_ID)= MAX(c.ST_ID) THEN '' 
                ELSE MAX(c.BT_ID)
            END,
            '',
            0,
            MAX(i.INSTALL_BILL_DATE),
            MAX(p.MEM_TRIB_NAME_TEXT)
       FROM [dbo].[Invoice] i
            INNER JOIN [dbo].[Trans] c ON i.REFERENCE_NUM = c.INVOICE_REFERENCE_NUM 
            INNER JOIN #FRTransTemp t ON c.TRANS_NUMBER = t.TransNum
                                   AND c.INVOICE_REFERENCE_NUM = t.InvoiceNum
            INNER JOIN [dbo].[Trans] p ON i.ORIGINATING_TRANS_NUM = p.TRANS_NUMBER
            INNER JOIN [dbo].[Activity] a on p.ACTIVITY_SEQN = a.SEQN
            LEFT OUTER JOIN [dbo].[Cash_Accounts] ca on c.CHECK_NUMBER = ca.CASH_ACCOUNT_CODE
      WHERE p.LINE_NUMBER = 1  
        AND p.SUB_LINE_NUMBER = 1 
        AND p.JOURNAL_TYPE = 'IN' 
        AND p.TRANSACTION_TYPE = 'DIST' 
        AND i.SOURCE_SYSTEM='FR' 
        AND c.JOURNAL_TYPE = 'PAY' 
        AND c.TRANSACTION_TYPE IN ('PAY','TR')
     GROUP BY p.ST_ID, c.TRANS_NUMBER, p.INVOICE_REFERENCE_NUM

-- Update rows in [dbo].[GiftReport] with MemorialTribute details from Activity
UPDATE gr 
   SET [MemorialTributeType] = a.MEM_TRIB_CODE,
       [MemorialTributeMessage] = ISNULL(a.NOTE_2, '')
  FROM [dbo].[Activity] a
       INNER JOIN @ActivityTemp at ON a.SEQN = at.SEQN
       LEFT OUTER JOIN [dbo].[GiftReport] gr ON gr.OriginalTransaction = a.ORIGINATING_TRANS_NUM 

-- BEGIN PledgeReport
-- Delete any existing rows from the PledgeReport table for transactions being updated
DELETE pr
  FROM PledgeReport pr
       INNER JOIN (SELECT DISTINCT InvoiceNum FROM #FRTransTemp) invoices
           ON pr.InvoiceReferenceNumber = invoices.InvoiceNum
 WHERE pr.[SourceSystem] = 'FR'
 
--Insert new rows into the PledgeReport table for transactions being updated
INSERT INTO PledgeReport( ID, 
                          TransactionType, 
                          TransactionNumber, 
                          InvoiceReferenceNumber, 
                          TransactionDate, 
                          DateReceived, 
                          FiscalYear, 
                          FiscalMonth, 
                          AppealCode, 
                          CampaignCode, 
                          Fund, 
                          SolicitorID, 
                          SourceSystem, 
                          MatchingTransaction, 
                          IsMatchingGift, 
                          MemorialID, 
                          ListAs, 
                          RequestNumber, 
                          InstallmentDate, 
                          LastPaymentDate, 
                          PledgeAmount, 
                          AdjustmentsAmount, 
                          PaymentsAmount, 
                          PledgeFairMarketValue, 
                          MemorialNameText
                        )
       SELECT pd.ID, 
              pd.TransactionType, 
              pd.TransactionNumber, 
              pd.InvoiceReferenceNumber, 
              pd.TransactionDate, 
              pd.DateReceived, 
              pd.FiscalYear, 
              pd.FiscalMonth, 
              pd.AppealCode, 
              pd.CampaignCode, 
              pd.Fund, 
              pd.SolicitorID, 
              pd.SourceSystem, 
              pd.MatchingTransaction, 
              pd.IsMatchingGift, 
              pd.MemorialID, 
              pd.ListAs, 
              pd.RequestNumber, 
              pd.InstallmentDate, 
              pd.LastPaymentDate, 
              pd.PledgeAmount, 
              pd.AdjustmentsAmount, 
              pd.PaymentsAmount, 
              pd.PledgeFairMarketValue, 
              pd.MemorialNameText
       FROM (
    --- Segment PLEDGE1  -- SINGLE PLEDGE OR INSTALLMENT (SOURCE SYSTEM = FR)
             SELECT a.ID,
                    'Pledge' AS TransactionType,
                    MAX(p.TRANS_NUMBER) AS TransactionNumber,
                    MAX(p.INVOICE_REFERENCE_NUM) AS InvoiceReferenceNumber,
                    MAX(p.TRANSACTION_DATE) AS TransactionDate,
                    MAX(a.EFFECTIVE_DATE) AS DateReceived,
                    CONVERT(int,substring(CONVERT(char(6),MAX(p.FISCAL_PERIOD)),1,4)) AS FiscalYear,
                    CONVERT(int,substring(CONVERT(char(6),MAX(p.FISCAL_PERIOD)),5,2)) AS FiscalMonth,
                    MAX(a.SOURCE_CODE) AS AppealCode,
                    MAX(a.CAMPAIGN_CODE) AS CampaignCode,
                    MAX(a.ORG_CODE) AS Fund,
                    MAX(a.SOLICITOR_ID) AS SolicitorID,
                    MAX(p.SOURCE_SYSTEM) AS SourceSystem,
                    MAX(p.MATCH_GIFT_TRANS_NUM) AS MatchingTransaction,
                    MAX(p.IS_MATCH_GIFT) AS IsMatchingGift,
                    MAX(p.MEM_TRIB_ID) AS MemorialID,
                    MAX(a.ACTION_CODES) AS ListAs,
                    MAX(a.UF_4) AS RequestNumber,
                    MAX(p.INSTALL_BILL_DATE) AS InstallmentDate,
                    NULL AS LastPaymentDate,
                    SUM(p.AMOUNT) * -1 AS PledgeAmount,
                    0 AS AdjustmentsAmount,
                    0 AS PaymentsAmount,
                    SUM(p.TAXABLE_VALUE) AS PledgeFairMarketValue,
                    MAX(p.MEM_TRIB_NAME_TEXT) AS MemorialNameText
               FROM [dbo].[Trans] p 
                    INNER JOIN (SELECT DISTINCT TransNum FROM #FRTransTemp) t ON t.TransNum = p.TRANS_NUMBER
                    INNER JOIN [dbo].[Activity] a ON p.ACTIVITY_SEQN = a.SEQN
              WHERE p.TRANSACTION_TYPE = 'DIST' 
                AND p.JOURNAL_TYPE = 'IN' 
                AND p.POSTED >= 2 
                AND p.SOURCE_SYSTEM = 'FR' 
                AND a.ACTIVITY_TYPE = 'PLEDGE' 
              GROUP BY a.ID, p.INVOICE_REFERENCE_NUM, a.ORG_CODE,a.CAMPAIGN_CODE,a.SOURCE_CODE
          UNION ALL  
    --- Segment *TAB2  -- OPEN CREDIT APPLICATION - PAY/PAY (SOURCE SYSTEM = FR)
             SELECT MAX(P.ST_ID) AS ID,
                    'Asterisk Tab Adjustment' AS TransactionType, 
                    0 AS TransactionNumber,
                    MAX(C.INVOICE_REFERENCE_NUM)   AS InvoiceReferenceNumber,
                    NULL AS asTransactionDate, 
                    NULL AS DateReceived, 
                    0 AS FiscalYear,
                    0 AS FiscalMonth, 
                    MAX(P.SOURCE_CODE)  AS Appeal, 
                    MAX(P.CAMPAIGN_CODE) AS Campaign, 
                    MAX(C.OWNER_ORG_CODE) AS Fund,
                    '' AS SolicitorID,
                    MAX(i.SOURCE_SYSTEM)  AS SourceSystem, 
                    0 AS MatchingTransaction,
                    0 AS IsMatchingGift, 
                    '' AS MemorialID,
                    '' AS ListAs, 
                    0 AS RequestNumber, 
                    NULL AS InstallmentDate,
                    NULL AS LastPaymentDate,
                    0 AS PledgeAmount, 
                    0 AS AdjustmentsAmount, 
                    SUM(C.AMOUNT) * - 1 AS PaymentsAmount, 
                    0 AS PledgeFairMarketValue, 
                    '' AS MemorialNameText
               FROM [dbo].[Trans] c 
                    INNER JOIN [dbo].[Invoice] i ON i.REFERENCE_NUM = c.INVOICE_REFERENCE_NUM
                    INNER JOIN [dbo].[Trans] p ON p.TRANS_NUMBER = i.ORIGINATING_TRANS_NUM
                    LEFT OUTER JOIN [dbo].[Cash_Accounts] ca ON ca.CASH_ACCOUNT_CODE = c.CHECK_NUMBER
                    INNER JOIN [dbo].[Activity] a ON a.SEQN = p.ACTIVITY_SEQN 
                    INNER JOIN (SELECT DISTINCT TransNum FROM #FRTransTemp) t ON t.TransNum = p.TRANS_NUMBER
              WHERE  p.LINE_NUMBER = 1 
                AND p.SUB_LINE_NUMBER = 1
                AND p.JOURNAL_TYPE = 'IN' 
                AND p.TRANSACTION_TYPE = 'DIST' 
                AND i.SOURCE_SYSTEM = 'FR' 
                AND c.JOURNAL_TYPE = 'PAY' 
                AND c.TRANSACTION_TYPE = 'PAY' 
              GROUP BY P.ST_ID, P.TRANS_NUMBER, P.INVOICE_REFERENCE_NUM
          UNION ALL  
    --- Segment *TAB1  -- OPEN CREDIT APPLICATION - IN/TR (SOURCE SYSTEM = FR)
             SELECT MAX(P.ST_ID) AS ID,
                    'Asterisk Tab Adjustment' AS TransactionType, 
                    0 AS TransactionNumber,
                    MAX(C.INVOICE_REFERENCE_NUM)   AS InvoiceReferenceNumber,
                    NULL AS asTransactionDate, 
                    NULL AS DateReceived, 
                    0 AS FiscalYear,
                    0 AS FiscalMonth, 
                    MAX(P.SOURCE_CODE)  AS Appeal, 
                    MAX(P.CAMPAIGN_CODE) AS Campaign, 
                    MAX(C.OWNER_ORG_CODE) AS Fund,
                    '' AS SolicitorID,
                    MAX(i.SOURCE_SYSTEM)  AS SourceSystem, 
                    0 AS MatchingTransaction,
                    0 AS IsMatchingGift, 
                    '' AS MemorialID,
                    '' AS ListAs, 
                    0 AS RequestNumber, 
                    NULL AS InstallmentDate,
                    NULL AS LastPaymentDate,
                    0 AS PledgeAmount, 
                    0 AS AdjustmentsAmount, 
                    SUM(C.AMOUNT) * - 1 AS PaymentsAmount, 
                    0 AS PledgeFairMarketValue, 
                    '' AS MemorialNameText
               FROM [dbo].[Trans] c 
                    INNER JOIN [dbo].[Invoice] i ON i.REFERENCE_NUM = c.INVOICE_REFERENCE_NUM
                    INNER JOIN [dbo].[Trans] p ON p.TRANS_NUMBER = i.ORIGINATING_TRANS_NUM
                    LEFT OUTER JOIN [dbo].[Cash_Accounts] ca ON ca.CASH_ACCOUNT_CODE = c.CHECK_NUMBER
                    INNER JOIN [dbo].[Activity] a ON a.SEQN = p.ACTIVITY_SEQN 
                    INNER JOIN (SELECT DISTINCT TransNum FROM #FRTransTemp) t ON t.TransNum = p.TRANS_NUMBER
              WHERE  p.LINE_NUMBER = 1 
                AND p.SUB_LINE_NUMBER = 1 
                AND p.JOURNAL_TYPE = 'IN' 
                AND p.TRANSACTION_TYPE = 'DIST' 
                AND i.SOURCE_SYSTEM = 'FR' 
                AND c.JOURNAL_TYPE = 'IN' 
                AND c.TRANSACTION_TYPE = 'TR'
              GROUP BY P.ST_ID, P.TRANS_NUMBER, P.INVOICE_REFERENCE_NUM
          UNION ALL
    --- Segment PLEDGE2  -- CM/DM PLEDGE (SOURCE SYSTEM = FR)
             SELECT CASE 
                       WHEN il.ST_ID IS NULL THEN i.BT_ID 
                       ELSE il.ST_ID 
                    END,
                    'Adjustment',
                    0,
                    MAX(adj.INVOICE_REFERENCE_NUM),
                    NULL,
                    NULL,
                    0,
                    0,
                    MAX(P.SOURCE_CODE),
                    MAX(P.CAMPAIGN_CODE),
                    MAX(adj.OWNER_ORG_CODE),
                    '',
                    MAX(i.SOURCE_SYSTEM),
                    0,
                    0,
                    '',
                    '',
                    0,
                    NULL,
                    NULL,
                    0,
                    SUM(adj.AMOUNT) * -1,
                    0,
                    0,
                    ''
               FROM [dbo].[Trans] adj 
                    INNER JOIN (SELECT DISTINCT InvoiceNum FROM #FRTransTemp) t ON t.InvoiceNum = adj.INVOICE_REFERENCE_NUM
                    INNER JOIN [dbo].[Invoice] i ON adj.INVOICE_REFERENCE_NUM = i.REFERENCE_NUM
                    INNER JOIN [dbo].[Trans] p ON p.TRANS_NUMBER = i.ORIGINATING_TRANS_NUM
                    INNER JOIN [dbo].[Activity] a ON a.SEQN = p.ACTIVITY_SEQN
                    LEFT OUTER JOIN [dbo].[Invoice_Lines] il ON il.REFERENCE_NUM = adj.INVOICE_REFERENCE_NUM 
                                                            AND il.LINE_NUM = adj.INVOICE_LINE_NUM
              WHERE adj.TRANSACTION_TYPE = 'DIST' 
                AND adj.JOURNAL_TYPE IN ('CM','DM')
                AND adj.POSTED >= 2 
                AND i.SOURCE_SYSTEM = 'FR' 
                AND i.INSTALL_BILL_DATE is not NULL 
                AND P.SUB_LINE_NUMBER = 1 
                AND a.ACTIVITY_TYPE='PLEDGE' 
                AND P.LINE_NUMBER = 1
              GROUP BY i.BT_ID, il.ST_ID, adj.INVOICE_REFERENCE_NUM, adj.OWNER_ORG_CODE,P.CAMPAIGN_CODE, P.SOURCE_CODE
       UNION ALL
     --- Segment FR2  -- PAYMENT ON FR INSTALLMENT/PAYMENT ON SINGLE PLEDGE (SOURCE SYSTEM = FR)
             SELECT CASE 
                       WHEN il.ST_ID IS NULL THEN i.BT_ID 
                       ELSE il.ST_ID 
                    END,
                    'Payment',
                    0,
                    MAX(Pay.INVOICE_REFERENCE_NUM),
                    NULL,
                    NULL,
                    0,
                    0,
                    P.SOURCE_CODE,
                    P.CAMPAIGN_CODE,
                    CASE
                        WHEN MAX(Pay.TRANSACTION_TYPE) = 'AR' THEN MAX(Pay.GL_ACCT_ORG_CODE) 
                        ELSE MAX(Pay.OWNER_ORG_CODE) 
                    END,
                    '',
                    MAX(i.SOURCE_SYSTEM),
                    0,
                    0,
                    '',
                    '',
                    0,
                    NULL,
                    MAX(Pay.TRANSACTION_DATE),
                    0,
                    0,
                    SUM(Pay.INVOICE_CREDITS),
                    0,
                    '' 
               FROM [dbo].[Trans] Pay
                        INNER JOIN (SELECT DISTINCT InvoiceNum FROM #FRTransTemp) t ON t.InvoiceNum = Pay.INVOICE_REFERENCE_NUM
                        INNER JOIN [dbo].[Invoice] i ON i.REFERENCE_NUM = Pay.INVOICE_REFERENCE_NUM
                        INNER JOIN [dbo].[Trans] p ON P.TRANS_NUMBER = i.ORIGINATING_TRANS_NUM
                        INNER JOIN [dbo].[Activity] a ON a.SEQN = P.ACTIVITY_SEQN
                        LEFT OUTER JOIN [dbo].[Invoice_Lines] il ON il.REFERENCE_NUM = Pay.INVOICE_REFERENCE_NUM 
                                                     AND il.LINE_NUM = Pay.INVOICE_LINE_NUM
             WHERE P.TRANSACTION_TYPE = 'DIST' 
               AND Pay.POSTED >= 2 and Pay.IS_FR_ITEM=1 
               AND a.ACTIVITY_TYPE='PLEDGE' 
               AND P.LINE_NUMBER = 1  
               AND P.SUB_LINE_NUMBER = 1 
               AND i.SOURCE_SYSTEM='FR' 
               AND Pay.JOURNAL_TYPE = 'PAY' 
               AND Pay.TRANSACTION_TYPE = 'AR'
            GROUP BY i.BT_ID, il.ST_ID, Pay.INVOICE_REFERENCE_NUM, Pay.OWNER_ORG_CODE,Pay.GL_ACCT_ORG_CODE, P.CAMPAIGN_CODE, P.SOURCE_CODE
       UNION ALL
     --- Segment FR3  -- DOWNPAYMENT ON FR INSTALLMENT (SOURCE SYSTEM = FR)
             SELECT CASE 
                       WHEN Pay.ST_ID IS NULL THEN Pay.BT_ID 
                       ELSE Pay.ST_ID 
                    END,
                    'Payment',
                    0,
                    MAX(Pay.INVOICE_REFERENCE_NUM),
                    NULL,
                    NULL,
                    0,
                    0,
                    P.SOURCE_CODE,
                    P.CAMPAIGN_CODE,
                    Max(Pay.OWNER_ORG_CODE),
                    '',
                    MAX(Pay.SOURCE_SYSTEM),
                    0,
                    0,
                    '',
                    '',
                    0,
                    NULL,
                    MAX(Pay.TRANSACTION_DATE),
                    0,
                    0,
                    SUM(Pay.INVOICE_CREDITS),
                    0,
                    '' 
               FROM [dbo].[Trans] Pay
                        INNER JOIN (SELECT DISTINCT InvoiceNum FROM #FRTransTemp) t ON t.InvoiceNum = Pay.INVOICE_REFERENCE_NUM
                        INNER JOIN [dbo].[Trans] p ON P.TRANS_NUMBER = Pay.TRANS_NUMBER
                        INNER JOIN [dbo].[Activity] a ON a.SEQN = P.ACTIVITY_SEQN
             WHERE P.TRANSACTION_TYPE = 'DIST' 
               AND Pay.POSTED >= 2 and Pay.IS_FR_ITEM=1 
               AND a.ACTIVITY_TYPE='PLEDGE' 
               AND P.LINE_NUMBER = 1  
               AND P.SUB_LINE_NUMBER = 1 
               AND Pay.SOURCE_SYSTEM='FR' 
               AND Pay.JOURNAL_TYPE = 'IN' 
               AND Pay.TRANSACTION_TYPE = 'PAY'
            GROUP BY Pay.BT_ID, Pay.ST_ID, Pay.INVOICE_REFERENCE_NUM, Pay.OWNER_ORG_CODE,Pay.GL_ACCT_ORG_CODE, P.CAMPAIGN_CODE, P.SOURCE_CODE
            ) pd  
            INNER JOIN (SELECT DISTINCT InvoiceNum FROM #FRTransTemp) invoices
                   ON pd.InvoiceReferenceNumber = invoices.InvoiceNum

-- BEGIN DonationReport 
-- Delete any existing rows from the DonationReport table for transactions being updated
DELETE FROM [dbo].[DonationReport]
 WHERE [OriginalTransaction] IN (SELECT t.TransNum FROM #FRTransTemp t )
   AND [SourceSystem] = 'FR'
   
-- Sum the amount of the negative single gift payment from GiftReport 
-- This will be used in DonationReport later
-- DonationReport will find all the GIFT type + it's corresponding Pledge payment (negative single gift) in the CollapsedNegGifts
;WITH CollapsedNegGifts AS (
    SELECT gr.OriginalTransaction, SUM(gr.Amount) AS Amount
      FROM GiftReport gr
           INNER JOIN (SELECT DISTINCT TransNum FROM #FRTransTemp) t ON gr.OriginalTransaction = t.TransNum
     WHERE gr.GiftType = 'Pledge Payment'
     GROUP BY gr.OriginalTransaction
),
TempPledgeData AS (
    SELECT v.ID, v.InvoiceReferenceNumber, v.Fund, v.Campaign, v.Appeal, 
           v.TransactionNumber   AS TransactionNumber, 
     v.TransactionDate     AS TransactionDate,
           v.DateReceived        AS DateReceived,
           v.SourceSystem        AS SourceSystem,
           v.SolicitorID         AS SolicitorID,
           v.FiscalMonth         AS FiscalMonth,
           v.FiscalYear          AS FiscalYear,
           v.MatchingTransaction AS MatchingTransaction,
           v.IsMatchingGift      AS IsMatchingGift,
           v.MemorialID          AS MemorialID,
           v.ListAs              AS ListAs,
           v.RequestNumber       AS RequestNumber,
           v.MemorialNameText    AS MemorialNameText, 
           v.PledgeAmount        AS PledgeAmount,  
		   v.AdjustmentsAmount   AS AdjustmentsAmount
      FROM vPledgeData v
     WHERE v.SourceSystem = 'FR' AND
           v.TransactionNumber IN (SELECT DISTINCT TransNum FROM #FRTransTemp WHERE Transnum > 0)
     UNION
    SELECT v.ID, v.InvoiceReferenceNumber, v.Fund, v.Campaign, v.Appeal, 
           v.TransactionNumber   AS TransactionNumber, 
           v.TransactionDate     AS TransactionDate,
           v.DateReceived        AS DateReceived,
           v.SourceSystem        AS SourceSystem,
           v.SolicitorID         AS SolicitorID,
           v.FiscalMonth         AS FiscalMonth,
           v.FiscalYear          AS FiscalYear,
           v.MatchingTransaction AS MatchingTransaction,
           v.IsMatchingGift      AS IsMatchingGift,
           v.MemorialID          AS MemorialID,
           v.ListAs              AS ListAs,
           v.RequestNumber       AS RequestNumber,
           v.MemorialNameText    AS MemorialNameText, 
           v.PledgeAmount        AS PledgeAmount,  
		   v.AdjustmentsAmount   AS AdjustmentsAmount
      FROM vPledgeData v
     WHERE v.SourceSystem = 'FR' AND
           v.ID IN (SELECT DISTINCT DonorId FROM #FRTransTemp)
),
NetPledgeInfo AS (
    SELECT v.ID, v.InvoiceReferenceNumber, v.Fund, v.Campaign, v.Appeal, 
	       MAX(v.TransactionNumber)   AS TransactionNumber,
           MAX(v.TransactionDate)     AS TransactionDate,
           MAX(v.DateReceived)        AS DateReceived,
           MAX(v.FiscalYear)          AS FiscalYear,
           MAX(v.FiscalMonth)         AS FiscalMonth,
           MAX(v.SolicitorID)         AS SolicitorID,
           MAX(v.SourceSystem)        AS SourceSystem,
           MAX(v.MatchingTransaction) AS MatchingTransaction,
           MAX(v.IsMatchingGift)      AS IsMatchingGift,
           MAX(v.MemorialID)          AS MemorialID,
           MAX(v.ListAs)              AS ListAs,
           MAX(v.RequestNumber)       AS RequestNumber,
           MAX(v.MemorialNameText)    AS MemorialNameText, 
           SUM(v.PledgeAmount)  +  SUM(v.AdjustmentsAmount) AS NetPledgeAmount
      FROM TempPledgeData v
     GROUP BY v.ID, v.InvoiceReferenceNumber, v.Fund, v.Campaign, v.Appeal
)          
-- Insert new rows into the DonationReport table for transactions being updated
INSERT INTO DonationReport( ID, 
                            OriginalTransaction, 
                            InvoiceRefNum, 
                            SourceSystem, 
                            TransactionDate, 
                            DateReceived, 
                            Amount, 
                            SolicitorID, 
                            CheckNumber, 
                            PaymentType, 
                            FiscalMonth, 
                            FiscalYear, 
                            GiftType, 
                            MatchingTransaction, 
                            IsMatchingGift, 
                            MemorialID, 
                            ListAs, 
                            RequestNumber, 
                            MemorialNameText
                          )
       --- Segment PLEDGE3  -- SINGLE PLEDGE OR INSTALLMENT (SOURCE SYSTEM = FR)
       --- AMOUNT IS NET PLEDGE AFTER CM/DM 
        SELECT npi.ID, npi.TransactionNumber, MAX(npi.InvoiceReferenceNumber), MAX(npi.SourceSystem), MAX(npi.TransactionDate), MAX(npi.DateReceived), 
               SUM(npi.NetPledgeAmount), MAX(npi.SolicitorID), '', '', MAX(npi.FiscalMonth), MAX(npi.FiscalYear), 'Pledge',
               MAX(npi.MatchingTransaction), MAX(npi.IsMatchingGift), MAX(npi.MemorialID), MAX(npi.ListAs), MAX(npi.RequestNumber), MAX(npi.MemorialNameText)
          FROM NetPledgeInfo npi
		 WHERE npi.TransactionNumber IN (SELECT DISTINCT TransNum FROM #FRTransTemp)
         GROUP BY ID, TransactionNumber
    UNION
       --- Segment FR1  -- SINGLE GIFT (SOURCE SYSTEM = FR)
       --- INCLUDES ANY NEGATIVE SINGLE GIFT PAYMENT. 
       SELECT MAX(g.ID),
             g.OriginalTransaction,
             MAX(g.InvoiceReferenceNumber),
             MAX(g.SourceSystem),
             MAX(g.TransactionDate),
             MAX(g.DateReceived),
             (SUM(g.Amount)+ ISNULL(MAX(cg.Amount),0)) AS Amount,
             MAX(g.SolicitorID),
             MAX(g.CheckNumber),
             MAX(g.PaymentType),
             MAX(g.FiscalMonth),
             MAX(g.FiscalYear),
             'Gift',
             MAX(g.MatchingTransaction),
             MAX(g.IsMatchingGift),
             MAX(g.MemorialID),
             MAX(g.ListAs),
             MAX(g.RequestNumber),
             MAX(g.MemorialNameText) 
      FROM [dbo].GiftReport g
             INNER JOIN (SELECT DISTINCT TransNum FROM #FRTransTemp) t ON g.OriginalTransaction = t.TransNum
             LEFT OUTER JOIN CollapsedNegGifts cg ON g.OriginalTransaction = cg.OriginalTransaction
      WHERE g.SourceSystem = 'FR' AND g.GiftType = 'GIFT'
      GROUP BY g.ID, g.OriginalTransaction

END




GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_UpdateFundraisingViewTables_MEET]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_UpdateFundraisingViewTables_MEET]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO



CREATE PROCEDURE [dbo].[asi_UpdateFundraisingViewTables_MEET] 
    @TransRangeBegin int = NULL, @TransRangeEnd int = NULL
AS
BEGIN

-- If No TransRange parameters are passed in and there is no #FRTransTemp table, then this is a complete rebuild
IF (@TransRangeBegin IS NULL AND @TransRangeEnd IS NULL AND (SELECT COUNT(*) FROM #FRTransTemp) = 0)
BEGIN
    RETURN  -- Not yet implemented. This will need to truncate the three Report tables. Very dangerous!
END

-- PBI36911 Create a new temp table and add value from #FRTransTemp to this table.
-- The first attempt was to use local variable instead of the new temp table, but performance is still very slow
IF OBJECT_ID('TempDB..#MeetTemp') IS NOT NULL DROP TABLE #MeetTemp
CREATE TABLE #MeetTemp (InvoiceNum int NOT NULL PRIMARY KEY)
INSERT #MeetTemp (InvoiceNum) (SELECT MAX(InvoiceNum) FROM #FRTransTemp 
                                WHERE InvoiceNum IS NOT NULL AND SourceSystem = 'MEETING' AND InvoiceNum != 0 HAVING MAX(InvoiceNum) IS NOT NULL)

-- BEGIN GiftReport
-- Delete any existing rows from the [dbo].[GiftReport] table for transactions being updated
DELETE gr
  FROM [dbo].[GiftReport] gr
       INNER JOIN #FRTransTemp t ON gr.[TransactionNumber] = t.[TransNum]
                              AND gr.[InvoiceReferenceNumber] = t.[InvoiceNum]
 WHERE gr.[SourceSystem] = 'MEETING';
 
DELETE gr
  FROM [dbo].[GiftReport] gr
       INNER JOIN #FRTransTemp t ON gr.[InvoiceReferenceNumber] = t.[InvoiceNum]
 WHERE gr.[SourceSystem] = 'MEETING';

-- Insert new rows into the [dbo].[GiftReport] table for transactions being updated
INSERT INTO [dbo].[GiftReport] ( ID, 
                                 OriginalTransaction, 
                                 TransactionNumber, 
                                 SourceSystem, 
                                 TransactionDate, 
                                 DateReceived, 
                                 Amount, 
                                 FairMktValue, 
                                 Fund, 
                                 AppealCode, 
                                 SolicitorID, 
                                 CheckNumber, 
                                 PaymentType, 
                                 CampaignCode, 
                                 FiscalYear, 
                                 FiscalMonth, 
                                 GiftType, 
                                 InvoiceReferenceNumber, 
                                 ReceiptID, 
                                 MatchingTransaction, 
                                 IsMatchingGift, 
                                 MemorialID, 
                                 PledgeID, 
                                 ListAs, 
                                 RequestNumber, 
                                 InstallmentDate, 
                                 MemorialNameText
                               )
     -------------- Segment MEET1 -- GIFT FROM EVENT REGISTRATION (SOURCE SYSTEM = MEETING)
     SELECT a.ID,
            ISNULL(MAX(i.ORIGINATING_TRANS_NUM),MIN(c.TRANS_NUMBER)),
            0,
            MAX(a.SOURCE_SYSTEM),
            MAX(a.TRANSACTION_DATE),
            MAX(COALESCE(a.EFFECTIVE_DATE,a.TRANSACTION_DATE)),
            SUM(a.AMOUNT),
            SUM(c.TAXABLE_VALUE),
            MAX(a.ORG_CODE),
            MAX(a.SOURCE_CODE),
            '',
            '',
            '',
            MAX(a.CAMPAIGN_CODE),
            CONVERT(int,SUBSTRING(CONVERT(char(6),MAX(c.FISCAL_PERIOD)),1,4)),
            CONVERT(int,SUBSTRING(CONVERT(char(6),MAX(c.FISCAL_PERIOD)),5,2)),
            'GIFT',
            MAX(c.INVOICE_REFERENCE_NUM),
            0,
            0,
            0,
            '',
            '',
            '',
            0,
            NULL,
            ''
       FROM [dbo].[Activity] a
            INNER JOIN [dbo].[Trans] c on a.ORIGINATING_TRANS_NUM = c.TRANS_NUMBER
            INNER JOIN #MeetTemp t on c.INVOICE_REFERENCE_NUM = t.InvoiceNum
            LEFT OUTER JOIN [dbo].[Invoice] i on i.REFERENCE_NUM = c.INVOICE_REFERENCE_NUM
      WHERE a.ACTIVITY_TYPE = 'GIFT' 
        AND c.TRANSACTION_TYPE = 'DIST' 
        AND (c.PRODUCT_CODE = a.PRODUCT_CODE OR c.PRODUCT_CODE LIKE a.PRODUCT_CODE +'/%') 
        AND a.SOURCE_SYSTEM = 'MEETING'
        --AND c.INVOICE_REFERENCE_NUM IN (SELECT MIN(t.InvoiceNum) FROM #FRTransTemp t)
     GROUP BY a.ID, c.INVOICE_REFERENCE_NUM, a.ORG_CODE, a.CAMPAIGN_CODE, a.SOURCE_CODE

-- BEGIN DonationReport 
-- Delete any existing rows from the DonationReport table for transactions being updated
DELETE FROM [dbo].[DonationReport]
 WHERE [OriginalTransaction] IN (SELECT t.TransNum FROM #FRTransTemp t )
   AND SourceSystem = 'MEETING';
   
DELETE FROM [dbo].[DonationReport]
 WHERE [InvoiceRefNum] IN (SELECT MAX(t.InvoiceNum) FROM #FRTransTemp t)
        AND SourceSystem = 'MEETING';
        
-- Insert new rows into the DonationReport table for transactions being updated
INSERT INTO DonationReport( ID, 
                            OriginalTransaction, 
                            InvoiceRefNum, 
                            SourceSystem, 
                            TransactionDate, 
                            DateReceived, 
                            Amount, 
                            SolicitorID, 
                            CheckNumber, 
                            PaymentType, 
                            FiscalMonth, 
                            FiscalYear, 
                            GiftType, 
                            MatchingTransaction, 
                            IsMatchingGift, 
                            MemorialID, 
                            ListAs, 
                            RequestNumber, 
                            MemorialNameText
                          )
       --- Segment MEET1 -- GIFT FROM EVENT REGISTRATION (SOURCE SYSTEM = MEETING)
             SELECT MAX(g.ID),
             MAX(g.OriginalTransaction),
             MAX(g.InvoiceReferenceNumber),
             MAX(g.SourceSystem),
             MAX(g.TransactionDate),
             MAX(g.DateReceived),
             SUM(g.Amount),
             '',
             '',
             '',
             MAX(g.FiscalMonth),
             MAX(g.FiscalYear),
             'Gift',
             0,
             0,
             '',
             '',
             0,
             ''
        FROM [dbo].GiftReport g
        INNER JOIN #MeetTemp t on g.InvoiceReferenceNumber = t.InvoiceNum
        WHERE g.SourceSystem = 'MEETING'
        GROUP BY g.ID, g.InvoiceReferenceNumber

DROP TABLE #MeetTemp 

END




GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_MergeRebuildGiftHistory]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_MergeRebuildGiftHistory]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO



-- This script rebuilds the gift history after a merge,
-- preventing a bug where gift amounts can be doubled after a merge
CREATE PROCEDURE [dbo].[asi_MergeRebuildGiftHistory]
@toDonorId varchar(10)
AS
BEGIN
    -- Clean up Temp Tables if they're still lying around
    IF OBJECT_ID('tempdb..#FRTransNums') IS NOT NULL
        DROP TABLE #FRTransNums; 
    IF OBJECT_ID('tempdb..#FRTransNums') IS NOT NULL
        DROP TABLE #FRTransNums; 

    -- Create a table containing one row for all Transactions that include at least one line with IS_FR_ITEM = True
    CREATE TABLE #FRTransNums(TransId int NOT NULL,
                              InvRefNum int,
                              DonorId varchar(10) COLLATE DATABASE_DEFAULT ,
                              SourceSystem varchar(10)COLLATE DATABASE_DEFAULT,
                              ActivitySeqn int);

    INSERT INTO #FRTransNums (TransId,
                              InvRefNum,
                              DonorId,
                              SourceSystem,
                              ActivitySeqn)
    SELECT DISTINCT(TRANS_NUMBER),
                   INVOICE_REFERENCE_NUM,
                   MAX(ST_ID),
                   MAX(SOURCE_SYSTEM),
                   ACTIVITY_SEQN
      FROM Trans
     WHERE ST_ID = @toDonorId AND IS_FR_ITEM = 1 AND NOT (TRANSACTION_TYPE = 'AR' AND JOURNAL_TYPE IN ('CM', 'DM', 'IN'))
     GROUP BY TRANS_NUMBER,
              INVOICE_REFERENCE_NUM,
              ACTIVITY_SEQN;

    SET NOCOUNT ON;
    SET ANSI_WARNINGS OFF;

    -- Clean up TransTemp if it's still lying around
    IF OBJECT_ID('tempdb..#FRTransTemp') IS NOT NULL
        DROP TABLE #FRTransTemp; 

    -- Create a Temp Table with all values to be passed to the StoredProcedures
    CREATE TABLE #FRTransTemp(TransNum int, 
                           InvoiceNum int, 
                           DonorId varchar(10) COLLATE DATABASE_DEFAULT NULL, 
                           SourceSystem varchar(10) COLLATE DATABASE_DEFAULT NULL, 
                           TransSourceSystem varchar(10) COLLATE DATABASE_DEFAULT NULL);

    ---- Populate Temp Table with the values to be passed to the Stored Procedures
    INSERT INTO #FRTransTemp (TransNum,
                            InvoiceNum,
                            DonorId,
                            SourceSystem,
                            TransSourceSystem)
    SELECT  a.TRANS_NUMBER,
            a.INVOICE_REFERENCE_NUM,
            a.ST_ID,
            a.SourceSystem,
            a.TransSourceSystem
      FROM(SELECT i.TransId AS TRANS_NUMBER,
                  i.InvRefNum AS INVOICE_REFERENCE_NUM,
                  i.DonorId AS ST_ID,
                  COALESCE(a.SOURCE_SYSTEM, inv.SOURCE_SYSTEM)AS SourceSystem,
                  i.SourceSystem AS TransSourceSystem
             FROM #FRTransNums AS i
                  LEFT OUTER JOIN Activity AS a ON i.ActivitySeqn = a.SEQN
                  LEFT OUTER JOIN Invoice AS inv ON i.InvRefNum = inv.REFERENCE_NUM
                  LEFT OUTER JOIN Activity AS ai ON inv.ORIGINATING_TRANS_NUM = ai.ORIGINATING_TRANS_NUM
           UNION ALL
           SELECT inv.ORIGINATING_TRANS_NUM,
                  i.InvRefNum,
                  inv.ST_ID,
                  inv.SOURCE_SYSTEM,
                  i.SourceSystem AS TransSourceSystem
             FROM #FRTransNums AS i
                  INNER JOIN [dbo].[Invoice] AS inv ON i.InvRefNum = inv.REFERENCE_NUM
                  LEFT OUTER JOIN Activity AS ai ON inv.ORIGINATING_TRANS_NUM = ai.ORIGINATING_TRANS_NUM)AS a
     GROUP BY a.TRANS_NUMBER,
              a.INVOICE_REFERENCE_NUM,
              a.ST_ID,
              a.SourceSystem,
              a.TransSourceSystem;

    -- If there are any rows in the temp table, then delete all gift history and rerun the logic
    IF (SELECT COUNT(1)
          FROM #FRTransTemp) <> 0
        BEGIN

            DELETE GiftReport
             WHERE ID = @toDonorId;
            DELETE DonationReport
             WHERE ID = @toDonorId;
            DELETE PledgeReport
             WHERE ID = @toDonorId;
            DELETE GiftHistorySummary
             WHERE DonorId = @toDonorId;

            IF EXISTS (SELECT 1
                         FROM #FRTransTemp
                        WHERE SourceSystem = 'FR' OR ((SourceSystem IS NULL OR SourceSystem = '') AND TransSourceSystem = 'FR'))
                BEGIN
                    EXEC dbo.asi_UpdateFundraisingViewTables_FR;
                END;
            IF EXISTS (SELECT 1
                         FROM #FRTransTemp
                        WHERE SourceSystem IN ('DUES', 'SC') OR ((SourceSystem IS NULL OR SourceSystem = '') AND TransSourceSystem IN ('DUES', 'SC')))
                BEGIN
                    EXEC dbo.asi_UpdateFundraisingViewTables_DUES;
                END;
            IF EXISTS (SELECT 1
                         FROM #FRTransTemp
                        WHERE SourceSystem = 'MEETING')
                BEGIN
                    EXEC dbo.asi_UpdateFundraisingViewTables_MEET;
                END;

            EXEC dbo.asi_RecalculateGiftHistorySummary @toDonorId;
        END;

    SET NOCOUNT OFF;
    SET ANSI_WARNINGS ON;

    IF OBJECT_ID('tempdb..#FRTransTemp') IS NOT NULL
        DROP TABLE #FRTransTemp; 
    IF OBJECT_ID('tempdb..#FRTransNums') IS NOT NULL
        DROP TABLE #FRTransNums; 
    IF OBJECT_ID('tempdb..#FRTransNums') IS NOT NULL
        DROP TABLE #FRTransNums; 

END;






GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_FRRebuildReportTables]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_FRRebuildReportTables]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- This script rebuilds the all of the various fund-raising report tables
-- (GiftReport, DonationReport, PledgeReport, GiftHistorySummary). This
-- process can take a VERY long time, so this stored procedure is written
-- to be interruptable and restartable, as well as to display its progress.
CREATE PROCEDURE [dbo].[asi_FRRebuildReportTables]
AS
BEGIN
    SET NOCOUNT ON;

    -- Grab where we left off (in case we restarted)
    DECLARE @startingPosition nvarchar(10);
    SELECT @startingPosition = [ParameterValue]
      FROM [dbo].[SystemConfig]
     WHERE [ParameterName] = N'FRReportRebuildPosition'
    IF (@startingPosition IS NULL)
    BEGIN
        -- Insert the missing SystemConfig parameter
        DECLARE @systemUserKey uniqueidentifier;
        DECLARE @organizationKey uniqueidentifier;
        DECLARE @systemEntityKey uniqueidentifier;
        DECLARE @now datetime;

        SELECT @systemUserKey = [UserKey] FROM [dbo].[UserMain] WHERE [UserId] = 'MANAGER';
        SELECT @systemEntityKey = [SystemEntityKey] FROM [dbo].[SystemEntity] WHERE [SystemKeyword] = 'Organization';
        SELECT @organizationKey = [OrganizationKey] FROM [dbo].[OrganizationMain] WHERE [IsDefault] = 1;
        SELECT @now = dbo.asi_GetAppDatetime();

        INSERT INTO [dbo].[SystemConfig] ([SystemConfigKey], [ParameterName], [ParameterValue],
                                          [Description], [CreatedByUserKey], [CreatedOn], [UpdatedByUserKey], [UpdatedOn],
                                          [OrganizationKey], [SystemEntityKey])
        VALUES ('F726DD47-0CB0-4E8C-9D0D-2B69FC7BC335', 'FRReportRebuildPosition', '',
                'This value specifies the last ID updated by asi_RebuildFRReportTables, or blank if all IDs rebuild successfully', 
                @systemUserKey, @now, @systemUserKey, @now, @organizationKey, @systemEntityKey)
        SET @startingPosition = '';
    END

    IF OBJECT_ID('tempdb..#IdsToRebuild') IS NOT NULL DROP TABLE #IdsToRebuild;
    CREATE TABLE #IdsToRebuild (ID varchar(10) PRIMARY KEY);
    INSERT INTO #IdsToRebuild (ID)
        SELECT DISTINCT([ST_ID])
          FROM [dbo].[Trans]
         WHERE [IS_FR_ITEM] = 1 AND NOT ([TRANSACTION_TYPE] = 'AR' AND [JOURNAL_TYPE] IN ('CM', 'DM', 'IN'))
           AND [ST_ID] > @startingPosition;
           
    DECLARE @count int;
    DECLARE @total int;
    SELECT @total = COUNT(1) FROM #IdsToRebuild;
    SET @count = 0;

    DECLARE @msg varchar(MAX);
    DECLARE @idToRebuild varchar(10);
    DECLARE @done bit;
    SET @done = 0;
    WHILE @done = 0
    BEGIN
        BEGIN TRANSACTION;
        -- Get next ID to rebuild
        SET @idToRebuild = NULL;
        SELECT TOP 1 @idToRebuild = [ID] FROM #IdsToRebuild ORDER BY [ID]
        IF @idToRebuild IS NOT NULL
        BEGIN
            SET @count += 1;
            SELECT @msg = 'Updating ID: ' + @idToRebuild + ' (' + CAST(@count AS varchar(10)) + ' of ' + CAST(@total AS varchar(10)) + ')';
            RAISERROR(@msg, 0, 1) WITH NOWAIT;

            -- Rebuild the ID
            EXEC dbo.asi_MergeRebuildGiftHistory @toDonorId = @idToRebuild;
            -- Remove the ID from our list of IDs to rebuild
            DELETE FROM #IdsToRebuild WHERE ID = @idToRebuild;
            -- Mark the last ID rebuilt
            UPDATE [dbo].[SystemConfig] SET [ParameterValue] = @idToRebuild WHERE [ParameterName] = 'FRReportRebuildPosition'
        END
        ELSE
        BEGIN
            RAISERROR('Done.' ,0, 1) WITH NOWAIT;
            -- Mark ourselves as done
            UPDATE [dbo].[SystemConfig] SET [ParameterValue] = '' WHERE [ParameterName] = 'FRReportRebuildPosition'
            SET @done = 1; -- We're done
        END
        
        COMMIT TRANSACTION;
    END

    IF OBJECT_ID('tempdb..#IdsToRebuild') IS NOT NULL DROP TABLE #IdsToRebuild
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GenerateContactSalutation]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GenerateContactSalutation]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROC [dbo].[asi_GenerateContactSalutation] (@salutationKey uniqueidentifier)
AS
BEGIN

SET NOCOUNT ON

DECLARE @sql nvarchar(2000)
DECLARE @contactKey uniqueidentifier
DECLARE @IndividualFormula nvarchar(2000)
DECLARE @InstituteFormula nvarchar(2000)

DECLARE @calcFormula nvarchar(2000) 

DECLARE @tempKey uniqueidentifier
DECLARE @tempValue nvarchar(1000)


SELECT @IndividualFormula = IndividualFormula, @InstituteFormula = InstituteFormula
	FROM SalutationRef
	WHERE SalutationRef.SalutationKey=@salutationKey AND AutoCreateFlag = 1

IF @@ROWCOUNT = 0
    RETURN

DECLARE theContactCursor CURSOR FAST_FORWARD FOR 
	SELECT ContactKey
		FROM vBoContact

OPEN theContactCursor
FETCH NEXT FROM theContactCursor INTO @contactKey

WHILE @@FETCH_STATUS = 0 -- spin through Contact entries
BEGIN

	SET @tempKey = newid()

	SELECT @sql =  
		CASE 
		WHEN IsInstitute = 1 THEN
			' asi_ProcessFormulaOutput ' 
				+ '''' + convert (nvarchar(100), @tempKey) + ''', '
				+ '''' + @InstituteFormula + ''', '
				+ '''Institute'', ''ContactKey'', ' 
				+ '''' + convert (nvarchar(50), @contactKey) 
				+ ''''

		WHEN IsInstitute = 0 THEN
			' asi_ProcessFormulaOutput ' 
				+ '''' + convert (nvarchar(100), @tempKey) + ''', '
				+ '''' + @IndividualFormula + ''', '
				+ '''Individual'', ''ContactKey'', ' 
				+ '''' + convert (nvarchar(50), @contactKey) 
				+ ''''
		END
	FROM ContactMain WHERE ContactKey = @contactKey

	EXEC (@sql)

	SELECT @tempValue = tempValue 
		FROM tempFormula
		WHERE tempKey = @tempKey

	IF @tempValue IS NOT NULL AND datalength (@tempValue) > 0 
	BEGIN
		IF not exists (SELECT 1 FROM vBoContactSalutation 
				WHERE ContactKey = @contactKey and SalutationKey = @salutationKey)
		BEGIN
			INSERT vBoContactSalutation
				(ContactSalutationKey, IsOverridden, SalutationText, ContactKey, SalutationKey, IsDeletable)
			VALUES (@tempKey, 0, @tempValue, @contactKey, @salutationKey, 1)
		END
		ELSE
		BEGIN
			UPDATE vBoContactSalutation set IsDeletable = 1 WHERE ContactKey = @contactKey and SalutationKey = @salutationKey
		END
	END

	DELETE FROM tempFormula WHERE tempKey = @tempKey

	FETCH NEXT FROM theContactCursor INTO @contactKey
END  -- spin through Contact entries

CLOSE theContactCursor
deallocate theContactCursor

UPDATE SalutationRef SET NeedsGenerationFlag = 0 WHERE SalutationKey = @salutationKey

SET NOCOUNT OFF

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GenerateContactSalutations]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GenerateContactSalutations]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROC [dbo].[asi_GenerateContactSalutations]
AS
BEGIN

SET NOCOUNT ON

DECLARE @sql nvarchar(2000)
DECLARE @contactKey uniqueidentifier
DECLARE @salutationKey uniqueidentifier
DECLARE @IndividualFormula nvarchar(2000)
DECLARE @InstituteFormula nvarchar(2000)

DECLARE @calcFormula nvarchar(2000) 

DECLARE @tempKey uniqueidentifier
DECLARE @tempValue nvarchar(1000)


DECLARE theSalutationRefCursor CURSOR FAST_FORWARD FOR 
	SELECT SalutationKey, IndividualFormula, InstituteFormula
		FROM SalutationRef
		WHERE AutoCreateFlag = 1

OPEN theSalutationRefCursor
FETCH NEXT FROM theSalutationRefCursor INTO @salutationKey, @IndividualFormula, @InstituteFormula

WHILE @@FETCH_STATUS = 0 -- spin through SalutationRef entries
BEGIN

	DECLARE theContactCursor CURSOR FAST_FORWARD FOR 
		SELECT ContactKey FROM ContactMain

	OPEN theContactCursor
	FETCH NEXT FROM theContactCursor INTO @contactKey

	WHILE @@FETCH_STATUS = 0 -- spin through Contact entries
	BEGIN

		SET @tempKey = newid()

		SELECT @sql =  
			CASE 
			WHEN IsInstitute = 1 THEN
					' asi_ProcessContactFormulaOutput ' 
						+ '''' + convert (nvarchar(100), @tempKey) + ''', '
						+ '''' + @InstituteFormula + ''', '
						+ '''Institute'', ''ContactKey'', ' 
						+ '''' + convert (nvarchar(50), @contactKey) 
						+ ''''

			WHEN IsInstitute = 0 THEN
					' asi_ProcessContactFormulaOutput ' 
						+ '''' + convert (nvarchar(100), @tempKey) + ''', '
						+ '''' + @IndividualFormula + ''', '
						+ '''Individual'', ''ContactKey'', ' 
						+ '''' + convert (nvarchar(50), @contactKey) 
						+ ''''
			END
		FROM ContactMain WHERE ContactKey = @contactKey

		EXEC (@sql)

		SELECT @tempValue = tempValue FROM tempFormula
			WHERE tempKey = @tempKey

		IF datalength(@tempValue) > 0 AND @tempValue IS NOT NULL
		BEGIN
			IF NOT EXISTS (SELECT 1 FROM ContactSalutation 
						   WHERE ContactKey = @contactKey AND SalutationKey = @salutationKey)
			BEGIN
				INSERT ContactSalutation (ContactSalutationKey, IsOverridden, SalutationText, ContactKey, SalutationKey)
				VALUES (newid(), 0, @tempValue, @contactKey, @salutationKey)
			END
		END

		DELETE FROM tempFormula WHERE tempKey = @tempKey

		FETCH NEXT FROM theContactCursor INTO @contactKey
	END  -- spin through Contact entries

	CLOSE theContactCursor
	DEALLOCATE theContactCursor


	FETCH NEXT FROM theSalutationRefCursor INTO @salutationKey, @IndividualFormula, @InstituteFormula
END  -- spin through SalutationRef entries

CLOSE theSalutationRefCursor
DEALLOCATE theSalutationRefCursor

SET NOCOUNT OFF

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GenerateExpectedPaymentSet]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GenerateExpectedPaymentSet]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_GenerateExpectedPaymentSet]
    (@newExpectedPaymentSetKey uniqueidentifier, -- used if no existing row
     @monthYear datetime, -- Month/Year to generate payments for
     @userKey uniqueidentifier, -- user to log as CreateBy UpdatedBy
     @batchSize integer, -- number of payments to set at a time
     @doNotLoop bit, -- if set to 1 will process the first batch and exit
     @clearExistingValues bit,  -- set to 1 to clear existing values
     @updateHeaderFlag bit -- set to 1 if the procedure should update the header
     )
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @expectedPaymentSetKey uniqueidentifier;
    DECLARE @foundExistingExpectedPaymentSet bit;
    DECLARE @monthDay integer;
    DECLARE @paymentMonth integer;
    DECLARE @paymentYear integer;
    DECLARE @monthYearEnd datetime;
    DECLARE @setStatusComplete smallint;
    DECLARE @setStatusGenerating smallint;
    DECLARE @setStatusCompleteWithError smallint;
    DECLARE @paymentStatusPending smallint;
    DECLARE @paymentStatusAwaiting smallint;
    DECLARE @paymentStatusProcessed smallint;
    DECLARE @errorMessage nvarchar(4000);
    DECLARE @errorSeverity int;
    DECLARE @errorState int;
    DECLARE @now datetime;
    
    -- VALIDATE - MonthYear must be at the start of the month
    SET @monthDay = DATEPART(DAY,@monthYear)
    
    IF @monthDay<>1
    BEGIN
        RAISERROR ( N'MonthYear Date must have day set to 1',16,1);
        RETURN;
    END

    -- Get the date part values
    SET @paymentMonth = DATEPART(MONTH,@monthYear);
    SET @paymentYear = DATEPART(YEAR,@monthYear);
    
    SET @monthYearEnd = DATEADD(MONTH,1,@monthYear);
    SET @monthYearEnd = DATEADD(DAY,-1,@monthYearEnd)
    
    -- variables for the expected set status values
    SET @setStatusComplete = 1;
    SET @setStatusGenerating = 2;
    SET @setStatusCompleteWithError = 3;

    -- set the payment status values
    SET @paymentStatusPending = 1;
    SET @paymentStatusAwaiting = 2;
    SET @paymentStatusProcessed = 3;
    
    -- Check value of Batch Size
    IF @batchSize <=0
        SET @batchSize = 50;

    -- do we already have a row for this month/year
    IF EXISTS (SELECT 1 FROM RecurringDonationExpectedPaymentSet WHERE ExpectedPaymentDate=@monthYear)
    BEGIN
        SET @foundExistingExpectedPaymentSet = 1;
        SELECT @expectedPaymentSetKey=[RecurringDonationExpectedPaymentSetKey]
          FROM [RecurringDonationExpectedPaymentSet]
         WHERE [ExpectedPaymentDate]=@monthYear
            
        -- if this isn't the GUID passed in raise an error
        IF @newExpectedPaymentSetKey <> @expectedPaymentSetKey
        BEGIN
            RAISERROR ( N'The ExpectedPaymentSetKey value passed into the Procedure does not match the existing ExpectedPaymentSetKey',16,1);
            RETURN
        END
    END
    ELSE
    BEGIN
        -- doesn't already exist so use the new key passed in
        SET @foundExistingExpectedPaymentSet = 0
        IF @newExpectedPaymentSetKey IS NOT NULL
            SET @expectedPaymentSetKey = @newExpectedPaymentSetKey
        ELSE
            SET @expectedPaymentSetKey = NEWID()
    END
    
    -- DROP THE EXISTING VALUES
    IF @clearExistingValues = 1 AND @foundExistingExpectedPaymentSet = 1
    BEGIN
        BEGIN TRANSACTION;
        
        DELETE 
          FROM [RecurringDonationExpectedPayment] 
         WHERE [RecurringDonationExpectedPaymentSetKey] = @expectedPaymentSetKey
               AND [RecurringDonationExpectedPaymentStatusCode] <> @paymentStatusProcessed
        
        COMMIT TRANSACTION;
    END

    -- Identify the donations for this month/year            
    DECLARE @recurringDonationTable TABLE (
        [StartDate] datetime NOT NULL,
        [EndDate] datetime NULL,
        [RecurringDonationFrequencyCode] integer NOT NULL,
        [RecurringDonationCommitmentKey] uniqueidentifier NOT NULL
    );
     
    ;WITH RecurringDonationTable AS (     
        SELECT StartDate, EndDate, RecurringDonationFrequencyCode, RecurringDonationCommitmentKey 
          FROM RecurringDonationCommitment 
         WHERE CommitmentStatusInd='A' AND
               StartDate<=@monthYearEnd AND 
               (
                   EndDate IS NULL
               OR
                   EndDate>=@monthYear
               )
        UNION ALL      
        SELECT DATEADD(m, 12/RecurringDonationFrequencyCode, StartDate), EndDate, RecurringDonationFrequencyCode, RecurringDonationCommitmentKey 
          FROM RecurringDonationTable a
         WHERE DATEADD(m, 12/RecurringDonationFrequencyCode, StartDate) <= ISNULL(EndDate,@monthYearEnd)
               AND DATEADD(m, 12/RecurringDonationFrequencyCode, StartDate)<=@monthYearEnd 
    )
    INSERT INTO @recurringDonationTable (StartDate, EndDate, RecurringDonationFrequencyCode, RecurringDonationCommitmentKey)
    SELECT StartDate, EndDate, RecurringDonationFrequencyCode, RecurringDonationCommitmentKey 
      FROM RecurringDonationTable 
     WHERE StartDate<=@monthYearEnd AND StartDate>=@monthYear 
    OPTION (maxrecursion 0);
    
    SELECT @now = dbo.asi_GetAppDatetime();

    -- Insert Header - we do this in a separate transaction so if the detail fails we can
    -- update the header with a completedWithError status
    BEGIN TRANSACTION

    BEGIN TRY

        IF @foundExistingExpectedPaymentSet = 0
        BEGIN
            INSERT INTO [dbo].[RecurringDonationExpectedPaymentSet] ([RecurringDonationExpectedPaymentSetKey], [ExpectedPaymentDate],
                                                                     [RecurringDonationExpectedPaymentSetStatusCode], [CreatedByUserKey], 
                                                                     [CreatedOn], [UpdatedByUserKey], [UpdatedOn])
             VALUES (@expectedPaymentSetKey, @monthYear, @setStatusGenerating, @userKey, @now, @userKey, @now)
        END
        ELSE
        BEGIN
            UPDATE [dbo].[RecurringDonationExpectedPaymentSet] 
               SET [UpdatedByUserKey] = @userKey, 
                   [UpdatedOn] = @now, 
                   [RecurringDonationExpectedPaymentSetStatusCode] = @setStatusGenerating
             WHERE [RecurringDonationExpectedPaymentSetKey] = @expectedPaymentSetKey
        END
        
        IF @@TRANCOUNT > 0
            COMMIT TRANSACTION

    END TRY
    BEGIN CATCH
    
        IF @@TRANCOUNT > 0
            ROLLBACK TRANSACTION
        SELECT 
            @errorMessage = ERROR_MESSAGE(),
            @errorSeverity = ERROR_SEVERITY(),
            @errorState = ERROR_STATE();
        
        RAISERROR (@errorMessage, -- Message text.
               @errorSeverity, -- Severity.
               @errorState -- State.
               );
        
    END CATCH
    
    -- Now insert the expected payments rows
    BEGIN TRANSACTION
        
    BEGIN TRY
                
        DECLARE @isDone bit;
        SET @isDone = 0;
        WHILE (@isDone = 0)
        BEGIN

            INSERT INTO [dbo].[RecurringDonationExpectedPayment]([RecurringDonationExpectedPaymentKey], [RecurringDonationExpectedPaymentSetKey], 
                                                                 [RecurringDonationCommitmentKey], [OpportunityKey], [DonationAmount], [PaymentMethod], 
                                                                 [Distribution], [Appeal], [Campaign], [Fund], [Narrative], [MatchReference], [BranchSortCode],
                                                                 [BankAccountNumber], [BankAccountName], [ResultingTransNum], [ResultingTransLineNum],
                                                                 [RecurringDonationExpectedPaymentStatusCode], [CreatedByUserKey], [CreatedOn], [UpdatedByUserKey], [UpdatedOn])
             SELECT TOP (@batchSize) NEWID(), @expectedPaymentSetKey, c.RecurringDonationCommitmentKey, NULL, c.DonationAmount, c.PaymentMethod,
                  c.Distribution, c.Appeal, c.Campaign, c.Fund, N'', c.MatchReference, c.BranchSortCode, c.BankAccountNumber,
                                     c.BankAccountName, 0, 0, @paymentStatusAwaiting, @userKey, @now, @userKey, @now
               FROM RecurringDonationCommitment c
                    INNER JOIN @recurringDonationTable r ON c.RecurringDonationCommitmentKey = r.RecurringDonationCommitmentKey
                    LEFT OUTER JOIN RecurringDonationExpectedPayment e ON c.RecurringDonationCommitmentKey=e.RecurringDonationCommitmentKey 
                         AND e.[RecurringDonationExpectedPaymentSetKey] = @expectedPaymentSetKey   
              WHERE e.RecurringDonationCommitmentKey IS NULL -- filter out the existing expected payments
             
             IF @@ROWCOUNT = 0
                 SET @isDone = 1

             IF @@TRANCOUNT > 0
                 COMMIT TRANSACTION
            
             IF @doNotLoop = 1
                 BREAK
        END -- WHILE
        
        -- Update the header to say the processing is complete
        IF @isDone = 1 AND @updateHeaderFlag=1
        BEGIN
            BEGIN TRANSACTION
            
            -- Update the header row to say we have finished generating
            UPDATE [dbo].[RecurringDonationExpectedPaymentSet] 
               SET [UpdatedByUserKey] = @userKey, [UpdatedOn] = @now, 
                   [RecurringDonationExpectedPaymentSetStatusCode] = @setStatusComplete
             WHERE [RecurringDonationExpectedPaymentSetKey] = @expectedPaymentSetKey
             IF @@TRANCOUNT > 0
                 COMMIT TRANSACTION

        END
        
    END TRY
    BEGIN CATCH
    
        IF @@TRANCOUNT > 0
            ROLLBACK TRANSACTION
   
        SELECT 
            @errorMessage = ERROR_MESSAGE(),
            @errorSeverity = ERROR_SEVERITY(),
            @errorState = ERROR_STATE();

        IF @updateHeaderFlag = 1
        BEGIN
            BEGIN TRANSACTION
            
            -- Update the header row to say we have finished with errors
            UPDATE [dbo].[RecurringDonationExpectedPaymentSet] 
               SET [UpdatedByUserKey] = @userKey, [UpdatedOn] = @now, 
                   [RecurringDonationExpectedPaymentSetStatusCode] = @setStatusCompleteWithError
             WHERE [RecurringDonationExpectedPaymentSetKey] = @expectedPaymentSetKey
             IF @@TRANCOUNT > 0
                 COMMIT TRANSACTION
        END
                
        RAISERROR (@errorMessage, -- Message text.
               @errorSeverity, -- Severity.
               @errorState -- State.
               );
        
    END CATCH
    
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GenTableByTableNameAndValue]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GenTableByTableNameAndValue]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_GenTableByTableNameAndValue    Script Date: 7/3/2003 4:58:03 PM ******/
CREATE   PROC asi_GenTableByTableNameAndValue
@Code varchar(60),
@TableName varchar(30)

AS
BEGIN
	select * from Gen_Tables where TABLE_NAME = @TableName and ((CODE = @Code) or (SUBSTITUTE = @Code) or (UPPER_CODE = @Code))
	
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetAccessArea]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetAccessArea]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_GetAccessArea    Script Date: 7/3/2003 4:58:03 PM ******/
CREATE PROCEDURE dbo.asi_GetAccessArea
	@navmarker varchar(36),
	@pageset varchar(36) = null
AS

select AccessAreaKey
from NavigationMain
where Marker = @navmarker
and PageSet = ISNULL(@pageset, ' ')

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetAccessKeyReferences]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetAccessKeyReferences]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_GetAccessKeyReferences]
    @accessKey uniqueidentifier
AS
BEGIN
	DECLARE @tableName nvarchar(255)
	DECLARE @columnName nvarchar(255)
	DECLARE @sql nvarchar(4000)
	DECLARE @results table (UserKey uniqueidentifier, TableName nvarchar(255), ColumnName nvarchar(255))
	DECLARE @exists bit
	DECLARE theCursor CURSOR FAST_FORWARD FOR
		SELECT isc.TABLE_NAME, isc.COLUMN_NAME from INFORMATION_SCHEMA.COLUMNS isc INNER JOIN INFORMATION_SCHEMA.TABLES ist ON isc.TABLE_NAME = ist.TABLE_NAME
		WHERE isc.COLUMN_NAME like '%AccessKey' AND isc.DATA_TYPE = 'uniqueidentifier' AND ist.TABLE_TYPE = 'BASE TABLE' AND ist.TABLE_SCHEMA = 'dbo'
	OPEN theCursor
	FETCH NEXT from theCursor INTO @tableName, @columnName
	WHILE (@@FETCH_STATUS =0)
	BEGIN
		SET @sql = N'IF EXISTS (SELECT 1 FROM ' + @tableName + N' WHERE ' + @columnName + N' = @aKey) BEGIN SET @e = 1 END ELSE BEGIN SET @e = 0 END';
		EXEC sp_executesql @sql, N'@e bit out, @aKey uniqueidentifier', @exists out, @accessKey
		IF (@exists = 1) INSERT INTO @results VALUES (@accessKey, @tableName, @columnName)
		FETCH NEXT from theCursor INTO @tableName, @columnName
	END
	CLOSE theCursor
	DEALLOCATE theCursor
	SELECT * from @results
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetAddressByEmail]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetAddressByEmail]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_GetAddressByEmail] 
    @email nvarchar (300)
AS
BEGIN

SELECT AddressKey FROM AddressMain WHERE AddressCategoryCode=4 AND FormattedAddress = @email

END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetAssignableChildTagKey]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetAssignableChildTagKey]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure retrieves records from vBoTagHierarchy records
-- that are child records of @ParentHierarchyKey and @UserKey has access to assign.
-- =============================================
CREATE PROCEDURE [dbo].[asi_GetAssignableChildTagKey]
	@ParentHierarchyKey uniqueidentifier,
    @UserKey uniqueidentifier
AS
BEGIN
	SELECT HierarchyKey FROM vBoTagHierarchy
	 WHERE ParentHierarchyKey = @ParentHierarchyKey
       AND EXISTS (SELECT 1
 	 FROM AccessItem INNER JOIN UserToken
  	   ON AccessItem.Grantee = UserToken.Grantee
	WHERE AccessItem.AccessKey = vBoTagHierarchy.AssignAccessKey
	  AND UserToken.UserKey = @UserKey
-- At least one of Control/Read/Add/Edit/Delete
	  AND (AccessItem.Permission&31)>0)
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetBlogArchiveMonths]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetBlogArchiveMonths]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_GetBlogArchiveMonths]
    @parentHierarchyKey uniqueidentifier,
    @userKey uniqueidentifier,
    @loggedInUserGroupKey uniqueidentifier = '00000000-0000-0000-0000-000000000000' -- if this is empty, we assume the user is not logged in
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @publishedOnly bit;
    DECLARE @ignoreLicensing bit;

    SET @publishedOnly = 1;
    SET @ignoreLicensing = 0;

    IF OBJECT_ID('tempdb..#ChildDocuments') IS NOT NULL
        DROP TABLE #ChildDocuments;
        
    CREATE TABLE #ChildDocuments (HierarchyKey uniqueidentifier PRIMARY KEY, DocumentKey uniqueidentifier, DocumentVersionKey uniqueidentifier,
                                  DocumentStatusCode nvarchar(6), DocumentName nvarchar(100), AlternateName nvarchar(100),
                                  DocumentDescription nvarchar(250), DocumentTypeCode nvarchar(6), IsSystem bit, 
                                  ContainsChildrenFlag bit, RelatedDocumentVersionKey uniqueidentifier, AccessKey uniqueidentifier,
                                  DefaultChildAccessKey uniqueidentifier, StatusUpdatedOn datetime, StatusUpdatedByUserKey uniqueidentifier,
                                  CreatedOn datetime, CreatedByUserKey uniqueidentifier, UpdatedOn datetime, UpdatedByUserKey uniqueidentifier,
                                  DocumentTypeName nvarchar(255), DocumentTypeDesc nvarchar(100), DocuemntIconUrl nvarchar(256),
                                  RelatedDocumentKey uniqueidentifier, RelatedDocumentTypeCode nvarchar(6), RelatedDocumentName nvarchar(100),
                                  RealtedAlternateName nvarchar(100), RelatedDocumentDescription nvarchar(250), relatedDocumentTypeName nvarchar(255),
                                  RelatedDocumentTypeDesc nvarchar(100), RelatedDocumentIconURL nvarchar(256), RelatedShortcutIconURL nvarchar(256));

    INSERT INTO #ChildDocuments
       EXECUTE [dbo].[asi_DocumentMainListByParentHierarchyKey] @parentHierarchyKey, @userKey, @loggedInUserGroupKey, @publishedOnly, @ignoreLicensing

    IF OBJECT_ID('tempdb..#SortedMonths') IS NOT NULL
        DROP TABLE #SortedMonths;
        
    CREATE TABLE #SortedMonths (ArchiveDateSorted datetime PRIMARY KEY);
    
    -- Now create a second table of dates that will only contain a single instance for the year and month 
    INSERT INTO #SortedMonths (ArchiveDateSorted)
        SELECT CAST(RIGHT('0' + RTRIM(MONTH(d.CreatedOn)),2) + '/1/' + RTRIM(YEAR(d.CreatedOn)) AS datetime) AS ArchiveDateSorted 
          FROM #ChildDocuments cd 
                  INNER JOIN Hierarchy h ON cd.HierarchyKey = h.ParentHierarchyKey 
                  INNER JOIN DocumentMain d ON h.UniformKey = d.DocumentVersionKey AND d.DocumentTypeCode = 'CTY'
         GROUP BY  CAST(RIGHT('0' + RTRIM(MONTH(d.CreatedOn)),2) + '/1/' + RTRIM(YEAR(d.CreatedOn)) AS datetime)

    -- Return the month/year literal properly ordered in desc order
    SELECT RIGHT('0' + RTRIM(MONTH(ArchiveDateSorted)),2) + '/' + RTRIM(YEAR(ArchiveDateSorted)) AS ArchiveDate 
      FROM #SortedMonths
     ORDER BY ArchiveDateSorted DESC
    
    IF OBJECT_ID('tempdb..#ChildDocuments') IS NOT NULL
        DROP TABLE #ChildDocuments;
    IF OBJECT_ID('tempdb..#SortedMonths') IS NOT NULL
        DROP TABLE #SortedMonths;
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetCommunityRoster]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetCommunityRoster]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_GetCommunityRoster] (
      @communityDocumentKey uniqueidentifier
)
AS
BEGIN
    -- Get ParentHierarchyKey
    DECLARE @parentHierarchyKey uniqueidentifier;
    SELECT @parentHierarchyKey = h.[ParentHierarchyKey]
      FROM [dbo].[DocumentMain] d
           INNER JOIN [dbo].[Hierarchy] h ON d.[DocumentVersionKey] = h.[UniformKey]
     WHERE d.[DocumentVersionKey] = @communityDocumentKey 
           AND d.DocumentTypeCode = 'CTY' 
           AND d.DocumentStatusCode = 40;

    -- Get the list of all community documents underneath the parent of the specified community document
    IF OBJECT_ID('tempdb..#communityDocument') IS NOT NULL DROP TABLE #communityDocument;
    CREATE TABLE #communityDocument
    (
        [DocumentVersionKey] uniqueidentifier,
        [StringVersionKey] nvarchar(36) COLLATE database_default,
        [Title] nvarchar(100) COLLATE database_default,
        [CreatedOn] datetime,
        [CreatedByUserKey] uniqueidentifier
    );

    INSERT INTO #communityDocument ([DocumentVersionKey], [StringVersionKey], [Title], [CreatedOn], [CreatedByUserKey])
        SELECT [DocumentVersionKey], LOWER(CAST([DocumentVersionKey] AS nvarchar(36))), [Title], [CreatedOn], [CreatedByUserKey] 
          FROM [dbo].[asi_PublishedCommunitiesByDocumentKey](@communityDocumentKey)
         WHERE [DocumentTypeCode] = 'CTY'
         
    CREATE NONCLUSTERED INDEX IX_#communityDocument_StringVersionKey ON #communityDocument ([StringVersionKey]);
    CREATE NONCLUSTERED INDEX IX_#communityDocument_CreatedByUserKey ON #communityDocument ([CreatedByUserKey] ASC, [CreatedOn] DESC) INCLUDE (DocumentVersionKey);

    -- Get all subscribers to all groups for all documents
    IF OBJECT_ID('tempdb..#subscriber') IS NOT NULL DROP TABLE #subscriber; 
    CREATE TABLE #subscriber 
    (
       [ContactKey] uniqueidentifier,
       [JoinDate] datetime,
       [IsAdmin] int, 
       [IsModerator] int, 
       [IsWikiAuthor] int
    );
             
    DECLARE @groupTypeKey uniqueidentifier;
    DECLARE @subscriberRoleKey uniqueidentifier;
    DECLARE @adminRoleKey uniqueidentifier;
    DECLARE @wikiAuthorRoleKey uniqueidentifier;
    DECLARE @communityModeratorRoleKey uniqueidentifier;

    SET @groupTypeKey = '44B62E6D-CB59-4113-B3B9-D85E52F176BF';
    SET @subscriberRoleKey = '5BF5FE7A-BF40-4072-B7E7-FD250635BF95';
    SET @adminRoleKey = '13FE69F0-19B3-4F47-805C-64FF8E836469';
    SET @wikiAuthorRoleKey = '62FF03ED-8C63-4CA3-A83B-8E6349FC15B2';
    SET @communityModeratorRoleKey = '4789BA6A-674A-4917-A02A-398236F95D14';
    
    WITH allMemberRoles AS (
          SELECT [MemberContactKey], m.[JoinDate], 
                  CASE WHEN d.GroupRoleKey = @adminRoleKey THEN 1 ELSE 0 END AS [AdminRole],
                  CASE WHEN d.GroupRoleKey = @communityModeratorRoleKey THEN 1 ELSE 0 END AS [ModeratorRole],
                  CASE WHEN d.GroupRoleKey = @wikiAuthorRoleKey THEN 1 ELSE 0 END AS [WikiAuthorRole]
            FROM #communityDocument cd
                  INNER JOIN [dbo].[GroupMain] g ON g.[GroupTypeKey] = @groupTypeKey AND g.[Name] = cd.[StringVersionKey]
                  INNER JOIN [dbo].[GroupMember] m ON g.[GroupKey] = m.[GroupKey] AND m.[IsActive] = 1
                  INNER JOIN [dbo].[GroupMemberDetail] d ON m.[GroupMemberKey] = d.[GroupMemberKey] 
                                                              AND d.[GroupRoleKey] IN (@subscriberRoleKey, @adminRoleKey, @wikiAuthorRoleKey, @communityModeratorRoleKey)
                                                              AND d.[IsActive] = 1
     )
    INSERT INTO #subscriber ( [ContactKey], [JoinDate], [IsAdmin], [IsModerator], [IsWikiAuthor])
          SELECT [MemberContactKey], MIN([JoinDate]) AS [JoinDate], 
                  MAX([AdminRole]) AS [IsAdmin], MAX(ModeratorRole) AS [IsModerator], MAX(WikiAuthorRole) AS [IsWikiAuthor]
            FROM allMemberRoles
           GROUP BY [MemberContactKey]
         
     CREATE CLUSTERED INDEX IX_#subscriber ON #subscriber ([ContactKey], [JoinDate]);

    -- Return each subscriber's roster info
    SELECT s.[ContactKey], i.[FirstName], i.[LastName], c.[FullName], i.[PrimaryInstituteName], ii.[InstituteName], s.[JoinDate], 
           [Title] AS [MostRecentPostTitle], [DocumentVersionKey] AS [MostRecentPostKey], d.[CreatedOn] AS [MostRecentPostOn],
           s.[IsAdmin], s.[IsModerator], s.[IsWikiAuthor]
      FROM #subscriber s
           INNER JOIN [dbo].[ContactMain] c ON s.[ContactKey] = c.[ContactKey]
           LEFT OUTER JOIN [dbo].[Individual] i ON s.[ContactKey] = i.[ContactKey]
           LEFT OUTER JOIN [dbo].[Institute] ii ON s.[ContactKey] = ii.[ContactKey]
           LEFT OUTER JOIN #communityDocument d ON s.[ContactKey] = d.[CreatedByUserKey]
     WHERE [DocumentVersionKey] IS NULL 
        OR [DocumentVersionKey] = (SELECT TOP 1 [DocumentVersionKey] 
                                     FROM #communityDocument cd 
                                    WHERE cd.[CreatedByUserKey] = d.[CreatedByUserKey] 
                                    ORDER BY cd.[CreatedOn] DESC)

    IF OBJECT_ID('tempdb..#subscriber') IS NOT NULL DROP TABLE #subscriber; 
    IF OBJECT_ID('tempdb..#communityDocument') IS NOT NULL DROP TABLE #communityDocument;
END



GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetCommunitySubscriptions]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetCommunitySubscriptions]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_GetCommunitySubscriptions] (
    @groupRoleKey uniqueidentifier,
    @groupTypeKey uniqueidentifier,
    @contactKey uniqueidentifier,
    @communityDocumentKey uniqueidentifier
)
AS
BEGIN
    SET NOCOUNT ON;
    
    -- Get the list of all community documents underneath the parent of the specified community document
    DECLARE @communityDocument table
    (
        [DocumentVersionKeyString] nvarchar(40) PRIMARY KEY
    )
    DECLARE @now datetime;
    SELECT @now = dbo.asi_GetAppDatetime();

    INSERT INTO @communityDocument
        SELECT LOWER(CAST([DocumentVersionKey] AS nvarchar(40))) 
          FROM [dbo].[asi_PublishedCommunitiesByDocumentKey](@communityDocumentKey)
         WHERE [DocumentTypeCode] = 'CTY'

    -- Return the subscription information
    SELECT CAST(NULL AS NVARCHAR(100)) AS [Community], 
           CAST(NULL AS NVARCHAR(100)) AS [Type], 
           CAST(NULL AS NVARCHAR(100)) AS [Title], 
           [g].[Name] AS [CommunityDocumentKey], 
           [c].[FullName]
      FROM [dbo].[GroupMember] AS [m]
           INNER JOIN [dbo].[GroupMemberDetail] AS [d] ON [m].[GroupMemberKey] = [d].[GroupMemberKey] AND 
                                                          [d].[GroupRoleKey] = @groupRoleKey AND [d].[IsActive] = 1 AND 
                                                          [d].[GroupMemberStatusCode] = 'A' AND 
                                                         ([d].[EffectiveDate] IS NULL OR [d].[EffectiveDate] < @now) AND 
                                                         ([d].[ExpirationDate] IS NULL OR [d].[ExpirationDate] > @now)
           INNER JOIN [dbo].[GroupMain] AS [g] on [m].[GroupKey] = [g].[GroupKey] AND [g].[GroupTypeKey] = @groupTypeKey
           INNER JOIN [dbo].[ContactMain] AS [c] on [m].[MemberContactKey] = [c].[ContactKey]
           INNER JOIN @communityDocument cd ON g.[Name] = cd.[DocumentVersionKeyString]
     WHERE [m].[MemberContactKey] = @contactKey 
END 


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetDatabaseVersion]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetDatabaseVersion]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- Author:		Paul Bradshaw
-- Create date: Sept 19, 2006
-- Description:	Get DB Version string
-- =============================================
CREATE PROCEDURE [dbo].[asi_GetDatabaseVersion] 
	@p1 nvarchar(20) = '' -- Specify which version part, or nothing for full version
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @version nvarchar(24)
	DECLARE @major nvarchar(10)
	DECLARE @minor nvarchar(10)
	DECLARE @patch nvarchar(10)
	DECLARE @build nvarchar(10)
	DECLARE @systemEntity uniqueidentifier
	DECLARE @type nvarchar(20)

	SET @type = UPPER(@p1)

	SELECT @systemEntity = SystemEntityKey FROM SystemEntity WHERE SystemKeyword = 'Organization'

	SELECT @major = ParameterValue FROM SystemConfig WHERE ParameterName = 'System.Database.Version.Major'
		AND OrganizationKey = '00000000-0000-0000-0000-000000000000' AND SystemEntityKey = @systemEntity
	SELECT @minor = ParameterValue FROM SystemConfig WHERE ParameterName = 'System.Database.Version.Minor'
		AND OrganizationKey = '00000000-0000-0000-0000-000000000000' AND SystemEntityKey = @systemEntity
	SELECT @patch = ParameterValue FROM SystemConfig WHERE ParameterName = 'System.Database.Version.Patch'
		AND OrganizationKey = '00000000-0000-0000-0000-000000000000' AND SystemEntityKey = @systemEntity
	SELECT @build = ParameterValue FROM SystemConfig WHERE ParameterName = 'System.Database.Version.Build'
		AND OrganizationKey = '00000000-0000-0000-0000-000000000000' AND SystemEntityKey = @systemEntity

	IF @major IS NOT NULL AND @minor IS NOT NULL AND @patch IS NOT NULL AND @build IS NOT NULL
	BEGIN
		IF @type = ''
		BEGIN
			SET @version = @major + '.' + @minor + '.' + @patch + '.' + @build
		END
		ELSE IF @type = 'NOBUILD'
		BEGIN
			SET @version = @major + '.' + @minor + '.' + @patch
		END
		ELSE IF @type = 'MAJORMINOR'
		BEGIN
			SET @version = @major + '.' + @minor
		END
		ELSE IF @type = 'MAJOR'
		BEGIN
			SET @version = @major
		END
		ELSE IF @type = 'MINOR'
		BEGIN
			SET @version = @minor
		END
		ELSE IF @type = 'PATCH'
		BEGIN
			SET @version = @patch
		END
		ELSE IF @type = 'BUILD'
		BEGIN
			SET @version = @build
		END
		
	END
	ELSE
	BEGIN
		SET @version = NULL
	END

	SELECT @version

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetDeferredAmount]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetDeferredAmount]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_GetDeferredAmount]
    @thisRunNumber int
AS
BEGIN
    DECLARE @thisRunKey uniqueidentifier;
    DECLARE @lastRunKey uniqueidentifier;
    DECLARE @thisAmount money;
    DECLARE @lastAmount money = 0;
    DECLARE @returnAmount money = 0;

    SELECT @thisRunKey = [GLExportKey]
      FROM [dbo].[GLExport]
     WHERE [RunNumber] = @thisRunNumber;

    SELECT @lastRunKey = [GLExportKey]
      FROM [dbo].[GLExport]
     WHERE [RunNumber] = @thisRunNumber - 1;

    IF EXISTS (SELECT 1 FROM [dbo].[GLExportDeferredIncomeItem] WHERE [GLExportKey] = @lastRunkey)
    BEGIN
        SELECT @thisAmount = [AmountTransferred]
          FROM [dbo].[GLExportDeferredIncomeItem]
         WHERE [GLExportKey] = @thisRunKey;

        SELECT @lastAmount = [AmountTransferred]
          FROM [dbo].[GLExportDeferredIncomeItem]
         WHERE [GLExportKey] = @lastRunkey;

        SET @returnAmount = @thisAmount - @lastAmount;
    END;

    --Return the last value of the assigned counter range
    SELECT @returnAmount AS [CurrentValue];
END;


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetPublishRequestDetails]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetPublishRequestDetails]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_GetPublishRequestDetails]
     @PublishRequestKey uniqueidentifier,
     @PublishServerCode nchar(1)
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @now datetime;
    SELECT @now = dbo.asi_GetAppDatetime();
    SELECT PublishRequestDetailKey
      FROM PublishRequestDetail prd, DocumentMain dm
     WHERE prd.PublishServerCode = @PublishServerCode
       AND prd.PublishRequestKey = @PublishRequestKey
       AND prd.ContentDocumentKey = dm.DocumentKey
       AND ((dm.DocumentStatusCode IN (30,40) AND prd.IsDelete = 0)
         OR (dm.DocumentStatusCode IN (70,80) AND prd.IsDelete = 1))
       AND ((PublishRequestStatusCode = 0 AND (PublishedDateTime IS NULL OR PublishedDateTime <= @now))
              OR
              (PublishRequestStatusCode = 1 AND prd.IsDelete = 0 AND
              (DATEADD(second, prd.Frequency, prd.PublishedDateTime) <= @now)
               AND (prd.Frequency <> 0))
              )
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetPublishRequests]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetPublishRequests]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_GetPublishRequests]
    @PublishServerCode nchar(1) 
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @now datetime;
    SELECT @now = dbo.asi_GetAppDatetime();
    SELECT [PublishRequestKey] 
      FROM [dbo].[PublishRequest] pr
     WHERE EXISTS (SELECT 1 
                     FROM [dbo].[PublishRequestDetail] prd
                          INNER JOIN [dbo].[DocumentMain] dm ON prd.[ContentDocumentKey] = dm.[DocumentKey]
                    WHERE prd.[PublishRequestKey] = pr.[PublishRequestKey]
                      AND prd.[PublishServerCode] = @PublishServerCode
                      AND (    (dm.[DocumentStatusCode] IN (30,40) AND prd.[IsDelete] = 0)
                            OR (dm.[DocumentStatusCode] IN (70,80) AND prd.[IsDelete] = 1)
                           )
                      AND (    (prd.[PublishRequestStatusCode] = 0 
                                AND (prd.[PublishedDateTime] IS NULL OR prd.[PublishedDateTime] <= @now)
                                )
                            OR (prd.[PublishRequestStatusCode] = 1 AND prd.[IsDelete] = 0 
                                AND (DATEADD(second, prd.[Frequency], prd.[PublishedDateTime]) <= @now)
                                AND (prd.[Frequency] <> 0)
                                )
                          )
                   )
     ORDER BY pr.[PublishPriorityCode], pr.[RequestDateTime]
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetPublishRequestStatus]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetPublishRequestStatus]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_GetPublishRequestStatus]
	@PublishRequestKey uniqueidentifier,
	@PublishServerCode nchar(1) AS
BEGIN

SELECT 
(SELECT Count(*) FROM PublishRequestDetail 
  WHERE PublishRequestKey = a.PublishRequestKey
	AND PublishServerCode = @PublishServerCode 
    AND PublishRequestStatusCode = 0) AS PendingCount,
(SELECT Count(*) FROM PublishRequestDetail 
  WHERE PublishRequestKey = a.PublishRequestKey
    AND PublishServerCode = @PublishServerCode 
    AND PublishRequestStatusCode = 1) AS PublishedCount,
(SELECT Count(*) FROM PublishRequestDetail 
  WHERE PublishRequestKey = a.PublishRequestKey
	AND PublishServerCode = @PublishServerCode
   AND PublishRequestStatusCode = 2) AS CanceledCount,
(SELECT Count(*) FROM PublishRequestDetail 
  WHERE PublishRequestKey = a.PublishRequestKey
	AND PublishServerCode = @PublishServerCode
	AND PublishRequestStatusCode = 3)  AS FailedCount
FROM PublishRequest a
WHERE PublishRequestKey = @PublishRequestKey
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetRecentCompletePublishRequests]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetRecentCompletePublishRequests]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_GetRecentCompletePublishRequests]
	@PublishServerCode nchar(1),
	@NumberOfRequests int = 20
AS
BEGIN
	DECLARE @recentRequests TABLE (
		ID int identity (1,1),
		PublishRequestKey uniqueidentifier
	)

	INSERT INTO @recentRequests (PublishRequestKey)
	SELECT PublishRequestKey FROM PublishRequest
    WHERE Exists (SELECT 1 FROM PublishRequestDetail prd, DocumentMain dm
                          WHERE prd.PublishRequestKey = PublishRequest.PublishRequestKey
							AND prd.PublishServerCode = @PublishServerCode
							AND prd.ContentDocumentKey = dm.DocumentKey
						    AND ((dm.DocumentStatusCode IN (30,40) AND prd.IsDelete = 0)
									OR (dm.DocumentStatusCode IN (70,80) AND prd.IsDelete = 1))
						   AND prd.PublishRequestStatusCode <> 0
				   )
    ORDER BY RequestDateTime DESC

	SELECT PublishRequestKey FROM @recentRequests WHERE ID <= @NumberOfRequests
END


SET ANSI_NULLS ON

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetRolesAccess]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetRolesAccess]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_GetRolesAccess    Script Date: 7/3/2003 4:58:03 PM ******/
CREATE PROCEDURE [dbo].[asi_GetRolesAccess]
	@accessArea uniqueidentifier
AS

select ai.AccessKey, ai.Grantee, ai.Permission, 
ai.RoleKey, ai.UserKey, ai.GroupKey
from AccessItem ai, AccessArea aa
where ai.AccessKey = aa.ProtectedAccessKey
and aa.AccessAreaKey = @accessArea

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetSalesHistoryResponseStart]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetSalesHistoryResponseStart]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_GetSalesHistoryResponseStart]
    @userKey uniqueidentifier,
    @rangeBegin datetime OUTPUT,
    @rangeEnd datetime OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @newGuid  uniqueidentifier;
    DECLARE @everyoneFullControlAccessKey uniqueidentifier;
    DECLARE @now  datetime;
    DECLARE @defaultDate datetime;

    SET @defaultDate = '1/1/1980';
    SET @rangeBegin = @defaultDate;
    SET @rangeEnd = @defaultDate;

    BEGIN TRANSACTION;

    -- Get the ending value
    SELECT @rangeEnd = ISNULL(MAX(CreatedOn), @defaultDate)
      FROM [dbo].[SalesHistory];

    -- Check to make sure the counter exists - create it if not
    IF NOT EXISTS(SELECT 1 FROM SystemConfig WHERE ParameterName='SalesHistoryResponseRangeStart')
    BEGIN
         SELECT @newGuid = NEWID();
         SELECT @now = dbo.asi_GetAppDatetime();

         INSERT SystemConfig (SystemConfigKey, ParameterName, ParameterValue, [Description], 
                OrganizationKey, SystemEntityKey, CreatedByUserKey, CreatedOn, UpdatedByUserKey, UpdatedOn)
         VALUES(@newGuid, 
              'SalesHistoryResponseRangeStart', 
              CAST(@rangeEnd As nvarchar(100)), 
              'Ending point in the SalesHistory table already processed by response acquisition.',
              '00000000-0000-0000-0000-000000000000',
              NULL,
              @userKey, 
              @now, 
              @userKey, 
              @now)
    END

    -- Get the beginning value
    SELECT @rangeBegin = ISNULL(CAST(ParameterValue AS datetime), @defaultDate)
      FROM SystemConfig
     WHERE ParameterName = 'SalesHistoryResponseRangeStart'

    -- Set the ending value
    UPDATE SystemConfig
       SET ParameterValue = CAST(@rangeEnd AS nvarchar(100))
     WHERE ParameterName = 'SalesHistoryResponseRangeStart'

    COMMIT TRANSACTION;
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetSeasonalFullAddressKeysByFullAddressKey]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetSeasonalFullAddressKeysByFullAddressKey]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE  PROCEDURE [dbo].[asi_GetSeasonalFullAddressKeysByFullAddressKey] (@fullAddressKey uniqueidentifier, @now datetime) 
AS
BEGIN

SELECT SeasonalFullAddressKey FROM SeasonalFullAddress 
 WHERE FullAddressKey = @fullAddressKey 
   AND BeginDate < @now
   AND (EndDate IS NULL OR EndDate > @now  OR IsSeasonalAnnually = 1) 
ORDER BY BeginDate

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetSpecialCommunityRolesForUser]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetSpecialCommunityRolesForUser]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_GetSpecialCommunityRolesForUser] 
(@userKey uniqueidentifier)
AS
BEGIN
    -- check for Community Administrator role, community moderator role, wiki author role
    SELECT gm.GroupKey, gm.GroupMemberKey, gm.MemberContactKey, gmd.GroupRoleKey
      FROM [dbo].[GroupMember] gm WITH (NOLOCK)
           INNER JOIN [dbo].[GroupMemberDetail] gmd WITH (NOLOCK) ON gm.GroupMemberKey = gmd.GroupMemberKey
     WHERE gmd.GroupRoleKey IN 
        ('13FE69F0-19B3-4F47-805C-64FF8E836469','4789BA6A-674A-4917-A02A-398236F95D14','62FF03ED-8C63-4CA3-A83B-8E6349FC15B2')
       AND gm.MemberContactKey = @userKey 
       AND gmd.IsActive = 1
     ORDER BY gmd.EffectiveDate
END
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetSystemEntityKeyForSourceCode]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetSystemEntityKeyForSourceCode]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE Procedure asi_GetSystemEntityKeyForSourceCode
@SourceCodeKey uniqueidentifier
AS
SELECT TOP 1 SystemEntityKey FROM CampaignMain C
INNER JOIN AppealMain A ON C.CampaignKey = A.CampaignKey
INNER JOIN SolicitationMain S ON S.AppealKey = A.AppealKey
INNER JOIN SourceCode SC on SC.SolicitationKey = S.SolicitationKey
WHERE SourceCodeKey = @SourceCodeKey

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetUserKeyReferences]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetUserKeyReferences]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_GetUserKeyReferences]
    @userKey uniqueidentifier
AS
BEGIN
	DECLARE @tableName nvarchar(255)
	DECLARE @columnName nvarchar(255)
	DECLARE @sql nvarchar(4000)
	DECLARE @results table (UserKey uniqueidentifier, TableName nvarchar(255), ColumnName nvarchar(255))
	DECLARE @exists bit
	DECLARE theCursor CURSOR FAST_FORWARD FOR
		SELECT isc.TABLE_NAME, isc.COLUMN_NAME from INFORMATION_SCHEMA.COLUMNS isc INNER JOIN INFORMATION_SCHEMA.TABLES ist ON isc.TABLE_NAME = ist.TABLE_NAME
		WHERE isc.COLUMN_NAME like '%UserKey' AND isc.DATA_TYPE = 'uniqueidentifier' AND ist.TABLE_TYPE = 'BASE TABLE' AND ist.TABLE_SCHEMA = 'dbo'
	OPEN theCursor
	FETCH NEXT from theCursor INTO @tableName, @columnName
	WHILE (@@FETCH_STATUS =0)
	BEGIN
		SET @sql = N'IF EXISTS (SELECT 1 FROM ' + @tableName + N' WHERE ' + @columnName + N' = @uKey) BEGIN SET @e = 1 END ELSE BEGIN SET @e = 0 END';
		EXEC sp_executesql @sql, N'@e bit out, @uKey uniqueidentifier', @exists out, @userKey
		IF (@exists = 1) INSERT INTO @results VALUES (@userKey, @tableName, @columnName)
		FETCH NEXT from theCursor INTO @tableName, @columnName
	END
	CLOSE theCursor
	DEALLOCATE theCursor
	SELECT * from @results
END

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetAccessKeyReferences]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[asi_GetAccessKeyReferences]

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetVatCountryForTaxByLocation]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetVatCountryForTaxByLocation]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


-- Calculate the vat country to use for taxing a "Tax by location" product
-- PARAMETERS
-- @orgCode             The financial entity (org) for the order.
--                      If passed empty/null the default org is assumed.
-- @billToId            Bill to contact Id.
-- @shipToCountry       The currently selected ship to country code. Accepts either a country name or country code.
--                      This may not necessarily be the ship to contacts ship to country. It may have been manually changed on the order.
-- @vatCountryCode OUT  Returns the country code that VAT is being charged based on.
--                      Could legitimately be empty if the determined country does not have a VAT_COUNTRY_CODE
--                      Will always be empty in a non VAT environment.

-- The procedure also returns  a single row resultset containing the value returned by @vatCountryCode OUT

CREATE PROCEDURE [dbo].[asi_GetVatCountryForTaxByLocation]
    @orgCode varchar(5),
    @billToID varchar(10),
    @shipToCountry varchar(25),
    @vatCountryCode varchar(2) = NULL OUT
AS
BEGIN

    -- Declare variables    
    DECLARE @taxOnShipTo bit
    DECLARE @orgVatCountryCode varchar(2)
    DECLARE @billCountry varchar(25)
    DECLARE @billVatCountryCode varchar(2)
    DECLARE @contactVatCountryCode varchar(2)
        
    -- Default the return value
    SET @vatCountryCode = ''

    -- Check we are licensed for VAT
    IF NOT EXISTS (SELECT 1 
                     FROM [dbo].[LicenseLegacyList] 
                    WHERE [LegacyLicenseCode]='VAT') 
    BEGIN
        GOTO ReturnValue
    END

    -- Get the org's VAT country code
    -- As part of this we check that it is a vat org and it has a vat country defined
    -- If no org was specified, then assume the default org
    IF LEN(COALESCE(@orgCode, ''))=0
    BEGIN
        SELECT @orgCode = o.[OrgCode], @orgVatCountryCode = o.[VATCountry]
          FROM [dbo].[Org_Control] o 
         WHERE o.[DefaultFlag]=1 AND o.[UseVATTaxation]=1 AND LEN(o.[VATCountry])>0
    END
    ELSE
    BEGIN
        SELECT @orgVatCountryCode = o.[VATCountry]
          FROM [dbo].[Org_Control] o 
         WHERE o.[OrgCode]=@orgCode AND o.[UseVATTaxation]=1 AND LEN(o.[VATCountry])>0
    END
    IF @@ROWCOUNT=0
    BEGIN
        -- Not a properly configured VAT org
        GOTO ReturnValue
    END

    -- Default to the org vat country code
    SET @vatCountryCode = @orgVatCountryCode

    -- Determine whether to use TaxOnShipTo option
    -- If the setting cannot be found, default to false
    SELECT @taxOnShipTo = CASE WHEN [ShortValue]='YES' THEN 1 ELSE 0 END
      FROM [dbo].[System_Params]
     WHERE [ParameterName] = 'AR_Control.TaxOnShipTo'  
    IF @@ROWCOUNT=0
    BEGIN
        SET @taxOnShipTo = 0
    END     
 
    -- Process based on the taxation method
    IF @taxOnShipTo = 1
    BEGIN
        
        -- Establish the vat country code of the ship to country 
        IF LEN(COALESCE(@shipToCountry,''))>0
        BEGIN
            -- Check the ship to country exists
            -- We could have been supplied either a country code or a country name    
            IF LEN(@shipToCountry)<=2
            BEGIN
                            SELECT @vatCountryCode = c.[VAT_COUNTRY_CODE]
                              FROM [dbo].[Country_Names] c
                            WHERE c.[COUNTRY_CODE] = @shipToCountry
            END
            ELSE
            BEGIN
                            SELECT @vatCountryCode = c.[VAT_COUNTRY_CODE]
                              FROM [dbo].[Country_Names] c
                            WHERE c.[COUNTRY] = @shipToCountry
            END
            -- @vatCountryCode remains unchanged if the country cannot be located
            -- If the country exists but the VAT_COUNTRY_CODE is empty, then we DO want that empty value
        END
        
    END
    ELSE
    BEGIN
        
        -- Do we have a bill to id
        IF LEN(COALESCE(@billToID, ''))=0
        BEGIN
            GOTO ReturnValue
        END
        
        -- Retrieve the various vat country codes from the contact
        SELECT @contactVatCountryCode = COALESCE(nf.[VAT_COUNTRY],''),
               @billCountry = COALESCE(na.[COUNTRY],''),
               @billVatCountryCode = COALESCE(c.[VAT_COUNTRY_CODE],'')
          FROM [dbo].[Name] n
               LEFT OUTER JOIN [dbo].[Name_Address] na ON n.[ID] = na.[ID] AND na.[PREFERRED_BILL] = 1
               LEFT OUTER JOIN [dbo].[Country_Names] c ON na.[COUNTRY] = c.[COUNTRY]
               LEFT OUTER JOIN [dbo].[Name_Fin] nf ON n.[ID] = nf.[ID]
         WHERE n.[ID] = @billToID
         
        -- We prioritize countries in a specific order
        -- 1. VAT Country code from the VAT tab in CP
        -- 2. VAT Country code of the primary billing address
        -- 3. VAT Country from the Org (already set as the default)
        IF LEN(@contactVatCountryCode)>0
        BEGIN
            -- The VAT Country from the VAT tab in CP  (Name_Fin.VAT_COUNTRY)
            SET @vatCountryCode = @contactVatCountryCode
        END
        ELSE
        BEGIN
            IF LEN(@billCountry)>0
            BEGIN
                -- The country of the contacts primary billing address
                -- @billVatCountryCode may be empty, thats OK
                -- If there was a bill to country then we want its VAT country code, even if its empty
                SET @vatCountryCode = @billVatCountryCode
            END
        END
        
    END

ReturnValue:    
 
    -- Return the values as a resultset for desktop
    SELECT @vatCountryCode AS [VatCountryCode]

END



GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GroupActiveMemberKeyByGroupRole]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GroupActiveMemberKeyByGroupRole]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_GroupActiveMemberKeyByGroupRole] (@groupKey uniqueidentifier, @roleKey uniqueidentifier) 
AS
BEGIN
    DECLARE @theGroupKey uniqueidentifier;
    DECLARE @theRoleKey uniqueidentifier;
    SET @theGroupKey = @groupKey;
    SET @theRoleKey = @roleKey;

    SELECT gm.GroupMemberKey, gm.MemberContactKey
      FROM [dbo].[GroupMember] gm WITH (NOLOCK)
           INNER JOIN [dbo].[GroupMemberDetail] gmd WITH (NOLOCK) ON gm.GroupMemberKey = gmd.GroupMemberKey
     WHERE gm.GroupKey=@theGroupKey AND gmd.GroupRoleKey=@theRoleKey AND gmd.IsActive = 1
     ORDER BY gmd.EffectiveDate
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GroupActiveMembershipCount]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GroupActiveMembershipCount]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_GroupActiveMembershipCount]
	@groupkey uniqueidentifier
	AS
BEGIN
	SELECT COUNT(1) AS MemberCount 
	FROM GroupMember 
	WHERE GroupKey=@groupkey AND IsActive=1
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GroupCopyDetailMembership]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GroupCopyDetailMembership]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_GroupCopyDetailMembership] (@srcGroupKey uniqueidentifier, @destGroupKey uniqueidentifier, @userKey uniqueidentifier, @now datetime) 
AS
BEGIN

-- Create temporary table to hold the results of a join of GroupMember and GroupMemberDetail
CREATE TABLE #tmpTable (GroupMemberKey uniqueidentifier, GroupKey uniqueidentifier, MemberContactKey uniqueidentifier, MemberIsActive bit, CreatedByUserKey uniqueidentifier, CreatedOn datetime, 
				UpdatedByUserKey uniqueidentifier, UpdatedOn datetime, DropDate datetime, JoinDate datetime,
				GroupRoleKey uniqueidentifier, EffectiveDate datetime, ExpirationDate datetime, TypeSpecificData nvarchar(250), TypeSpecificKey uniqueidentifier, TypeSpecificFlag bit, TypeSpecificInt int, 
				DetailGroupMemberStatusCode nvarchar(4), DetailIsActive bit, GroupMemberDetailKey uniqueidentifier)

-- Fill the temporary table with the results of the join, creating new ids for the GroupMemberKey and GroupMemberDetailKey, and setting other columns to specified values
INSERT INTO #tmpTable (GroupMemberKey, GroupKey, MemberContactKey, MemberIsActive, CreatedByUserKey, CreatedOn, UpdatedByUserKey,UpdatedOn, 
				DropDate, JoinDate,
				GroupRoleKey, EffectiveDate, ExpirationDate, TypeSpecificData, TypeSpecificKey, TypeSpecificFlag, TypeSpecificInt, 
				DetailGroupMemberStatusCode, DetailIsActive, GroupMemberDetailKey)
	SELECT newid(), @destGroupKey, gm.MemberContactKey, gm.IsActive, @userKey, @now, @userKey, @now, gm.DropDate, gm.JoinDate,
			gmd.GroupRoleKey, gmd.EffectiveDate, gmd.ExpirationDate, gmd.TypeSpecificData, gmd.TypeSpecificKey, gmd.TypeSpecificFlag, gmd.TypeSpecificInt, 
			gmd.GroupMemberStatusCode, gmd.IsActive, newid()
	FROM GroupMember gm INNER JOIN GroupMemberDetail gmd ON gm.GroupMemberKey = gmd.GroupMemberKey
	WHERE gm.GroupKey = @srcGroupKey

-- Fill the GroupMember table from the temporary table, selecting distinct GroupMemberKey rows
INSERT INTO GroupMember (GroupMemberKey, GroupKey, MemberContactKey, IsActive, CreatedByUserKey, CreatedOn, UpdatedByUserKey, UpdatedOn, DropDate, JoinDate)
	SELECT DISTINCT GroupMemberKey, GroupKey, MemberContactKey, MemberIsActive, CreatedByUserKey, CreatedOn, UpdatedByUserKey, UpdatedOn, DropDate, JoinDate
		FROM #tmpTable

-- Fill the GroupMemberDetail table from the temporary table, using all the rows
INSERT INTO GroupMemberDetail (GroupMemberKey, GroupRoleKey, EffectiveDate, ExpirationDate, TypeSpecificData, TypeSpecificKey, TypeSpecificFlag, CreatedOn, CreatedByUserKey, UpdatedOn, UpdatedByUserKey,
					TypeSpecificInt, GroupMemberStatusCode, IsActive, GroupMemberDetailKey, GroupKey)
	SELECT GroupMemberKey, GroupRoleKey, EffectiveDate, ExpirationDate, TypeSpecificData, TypeSpecificKey, TypeSpecificFlag, CreatedOn, CreatedByUserKey, UpdatedOn, UpdatedByUserKey,
			TypeSpecificInt, DetailGroupMemberStatusCode, DetailIsActive, GroupMemberDetailKey, GroupKey
		FROM #tmpTable

DROP TABLE #tmpTable

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GroupCopySimpleMembership]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GroupCopySimpleMembership]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_GroupCopySimpleMembership] (@srcGroupKey uniqueidentifier, @destGroupKey uniqueidentifier, @userKey uniqueidentifier, @now datetime) 
AS
BEGIN

INSERT INTO GroupMember (GroupMemberKey, GroupKey, MemberContactKey, IsActive, CreatedByUserKey, CreatedOn, UpdatedByUserKey, UpdatedOn, DropDate, JoinDate)
	SELECT newid(), @destGroupKey, MemberContactKey, IsActive, @userKey, @now, @userKey, @now, DropDate, JoinDate 
		FROM GroupMember
		WHERE GroupMember.GroupKey=@srcGroupKey
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GroupMainDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GroupMainDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create proc [dbo].[asi_GroupMainDelete]
       @groupKey uniqueidentifier As
begin
	if not exists(select 1 from GroupMember where GroupKey = @groupKey) and
	   not exists(select 1 from AccessItem where GroupKey = @groupKey)
	begin
		begin transaction
		delete GroupMemberDetail where GroupKey = @groupKey
		delete GroupMember where GroupKey = @groupKey
		delete AccessItem where GroupKey = @groupKey
		delete GroupMain where GroupKey = @groupKey 
		commit transaction
	end
	else
	begin
		RAISERROR('Cannot delete group while child items exist.', 16, 1)
	end
end

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GroupMemberKeyByGroupRole]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GroupMemberKeyByGroupRole]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_GroupMemberKeyByGroupRole] (@groupKey uniqueidentifier, @roleKey uniqueidentifier) 
AS
BEGIN

SELECT gm.GroupMemberKey, gm.MemberContactKey
FROM GroupMember gm INNER JOIN GroupMemberDetail gmd ON gm.GroupMemberKey = gmd.GroupMemberKey
WHERE gm.GroupKey=@groupKey AND gmd.GroupRoleKey=@roleKey
ORDER BY gmd.EffectiveDate DESC

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GroupMembership]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GroupMembership]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_GroupMembership] (@contactKey uniqueidentifier) 
AS
BEGIN

SELECT DISTINCT GroupMain.GroupKey
FROM	GroupMember INNER JOIN
	GroupMain ON GroupMember.GroupKey = GroupMain.GroupKey 
WHERE     (GroupMember.MemberContactKey = @contactKey)
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GroupMembershipByGroup]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GroupMembershipByGroup]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_GroupMembershipByGroup    Script Date: 7/3/2003 4:58:03 PM ******/

CREATE PROCEDURE [dbo].[asi_GroupMembershipByGroup]
	@causeGroupKey uniqueidentifier,
	@effectGroupKey uniqueidentifier AS

BEGIN
	PRINT 'This SP is obsolete'
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GroupMembershipByMember]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GroupMembershipByMember]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_GroupMembershipByMember    Script Date: 7/3/2003 4:58:04 PM ******/

CREATE   PROCEDURE [dbo].[asi_GroupMembershipByMember]
	@effectGroupKey uniqueidentifier,
	@userKey uniqueidentifier AS

BEGIN
	PRINT 'This SP is obsolete'
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GroupMembershipByType]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GroupMembershipByType]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_GroupMembershipByType] (@contactKey uniqueidentifier, @groupTypeKey uniqueidentifier) 
AS
BEGIN

SELECT DISTINCT GroupMain.GroupKey, GroupMain.Name
FROM	GroupMember INNER JOIN
	GroupMain ON GroupMember.GroupKey = GroupMain.GroupKey 
WHERE     (GroupMember.MemberContactKey = @contactKey) AND
	     (GroupMain.GroupTypeKey = @groupTypeKey)
ORDER BY GroupMain.Name
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GroupMembershipCount]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GroupMembershipCount]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_GroupMembershipCount]
	@groupkey uniqueidentifier
	AS
BEGIN
	SELECT COUNT(1) AS MemberCount 
	FROM GroupMember 
	WHERE GroupKey=@groupkey
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GroupRoleCountByType]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GroupRoleCountByType]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_GroupRoleCountByType]
	@groupTypeKey uniqueidentifier,
	@groupRoleKey uniqueidentifier
	AS
BEGIN
	SELECT COUNT(1) AS RoleCount 
	FROM GroupMain INNER JOIN  GroupMemberDetail ON GroupMain.GroupKey = GroupMemberDetail.GroupKey
	WHERE GroupMain.GroupTypeKey = @groupTypeKey AND GroupRoleKey=@groupRoleKey AND GroupMemberDetail.IsActive = 1
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GroupRoleInstanceCountByType]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GroupRoleInstanceCountByType]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_GroupRoleInstanceCountByType]
	@groupTypeKey uniqueidentifier,
	@groupRoleKey uniqueidentifier
	AS
BEGIN
	SELECT COUNT(1) AS RoleCount 
	FROM GroupMain INNER JOIN GroupInstanceRole on GroupMain.GroupKey = GroupInstanceRole.GroupKey
	WHERE GroupMain.GroupTypeKey = @groupTypeKey AND GroupInstanceRole.GroupRoleKey=@groupRoleKey
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GroupTypeMembershipByContact]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GroupTypeMembershipByContact]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_GroupTypeMembershipByContact] (@contactKey uniqueidentifier) 
AS
BEGIN

SELECT DISTINCT GroupMain.GroupTypeKey, GroupTypeRef.GroupTypeName
FROM	GroupMember INNER JOIN
	GroupMain ON GroupMember.GroupKey = GroupMain.GroupKey INNER JOIN
	GroupTypeRef ON GroupMain.GroupTypeKey = GroupTypeRef.GroupTypeKey
WHERE     (GroupMember.MemberContactKey = @contactKey)
ORDER BY GroupTypeRef.GroupTypeName

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_HierarchyResortChildren]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_HierarchyResortChildren]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_HierarchyResortChildren] 
    @parentHierarchyKey uniqueidentifier,
    @parentDepth int = -1 
AS
BEGIN
	SET NOCOUNT ON
	IF (@parentDepth < 0)
	   SELECT @parentDepth = Depth FROM [dbo].[Hierarchy] WHERE [HierarchyKey] = @parentHierarchyKey

	INSERT INTO #Reorder (HierarchyKey, NewDepth) VALUES (@parentHierarchyKey, @parentDepth)

	DECLARE @ChildrenTable TABLE
	(
		[HierarchyKey] uniqueidentifier,
		[SortOrder] int,
		[Depth] int
	)

	INSERT INTO @ChildrenTable
	    SELECT HierarchyKey, SortOrder, @parentDepth + 1 
	      FROM Hierarchy 
	     WHERE ParentHierarchyKey = @parentHierarchyKey

	DECLARE @childHierarchyKey uniqueidentifier
    DECLARE @childDepth int
	
	WHILE EXISTS (SELECT 1 FROM @ChildrenTable)
	BEGIN
		SELECT TOP 1 @childHierarchyKey = HierarchyKey, @childDepth = Depth FROM @ChildrenTable ORDER BY SortOrder
		EXEC asi_HierarchyResortChildren @childHierarchyKey, @childDepth
		DELETE FROM @ChildrenTable WHERE HierarchyKey = @childHierarchyKey
	END

	SET NOCOUNT OFF
END


GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_HierarchyAlphaResortChildren]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_HierarchyAlphaResortChildren]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- Recursively sorts hierarchy into alpha order.
-- Called by asi_HierarchyAlphaResort.
CREATE PROCEDURE [dbo].[asi_HierarchyAlphaResortChildren] 
    @parentHierarchyKey uniqueidentifier, 
    @parentDepth int = -1 
AS
BEGIN
	SET NOCOUNT ON
	
	IF (@parentDepth < 0)
	   SELECT @parentDepth = Depth FROM [dbo].[Hierarchy] WHERE [HierarchyKey] = @parentHierarchyKey


	INSERT INTO #Reorder (HierarchyKey, NewDepth) VALUES (@parentHierarchyKey, @parentDepth)

	DECLARE @ChildrenTable TABLE
	(
		[HierarchyKey] uniqueidentifier,
        [DocumentName] nvarchar(100),
        [DocumentTypeCode] nvarchar(3),
        [Depth] int
	)

	INSERT INTO @ChildrenTable
	    SELECT h.[HierarchyKey], d.[DocumentName], d.[DocumentTypeCode], @parentDepth + 1
          FROM [dbo].[Hierarchy] h 
               INNER JOIN [dbo].[DocumentMain] d ON h.UniformKey = d.DocumentVersionKey 
         WHERE h.[ParentHierarchyKey] = @parentHierarchyKey

	DECLARE @childHierarchyKey uniqueidentifier
    DECLARE @childDocumentType nvarchar(3)
    DECLARE @childDepth int
	
	WHILE EXISTS (SELECT 1 FROM @ChildrenTable)
	BEGIN
		SELECT TOP 1 @childHierarchyKey = [HierarchyKey], @childDocumentType = [DocumentTypeCode], @childDepth = [Depth]
          FROM @ChildrenTable ORDER BY [DocumentName]
        IF (@childDocumentType != 'NAV')
		    EXEC asi_HierarchyAlphaResortChildren @childHierarchyKey, @childDepth
        ELSE
            EXEC asi_HierarchyResortChildren @childHierarchyKey, @childDepth
		DELETE FROM @ChildrenTable WHERE [HierarchyKey] = @childHierarchyKey
	END

	SET NOCOUNT OFF
END


GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_HierarchyAlphaResort]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_HierarchyAlphaResort]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- Resets the SortOrder column on all records within a given Root Hierarchy so that
-- documents refered to are in alphanumeric order
CREATE PROCEDURE [dbo].[asi_HierarchyAlphaResort] 
    @rootHierarchyKey uniqueidentifier 
AS
BEGIN
   SET NOCOUNT ON

   CREATE TABLE #Reorder (
      NewSortOrder int IDENTITY (0, 1024),
      HierarchyKey uniqueidentifier,
      NewDepth int)

   DECLARE @rootDepth int
   SELECT @rootDepth = Depth FROM [dbo].[Hierarchy] WHERE [HierarchyKey] = @rootHierarchyKey
   EXEC asi_HierarchyAlphaResortChildren @rootHierarchyKey, @rootDepth

   UPDATE h
      SET h.SortOrder = r.NewSortOrder,
          h.Depth = r.NewDepth
     FROM [dbo].[Hierarchy] h 
          INNER JOIN #Reorder r ON h.HierarchyKey = r.HierarchyKey

   DROP TABLE #Reorder

   SET NOCOUNT OFF
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_HierarchyDeleteBranch]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_HierarchyDeleteBranch]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- Deletes the hierarchy branched rooted at the hierarchyKey sent in.  This includes all descendants
CREATE PROCEDURE [dbo].[asi_HierarchyDeleteBranch] @hierarchyKey uniqueidentifier AS
DECLARE
	@LowSort int, @HighSort int, @RootHierarchyKey uniqueidentifier
BEGIN
	-- first, find the high (if it is there) as the lowest sort order that is higher than the one sent in
	-- and with a depth equal or shallower
	SELECT @RootHierarchyKey = a.RootHierarchyKey, @LowSort = a.SortOrder, @HighSort = Min(b.SortOrder)
	  FROM Hierarchy a LEFT OUTER JOIN Hierarchy b
	    ON a.RootHierarchyKey = b.RootHierarchyKey
	   AND a.SortOrder < b.SortOrder
	   AND a.Depth >= b.Depth
	 WHERE a.HierarchyKey = @hierarchyKey
	 GROUP BY a.RootHierarchyKey, a.SortOrder
	
	-- if we found the high sort, delete everything in between
	IF @HighSort IS NOT NULL
	BEGIN
		DELETE 
		  FROM Hierarchy 
		 WHERE RootHierarchyKey = @RootHierarchyKey
		   AND SortOrder >= @LowSort 
		   AND SortOrder < @HighSort
	END
	-- if we didn't, delete everything beyond this one
	ELSE
	BEGIN
		DELETE 
		  FROM Hierarchy 
		 WHERE RootHierarchyKey = @RootHierarchyKey
		   AND SortOrder >= @LowSort 
	END
	
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_HierarchyDemoteBranch]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_HierarchyDemoteBranch]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- Demotes the hierarchy branch rooted at the hierarchyKey sent in to be the last child of
-- its older sibling. Since it is already in the right place as far as sort order goes, this
-- just means incrementing the depth on all descendants and changing the parent of the one sent
CREATE PROCEDURE [dbo].[asi_HierarchyDemoteBranch] @hierarchyKey uniqueidentifier AS
DECLARE
	@NewParentSort int, @Depth int, @LowSort int, @HighSort int, @RootHierarchyKey uniqueidentifier
BEGIN
	-- find the prior sibling that will become the parent
	SELECT @RootHierarchyKey = a.RootHierarchyKey, @Depth=a.Depth, @LowSort = a.SortOrder, @NewParentSort = ISNULL(Max(b.SortOrder),0)
	  FROM Hierarchy a LEFT OUTER JOIN Hierarchy b
            ON a.RootHierarchyKey = b.RootHierarchyKey
           AND a.SortOrder > b.SortOrder
	   AND a.Depth = b.Depth
	   AND a.ParentHierarchyKey = b.ParentHierarchyKey
	 WHERE a.HierarchyKey = @hierarchyKey
	 GROUP BY a.RootHierarchyKey, a.Depth, a.SortOrder

	-- if we didn't get one (shouldn't happen) throw an exception
	if @NewParentSort IS NULL
		RAISERROR ('Cannot Demote. No older sibling available',16,1)
	
	-- find the high sortorder to move (if it is there) as the lowest sort order that is higher than the one sent in
	-- and with a depth equal or shallower
	SELECT @HighSort = Min(SortOrder)
	  FROM Hierarchy
	 WHERE RootHierarchyKey = RootHierarchyKey
	   AND SortOrder > @LowSort
	   AND Depth <= @Depth
	
	-- if we found the high sort, update everything in between
	IF @HighSort IS NOT NULL
	BEGIN
		UPDATE Hierarchy 
		   SET Depth = Depth + 1
		 WHERE RootHierarchyKey = @RootHierarchyKey
		   AND SortOrder >= @LowSort 
		   AND SortOrder < @HighSort
	END
	-- if we didn't, update everything beyond this one
	ELSE
	BEGIN
		UPDATE Hierarchy 
		   SET Depth = Depth + 1
		 WHERE RootHierarchyKey = @RootHierarchyKey
		   AND SortOrder >= @LowSort 
	END

	-- move to the new parent
	UPDATE Hierarchy
	   SET ParentHierarchyKey = (
		SELECT HierarchyKey
		  FROM Hierarchy
		 WHERE RootHierarchyKey = @RootHierarchyKey
		   AND SortOrder = @NewParentSort)
	 WHERE HierarchyKey = @hierarchyKey
	
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_HierarchyGetAdjacentSortOut]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_HierarchyGetAdjacentSortOut]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- Given the HierarchyKey of the Hierarchy element near which the new (or moved) one needs to go, and where, in relation
-- to this near one it needs to be, this procedure returns a SortOrder that will place the new (or moved) record
-- in the right place.  If there is no space to put it there (i.e., there is no integer between the record just prior
-- and the record just after) the entire hierarchy, from the root, will be resorted so all SortOrders are divisible by 1024
-- Values for addType parameter:
--    0 - Before the adjacent Hierarchy record, as a sibling
--    1 - After the adjacent Hierarchy record, as a sibling
--    2 - As the first child of the adjacent Hierarchy record
--    3 - As the last child of the adjacent Hierarchy record
--    4 - With the same sort order as that of the adjacent Hierarchy record (for use when sorting after the fact, e.g., alpha)
-- TO DO: implement locking later so sort order can't come up twice with highly concurrent work
-- TO DO: Resort has deadlocking issues - fix!
CREATE PROCEDURE [dbo].[asi_HierarchyGetAdjacentSortOut] @adjacentHierarchyKey uniqueidentifier, @addType smallint = 3, @NewSort int OUTPUT AS
DECLARE
      @LowSort int, @HighSort int, @SortOrder int, @RootHierarchyKey uniqueidentifier, @Run bit
BEGIN
      SET @Run = 1
      WHILE @Run = 1
      BEGIN
            -- BeforeAsSibling - SortOrder is between that of the adjacentHierarchyKey and the max SortOrder lower than that (or 0 if none)
            IF @addType = 0
            BEGIN
                  SELECT @RootHierarchyKey = a.RootHierarchyKey, @HighSort = a.SortOrder, @LowSort = ISNULL(Max(b.SortOrder),0)
                   FROM Hierarchy a LEFT OUTER JOIN Hierarchy b
                          ON a.RootHierarchyKey = b.RootHierarchyKey
                         AND a.SortOrder > b.SortOrder
                  WHERE a.HierarchyKey = @adjacentHierarchyKey
                  GROUP BY a.SortOrder, a.RootHierarchyKey
            END
      
            -- AfterAsSibling or AsLastChild - The SortOrder for both is the same but parent and depth will be different.
            -- SortOrder is between the min SortOrder on an element with a higher SortOrder and an equal or higher depth 
            -- (lower depth number) than that of the adjacentHierarchyKey and the max sort order lower than that.
            ELSE IF @addType = 1 OR @addType = 3
            BEGIN
                  -- first, find the high (if it is there) as the lowest sort order that is higher than the adjacent one
                  -- and with a depth equal or shallower than the adjacent one
                  SELECT @RootHierarchyKey = a.RootHierarchyKey, @HighSort = Min(b.SortOrder)
                   FROM Hierarchy a LEFT OUTER JOIN Hierarchy b
                          ON a.RootHierarchyKey = b.RootHierarchyKey
                         AND a.SortOrder < b.SortOrder
                     AND a.Depth >= b.Depth
                  WHERE a.HierarchyKey = @adjacentHierarchyKey
                  GROUP BY a.RootHierarchyKey
      
                  -- if we found the high sort, then the low is the one just lower
                  IF @HighSort IS NOT NULL
                  BEGIN
                        SELECT @LowSort = Max(a.SortOrder)
                         FROM Hierarchy a
                        WHERE a.RootHierarchyKey = @RootHierarchyKey
                           AND a.SortOrder < @HighSort 
                  END
                  -- if we didn't find one, the Low is the last sort order for the root and the max is that + 1024
                  ELSE
                  BEGIN
                        SELECT @LowSort = Max(a.SortOrder)
                         FROM Hierarchy a
                        WHERE a.RootHierarchyKey = @RootHierarchyKey
      
                        SET @HighSort = @LowSort + 1024
                  END
      
            END
      
            -- AsFirstChild  - SortOrder is between that of the adjacentHierarchyKey and the min SortOrder higher than that
            ELSE IF @addType = 2
            BEGIN
                  SELECT @RootHierarchyKey = a.RootHierarchyKey, @LowSort = a.SortOrder, @HighSort = ISNULL(Min(b.SortOrder), a.SortOrder + 1024)
                   FROM Hierarchy a LEFT OUTER JOIN Hierarchy b
                          ON a.RootHierarchyKey = b.RootHierarchyKey
                     AND a.SortOrder < b.SortOrder
                  WHERE a.HierarchyKey = @adjacentHierarchyKey
                  GROUP BY a.SortOrder, a.RootHierarchyKey
            END
            -- Same  - SortOrder is the same as the adjecent one (presumably the parent or a sibling)
            ELSE IF @addType = 4
            BEGIN
                  SELECT @RootHierarchyKey = a.RootHierarchyKey, @LowSort = a.SortOrder, @HighSort = a.SortOrder
                   FROM Hierarchy a
                  WHERE a.HierarchyKey = @adjacentHierarchyKey
            END
      
            -- if there is no room between the low and the high, need to redo the sort order for this root
            IF @HighSort - @LowSort < 2  AND @addType != 4
                  EXEC asi_HierarchyResort2 @RootHierarchyKey
            ELSE
                  SET @Run = 0
      END

      SET @NewSort = ISNULL(((@HighSort - @LowSort) / 2) + @LowSort, 0)
END


GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_HierarchyGetAdjacentSort]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_HierarchyGetAdjacentSort]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- Calls asi_HierarchyGetAdjacentSortOut using an OUTPUT Variable but returning the answer in a result set
CREATE PROCEDURE [dbo].[asi_HierarchyGetAdjacentSort] @adjacentHierarchyKey uniqueidentifier, @addType smallint = 3 AS
DECLARE @NewSort int
BEGIN
  EXEC asi_HierarchyGetAdjacentSortOut @adjacentHierarchyKey, @addType, @NewSort OUTPUT

  SELECT @NewSort AS NewSort
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_HierarchyMoveBranch]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_HierarchyMoveBranch]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- Moves the hierarchy branch rooted at the moveHierarchyKey sent in to be the next youngest sibling
-- of the targetHierarchyKey. The item can be moved as the oldest child of the targetHierarchyKey by
-- passing moveAsChild. All descendents are also moved.  Moving means changeing sort order on
-- all to be moved, changing the parent of the one sent in moveHierarchyKey, and possibly changing the depth
-- on all to be moved.
CREATE PROCEDURE [dbo].[asi_HierarchyMoveBranch] @moveHierarchyKey uniqueidentifier, @targetHierarchyKey uniqueidentifier, @addType smallint = 1 AS
DECLARE
	@MoveRootHierarchyKey uniqueidentifier, @MoveDepth int, @MoveLowSort int, @MoveHighSort int, 
	@TargetDepth int, @TargetLowSort int, @TargetHighSort int, @TargetRootHierarchyKey uniqueidentifier,
	@TargetParentHierarchyKey uniqueidentifier, @Adjustment int, @MoveAdjustment int, @DepthAdjustment int
BEGIN
	-- 1. Figure out the low and high sort order containing the branch to be moved
	SELECT @MoveRootHierarchyKey = a.RootHierarchyKey, @MoveDepth = a.Depth, @MoveLowSort = a.SortOrder, @MoveHighSort = Min(b.SortOrder) - 1
	  FROM Hierarchy a LEFT OUTER JOIN Hierarchy b
            ON a.RootHierarchyKey = b.RootHierarchyKey
           AND a.SortOrder < b.SortOrder
	   AND a.Depth >= b.Depth
	 WHERE a.HierarchyKey = @moveHierarchyKey
	 GROUP BY a.RootHierarchyKey, a.Depth, a.SortOrder

	IF @MoveHighSort IS NULL
		SELECT @MoveHighSort = Max(a.SortOrder)
 		  FROM Hierarchy a
		 WHERE a.RootHierarchyKey = @MoveRootHierarchyKey

	-- 2. Get the SortOrder, Depth and parent of the target and
	-- figure out the low and high sort order of the target area

	-- get the sort order of where the moved item itself should go
	EXEC asi_HierarchyGetAdjacentSortOut @targetHierarchyKey, @addType, @TargetLowSort OUTPUT

	-- then find the relavent keys and the top sort order in the target area
	SELECT @TargetRootHierarchyKey = a.RootHierarchyKey, @TargetDepth = a.Depth, 
	       @TargetParentHierarchyKey = a.ParentHierarchyKey, @TargetHighSort = Min(b.SortOrder)
	  FROM Hierarchy a LEFT OUTER JOIN Hierarchy b
            ON a.RootHierarchyKey = b.RootHierarchyKey
           AND b.SortOrder > @TargetLowSort
	 WHERE a.HierarchyKey = @targetHierarchyKey
	 GROUP BY a.RootHierarchyKey, a.Depth, a.ParentHierarchyKey
     
     --If we are moving the item as a child of the target, set depth and parent key.
     If @addType = 2 OR @addType = 3
     BEGIN
		SET @TargetParentHierarchyKey = @targetHierarchyKey
        SET @TargetDepth = @TargetDepth + 1
     END

	-- 3. Expand the target area by moving all higher ones back (unless we're moving to the end)
	SET @Adjustment = 0
	IF @TargetHighSort IS NOT NULL AND (@MoveLowSort <> @TargetLowSort OR @MoveRootHierarchyKey <> @TargetRootHierarchyKey)
	BEGIN
		SET @Adjustment = @MoveHighSort - @MoveLowSort + 1024
		UPDATE Hierarchy
		   SET SortOrder = SortOrder + @Adjustment
		 WHERE SortOrder >= @TargetHighSort
 		   AND RootHierarchyKey = @TargetRootHierarchyKey
	END

	-- 4. update the SortOrder of the items to be moved so they move into the target area.  Update depth as well
	IF @MoveLowSort <= @TargetLowSort
		SET @Adjustment = 0

	SET @MoveAdjustment = (@TargetLowSort + 1024) - (@MoveLowSort + @Adjustment)
	IF @MoveLowSort = @TargetLowSort
		SET @MoveAdjustment = 0

	SET @DepthAdjustment = @TargetDepth - @MoveDepth

	UPDATE Hierarchy
	   SET SortOrder = SortOrder + @MoveAdjustment,
	       RootHierarchyKey = @TargetRootHierarchyKey,
	       Depth = Depth + @DepthAdjustment
	 WHERE RootHierarchyKey = @MoveRootHierarchyKey
	   AND SortOrder >= @MoveLowSort + @Adjustment
	   AND SortOrder <= @MoveHighSort + @Adjustment

	-- 5. update the moved item to reflect its new parent
	UPDATE Hierarchy
	   SET ParentHierarchyKey = @TargetParentHierarchyKey
	 WHERE HierarchyKey = @moveHierarchyKey
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_HierarchyResort]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_HierarchyResort]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


-- Resets the SortOrder column on all records within a given Root Hierarchy so that each is a multiple
-- of 1024.  This allows for 12 worst case inserts before a resort is needed.
CREATE PROCEDURE [dbo].[asi_HierarchyResort] 
    @rootHierarchyKey uniqueidentifier 
AS
BEGIN
   SET NOCOUNT ON

   CREATE TABLE #Reorder (
      NewSortOrder int IDENTITY (0, 1024),
      HierarchyKey uniqueidentifier,
      NewDepth int)

   DECLARE @rootDepth int
   SELECT @rootDepth = Depth FROM [dbo].[Hierarchy] WHERE [HierarchyKey] = @rootHierarchyKey

   EXEC asi_HierarchyResortChildren @rootHierarchyKey, @rootDepth

   UPDATE Hierarchy
      SET SortOrder = NewSortOrder,
          Depth = NewDepth
     FROM Hierarchy 
          INNER JOIN #Reorder ON Hierarchy.HierarchyKey = #Reorder.HierarchyKey

   SET NOCOUNT OFF
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_InsertChangeLog]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_InsertChangeLog]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_InsertChangeLog]

@logKey uniqueidentifier, 
@orgKey uniqueidentifier,
@objectTypeName nvarchar(100),
@objectKey uniqueidentifier,
@actionType tinyint, 
@desc nvarchar(250),
@createdOn datetime,
@createdByUserKey uniqueidentifier

AS

INSERT 
	ChangeLog (ChangeLogKey, OrganizationKey, ObjectTypeName, ObjectKey, ActionType, Description, CreatedOn, CreatedByUserKey)
	VALUES
	(@logKey, @orgKey, @objectTypeName, @objectKey, @actionType, @desc, @createdOn, @createdByUserKey)

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_InsertChangeProperty]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_InsertChangeProperty]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_InsertChangeProperty]

@logKey uniqueidentifier,
@propertyName nvarchar(100),
@originalValue nvarchar(250),
@originalDesc nvarchar(250),
@currentValue nvarchar(250),
@currentDesc nvarchar(250)

AS

INSERT 
	ChangeProperty (ChangeLogKey, PropertyName, OriginalValue, OriginalDescription, CurrentValue, CurrentDescription)
	VALUES
	(@logKey, @propertyName, @originalValue, @originalDesc, @currentValue, @currentDesc)

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_InsertDonation_Premium]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_InsertDonation_Premium]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_InsertDonation_Premium]
    @originalTransactionNumber int,
    @donorId varchar(10),
    @productCode varchar(31),
    @quantity int,
    @orderNumber float
AS
    INSERT INTO [dbo].[Donation_Premium] ([ORIG_TRANS_NUMBER], [DONOR_ID], [PRODUCT_CODE], [QUANTITY], [ORDER_NUMBER])
    VALUES (@originalTransactionNumber, @donorId , @productCode,@quantity, @orderNumber)

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_InsertSystemConfig]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_InsertSystemConfig]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

------------------------------------------------------------------------------------------------------------
-- Creates the necessary entries in PropertyDefinition, SystemConfigParameterRef, (optionally) SystemConfig
-- and SystemConfigPageParameterRef in the correct in order to create working, UI editable
-- configuration parameters
------------------------------------------------------------------------------------------------------------
CREATE PROCEDURE [dbo].[asi_InsertSystemConfig]
    @systemKeyword         nvarchar(25),
    @systemConfigPageName  nvarchar(30),
    @userId                nvarchar(60),
    @systemConfigKey       uniqueidentifier,
    @parameterName         nvarchar(255),
    @propertyDefinitionKey uniqueidentifier,
    @dataTypeCode          int,
    @hiControlTypeCode     int,
    @hiControlWidth        int,
    @description           nvarchar(500),
    @defaultParameterValue nvarchar(2500),
    @sortOrder             int = -1,
    @createSystemConfigRow bit = 1    -- Specify 0 in call to utilize existing SystemConfig row
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @systemEntityKey uniqueidentifier;
    DECLARE @systemConfigPageKey uniqueidentifier;
    DECLARE @systemUserKey uniqueidentifier;
    DECLARE @organizationKey uniqueidentifier;
    DECLARE @now datetime;
    
    SELECT @now = dbo.asi_GetAppDatetime();

    -- gets the system entity key for the system (module)
    SELECT @systemEntityKey = [SystemEntityKey]
      FROM [dbo].[SystemEntity]
     WHERE [SystemKeyword] = @systemKeyword;

    -- Get existing page key
    SELECT @systemConfigPageKey = [SystemConfigPageKey]
      FROM [dbo].[SystemConfigPageRef]
     WHERE [SystemConfigPageName] = @systemConfigPageName;

    -- Get a user key to use for the System Config variable
    SELECT @systemUserKey = [UserKey]
      FROM [dbo].[UserMain]
     WHERE [UserId] = @userId;
     
    -- Provide fall-back values if UserId is not found (rather than failing on insert with cannot insert NULL)
    IF @systemUserKey IS NULL
    BEGIN
        SELECT @systemUserKey = [UserKey]
          FROM [dbo].[UserMain]
         WHERE [UserId] = 'SYSTEM'
    END;
    IF @systemUserKey IS NULL
    BEGIN
        SELECT @systemUserKey = [UserKey]
          FROM [dbo].[UserMain]
         WHERE [UserId] = 'ADMINISTRATOR'
    END;
    IF @systemUserKey IS NULL
    BEGIN
        SELECT @systemUserKey = [UserKey]
          FROM [dbo].[UserMain]
         WHERE [UserId] = 'MANAGER'
    END;

    -- Get the default organization for the system config variable
    SELECT @organizationKey = [OrganizationKey]
      FROM [dbo].[OrganizationMain]
     WHERE [IsDefault] = 1;

    -- create the property definition for the new parameter
    IF NOT EXISTS (SELECT 1
                     FROM [dbo].[PropertyDefinition]
                    WHERE [PropertyDefinitionKey] = @propertyDefinitionKey)
    BEGIN
        INSERT INTO [dbo].[PropertyDefinition] ([PropertyDefinitionKey],
                                                [Label],
                                                [DataTypeCode],
                                                [HIControlTypeCode],
                                                [HIControlWidth]
                                               )
        VALUES (@propertyDefinitionKey,
                @parameterName,
                @dataTypeCode,
                @hiControlTypeCode,
                @hiControlWidth
               );
    END;

    -- create the definition for the new parameter
    IF NOT EXISTS (SELECT 1
                     FROM [dbo].[SystemConfigParameterRef]
                    WHERE [ParameterName] = @parameterName)
    BEGIN
        INSERT INTO [dbo].[SystemConfigParameterRef] ([ParameterName],
                                                      [SystemKeyword],
                                                      [PropertyDefinitionKey],
                                                      [Description],
                                                      [DefaultParameterValue]
                                                     )
        VALUES (@parameterName,
                @systemKeyword,
                @propertyDefinitionKey,
                @description,
                @defaultParameterValue
               );
    END;

    -- Create the SystemConfig variable itself
    IF @createSystemConfigRow = 1 AND NOT EXISTS (
                                                  SELECT 1
                                                    FROM [dbo].[SystemConfig]
                                                   WHERE [SystemConfigKey] = @systemConfigKey
    )
    BEGIN
        INSERT INTO [dbo].[SystemConfig] ([SystemConfigKey],
                                          [ParameterName],
                                          [ParameterValue],
                                          [Description],
                                          [CreatedByUserKey],
                                          [CreatedOn],
                                          [UpdatedByUserKey],
                                          [UpdatedOn],
                                          [OrganizationKey],
                                          [SystemEntityKey]
                                         )
        VALUES (@systemConfigKey,
                @parameterName,
                @defaultParameterValue,
                @description,
                @systemUserKey,
                @now,
                @systemUserKey,
                @now,
                @organizationKey,
                @systemEntityKey
               );
    END;

    -- connect the parameter to the page
    IF NOT EXISTS (
                   SELECT 1
                     FROM [dbo].[SystemConfigPageParameterRef]
                    WHERE [SystemConfigPageKey] = @systemConfigPageKey AND [ParameterName] = @parameterName
    )
    BEGIN

        -- Validate the supplied sort order
        SET @sortOrder = ISNULL(@sortOrder, -1);
        IF @sortOrder != -1
        BEGIN
            -- Check if this sort location is already in use
            IF EXISTS (
                       SELECT 1
                         FROM [dbo].[SystemConfigPageParameterRef]
                        WHERE [SystemConfigPageKey] = @systemConfigPageKey AND [SortOrder] = @sortOrder
            )
            BEGIN
                -- Sort location is already in use, so update the existing sort orders to create a space
                UPDATE [dbo].[SystemConfigPageParameterRef]
                   SET
                       [SortOrder] = ISNULL([SortOrder], 0) + 1
                 WHERE [SystemConfigPageKey] = @systemConfigPageKey AND ISNULL([SortOrder], 0) >= @sortOrder;
            END;
        END;
        ELSE
        BEGIN
            -- Place the sort order at the end
            SELECT @sortOrder = ISNULL(MAX([SortOrder]), 0) + 1
              FROM [dbo].[SystemConfigPageParameterRef]
             WHERE [SystemConfigPageKey] = @systemConfigPageKey;
        END;
        INSERT INTO [dbo].[SystemConfigPageParameterRef] ([SystemConfigPageKey],
                                                          [ParameterName],
                                                          [SortOrder]
                                                         )
        VALUES (@systemConfigPageKey,
                @parameterName,
                @sortOrder
               );
    END;
END;


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_InstitutesFromIndividual]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_InstitutesFromIndividual]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE  PROCEDURE [dbo].[asi_InstitutesFromIndividual]
	@individualkey uniqueidentifier
AS
BEGIN
select vBoInstitute.ContactKey from vBoInstitute
	where vBoInstitute.InstituteGroupKey in 
		(select	vBoGroup.GroupKey from vBoGroup inner join GroupMember 
			on vBoGroup.GroupKey = GroupMember.GroupKey 
			where GroupMember.MemberContactKey = @individualkey)
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_InstitutesFromIndividualByType]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_InstitutesFromIndividualByType]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE  PROCEDURE [dbo].[asi_InstitutesFromIndividualByType]
	@institutegrouptypekey uniqueidentifier,
	@individualkey uniqueidentifier
AS
BEGIN
select vBoInstitute.ContactKey from vBoInstitute
	where vBoInstitute.InstituteGroupKey in 
		(select	vBoGroup.GroupKey from vBoGroup inner join GroupMember 
			on vBoGroup.GroupKey = GroupMember.GroupKey 
			where GroupMember.MemberContactKey = @individualkey and
	           			vBoGroup.GroupTypeKey = @institutegrouptypekey)
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_IsVatTaxableOrder]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_IsVatTaxableOrder]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- For a given order or event, returns whether VAT should be charged
-- PARAMETERS
-- @orgCode             The financial entity (org) for the order.
--                      If passed empty the default org is assumed.
-- @billToId            Bill to contact Id.
-- @shipToId            Ship to contact Id.
-- @shipToCountry       The currently selected ship to country code. Accepts either a country name or country code.
--                      This may not necessarily be the ship to contacts ship to country. It may have been manually changed on the order.
-- @applyVat OUT        Returns a bit to indicate whether VAT should be charged for this order.
-- @vatCountryCode OUT  Returns the country code that VAT is being charged based on.
--                      Will always be empty unless @applyVat == 1
-- @taxCodeSub OUT      The substitute tax code to be used if VAT is not to be charged

-- The procedure also returns single row resultset containing the value returned by @applyVat OUT, @vatCountryCode OUT, @taxCodeSub OUT

CREATE PROCEDURE [dbo].[asi_IsVatTaxableOrder]
    @orgCode varchar(5),
    @billToID varchar(10),
    @shipToID varchar(10),
    @shipToCountry varchar(25),
    @applyVat bit = NULL OUT,
    @vatCountryCode varchar(2) = NULL OUT,
    @taxCodeSub varchar(15) = '' OUT    
AS
BEGIN

    -- declare variables    
    DECLARE @taxOnShipTo bit
    DECLARE @orgVatCountryCode varchar(2)
    DECLARE @contactIsVatExempt bit
    DECLARE @contactVatRegNumber varchar(25)
    DECLARE @contactVatCountryCode varchar(2)
    DECLARE @billToVatCountryCode varchar(2)
    DECLARE @shipToVatCountryCode varchar(2)
        
    DECLARE @vatZeroExempt as varchar(255)
    DECLARE @vatZeroOrderOtherEu as varchar(255)
    DECLARE @vatZeroOrderOutsideEu as varchar(255)

    -- retrieve substitute tax codes
    SELECT @vatZeroExempt=ShortValue FROM System_Params WHERE ParameterName='AR_Control.VatZeroExempt'
    SELECT @vatZeroOrderOtherEu=ShortValue FROM System_Params WHERE ParameterName='AR_Control.VatZeroOrderOtherEu'
    SELECT @vatZeroOrderOutsideEu=ShortValue FROM System_Params WHERE ParameterName='AR_Control.VatZeroOrderOutsideEu'
    SET @vatZeroExempt = ISNULL(@vatZeroExempt,'')
    SET @vatZeroOrderOtherEu = ISNULL(@vatZeroOrderOtherEu,'')
    SET @vatZeroOrderOutsideEu = ISNULL(@vatZeroOrderOutsideEu,'')
    
    -- default the return value to no vat
    SET @applyVat = 0
    SET @vatCountryCode = ''

    -- check we are licensed for VAT
    IF NOT EXISTS (SELECT 1 
                     FROM [dbo].[LicenseLegacyList] 
                    WHERE [LegacyLicenseCode]='VAT') 
    BEGIN
        GOTO ReturnValue
    END

    -- get the org's VAT country code
    -- as part of this we check that it is a vat org and it has a vat country defined
    -- if no org was specified, then assume the default org
    IF LEN(ISNULL(@orgCode, ''))=0
    BEGIN
        SELECT @orgCode = o.[OrgCode], @orgVatCountryCode = o.[VATCountry]
          FROM [dbo].[Org_Control] o 
         WHERE o.[DefaultFlag]=1 AND o.[UseVATTaxation]=1 AND LEN(o.[VATCountry])>0
    END
    ELSE
    BEGIN
        SELECT @orgVatCountryCode = o.[VATCountry]
          FROM [dbo].[Org_Control] o 
         WHERE o.[OrgCode]=@orgCode AND o.[UseVATTaxation]=1 AND LEN(o.[VATCountry])>0
    END
    IF @@ROWCOUNT=0
    BEGIN
        GOTO ReturnValue
    END
    
    -- now we have established the org is correctly configured for vat,
    -- assume we are going to charge vat
    SET @applyVat = 1
    SET @vatCountryCode = @orgVatCountryCode

    -- determine whether to use TaxOnShipTo option
    -- if the setting cannot be found, default to false
    SELECT @taxOnShipTo = CASE WHEN [ShortValue]='YES' THEN 1 ELSE 0 END
      FROM [dbo].[System_Params]
     WHERE [ParameterName] = 'AR_Control.TaxOnShipTo'  
    IF @@ROWCOUNT=0
    BEGIN
        SET @taxOnShipTo = 0
    END     
 
    -- process based on the taxation method
    IF @taxOnShipTo = 1
    BEGIN
        
        -- do we have a ship to id
        IF LEN(ISNULL(@shipToID, ''))=0
        BEGIN
            GOTO ReturnValue
        END
        
        -- load vat details from the ship to contact
        SELECT @contactIsVatExempt = ISNULL(nf.[USE_VAT_TAXATION],0),
               @contactVatRegNumber = ISNULL(nf.[VAT_REG_NUMBER],''),
               @contactVatCountryCode = ISNULL(nf.[VAT_COUNTRY],'')
          FROM [dbo].[Name] n 
               LEFT OUTER JOIN [dbo].[Name_Fin] nf ON n.[ID] = nf.[ID]
         WHERE n.[ID]=@shipToID
        IF @@ROWCOUNT=0
        BEGIN
            GOTO ReturnValue
        END
         
        -- if the contact is vat exempt, go no further
        IF @contactIsVatExempt=1
        BEGIN
            SET @applyVat = 0
            SET @taxCodeSub = @vatZeroExempt
            GOTO ReturnValue
        END
        
        -- establish the vat country code of the ship to country 
        -- if no country was specified, or we can't find a match, assume its the org vat country code
        SET @shipToVatCountryCode = @orgVatCountryCode
        IF LEN(ISNULL(@shipToCountry,''))>0
        BEGIN
                                                -- check the ship to country exists
                                                -- we could have been supplied either a country code or a country name    
                                                IF LEN(@shipToCountry)<=2
                                                BEGIN
                                                                SELECT @shipToVatCountryCode = c.[VAT_COUNTRY_CODE]
                                                                  FROM [dbo].[Country_Names] c
                                                                WHERE c.[COUNTRY_CODE] = @shipToCountry
                                                END
                                                ELSE
                                                BEGIN
                                                                SELECT @shipToVatCountryCode = c.[VAT_COUNTRY_CODE]
                                                                  FROM [dbo].[Country_Names] c
                                                                WHERE c.[COUNTRY] = @shipToCountry
                                                END
            -- if the above doesn't find anything, @shipToVatCountryCode remains unchanged
        END
        
        -- is the contact considered vat registered
        IF LEN(@contactVatRegNumber)>0 AND LEN(@contactVatCountryCode)>0 AND @contactVatCountryCode=@shipToVatCountryCode
        BEGIN
            -- not taxable if different EU country from org
            IF (@contactVatCountryCode != @orgVatCountryCode)
            BEGIN
                SET @applyVat = 0
                SET @taxCodeSub = @vatZeroOrderOtherEu
                GOTO ReturnValue
            END
        END
    
        -- if we have a ship to vat country code, then charge vat
        IF LEN(@shipToVatCountryCode)>0
        BEGIN
            SET @vatCountryCode = @shipToVatCountryCode
        END
        ELSE
        BEGIN
            SET @applyVat = 0
            SET @taxCodeSub = @vatZeroOrderOutsideEu
        END
         
    END
    ELSE
    BEGIN
        
        -- do we have a bill to id
        IF LEN(ISNULL(@billToID, ''))=0
        BEGIN
            GOTO ReturnValue
        END
        
        -- load vat details from the bill to contact
        SELECT @contactIsVatExempt = ISNULL(nf.[USE_VAT_TAXATION],0),
               @contactVatRegNumber = ISNULL(nf.[VAT_REG_NUMBER],''),
               @contactVatCountryCode = ISNULL(nf.[VAT_COUNTRY],'')
          FROM [dbo].[Name] n 
               LEFT OUTER JOIN [dbo].[Name_Fin] nf ON n.[ID] = nf.[ID]
         WHERE n.[ID]=@billToID
        IF @@ROWCOUNT=0
        BEGIN
            GOTO ReturnValue
        END
         
        -- if the contact is vat exempt, go no further
        IF @contactIsVatExempt=1
        BEGIN
            SET @applyVat = 0
            SET @taxCodeSub = @vatZeroExempt
            GOTO ReturnValue
        END

        -- establish the vat country code for the bill to contact
        -- if the contact has a specific vat country code defined, use that
        -- otherwise establish it from their billing address
        IF LEN(@contactVatCountryCode)>0
        BEGIN
            SET @billToVatCountryCode = @contactVatCountryCode
        END
        ELSE
        BEGIN
            -- get the vat country code from the contacts billing country
            -- if the contact has no billing country, assume the org vat country
            SELECT @billToVatCountryCode = c.[VAT_COUNTRY_CODE]
              FROM [dbo].[Name_Address] n
                   INNER JOIN [dbo].[Country_Names] c ON n.[COUNTRY] = c.[COUNTRY]
             WHERE n.[ID] = @billToID AND n.[PREFERRED_BILL]=1 AND LEN(ISNULL(n.[COUNTRY],''))>0
            IF @@ROWCOUNT=0
            BEGIN
                SET @billToVatCountryCode = @orgVatCountryCode
            END
        END
        
        -- is the contact considered vat registered
        IF LEN(@contactVatRegNumber)>0
        BEGIN
            -- not taxable if different EU country from org
            IF (@billToVatCountryCode != @orgVatCountryCode)
            BEGIN
                SET @applyVat = 0
                SET @taxCodeSub = @vatZeroOrderOtherEu
                GOTO ReturnValue
            END
        END

        -- if we have a bill to vat country code, then charge vat
        IF LEN(@billToVatCountryCode)>0
        BEGIN
            SET @vatCountryCode = @billToVatCountryCode
        END
        ELSE
        BEGIN
            SET @applyVat = 0
            SET @taxCodeSub = @vatZeroOrderOutsideEu
        END
        
    END

ReturnValue:    
 
    -- if we arent applying vat, then clear any country code
    IF @applyVat = 0
    BEGIN
        SET @vatCountryCode = ''
    END

    -- return the values as a resultset for desktop
    SELECT @applyVat AS [ApplyVat], @vatCountryCode AS [VatCountryCode], @taxCodeSub AS [TaxCodeSub]

END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_IsVatTaxableRegistration2]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_IsVatTaxableRegistration2]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_IsVatTaxableRegistration2]
    @eventCode varchar(10),
    @registrantCountry varchar(25),
    @registrantIsCompany bit,
    @registrantIsVatRegistered bit,
    @registrantVatCountry varchar(25)='',
    @applyVat bit = NULL OUT,
    @taxCodeSub varchar(15) = '' OUT   
AS
BEGIN

    -- declare variables    
    DECLARE @orgCode varchar(5)
    DECLARE @orgCountryCode varchar(2)
    DECLARE @registrantCountryCode varchar(2)
    DECLARE @ruleSet varchar(10)
    DECLARE @isEuCountry bit
    DECLARE @taxOnShipTo bit
    DECLARE @shipToVatCountryCode varchar(25)
     
    -- determine whether to use TaxOnShipTo option. defaults to false.
    SELECT @taxOnShipTo = CASE WHEN [ShortValue]='YES' THEN 1 ELSE 0 END
      FROM [dbo].[System_Params]
     WHERE [ParameterName] = 'AR_Control.TaxOnShipTo'  
 
    -- default the return value to true
    -- this effectively means, handle tax as you always did
    -- if we fail any validations we want the system to behave as it always did
    SET @applyVat = 1
    
    -- check we are licensed for VAT
    IF NOT EXISTS (SELECT 1 
                     FROM [dbo].[LicenseLegacyList] 
                    WHERE [LegacyLicenseCode]='VAT') 
    BEGIN
        GOTO ReturnValue
    END

    -- verify the event exists, and retrieve some basic details
    IF LEN(ISNULL(@eventCode, ''))=0
    BEGIN
        GOTO ReturnValue
    END
    SELECT @orgCode = [ORG_CODE], @ruleSet = [VAT_RULESET]
      FROM [dbo].[Meet_Master] 
     WHERE [MEETING] = @eventCode
    IF @@ROWCOUNT=0
    BEGIN
        GOTO ReturnValue
    END

    -- if the event has no vat ruleset assigned, we need go no further
    IF LEN(ISNULL(@ruleSet, ''))=0
    BEGIN
        GOTO ReturnValue
    END

    -- verify the event org code is configured for VAT, and that a VAT country has been specified for the org  
    -- if the event has no org code, assume the default org code
    IF LEN(ISNULL(@orgCode, ''))=0
    BEGIN
        SELECT @orgCode = o.[OrgCode], @orgCountryCode = c.[COUNTRY_CODE]
          FROM [dbo].[Org_Control] o 
               INNER JOIN [dbo].[Country_Names] c on o.[VATCountry]=c.[VAT_COUNTRY_CODE]
         WHERE o.[DefaultFlag]=1 AND o.[UseVATTaxation]=1 AND LEN(o.[VATCountry])>0
    END
    ELSE
    BEGIN
        SELECT @orgCountryCode = c.[COUNTRY_CODE]
          FROM [dbo].[Org_Control] o 
               INNER JOIN [dbo].[Country_Names] c on o.[VATCountry]=c.[VAT_COUNTRY_CODE]
         WHERE o.[OrgCode]=@orgCode AND o.[UseVATTaxation]=1 AND LEN(o.[VATCountry])>0
    END
    IF @@ROWCOUNT = 0
    BEGIN
        GOTO ReturnValue
    END
           
    -- verify the contact country exists
    -- if no country was supplied, establish the default
    SET @registrantCountryCode = NULL
    IF LEN(ISNULL(@registrantCountry, ''))=0
    BEGIN
        -- no country supplied, so assume the default
        -- use the VAT country code from the default org
        -- but only if the default org is configured for VAT
        SELECT @registrantCountryCode=c.[COUNTRY_CODE], @shipToVatCountryCode =  c.[VAT_COUNTRY_CODE] 
          FROM [dbo].[Org_Control] o 
               INNER JOIN [dbo].[Country_Names] c on o.[VATCountry]=c.[VAT_COUNTRY_CODE]
         WHERE o.[DefaultFlag]=1 AND o.[UseVATTaxation]=1 AND LEN(o.[VATCountry])>0
        -- if we still don't have a country code, assume US
        IF @@ROWCOUNT=0
        BEGIN
            SET @registrantCountryCode='US'        
            SET @shipToVatCountryCode=''
        END
    END
    ELSE
    BEGIN     
        -- check the supplied country exists    
        IF LEN(@registrantCountry)<=2
        BEGIN
            SELECT @registrantCountryCode = [COUNTRY_CODE], @shipToVatCountryCode =  [VAT_COUNTRY_CODE]  
              FROM [dbo].[Country_Names] 
             WHERE [COUNTRY_CODE]=@registrantCountry
        END
        ELSE
        BEGIN
            SELECT @registrantCountryCode = [COUNTRY_CODE], @shipToVatCountryCode =  [VAT_COUNTRY_CODE]  
              FROM [dbo].[Country_Names] 
             WHERE [COUNTRY]=@registrantCountry
        END
        IF @@ROWCOUNT=0
        BEGIN
            GOTO ReturnValue
        END
    END

    -- if taxing on ShipTo, then correct the @registrantIsVatRegistered flag, to ALSO check VatCountry
    IF @taxOnShipTo=1 AND @registrantIsVatRegistered = 1
    BEGIN
          SELECT @registrantIsVatRegistered = CASE WHEN LEN(ISNULL(@registrantVatCountry, ''))>0 AND @registrantVatCountry=@shipToVatCountryCode THEN 1 ELSE 0 END
    END
    
    -- now we have everything we need to start processing the rules
    
    -- determine whether the contact country is within the EU
    IF EXISTS (SELECT 1
                 FROM [dbo].[Country_Names]
                WHERE [COUNTRY_CODE]=@registrantCountryCode AND [MAIL_GROUP]='EU') 
    BEGIN
        SET @isEuCountry = 1
    END
    ELSE
    BEGIN
        SET @isEuCountry = 0
    END
    
    -- process the ruleset
    SELECT TOP 1 @applyVat = [VAT_APPLIES], @taxCodeSub = [TAX_CODE_SUB]
     FROM [dbo].[Vat_Rule]
     WHERE [VAT_RULESET]=@ruleSet
           AND ([VAT_REGISTERED]=CASE @registrantIsVatRegistered WHEN 1 THEN 'Y' ELSE 'N' END OR [VAT_REGISTERED]='')
           AND ([COMPANY_CONTACT]=CASE @registrantIsCompany WHEN 1 THEN 'Y' ELSE 'N' END OR [COMPANY_CONTACT]='')
           AND (([LOCATION]='Same' AND @registrantCountryCode=@orgCountryCode)
                  OR
                ([LOCATION]='EU' AND @isEuCountry=1 AND @registrantCountryCode<>@orgCountryCode)
                  OR
                ([LOCATION]='NonEU' AND @isEuCountry=0)
                  OR
                [LOCATION]=''
               )
     ORDER BY [RULE_ORDER]
        
    IF @@ROWCOUNT = 0
    BEGIN
        SET @applyVat = 1
    END     
 
ReturnValue:    
    
    -- output parameter has already been set
    -- also return the value as a resultset for desktop
    SELECT @applyVat AS [ApplyVat], @taxCodeSub AS [TaxCodeSub]
    
END


GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_IsVatTaxableRegistration]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_IsVatTaxableRegistration]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- For a given registration, returns whether VAT should be charged
-- @eventCode = The code of the event being registered for
-- @registrantId = The ID of the contact who is registering
-- @registrantCountry = The country the contact is registering from, either the country name or country code can be used
-- @applyVat OUT = Returns a bit to indicate whether VAT should or should not be charged in this registration scenario
-- @taxCodeSub OUT = Returns the substitute tax code to be used if VAT is not to be charged
-- The procedure also returns single row single column resultset containing the value returned by @applyVat OUT, taxCodeSub OUT

CREATE PROCEDURE [dbo].[asi_IsVatTaxableRegistration]
    @eventCode varchar(10),
    @registrantId varchar(10),
    @registrantCountry varchar(25),
    @applyVat bit = NULL OUT,
    @taxCodeSub varchar(15) = '' OUT 
AS
BEGIN

    -- declare variables    
    DECLARE @isVatRegistered bit
    DECLARE @isVatExempt bit
    DECLARE @isCompany bit
    DECLARE @registrantVatCountry varchar(25)
     
    DECLARE @vatZeroExempt as varchar(255)
    SELECT @vatZeroExempt=ShortValue FROM System_Params WHERE ParameterName='AR_Control.VatZeroExempt'
    SET @vatZeroExempt = ISNULL(@vatZeroExempt,'')

    -- default the return value to true
    -- this effectively means, handle tax as you always did
    -- if we fail any validations we want the system to behave as it always did
    SET @applyVat = 1

    -- verify the contact exists, and retrieve some basic details
    -- USE_VAT_TAXATION is confusing, if a contact is marked VAT Exempt, [USE_VAT_TAXATION] is actually 1
    IF LEN(ISNULL(@registrantId, ''))=0
    BEGIN
        GOTO ReturnValue
    END
    SELECT @isCompany = n.[COMPANY_RECORD],
           @isVatRegistered = CASE WHEN LEN(ISNULL(nf.[VAT_REG_NUMBER], ''))>0 THEN 1 ELSE 0 END,
           @isVatExempt = CASE WHEN ISNULL(nf.[USE_VAT_TAXATION], 0)=1 THEN 1 ELSE 0 END,
           @registrantVatCountry = ISNULL(nf.[VAT_COUNTRY],'')
      FROM [dbo].[Name] n 
           LEFT OUTER JOIN [dbo].[Name_Fin] nf ON n.[ID] = nf.[ID]
     WHERE n.[ID]=@registrantId
    IF @@ROWCOUNT=0
    BEGIN
        GOTO ReturnValue
    END

    -- if the contact is vat exempt, go no further
    IF @isVatExempt=1
    BEGIN
        SET @applyVat = 0 
        SET @taxCodeSub = @vatZeroExempt
        GOTO ReturnValue
    END
        
    -- see if parent record is a company record (if there is a parent)
    IF @isCompany=0
    BEGIN
        SELECT @isCompany = p.[COMPANY_RECORD]
          FROM [dbo].[Name] p 
               LEFT OUTER JOIN [dbo].[Name] c ON p.[ID] = c.[CO_ID]
         WHERE c.[ID]=@registrantId
    END
    
    EXEC [dbo].[asi_IsVatTaxableRegistration2] @eventCode, @registrantCountry, @isCompany, @isVatRegistered, @registrantVatCountry, @applyVat OUT, @taxCodeSub OUT
ReturnValue:    
    
    -- output parameter has already been set
    -- also return the value as a resultset for desktop
    SELECT @applyVat AS [ApplyVat], @taxCodeSub AS [TaxCodeSub]
    
END  

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_LoadPrinterList]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_LoadPrinterList]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_LoadPrinterList    Script Date: 7/3/2003 4:58:04 PM ******/
CREATE   PROC asi_LoadPrinterList
	AS
BEGIN
	select SystemConfigKey, ParameterName, ParameterValue, Description from SystemConfig
where ParameterName='Printer'
	
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_LoginTokenCleanup]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_LoginTokenCleanup]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- Cleanup old login tokens
CREATE PROCEDURE [dbo].[asi_LoginTokenCleanup]
AS
BEGIN

     -- Tokens are only valid for 60 seconds, so anything older than 5 minutes has long expired
     DELETE FROM [dbo].[LoginToken]
     WHERE [CreatedOn] <= DATEADD(minute,-5,GETUTCDATE())
        
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_LoginTokenCreate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_LoginTokenCreate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- Create a login token for a specific user
-- @username : The username of the user to create the token for
-- @token : Returns the token
CREATE PROCEDURE [dbo].[asi_LoginTokenCreate]
     @username nvarchar(256),
     @token nvarchar(50) = NULL OUT
AS
BEGIN

     -- Create the token
     SET @token = NEWID()
     INSERT INTO [dbo].[LoginToken] ([Token], [UserName], [CreatedOn], [Expired])
     VALUES (@token, @username, GETUTCDATE(), 0)

     EXEC [dbo].[asi_LoginTokenCleanup]

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_LoginTokenValidate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_LoginTokenValidate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- Validate a login token
-- @token : the token to validate
-- @username : Returns the username of the user it authenticates,
-- or null if the token is invalid or expired
CREATE PROCEDURE [dbo].[asi_LoginTokenValidate]
     @token nvarchar(50),
     @username nvarchar(256) = NULL OUT
AS
BEGIN

     DECLARE @valid BIT

     -- look for an active token created within the last 60 seconds
     SELECT @username = [UserName] 
       FROM [dbo].[LoginToken]
      WHERE [Token] = @token
            AND [CreatedOn] > DATEADD(second,-60,GETUTCDATE())
            AND [Expired] = 0
            
     -- update the token on the database
     IF @@ROWCOUNT > 0
     BEGIN
          -- we found a valid token
          -- we've now used it so mark it as expired, these are one time use only
          UPDATE [dbo].[LoginToken] 
             SET [Expired]=1 
           WHERE [Token] = @token
     END
     ELSE
     BEGIN
          -- we couldn't find a valid token
          -- delete any invalid matches
          DELETE FROM [dbo].[LoginToken] WHERE [Token] = @token
     END
      
     -- cleanup expired tokens
     EXEC [dbo].[asi_LoginTokenCleanup]
        
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_LogMerge]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_LogMerge]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- This will mark all properties as being merged.
-- Used by the merge process ahead of the actual merge.
-- =============================================
CREATE PROCEDURE [dbo].[asi_LogMerge] 
    @fromContactId varchar(10),
    @toContactId varchar(10),
    @userName varchar(60)
AS
BEGIN
    SET NOCOUNT ON;
    --change the existing "from" logs
    UPDATE [dbo].[Name_Log] 
       SET [LOG_TEXT] =  
           CASE WHEN [LOG_TEXT] NOT LIKE '%Merged' THEN [LOG_TEXT] + ' - Merged'
                ELSE [LOG_TEXT]
           END
     WHERE ID = @fromContactId;

     DECLARE @currentDate datetime;
     DECLARE @currentTS timestamp;
     DECLARE @text nvarchar(800);
     SET @currentDate = dbo.asi_GetAppDatetime();
     SET @text = 'Party.Merged: ID ' + @fromContactId + ' -> ID ' + @toContactId;

     --add to to-party
     INSERT INTO [dbo].[Name_Log] ([DATE_TIME], [LOG_TYPE], [SUB_TYPE], [USER_ID], [ID], [LOG_TEXT])
     VALUES(@currentDate, 'CHANGE', 'MERGE', @userName, @toContactId, @text);
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ManageExpiredMembers]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ManageExpiredMembers]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_ManageExpiredMembers]
       @oldMemberType    varchar(5),
       @expiredDate      datetime,
       @includeWithBlank bit,
       @newMemberType    varchar(5),
       @newStatus        varchar(5),
       @updatedById      varchar(60)
AS
BEGIN
    SET NOCOUNT ON;
    
    -- validate all input strings to avoid SQL injection
    DECLARE @inputValid   bit,
            @paramName    varchar(15),
            @paramValue   varchar(10),
            @errorMessage varchar(900); -- max value of text field in sys.messages
    SET @inputValid = 1;
    IF (@oldMemberType <> '' AND NOT EXISTS (SELECT 1
                                               FROM [Member_Types]
                                              WHERE [MEMBER_TYPE] = @oldMemberType
                                            ) ) --ask if it can be empty
    BEGIN
        SET @inputValid = 0;
        SET @paramName = '@oldMemberType';
        SET @paramValue = @oldMemberType;
    END;
    IF (@newMemberType <> '' AND NOT EXISTS (SELECT 1
                                               FROM [Member_Types]
                                              WHERE [MEMBER_TYPE] = @newMemberType
                                            ) ) --ask if it can be empty
    BEGIN
        SET @inputValid = 0;
        SET @paramName = '@newMemberType';
        SET @paramValue = @newMemberType;
    END;
    IF (@newStatus <> '' AND NOT EXISTS (SELECT 1
                                           FROM [Gen_Tables]
                                          WHERE [TABLE_NAME] = 'MEMBER_STATUS' AND [UPPER_CODE] = @newStatus
                                        ) ) --ask if it can be empty
    BEGIN
        SET @inputValid = 0;
        SET @paramName = '@newStatus';
        SET @paramValue = @newStatus;
    END;
    IF (NOT EXISTS (SELECT 1
                      FROM [UserMain]
                     WHERE [UserId] = @updatedById
                   ) ) --ask if it can be empty
    BEGIN
        SET @inputValid = 0;
        SET @paramName = '@updatedById';
        SET @paramValue = @updatedById;
    END;
    IF (@inputValid = 0)
    BEGIN
        RAISERROR('The value specified for parameter %s = ''%s'' is not valid. ', 16, 1, @paramName, @paramValue);
        RETURN;
    END;    
        
    -- load log fields
    DECLARE @logFields varchar(255);
    SELECT @logFields = [ShortValue]
      FROM [dbo].[System_Params]
     WHERE [ParameterName] = 'Member_Control.LogFieldsString';
    
    -- load flow down fields
    DECLARE @flowDownFields varchar(255);
    SELECT @flowDownFields = [ShortValue]
      FROM [dbo].[System_Params]
     WHERE [ParameterName] = 'Member_Control.FlowDownFields';
     
    
    
    --create MEMBER_TYPE table variable
    DECLARE @memberTypes TABLE (
                               [MEMBER_TYPE]    varchar(5),
                               [MEMBER_RECORD]  bit,
                               [COMPANY_RECORD] bit
    );
    INSERT INTO @memberTypes ([MEMBER_TYPE],
                              [MEMBER_RECORD],
                              [COMPANY_RECORD]
                             )
           SELECT [MEMBER_TYPE],
                  [MEMBER_RECORD],
                  [COMPANY_RECORD]
             FROM [Member_Types];
    DECLARE @name_ID             varchar(10),
            @name_COMPANY_SORT   varchar(30),
            @name_LAST_FIRST     varchar(70),
            @name_FULL_NAME      varchar(70),
            @name_COMPANY        varchar(80),
            @name_CITY           varchar(40),
            @name_STATE_PROVINCE varchar(15),
            @name_MEMBER_TYPE    varchar(5),
            @name_STATUS         varchar(5),
            @name_MEMBER_STATUS  varchar(5),
            @name_MEMBER_RECORD  bit,
            @name_COMPANY_RECORD bit;
        
    -- ChangeLog elements
    DECLARE @changeLogKey uniqueidentifier;
    DECLARE @organizationKey uniqueidentifier;
    DECLARE @objectTypeName nvarchar(100);
    -- object key is @name_ID
    DECLARE @actionType bit;
    DECLARE @description nvarchar(250);
    -- created on [dbo].asi_GetAppDatetime()
    DECLARE @createdByUserKey uniqueidentifier;
    -- marked for delete on - null

    DECLARE @changeLogKeyCreated bit;
    DECLARE @changeLogKeyInserted bit;
    DECLARE @logMemberTypeChange bit;
    DECLARE @logStatusChange bit;
    DECLARE @contactKey uniqueidentifier;
    SET @organizationKey = CONVERT(uniqueidentifier, '673A2ED2-EC66-4E5A-8453-D16844186C71');
    SET @objectTypeName = 'Name';
    SET @actionType = 0; -- 0 is Update and 1 is Delete
    SET @description = 'BusinessItem is being updated. See associated property log items for property changes.';
    SELECT @createdByUserKey = [UserKey]
      FROM [UserMain]
     WHERE [UserId] = @updatedById;
     
    -- Begin user log
    -- create table
    DECLARE @runNumberTable TABLE (
                                  [RunNumber] int
    );
    -- create parent entry in ExpiredMemberUpdateLog
    INSERT INTO [ExpiredMemberUpdateLog] ([UserId],
                                          [Status],
                                          [Start],
                                          [MembersUpdated],
                                          [Errors]
                                         )
    OUTPUT [inserted].[RunNumber]
           INTO @runNumberTable
    VALUES (@updatedById,
            'In Progress',
            [dbo].[asi_GetAppDatetime](),
            0,
            0
           );
    DECLARE @runNumber int;
    SELECT @runNumber = [RunNumber]
      FROM @runNumberTable;
    DECLARE @runItemNumber int;
    SET @runItemNumber = 0;
    
    -- lines 22 - 27
    DECLARE MAN_EXP_MEM_CUR CURSOR FORWARD_ONLY
    FOR SELECT [Name].[ID],
               [Name].[COMPANY_SORT],
               [Name].[LAST_FIRST],
               [Name].[FULL_NAME],
               [Name].[COMPANY],
               [Name].[CITY],
               [Name].[STATE_PROVINCE],
               [Name].[MEMBER_TYPE],
               [Name].[STATUS],
               [Name].[MEMBER_STATUS],
               [Name].[MEMBER_RECORD],
               [Name].[COMPANY_RECORD]
          FROM [Name]
         WHERE [Name].[MEMBER_TYPE] = @oldMemberType AND ( (@includeWithBlank = 1 AND [Name].[PAID_THRU] IS NULL) OR [Name].[PAID_THRU] <= @expiredDate) -- lines 7 - 11
    FOR UPDATE OF [Name].[MEMBER_TYPE],
                  [Name].[PREVIOUS_MT],
                  [Name].[MT_CHANGE_DATE],
                  [Name].[STATUS],
                  [Name].[MEMBER_STATUS],
                  [Name].[MEMBER_STATUS_DATE],
                  [Name].[LAST_UPDATED],
                  [Name].[UPDATED_BY],
                  [Name].[MEMBER_RECORD],
                  [Name].[COMPANY_RECORD];
    OPEN MAN_EXP_MEM_CUR;
    FETCH NEXT FROM MAN_EXP_MEM_CUR INTO @name_ID,
                                         @name_COMPANY_SORT,
                                         @name_LAST_FIRST,
                                         @name_FULL_NAME,
                                         @name_COMPANY,
                                         @name_CITY,
                                         @name_STATE_PROVINCE,
                                         @name_MEMBER_TYPE,
                                         @name_STATUS,
                                         @name_MEMBER_STATUS,
                                         @name_MEMBER_RECORD,
                                         @name_COMPANY_RECORD;
    WHILE (@@fetch_Status = 0)
    BEGIN
        SET @runItemNumber+=1;
        
        -- log what is about to change -- line 53

        SET @changeLogKeyCreated = 0;
        SET @changeLogKeyInserted = 0;
        SET @logMemberTypeChange = CASE WHEN (LEN(@newMemberType) > 0 AND CHARINDEX('Name.MEMBER_TYPE', @logFields) > 0)
                                        THEN 1
                                        ELSE 0
                                   END;
        SET @logStatusChange = CASE WHEN (LEN(@newStatus) > 0 AND CHARINDEX('Name.STATUS', @logFields) > 0 AND @name_STATUS <> @newStatus)
                                    THEN 1
                                    ELSE 0
                               END;
        SET @changeLogKey = CAST(0 AS binary); -- set to Guid.Empty

        IF (@logMemberTypeChange = 1 OR @logStatusChange = 1)
        BEGIN
            -- create change log key
            SET @changeLogKey = NEWID();
            SET @changeLogKeyCreated = 1;
        END;
                
        --get contact key from vBoNetContact
        SELECT @contactKey = [ContactKey]
          FROM [dbo].[ContactMain]
         WHERE [ID] = @name_ID; -- IsCompany
        -- if Name.MEMBER_TYPE has changed - log
        IF (@logMemberTypeChange = 1) --(LEN(@newMemberType) > 0 AND CHARINDEX('Name.MEMBER_TYPE', @logFields) > 0)
        BEGIN
            BEGIN TRY
                INSERT INTO [ChangeLog] ([ChangeLogKey],
                                         [OrganizationKey],
                                         [ObjectTypeName],
                                         [ObjectKey],
                                         [ActionType],
                                         [Description],
                                         [CreatedOn],
                                         [CreatedByUserKey]
                                        )
                VALUES (@changeLogKey,
                        @organizationKey,
                        @objectTypeName,
                        @contactKey,
                        @actionType,
                        @description,
                        [dbo].[asi_GetAppDatetime](),
                        @createdByUserKey
                       );
                SET @changeLogKeyInserted = 1;
                -- log property change 
                INSERT INTO [ChangeProperty] ([ChangeLogKey],
                                              [PropertyName],
                                              [OriginalValue],
                                              [CurrentValue]
                                             )
                VALUES (@changeLogKey,
                        'MEMBER_TYPE',
                        @name_MEMBER_TYPE,
                        @newMemberType
                       );
            END TRY
            BEGIN CATCH
                SET @errorMessage = ERROR_MESSAGE();
                RAISERROR('An error occurred while inserting Name.MEMBER_TYPE change into ChangeLog or ChangeProperty table. Error:%s', 16, 1, @errorMessage);
                RETURN;
            END CATCH;
        END;
            
        -- if Name.STATUS has changed - log 
        IF (@logStatusChange = 1) --(LEN(@newStatus) > 0 AND CHARINDEX('Name.STATUS', @logFields) > 0 AND @name_STATUS <> @newStatus)
        BEGIN
            BEGIN TRY
                IF (@changeLogKeyInserted = 0)
                BEGIN
                    INSERT INTO [ChangeLog] ([ChangeLogKey],
                                             [OrganizationKey],
                                             [ObjectTypeName],
                                             [ObjectKey],
                                             [ActionType],
                                             [Description],
                                             [CreatedOn],
                                             [CreatedByUserKey]
                                            )
                    VALUES (@changeLogKey,
                            @organizationKey,
                            @objectTypeName,
                            @contactKey,
                            @actionType,
                            @description,
                            [dbo].[asi_GetAppDatetime](),
                            @createdByUserKey
                           );
                    SET @changeLogKeyInserted = 1;
                END;
                INSERT INTO [ChangeProperty] ([ChangeLogKey],
                                              [PropertyName],
                                              [OriginalValue],
                                              [CurrentValue]
                                             )
                VALUES (@changeLogKey,
                        'STATUS',
                        @name_STATUS,
                        @newStatus
                       );
            END TRY
            BEGIN CATCH
                SET @errorMessage = ERROR_MESSAGE();
                RAISERROR('An error occurred while inserting Name.STATUS change into ChangeLog or ChangeProperty table. Error:%s', 16, 1, @errorMessage);
                RETURN;
            END CATCH;
        END;
                
        ------------------------------------- FINISHED LOGGING -------------------------------------
        -- update Name
        -- line 55 
        DECLARE @name_update_sql nvarchar(400); -- check the lenth
        SET @name_update_sql = 'UPDATE Name SET ';
        -- lines 56 - 59
        IF (@newMemberType <> '')
        BEGIN
            SET @name_update_sql+=' MEMBER_TYPE = '''+@newMemberType+''', PREVIOUS_MT = '''+@name_MEMBER_TYPE+''', MT_CHANGE_DATE = '''+CONVERT(varchar(19), [dbo].[asi_GetAppDatetime](), 126)+''',';
        END; 
        -- lines 60 - 62
        IF (@newStatus <> '')
        BEGIN
            SET @name_update_sql+=' STATUS = '''+@newStatus+''',';
        END;
        
        -- lines 63 - 66
        DECLARE @lMemberRecord    bit,
                @lCompanyRecord   bit,
                @lWasActiveMember bit;
        IF (@newMemberType = '')
        BEGIN
            SET @lMemberRecord = @name_MEMBER_RECORD;
            SET @lCompanyRecord = @name_COMPANY_RECORD;
        END;
        ELSE
        BEGIN
            -- this portion is from lines 13 - 19 
            SELECT @lMemberRecord = [MEMBER_RECORD],
                   @lCompanyRecord = [COMPANY_RECORD]
              FROM @memberTypes
             WHERE [MEMBER_TYPE] = @newMemberType;
        END;
        
        -- lines 67
        -- there is probably a better way to do this
        SET @lWasActiveMember = CASE WHEN (@name_MEMBER_RECORD = 1 AND NOT (@name_STATUS <> '' AND CHARINDEX(SUBSTRING(UPPER(@name_STATUS), 1, 1), 'DSI') > 0) )
                                     THEN 1
                                     ELSE 0
                                END;
        
        -- lines 68 - 72
        DECLARE @lIsActiveMember bit;
        IF (@newStatus <> '')
        BEGIN
            SET @lIsActiveMember = CASE WHEN (@lMemberRecord = 1 AND NOT (@newStatus <> '' AND CHARINDEX(SUBSTRING(UPPER(@newStatus), 1, 1), 'DSI') > 0) )
                                        THEN 1
                                        ELSE 0
                                   END;
        END;
        ELSE
        BEGIN
            SET @lIsActiveMember = CASE WHEN (@lMemberRecord = 1 AND NOT (@name_STATUS <> '' AND CHARINDEX(SUBSTRING(UPPER(@name_STATUS), 1, 1), 'DSI') > 0) )
                                        THEN 1
                                        ELSE 0
                                   END;
        END;
        
        -- lines 
        DECLARE @lMemberStatusWasChanged bit,
                @lNewMemberStatus        varchar(50);
        SET @lMemberStatusWasChanged = 0;
        SET @lNewMemberStatus = 0;
        IF (@lIsActiveMember <> @lWasActiveMember) -- line 73
        BEGIN
            IF (@lIsActiveMember = 1 AND NOT (@lWasActiveMember = 1) ) -- line 74
            BEGIN
                IF (@name_MEMBER_STATUS <> '' AND UPPER(@name_MEMBER_STATUS) = 'D') -- line 75
                BEGIN
                    SET @name_update_sql+=' MEMBER_STATUS = ''S'','; -- line 76
                    SET @lNewMemberStatus = 'S'; -- line 77
                    SET @name_update_sql+=' MEMBER_STATUS_DATE = '''+CONVERT(varchar(19), [dbo].[asi_GetAppDatetime](), 126)+''','; -- line 78
                END;
                ELSE
                BEGIN
                    SET @name_update_sql+=' MEMBER_STATUS = ''N'','; -- line 80
                    SET @lNewMemberStatus = 'N'; -- line 81
                    SET @name_update_sql+=' MEMBER_STATUS_DATE = '''+CONVERT(varchar(19), [dbo].[asi_GetAppDatetime](), 126)+''','; -- line 82
                END;
            END;
            ELSE
            BEGIN
                IF (@lWasActiveMember = 1 AND NOT (@lIsActiveMember = 1) )
                BEGIN
                    SET @name_update_sql+=' MEMBER_STATUS = ''D'','; -- line 85
                    SET @lNewMemberStatus = 'D'; -- line 86
                    SET @name_update_sql+=' MEMBER_STATUS_DATE = '''+CONVERT(varchar(19), [dbo].[asi_GetAppDatetime](), 126)+''','; -- line 87
                END;
            END;
            SET @lMemberStatusWasChanged = 1; --line 89
        END;
        SET @name_update_sql+=' LAST_UPDATED = '''+CONVERT(varchar(19), [dbo].[asi_GetAppDatetime](), 126)+''','; -- line 91]
        SET @name_update_sql+=' UPDATED_BY = '''+@updatedById+''''; -- line 93

        IF (@newMemberType <> '')
        BEGIN -- line 94
            SET @name_update_sql+=', MEMBER_RECORD = '+CAST(@lMemberRecord AS char(1))+', COMPANY_RECORD = '+CAST(@lCompanyRecord AS char(1));
        END; -- line 95
        SET @name_update_sql+=' WHERE ID = '+@name_ID; -- line 97

        EXEC [sp_executesql]
             @name_update_sql; -- line 99
        -- start Do Child Updates - line 100
        IF (LEN(@newMemberType) > 0 AND @name_COMPANY_RECORD = 1)
        BEGIN -- line 2 (Do Child Updates)
            BEGIN TRY
                UPDATE [Name]
                   SET
                       [CO_MEMBER_TYPE] = @newMemberType,
                       [LAST_UPDATED] = CONVERT( varchar(19), [dbo].[asi_GetAppDatetime](), 126),
                       [UPDATED_BY] = @updatedById
                 WHERE [CO_ID] = @name_ID;
            END TRY
            BEGIN CATCH
                SET @errorMessage = ERROR_MESSAGE();
                RAISERROR('An error occurred while updating @newMemberType in Name table. Error:%s', 16, 1, @errorMessage);
                RETURN;
            END CATCH;
        END;
        IF ( (@lMemberStatusWasChanged = 1 OR @name_COMPANY_RECORD = 1) AND (CHARINDEX('Name.STATUS', @flowDownFields) > 0) )
        BEGIN -- line 16 (Do Child Updates)
            BEGIN TRY
                UPDATE [Name]
                   SET
                       [STATUS] = @newStatus,
                       [LAST_UPDATED] = CONVERT( varchar(19), [dbo].[asi_GetAppDatetime](), 126),
                       [UPDATED_BY] = @updatedById
                 WHERE [CO_ID] = @name_ID;
            END TRY
            BEGIN CATCH
                SET @errorMessage = ERROR_MESSAGE();
                RAISERROR('An error occurred while updating @newStatus in Name table. Error:%s', 16, 1, @errorMessage);
                RETURN;
            END CATCH;
        END;
        -- end Do Child Updates

        IF (@lMemberStatusWasChanged = 1 AND (CHARINDEX('Name.MEMBER_STATUS', @logFields)) > 0) -- line 101
        BEGIN
            IF (@changeLogKeyCreated = 0)
            BEGIN
                SET @changeLogKey = NEWID();
            END;
            IF (@changeLogKeyInserted = 0)
            BEGIN
                INSERT INTO [ChangeLog] ([ChangeLogKey],
                                         [OrganizationKey],
                                         [ObjectTypeName],
                                         [ObjectKey],
                                         [ActionType],
                                         [Description],
                                         [CreatedOn],
                                         [CreatedByUserKey]
                                        )
                VALUES (@changeLogKey,
                        @organizationKey,
                        @objectTypeName,
                        @contactKey,
                        @actionType,
                        @description,
                        [dbo].[asi_GetAppDatetime](),
                        @createdByUserKey
                       );
            END;
            INSERT INTO [ChangeProperty] ([ChangeLogKey],
                                          [PropertyName],
                                          [OriginalValue],
                                          [CurrentValue]
                                         )
            VALUES (@changeLogKey,
                    'MEMBER_STATUS',
                    @name_MEMBER_STATUS,
                    @lNewMemberStatus
                   );
        END; -- line 102
        -- Log updated member in ExpiredMemberUpdateLog and ExpiredMemberUpdateDetailLog 
        INSERT INTO [ExpiredMemberUpdateDetailLog] ([RunNumber],
                                                    [RunItemNumber],
                                                    [Id],
                                                    [FullName],
                                                    [PreviousStatus],
                                                    [CurrentStatus],
                                                    [PreviousMemberType],
                                                    [CurrentMemberType]
                                                   )
        VALUES (@runNumber,
                @runItemNumber,
                @name_ID,
                CASE WHEN (@name_FULL_NAME = '')
                     THEN @name_COMPANY
                     ELSE @name_FULL_NAME
                END,
                @name_STATUS,
                CASE WHEN (@logStatusChange = 1)
                     THEN @newStatus
                     ELSE @name_STATUS
                END,
                @name_MEMBER_TYPE,
                CASE WHEN (@logMemberTypeChange = 1)
                     THEN @newMemberType
                     ELSE @name_MEMBER_TYPE
                END
               );
        UPDATE [ExpiredMemberUpdateLog]
           SET
               [MembersUpdated]+=1
         WHERE [RunNumber] = @runNumber;
        FETCH NEXT FROM MAN_EXP_MEM_CUR INTO @name_ID,
                                             @name_COMPANY_SORT,
                                             @name_LAST_FIRST,
                                             @name_FULL_NAME,
                                             @name_COMPANY,
                                             @name_CITY,
                                             @name_STATE_PROVINCE,
                                             @name_MEMBER_TYPE,
                                             @name_STATUS,
                                             @name_MEMBER_STATUS,
                                             @name_MEMBER_RECORD,
                                             @name_COMPANY_RECORD;
    END;
    CLOSE MAN_EXP_MEM_CUR;
    DEALLOCATE MAN_EXP_MEM_CUR;
    UPDATE [ExpiredMemberUpdateLog]
       SET
           [End] = [dbo].[asi_GetAppDatetime](),
           [Status] = CASE WHEN ([Errors] = 0)
                           THEN 'Completed'
                           ELSE 'Failed'
                      END
     WHERE [RunNumber] = @runNumber;
END;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_MemberTypeCompanyRecordUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_MemberTypeCompanyRecordUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_MemberTypeCompanyRecordUpdate]
AS
BEGIN

    SET NOCOUNT ON

    UPDATE n 
       SET n.[COMPANY_RECORD] = mt.[COMPANY_RECORD] 
      FROM [dbo].[Name] n
           INNER JOIN [dbo].[Member_Types] mt ON n.[MEMBER_TYPE] = mt.[MEMBER_TYPE]
    WHERE n.COMPANY_RECORD <> mt.COMPANY_RECORD 

END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_MemberTypeMemberRecordUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_MemberTypeMemberRecordUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


CREATE PROCEDURE [dbo].[asi_MemberTypeMemberRecordUpdate]
AS
BEGIN

    SET NOCOUNT ON

    UPDATE n 
       SET n.[MEMBER_RECORD] = mt.[MEMBER_RECORD]
      FROM [dbo].[Name] n
           INNER JOIN [dbo].[Member_Types] mt ON n.[MEMBER_TYPE] = mt.[MEMBER_TYPE]
    WHERE n.[MEMBER_RECORD] <> mt.[MEMBER_RECORD] 

    UPDATE n1 
       SET n1.[CO_MEMBER_TYPE] = n2.[MEMBER_TYPE] 
      FROM [dbo].[Name] n1
           INNER JOIN [dbo].[Name] n2 ON n1.[CO_ID] = n2.[ID]
    WHERE n1.[CO_ID] <> ''
       AND n1.[CO_MEMBER_TYPE] <> n2.[MEMBER_TYPE]

END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_MergeCleanDuplicatePartyRecords]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_MergeCleanDuplicatePartyRecords]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


CREATE PROCEDURE [dbo].[asi_MergeCleanDuplicatePartyRecords]
AS
BEGIN
    IF OBJECT_ID('tempdb..#singlePartyGroups') IS NOT NULL DROP TABLE #singlePartyGroups;
    CREATE TABLE #singlePartyGroups ([DuplicatePartyGroupCode] nvarchar(10) COLLATE DATABASE_DEFAULT,
                                     [DuplicateRuleSetCode] nvarchar(3) COLLATE DATABASE_DEFAULT);
    
    -- If there is only 1 party left in the group, then delete the party from the DuplicateParty table first, 
    -- then delete the group from the DuplicatePartyGroup table. 
    INSERT INTO #singlePartyGroups ([DuplicatePartyGroupCode], [DuplicateRuleSetCode])
         SELECT [DuplicatePartyGroupCode], [DuplicateRuleSetCode]
           FROM [dbo].[DuplicateParty] 
          GROUP BY [DuplicatePartyGroupCode], [DuplicateRuleSetCode]
         HAVING COUNT([DuplicatePartyGroupCode]) = 1;

    CREATE INDEX IX_SinglePartyGroups_DuplicatePartyGroupCode ON #singlePartyGroups ([DuplicatePartyGroupCode] ASC, [DuplicateRuleSetCode] ASC);

    DELETE dp 
      FROM [dbo].[DuplicateParty] dp
           INNER JOIN #singlePartyGroups spg ON spg.[DuplicatePartyGroupCode] = dp.[DuplicatePartyGroupCode] 
                                            AND spg.[DuplicateRuleSetCode] = dp.[DuplicateRuleSetCode]
                                             
    IF OBJECT_ID('tempdb..#singlePartyGroups') IS NOT NULL DROP TABLE #singlePartyGroups;
END



GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_MergeCustomizerUDTables]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_MergeCustomizerUDTables]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO




-- =============================================
-- This procedure will gather up all the custom UD Tables defined by the customer
-- and load them into a meta table.  We will use this temp table to merge records
-- in these tables similar to what we do for asi_MergeReferences
-- =============================================
CREATE PROCEDURE [dbo].[asi_MergeCustomizerUDTables] ( @fromContactId varchar(10), 
                                               @toContactId varchar(10))
AS
BEGIN
       SET NOCOUNT ON;
    --create a temp table to store our metadata 
    CREATE TABLE #UDMergeSchemaReference([TableName] nvarchar(128) COLLATE DATABASE_DEFAULT NOT NULL,
                                         [ColumnName] nvarchar(128) COLLATE DATABASE_DEFAULT NOT NULL,
                                         [ProcessingOrder] int NOT NULL,
                                         [ProcessingType] nvarchar(10) COLLATE DATABASE_DEFAULT,
                                         [DataColumnName] nvarchar(128) COLLATE DATABASE_DEFAULT
                                         );

    -- Insert the update type rows for each of the defined UD tables
    INSERT INTO #UDMergeSchemaReference([TableName],
                                        [ColumnName],
                                        [ProcessingOrder],
                                        [ProcessingType],
                                        [DataColumnName])
    SELECT ud1.ObjectName AS TableName,
            'ID' AS [ColumnName],
            ROW_NUMBER() OVER (ORDER BY ud1.[ObjectName] ASC, udf.[SEQ]) AS [ProcessingOrder],
            CASE
            WHEN ud1.[IsMultiInstance] = 1
                THEN 'UPDATE'
            WHEN (ud2.[REQUIRED] = 1 AND c.DATA_TYPE = 'text')
                THEN 'IGNORE'
            WHEN (ud2.[REQUIRED] = 1 AND c.DATA_TYPE <> 'text')
                THEN 'DATAUPDATE'
                ELSE 'NODUPEKEY'
            END AS [ProcessingType],
            udf.[FIELD_NAME] AS [DataColumnName]
    FROM [dbo].[vUserDefinedDynamicBusinessObjectSources] AS ud1
        INNER JOIN dbo.[UD_Table] AS ud2 ON ud1.[ObjectName] = ud2.[TABLE_NAME]
        LEFT OUTER JOIN dbo.[UD_Field] AS udf ON ud2.[TABLE_NAME] = udf.[TABLE_NAME] AND ud2.[REQUIRED] = 1
        LEFT OUTER JOIN INFORMATION_SCHEMA.COLUMNS c ON ud2.[TABLE_NAME] = c.TABLE_NAME AND c.COLUMN_NAME = udf.[FIELD_NAME]
    ORDER BY ud1.[ObjectName], udf.[SEQ];

    DECLARE @UpdateRows int
    SELECT @UpdateRows = MAX([ProcessingOrder]) FROM #UDMergeSchemaReference

    -- Then insert the delete type rows so that we delete them last
    INSERT INTO #UDMergeSchemaReference([TableName],
                                    [ColumnName],
                                    [ProcessingOrder],
                                    [ProcessingType],
                                    [DataColumnName])
        SELECT ud1.[ObjectName] AS [TableName],
            'ID' AS [ColumnName],
            ROW_NUMBER() OVER (ORDER BY ud1.[ObjectName] ASC) + @UpdateRows AS [ProcessingOrder],
            'DELETE' AS [ProcessingType],
            NULL AS [DataColumnName]
        FROM dbo.[vUserDefinedDynamicBusinessObjectSources] AS ud1
        INNER JOIN dbo.[UD_Table] AS ud2 ON ud1.ObjectName = ud2.TABLE_NAME
        WHERE ud1.[IsMultiInstance] = 0
        ORDER BY ud1.[ObjectName];

    -- The processing logic - very similar to that seen in asi_MergePartyReferences save we also deal with multi-instance sequences
    DECLARE @tempProcessingStatement nvarchar(max);
    DECLARE @errorMessage nvarchar(max);
    SET @errorMessage = '';
    DECLARE @tempReferencesRowCount int;
    DECLARE @currentTable sysname;
    DECLARE @currentColumn sysname;
    DECLARE @currentOperation nvarchar(10);

    SET @tempReferencesRowCount = (SELECT MAX([ProcessingOrder]) FROM #UDMergeSchemaReference);

    DECLARE @counter int;
    SET @counter = 0;

    WHILE (@counter < @tempReferencesRowCount)
    BEGIN
        SET @counter += 1;
        --The following processing types explained:
        -- DATAUPDATE - Replace to-party's data column value if NULL with from-party data column value.
        -- NODUPKEY - If previous to-party record exists, we keep it and delete from-party or else switch keys.  This prevents duplicate key errors in certain tables.
        -- UPDATE - Switched out the from-party's key with the to-party's key and increments the SEQN 
        -- DELETE - Deletes the from-part record so order of table in list is important
        BEGIN TRY
            SELECT
               @currentColumn = [ColumnName],
               @currentTable = [TableName],
               @currentOperation = [ProcessingType],
               @tempProcessingStatement = 
               CASE WHEN [ProcessingType] = N'NODUPEKEY' THEN N'IF NOT EXISTS (SELECT * FROM '
                        + QUOTENAME([TableName]) 
                        + N' WHERE '
                        + QUOTENAME([ColumnName]) + N' = ''' 
                        + @toContactId + N''''
                        + N') BEGIN UPDATE'
                        + N' [dbo].' + QUOTENAME([TableName]) 
                        + N' SET ' + QUOTENAME([ColumnName]) +  N' = ''' 
                        + @toContactId + N''' WHERE ' 
                        + QUOTENAME([ColumnName]) + N' = ''' 
                        + @fromContactId + ''''
                        + N' END ELSE BEGIN DELETE FROM [dbo].'
                        + QUOTENAME([TableName])
                        + N' WHERE '
                        + QUOTENAME([ColumnName]) + N' = ''' 
                        + @fromContactId + N''' END'
                   WHEN [ProcessingType] = N'UPDATE' THEN N'UPDATE'
                        + N' [dbo].' + QUOTENAME([TableName]) 
                        + N' SET [SEQN] = [SEQN] + (SELECT COALESCE(MAX([SEQN]),0) FROM '
                        + N' [dbo].' + QUOTENAME([TableName]) 
                        + N' WHERE ' + QUOTENAME([ColumnName]) + N' = ''' 
                        + @toContactId + N''') '
                        + N' WHERE ' + QUOTENAME([ColumnName]) + N' = ''' 
                        + @fromContactId + N''';'
                        + N'UPDATE' 
                        + N' [dbo].' + QUOTENAME([TableName]) 
                        + N' SET ' + QUOTENAME([ColumnName]) + N' = ''' 
                        + @toContactId + ''''
                        + N' WHERE ' + QUOTENAME([ColumnName]) + N' = ''' 
                        + @fromContactId + N''''
                   WHEN [ProcessingType] = N'DELETE' THEN N'DELETE'
                        + N' FROM [dbo].' + QUOTENAME([TableName]) 
                        + N' WHERE ' 
                        + QUOTENAME([ColumnName]) + N' = ''' 
                        + @fromContactId + N''''
                   WHEN [ProcessingType] = N'DATAUPDATE' THEN N'UPDATE toTable SET'
                        + N'' + QUOTENAME([DataColumnName]) + N' = fromTable.'
                        + QUOTENAME([DataColumnName])  
                        + N' FROM [dbo].' + QUOTENAME([TableName]) + N' fromTable,'
                        + N' [dbo].' + QUOTENAME([TableName]) + ' toTable'
                        + N' WHERE fromTable.' + QUOTENAME([ColumnName]) + N' = '''
                        + @fromContactId + N''''
                        + N' AND toTable.'+ QUOTENAME([ColumnName]) + N' = '''
                        + @toContactId + ''''
                        + N' AND (toTable.'+ QUOTENAME([DataColumnName]) + N' IS NULL OR' 
                        + ' DATALENGTH(toTable.'+ QUOTENAME([DataColumnName]) + ') = 0 OR'
                        + ' (ISNUMERIC(toTable.' + QUOTENAME([DataColumnName]) +') = 1 AND' 
                        + ' CAST (REPLACE (REPLACE (toTable.' + QUOTENAME([DataColumnName]) + ','
                        + ''','',''''),''.'','''') AS BIGINT) = 0))'
              END 
              FROM #UDMergeSchemaReference 
             WHERE [ProcessingOrder] = @counter;
            --PRINT @tempProcessingStatement;
            EXEC (@tempProcessingStatement);
        END TRY
        BEGIN CATCH
           SET @errorMessage  += '**' + 'Number = ' + convert(nvarchar(4), ERROR_NUMBER())
                                + ', ' + 'Severity = ' + convert(nvarchar(4), ERROR_SEVERITY())
                               + ', ' + 'Message = ' + convert(nvarchar(max), ERROR_MESSAGE())
                               + ' : ' + @currentTable + ' - ' + @currentColumn + ' - ' + @currentOperation
                                + CHAR(13);
            
            CONTINUE;
        END CATCH
    END

    -- Drop the temp table
    DROP TABLE #UDMergeSchemaReference;

    IF (@errorMessage <> '')
      RAISERROR(@errorMessage, 16, 1);
END





GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_MergeEngagementScores]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_MergeEngagementScores]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_MergeEngagementScores]
       @fromContactId varchar(10),
       @toContactId   varchar(10)
AS
BEGIN
    -- This procedure does two things.
    -- 1) Updates the CalculatedEngagementScore table by adding scores from the contact being deleted
    --    to the appropriate entry for the contact being kept, if both sets of scores exist.  If only
    --    a score for the kept contact exists, we take no action.  If only a score for the deleted contact
    --    exist, we insert new corresponding rows for the kept contact.  After this is complete we delete
    --    all CalculatedEngagementScore entries for the deleted contact.
    -- 2) Updates the EngagementCategoryContact table.  We can't really recalculate categories here, so we 
    --    do some approximating.  For data points where both contacts have a category assignment, we set 
    --    the kept contact to the higher of the two.  If only the deleted contact has a category assignment,
    --    we copy that to the kept contact.  If only the kept contact has a category for the data point, we 
    --    take no action.  After this is complete we delete
    --    all EngagementCategoryContact entries for the deleted contact.
    SET NOCOUNT ON;

	IF  EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[CalculatedEngagementScore]') AND name = N'IX_CalculatedEngagementScore_ContactKey')
        DROP INDEX [IX_CalculatedEngagementScore_ContactKey] ON [dbo].[CalculatedEngagementScore] WITH ( ONLINE = OFF )

    CREATE NONCLUSTERED INDEX [IX_CalculatedEngagementScore_ContactKey] ON [dbo].[CalculatedEngagementScore] 
    (
        [ContactKey] ASC
    )
    WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON)


    DECLARE @currentDate datetime;
    DECLARE @fromContactKey uniqueidentifier;
    DECLARE @toContactKey uniqueidentifier;
    DECLARE @fromEngagement TABLE (
                                  [CalculatedEngagementScoreKey] uniqueidentifier PRIMARY KEY,
                                  [EngagementScoreKey]           uniqueidentifier,
                                  [ScoreComponentKey]            uniqueidentifier,
                                  [Score]                        decimal(18, 4),
                                  [ScoreYear]                    int,
                                  [ScoreMonth]                   int,
                                  [ScoreWeek]                    int
    );
    DECLARE @toEngagement TABLE (
                                [CalculatedEngagementScoreKey] uniqueidentifier PRIMARY KEY,
                                [EngagementScoreKey]           uniqueidentifier,
                                [ScoreComponentKey]            uniqueidentifier,
                                [Score]                        decimal(18, 4),
                                [ScoreYear]                    int,
                                [ScoreMonth]                   int,
                                [ScoreWeek]                    int
    );
    DECLARE @toCategory TABLE (
                              [EngagementCategoryContactKey] uniqueidentifier PRIMARY KEY,
                              [EngagementScoreKey]           uniqueidentifier,
                              [ScoreYear]                    int,
                              [ScoreMonth]                   int,
                              [ScoreWeek]                    int,
                              [EngagementCategoryKey]        uniqueidentifier,
                              [EngagementCategoryPriority]   int
    );
    DECLARE @fromCategory TABLE (
                                [EngagementCategoryContactKey] uniqueidentifier PRIMARY KEY,
                                [EngagementScoreKey]           uniqueidentifier,
                                [ScoreYear]                    int,
                                [ScoreMonth]                   int,
                                [ScoreWeek]                    int,
                                [EngagementCategoryKey]        uniqueidentifier,
                                [EngagementCategoryPriority]   int
    );

    --need our guid keys
    SELECT @fromContactKey = [Contactkey]
      FROM [dbo].[Contactmain]
     WHERE [SyncContactId] = @fromContactId;
    SELECT @toContactKey = [Contactkey]
      FROM [dbo].[Contactmain]
     WHERE [SyncContactId] = @toContactId;
    SELECT @currentDate = dbo.Asi_GetAppDatetime();
    
    INSERT INTO @fromEngagement
           SELECT [CalculatedEngagementScoreKey],
                  [EngagementScoreKey],
                  ISNULL([ScoreComponentKey], '00000000-0000-0000-0000-000000000000'),
                  [Score],
                  ISNULL([ScoreYear], 0),
                  ISNULL([ScoreMonth], 0),
                  ISNULL([ScoreWeek], 0)
             FROM [CalculatedEngagementScore]
            WHERE [Contactkey] = @fromContactKey;
            
    INSERT INTO @toEngagement
           SELECT [CalculatedEngagementScoreKey],
                  [EngagementScoreKey],
                  ISNULL([ScoreComponentKey], '00000000-0000-0000-0000-000000000000'),
                  [Score],
                  ISNULL([ScoreYear], 0),
                  ISNULL([ScoreMonth], 0),
                  ISNULL([ScoreWeek], 0)
             FROM [CalculatedEngagementScore]
            WHERE [Contactkey] = @toContactKey;
            
    WITH MergingScoreData
         AS (SELECT keeper.[CalculatedEngagementScoreKey],
                    keeper.[Score] + loser.[Score] AS [NewScore]
               FROM @toEngagement AS keeper
                    INNER JOIN @fromEngagement AS loser ON loser.[ScoreComponentKey] = keeper.[ScoreComponentKey] AND loser.[ScoreYear] = keeper.[ScoreYear] AND loser.[ScoreMonth] = keeper.[ScoreMonth] AND loser.[ScoreWeek] = keeper.[ScoreWeek])
         UPDATE [CalculatedEngagementScore]
            SET
                [Score] = MergingScoreData.[NewScore]
           FROM [MergingScoreData]
                INNER JOIN [CalculatedEngagementScore] ces ON ces.[CalculatedEngagementScoreKey] = [MergingScoreData].[CalculatedEngagementScoreKey];
                
    WITH NewScoreData
         AS (SELECT loser.[Score] AS [NewScore],
                    loser.[EngagementScoreKey],
                    loser.[ScoreComponentKey],
                    loser.[ScoreYear],
                    loser.[ScoreMonth],
                    loser.[ScoreWeek]
               FROM @fromEngagement AS loser
              WHERE NOT EXISTS (SELECT 1
                                  FROM @toEngagement AS keeper
                                 WHERE keeper.[ScoreComponentKey] = loser.[ScoreComponentKey] AND keeper.[ScoreYear] = loser.[ScoreYear] AND keeper.[ScoreMonth] = loser.[ScoreMonth] AND keeper.[ScoreWeek] = loser.[ScoreWeek]
                               ) )
         INSERT INTO [CalculatedEngagementScore] ([CalculatedEngagementScoreKey],
                                                  [EngagementScoreKey],
                                                  [ScoreComponentKey],
                                                  [Contactkey],
                                                  [Score],
                                                  [ScoreYear],
                                                  [ScoreMonth],
                                                  [ScoreWeek]
                                                 )
                SELECT NEWID(),
                       nsd.[EngagementScoreKey],
                       CASE WHEN nsd.[ScoreComponentKey] = '00000000-0000-0000-0000-000000000000'
                            THEN NULL
                            ELSE nsd.[ScoreComponentKey]
                       END,
                       @toContactKey,
                       nsd.[NewScore],
                       CASE WHEN nsd.[ScoreYear] = 0
                            THEN NULL
                            ELSE nsd.[ScoreYear]
                       END,
                       CASE WHEN nsd.[ScoreMonth] = 0
                            THEN NULL
                            ELSE nsd.[ScoreMonth]
                       END,
                       CASE WHEN nsd.[ScoreWeek] = 0
                            THEN NULL
                            ELSE nsd.[ScoreWeek]
                       END
                  FROM NewScoreData AS nsd;
    DELETE [CalculatedEngagementScore]
     WHERE [Contactkey] = @fromContactKey;
    INSERT INTO @toCategory
           SELECT ecc.[EngagementCategoryContactKey],
                  ecc.[EngagementScoreKey],
                  ecc.[ScoreYear],
                  ecc.[ScoreMonth],
                  ecc.[ScoreWeek],
                  ecc.[EngagementCategoryKey],
                  ec.[EngagementCategoryPriority]
             FROM [EngagementCategoryContact] AS ecc
                  INNER JOIN [Engagementcategory] AS ec ON ecc.[EngagementCategoryKey] = ec.[EngagementCategoryKey]
            WHERE ecc.[Contactkey] = @toContactKey
            ORDER BY ec.[EngagementCategoryPriority];
    INSERT INTO @fromCategory
           SELECT ecc.[EngagementCategoryContactKey],
                  ecc.[EngagementScoreKey],
                  ecc.[ScoreYear],
                  ecc.[ScoreMonth],
                  ecc.[ScoreWeek],
                  ecc.[EngagementCategoryKey],
                  ec.[EngagementCategoryPriority]
             FROM [EngagementCategoryContact] AS ecc
                  INNER JOIN [Engagementcategory] AS ec ON ecc.[EngagementCategoryKey] = ec.[EngagementCategoryKey]
            WHERE ecc.[Contactkey] = @fromContactKey
            ORDER BY ec.[EngagementCategoryPriority];
    
         
    
    -- We can't really recalculate categories here.  We just update data points where
    -- both contacts have categories to give the remaining category the higher of the two,
    -- and we insert missing categories into the "to" contact.
    UPDATE [EngagementCategoryContact]
       SET
           [EngagementCategoryKey] = fc.[EngagementCategoryKey]
      FROM @fromCategory fc
           INNER JOIN @toCategory tc ON fc.[ScoreYear] = tc.[ScoreYear] AND fc.[ScoreMonth] = tc.[ScoreMonth] AND fc.[ScoreWeek] = tc.[ScoreWeek] AND fc.[EngagementCategoryPriority] < tc.[EngagementCategoryPriority]
     WHERE [EngagementCategoryContact].[EngagementCategoryContactKey] = tc.[EngagementCategoryContactKey];
    INSERT INTO [EngagementCategoryContact]
           SELECT NEWID(),
                  @toContactKey,
                  fc.[EngagementScoreKey],
                  fc.[ScoreYear],
                  fc.[ScoreMonth],
                  fc.[ScoreWeek],
                  fc.[EngagementCategoryKey]
             FROM @fromCategory AS fc
            WHERE NOT EXISTS (SELECT 1
                                FROM @toCategory
                               WHERE [EngagementScoreKey] = fc.[EngagementScoreKey] AND [ScoreYear] = fc.[ScoreYear] AND [ScoreMonth] = fc.[ScoreMonth] AND [ScoreWeek] = fc.[ScoreWeek]
                             );
    DELETE [EngagementCategoryContact]
     WHERE [Contactkey] = @fromContactKey;

	 IF  EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[CalculatedEngagementScore]') AND name = N'IX_CalculatedEngagementScore_ContactKey')
        DROP INDEX [IX_CalculatedEngagementScore_ContactKey] ON [dbo].[CalculatedEngagementScore] WITH ( ONLINE = OFF )

END;
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_MergeFinancialGroups]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_MergeFinancialGroups]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO



CREATE PROCEDURE [dbo].[asi_MergeFinancialGroups] 
    @fromContactId varchar(10), 
    @toContactId varchar(10)
AS
BEGIN
       SET NOCOUNT ON;

    --collect existing groups (product codes) for toParty
     DECLARE @ToPartyExistingGroups TABLE  (
        [GroupId] varchar(31)
     );

     WITH ExistingGroups
        AS (
        SELECT [PRODUCT_CODE] AS [GroupId]
          FROM [dbo].[Subscriptions]
         WHERE [ID] = @toContactId
        )
     INSERT INTO @ToPartyExistingGroups ([GroupId]) SELECT [GroupId] FROM ExistingGroups;

   --merge records that are only in the fromContact
      UPDATE [dbo].[Subscriptions]
         SET [ID] = @toContactId
       WHERE [ID] = @fromContactId
         AND [PRODUCT_CODE] NOT IN (SELECT [GroupId] FROM  @ToPartyExistingGroups);

   --extend record dates where there are matching records
     UPDATE toPartySubscriptions
            SET [BEGIN_DATE] = CASE WHEN toPartySubscriptions.[BEGIN_DATE] IS NOT NULL
                                     AND fromPartySubscriptions.[BEGIN_DATE] IS NOT NULL
                                     AND fromPartySubscriptions.[BEGIN_DATE] < toPartySubscriptions.[BEGIN_DATE]
                                    THEN fromPartySubscriptions.[BEGIN_DATE]
                                    WHEN toPartySubscriptions.[BEGIN_DATE] IS NULL
                                     AND fromPartySubscriptions.[BEGIN_DATE] IS NOT NULL
                                    THEN fromPartySubscriptions.[BEGIN_DATE]
                                    ELSE toPartySubscriptions.[BEGIN_DATE]
                                     END,
                [CONTINUOUS_SINCE] = CASE WHEN toPartySubscriptions.[CONTINUOUS_SINCE] IS NOT NULL
                                       AND fromPartySubscriptions.[CONTINUOUS_SINCE] IS NOT NULL
                                       AND fromPartySubscriptions.[CONTINUOUS_SINCE] < toPartySubscriptions.[CONTINUOUS_SINCE]
                                      THEN fromPartySubscriptions.[CONTINUOUS_SINCE]
                                      WHEN toPartySubscriptions.[CONTINUOUS_SINCE] IS NULL
                                       AND fromPartySubscriptions.[CONTINUOUS_SINCE] IS NOT NULL
                                      THEN fromPartySubscriptions.[CONTINUOUS_SINCE]
                                      ELSE toPartySubscriptions.[CONTINUOUS_SINCE]
                                       END,
                [BILL_THRU] = CASE WHEN toPartySubscriptions.[BILL_THRU] IS NOT NULL
                                       AND fromPartySubscriptions.[BILL_THRU] IS NOT NULL
                                       AND fromPartySubscriptions.[BILL_THRU] < toPartySubscriptions.[BILL_THRU]
                                      THEN fromPartySubscriptions.[BILL_THRU]
                                      WHEN toPartySubscriptions.[BILL_THRU] IS NULL
                                       AND fromPartySubscriptions.[BILL_THRU] IS NOT NULL
                                      THEN fromPartySubscriptions.[BILL_THRU]
                                      ELSE toPartySubscriptions.[BILL_THRU]
                                       END,
                [PAID_THRU] = CASE WHEN toPartySubscriptions.[PAID_THRU] IS NOT NULL
                                       AND fromPartySubscriptions.[PAID_THRU] IS NOT NULL
                                       AND fromPartySubscriptions.[PAID_THRU] < toPartySubscriptions.[PAID_THRU]
                                      THEN fromPartySubscriptions.[PAID_THRU]
                                      WHEN toPartySubscriptions.[PAID_THRU] IS NULL
                                       AND fromPartySubscriptions.[PAID_THRU] IS NOT NULL
                                      THEN fromPartySubscriptions.[PAID_THRU]
                                      ELSE toPartySubscriptions.[PAID_THRU]
                                       END,
                [LAST_PAID_THRU] = CASE WHEN toPartySubscriptions.[LAST_PAID_THRU] IS NOT NULL
                                       AND fromPartySubscriptions.[LAST_PAID_THRU] IS NOT NULL
                                       AND fromPartySubscriptions.[LAST_PAID_THRU] < toPartySubscriptions.[LAST_PAID_THRU]
                                     THEN fromPartySubscriptions.[LAST_PAID_THRU]
                                      WHEN toPartySubscriptions.[LAST_PAID_THRU] IS NULL
                                       AND fromPartySubscriptions.[LAST_PAID_THRU] IS NOT NULL
                                      THEN fromPartySubscriptions.[LAST_PAID_THRU]
                                      ELSE toPartySubscriptions.[LAST_PAID_THRU]
                                       END,
                [FUTURE_CREDITS] = toPartySubscriptions.[FUTURE_CREDITS] + fromPartySubscriptions.[FUTURE_CREDITS]
           FROM [dbo].[Subscriptions] toPartySubscriptions
     INNER JOIN @ToPartyExistingGroups g ON g.[GroupId] = toPartySubscriptions.[PRODUCT_CODE]
     INNER JOIN [dbo].[Subscriptions] fromPartySubscriptions ON fromPartySubscriptions.[PRODUCT_CODE] = toPartySubscriptions.[PRODUCT_CODE]   
          WHERE toPartySubscriptions.[ID] = @toContactId
            AND fromPartySubscriptions.[ID] = @fromContactId
  
    --make sure the gaining party gets the highest billing date data in the Name_Fin table
    UPDATE toNameFinTable
      SET [RENEWED_THRU] = CASE WHEN fromNameFinTable.[RENEWED_THRU] IS NOT NULL
                               AND toNameFinTable.[RENEWED_THRU] IS NOT NULL
                               AND fromNameFinTable.[RENEWED_THRU] > toNameFinTable.[RENEWED_THRU]
                              THEN fromNameFinTable.[RENEWED_THRU]
                              WHEN toNameFinTable.[RENEWED_THRU] IS NULL
                               AND fromNameFinTable.[RENEWED_THRU] IS NOT NULL
                              THEN fromNameFinTable.[RENEWED_THRU]
                              ELSE toNameFinTable.[RENEWED_THRU]
                               END
     FROM [dbo].[Name_Fin] toNameFinTable, [dbo].[Name_Fin] fromNameFinTable
    WHERE toNameFinTable.[ID] = @toContactId
      AND fromNameFinTable.[ID] = @fromContactId;   

   --delete fromContact records
   DELETE [dbo].[Subscriptions] WHERE [ID] = @fromContactId

END



GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_MergeFullAddressesDeleteDuplicatePurposes]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_MergeFullAddressesDeleteDuplicatePurposes]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO



/*=========================================================================
This procedure will merge all addresses between parties, excepting that the
system-based purpose addresses (such as 'Address' or 'Home Address') will
only be moved if the gaining party doesn't already have an entry.  Then the
losing party's addresses will be deleted.
TODO: Individual fields not xferred if empty in gaining party's existing system-purpose addresses
=========================================================================*/
CREATE PROCEDURE [dbo].[asi_MergeFullAddressesDeleteDuplicatePurposes] 
       @fromContactId varchar(10), 
       @toContactId varchar(10)
AS
BEGIN
       SET NOCOUNT ON;

       DECLARE @fromAddress1Key int,
               @fromAddress2Key int,
               @fromAddress3Key int,
               @toAddress1Key int,
               @toAddress2Key int,
               @toAddress3Key int,
               @toAddressShipKey int;
      
       --retrieve the three system purpose address keys for both parties, guarding against data corruption (record doesn't exist)
       --note that we also guard against all three addresses ending up with same address key (default setting when creating party)
       SET @fromAddress1Key = COALESCE ((SELECT [ADDRESS_NUM_1] 
                                          FROM [dbo].[Name] n1
                                    INNER JOIN [dbo].[Name_Address] add1 ON add1.[ADDRESS_NUM] = n1.[ADDRESS_NUM_1]
                                         WHERE n1.[ID] = @fromContactId),0);

       SET @toAddress1Key = COALESCE ((SELECT [ADDRESS_NUM_1] 
                                          FROM [dbo].[Name] n1
                                    INNER JOIN [dbo].[Name_Address] add1 ON add1.[ADDRESS_NUM] = n1.[ADDRESS_NUM_1]
                                         WHERE n1.[ID] = @toContactId),0);

       SET @fromAddress2Key = COALESCE ((SELECT [ADDRESS_NUM_2] 
                                          FROM [dbo].[Name] n1
                                    INNER JOIN [dbo].[Name_Address] add1 ON add1.[ADDRESS_NUM] = n1.[ADDRESS_NUM_2]
                                         WHERE n1.[ID] = @fromContactId
                                           AND n1.[ADDRESS_NUM_2] != n1.[ADDRESS_NUM_1]),0);

       SET @toAddress2Key = COALESCE ((SELECT [ADDRESS_NUM_2] 
                                          FROM [dbo].[Name] n1
                                    INNER JOIN [dbo].[Name_Address] add1 ON add1.[ADDRESS_NUM] = n1.[ADDRESS_NUM_2]
                                         WHERE n1.[ID] = @toContactId
                                           AND n1.[ADDRESS_NUM_2] != n1.[ADDRESS_NUM_1]),0);

      SET @fromAddress3Key = COALESCE ((SELECT [ADDRESS_NUM_3] 
                                          FROM [dbo].[Name] n1
                                    INNER JOIN [dbo].[Name_Address] add1 ON add1.[ADDRESS_NUM] = n1.[ADDRESS_NUM_3]
                                         WHERE n1.[ID] = @fromContactId
                                           AND n1.[ADDRESS_NUM_3] != n1.[ADDRESS_NUM_1]),0);

       SET @toAddress3Key = COALESCE ((SELECT [ADDRESS_NUM_3] 
                                          FROM [dbo].[Name] n1
                                    INNER JOIN [dbo].[Name_Address] add1 ON add1.[ADDRESS_NUM] = n1.[ADDRESS_NUM_3]
                                         WHERE n1.[ID] = @toContactId
                                           AND n1.[ADDRESS_NUM_3] != n1.[ADDRESS_NUM_1]),0);
        
        SET @toAddressShipKey = COALESCE ((SELECT [SHIP_ADDRESS_NUM] 
                                          FROM [dbo].[Name] n1
                                    INNER JOIN [dbo].[Name_Address] add1 ON add1.[ADDRESS_NUM] = n1.[SHIP_ADDRESS_NUM]
                                         WHERE n1.[ID] = @toContactId),0);

       --clear the preferred settings for the fromParty 
       UPDATE [dbo].[Name_Address]
          SET [PREFERRED_MAIL] = 0,
              [PREFERRED_BILL] = 0,
              [PREFERRED_SHIP] = 0
        WHERE [ID] = @fromContactId
       
       --transfer any of the system purpose addresses that are missing from toParty and exist in fromParty
       IF @fromAddress1Key > 0 AND @toAddress1Key = 0
           BEGIN
                UPDATE [dbo].[Name]
                   SET [ADDRESS_NUM_1] = @fromAddress1Key
                WHERE [ID] = @toContactId;

                UPDATE [dbo].[Name_Address]
                   SET [ID] = @toContactId
                 WHERE [ID] = @fromContactId
                   AND [ADDRESS_NUM] = @fromAddress1Key
           END;

       IF @fromAddress2Key > 0 AND @toAddress2Key = 0
           BEGIN
                UPDATE [dbo].[Name]
                   SET [ADDRESS_NUM_2] = @fromAddress2Key
                WHERE [ID] = @toContactId;

                UPDATE [dbo].[Name_Address]
                   SET [ID] = @toContactId
                 WHERE [ID] = @fromContactId
                   AND [ADDRESS_NUM] = @fromAddress2Key
           END;

       IF @fromAddress3Key > 0 AND @toAddress3Key = 0
           BEGIN
                UPDATE [dbo].[Name]
                   SET [ADDRESS_NUM_3] = @fromAddress3Key
                WHERE [ID] = @toContactId;

                UPDATE [dbo].[Name_Address]
                   SET [ID] = @toContactId
                 WHERE [ID] = @fromContactId
                   AND [ADDRESS_NUM] = @fromAddress3Key
           END;

       -- selectively update values where the toParty does not have an address element that the fromParty does have
       IF @fromAddress1Key > 0 AND @toAddress1Key > 0
           BEGIN
                -- populate physical address values if they are blank
                UPDATE toAddress
                   SET toAddress.[ADDRESS_1] = fromAddress.[ADDRESS_1],
                       toAddress.[ADDRESS_2] = fromAddress.[ADDRESS_2],
                       toAddress.[ADDRESS_3] = fromAddress.[ADDRESS_3],
                       toAddress.[CITY] = fromAddress.[CITY],
                       toAddress.[STATE_PROVINCE] = fromAddress.[STATE_PROVINCE],
                       toAddress.[ZIP] = fromAddress.[ZIP],
                       toAddress.[COUNTRY] = fromAddress.[COUNTRY],
                       toAddress.[FULL_ADDRESS] = fromAddress.[FULL_ADDRESS]
                  FROM [dbo].[Name_Address] fromAddress 
                        CROSS JOIN [dbo].[Name_Address] toAddress
                WHERE fromAddress.[ADDRESS_NUM] = @fromAddress1Key
                  AND toAddress.[ADDRESS_NUM] = @toAddress1Key
                  AND  toAddress.[ADDRESS_1] = ''
                  AND  toAddress.[ADDRESS_2] = ''
                  AND  toAddress.[ADDRESS_3] = ''
                  AND  toAddress.[CITY] = ''
                  AND  toAddress.[STATE_PROVINCE] = ''
                  AND  toAddress.[ZIP] = ''
                  -- We're not checking that the toAddress's country is blank.
                  -- If the rest of the physical address is blank in the ToParty,
                  -- overwrite the ToParty's country.

                -- populate phone value if it is blank
                UPDATE toAddress
                   SET toAddress.[PHONE] = fromAddress.[PHONE]
                  FROM [dbo].[Name_Address] fromAddress 
                        CROSS JOIN [dbo].[Name_Address] toAddress
                WHERE fromAddress.[ADDRESS_NUM] = @fromAddress1Key
                  AND toAddress.[ADDRESS_NUM] = @toAddress1Key
                  AND  toAddress.[PHONE] = ''

                -- populate fax value if it is blank
                UPDATE toAddress
                   SET toAddress.[FAX] = fromAddress.[FAX]
                  FROM [dbo].[Name_Address] fromAddress 
                        CROSS JOIN [dbo].[Name_Address] toAddress
                WHERE fromAddress.[ADDRESS_NUM] = @fromAddress1Key
                  AND toAddress.[ADDRESS_NUM] = @toAddress1Key
                  AND  toAddress.[FAX] = ''

                -- populate toll_free value if it is blank
                UPDATE toAddress
                   SET toAddress.[TOLL_FREE] = fromAddress.[TOLL_FREE]
                  FROM [dbo].[Name_Address] fromAddress 
                        CROSS JOIN [dbo].[Name_Address] toAddress
                WHERE fromAddress.[ADDRESS_NUM] = @fromAddress1Key
                  AND toAddress.[ADDRESS_NUM] = @toAddress1Key
                  AND  toAddress.[TOLL_FREE] = ''

                -- populate email value if it is blank
                UPDATE toAddress
                   SET toAddress.[EMAIL] = fromAddress.[EMAIL]
                  FROM [dbo].[Name_Address] fromAddress 
                        CROSS JOIN [dbo].[Name_Address] toAddress
                WHERE fromAddress.[ADDRESS_NUM] = @fromAddress1Key
                  AND toAddress.[ADDRESS_NUM] = @toAddress1Key
                  AND  toAddress.[EMAIL] = ''
                  
                -- populate note value if it is blank
                UPDATE toAddress
                   SET toAddress.[NOTE] = fromAddress.[NOTE]
                  FROM [dbo].[Name_Address] fromAddress 
                        CROSS JOIN [dbo].[Name_Address] toAddress
                WHERE fromAddress.[ADDRESS_NUM] = @fromAddress1Key
                  AND toAddress.[ADDRESS_NUM] = @toAddress1Key
                  AND toAddress.[NOTE] IS NULL
 
       END

       --move over all remaining addresses that are not included in system purpose
       UPDATE [dbo].[Name_Address]
          SET ID = @toContactId
        WHERE [ID] = @fromContactId
          AND [ADDRESS_NUM] NOT IN ( @fromAddress1Key, @fromAddress2Key, @fromAddress3Key)
          
       --identify all addresses that are about to be deleted and ensure that any Orders, Order_Badge, or Name_PL_Pref entries using them are also updated
       DECLARE @fromAddressesToDelete TABLE(AddressKey int NOT NULL)
       
       INSERT @fromAddressesToDelete(AddressKey)
       SELECT na.[ADDRESS_NUM]  
         FROM dbo.[Name_Address] na
        WHERE na.[ID] = @fromContactId
        
       UPDATE o
          SET [ST_ADDRESS_NUM] = @toAddressShipKey
         FROM [dbo].[Orders] o INNER JOIN @fromAddressesToDelete a ON o.[ST_ADDRESS_NUM] = a.[AddressKey]
        
       UPDATE ob
          SET [ADDRESS_NUM] = @toAddressShipKey
         FROM [dbo].[Order_Badge] ob INNER JOIN @fromAddressesToDelete a ON ob.[ADDRESS_NUM] = a.[AddressKey]

        --now delete remaining system purpose addresses for from-party
        DELETE [dbo].[Name_Address]
         WHERE [ID] = @fromContactId
      
        --restore the full address required for legacy desktop and reports
          UPDATE n
          SET n.[FULL_ADDRESS] = na.[FULL_ADDRESS],
              n.[CITY] = na.[CITY],
              n.[STATE_PROVINCE] = na.[STATE_PROVINCE],
              n.[ZIP] = na.[ZIP],
              n.[COUNTRY] = na.[COUNTRY],
              n.[COUNTY] = na.[COUNTY],
              n.[CRRT] = na.[CRRT],
              n.[BAR_CODE] = na.[BAR_CODE]
         FROM [dbo].[Name] n
              INNER JOIN [dbo].[Name_Address] na ON n.[MAIL_ADDRESS_NUM] = na.[ADDRESS_NUM] AND n.[ID] = @toContactId;
       
END




GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_MergeGroups]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_MergeGroups]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_MergeGroups]
       @fromContactId varchar(10),
       @toContactId   varchar(10)
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @currentDate datetime;
    DECLARE @fromContactKey uniqueidentifier;
    DECLARE @toContactKey uniqueidentifier;

    --need our guid keys
    SELECT @fromContactKey = [ContactKey]
      FROM [dbo].[ContactMain]
     WHERE [SyncContactID] = @fromContactId;

    SELECT @toContactKey = [ContactKey]
      FROM [dbo].[ContactMain]
     WHERE [SyncContactID] = @toContactId;

    SELECT @currentDate = dbo.asi_GetAppDatetime();

    --make sure the gaining party gets the group-related data in the Name table
    UPDATE [toNameTable]
       SET [JOIN_DATE] = CASE WHEN [fromNameTable].[JOIN_DATE] IS NOT NULL AND [toNameTable].[JOIN_DATE] IS NOT NULL AND [fromNameTable].[JOIN_DATE] < [toNameTable].[JOIN_DATE]
                              THEN [fromNameTable].[JOIN_DATE] WHEN [toNameTable].[JOIN_DATE] IS NULL AND [fromNameTable].[JOIN_DATE] IS NOT NULL
                              THEN [fromNameTable].[JOIN_DATE]
                              ELSE [toNameTable].[JOIN_DATE]
                         END,
           -- Choose proper MEMBER_STATUS based on MEMBER_STATUS_DATE
           [MEMBER_STATUS] = CASE WHEN [fromNameTable].[MEMBER_STATUS_DATE] IS NOT NULL AND [toNameTable].[MEMBER_STATUS_DATE] IS NOT NULL AND [fromNameTable].[MEMBER_STATUS_DATE] > [toNameTable].[MEMBER_STATUS_DATE]
                                  THEN [fromNameTable].[MEMBER_STATUS] WHEN [toNameTable].[MEMBER_STATUS_DATE] IS NULL AND [fromNameTable].[MEMBER_STATUS_DATE] IS NOT NULL
                                  THEN [fromNameTable].[MEMBER_STATUS]
                                  ELSE [toNameTable].[MEMBER_STATUS]
                             END,
           [MEMBER_STATUS_DATE] = CASE WHEN [fromNameTable].[MEMBER_STATUS_DATE] IS NOT NULL AND [toNameTable].[MEMBER_STATUS_DATE] IS NOT NULL AND [fromNameTable].[MEMBER_STATUS_DATE] > [toNameTable].[MEMBER_STATUS_DATE]
                                       THEN [fromNameTable].[MEMBER_STATUS_DATE] WHEN [toNameTable].[MEMBER_STATUS_DATE] IS NULL AND [fromNameTable].[MEMBER_STATUS_DATE] IS NOT NULL
                                       THEN [fromNameTable].[MEMBER_STATUS_DATE]
                                       ELSE [toNameTable].[MEMBER_STATUS_DATE]
                                  END,
           -- Choose proper PAID_THRU 
           [PAID_THRU] = CASE WHEN [fromNameTable].[PAID_THRU] IS NOT NULL AND [toNameTable].[PAID_THRU] IS NOT NULL AND [fromNameTable].[PAID_THRU] > [toNameTable].[PAID_THRU]
                              THEN [fromNameTable].[PAID_THRU] WHEN [toNameTable].[PAID_THRU] IS NULL AND [fromNameTable].[PAID_THRU] IS NOT NULL
                              THEN [fromNameTable].[PAID_THRU]
                              ELSE [toNameTable].[PAID_THRU]
                         END
      FROM [dbo].[Name] [toNameTable], [dbo].[Name] [fromNameTable]
     WHERE [toNameTable].[ID] = @toContactId AND [fromNameTable].[ID] = @fromContactId;

    --update group exipration dates where fromParty and toParty have matching groups and roles - favor the longer fromParty date
    --update group effective dates as well - favor the earlier date.  Also pass along the active flag if active
    --do not update dates where from party has already reached their expiration
    --do not update expiration dates where from-party's membership started after the to-party's membership 
    --do not update any historical data (either membership ended on or before current date)
    UPDATE [toGroupMemberDetail]
       SET [ExpirationDate] = CASE WHEN [fromGroupMemberDetail].[ExpirationDate] IS NOT NULL AND [toGroupMemberDetail].[ExpirationDate] IS NOT NULL AND [fromGroupMemberDetail].[ExpirationDate] > [toGroupMemberDetail].[ExpirationDate] AND [fromGroupMemberDetail].[EffectiveDate] < [toGroupMemberDetail].[ExpirationDate]
                                   THEN [fromGroupMemberDetail].[ExpirationDate] WHEN [fromGroupMemberDetail].[ExpirationDate] IS NULL AND [fromGroupMemberDetail].[IsActive] = 1
                                   THEN [fromGroupMemberDetail].[ExpirationDate]
                                   ELSE [toGroupMemberDetail].[ExpirationDate]
                              END,
           [EffectiveDate] = CASE WHEN [fromGroupMemberDetail].[EffectiveDate] IS NOT NULL AND [toGroupMemberDetail].[EffectiveDate] IS NOT NULL AND [fromGroupMemberDetail].[EffectiveDate] < [toGroupMemberDetail].[EffectiveDate]
                                  THEN [fromGroupMemberDetail].[EffectiveDate]
                                  ELSE [toGroupMemberDetail].[EffectiveDate]
                             END,
           [IsActive] = CASE WHEN [fromGroupMemberDetail].[IsActive] = 1
                             THEN 1
                             ELSE [toGroupMemberDetail].[IsActive]
                        END,
           [GroupMemberStatusCode] = CASE WHEN [fromGroupMemberDetail].[IsActive] = 1 AND [toGroupMemberDetail].[IsActive] = 0
                                          THEN [fromGroupMemberDetail].[GroupMemberStatusCode]
                                          ELSE [toGroupMemberDetail].[GroupMemberStatusCode]
                                     END
      FROM [dbo].[GroupMemberDetail] [toGroupMemberDetail]
           INNER JOIN [dbo].[GroupMemberDetail] [fromGroupMemberDetail] ON [toGroupMemberDetail].[GroupKey] = [fromGroupMemberDetail].[GroupKey] AND [toGroupMemberDetail].[GroupRoleKey] = [fromGroupMemberDetail].[GroupRoleKey]
           INNER JOIN [dbo].[GroupMember] [toGroupMember] ON [toGroupMember].[GroupMemberKey] = [toGroupMemberDetail].[GroupMemberKey]
           INNER JOIN [dbo].[GroupMember] [fromGroupMember] ON [fromGroupMember].[GroupMemberKey] = [fromGroupMemberDetail].[GroupMemberKey]
     WHERE [toGroupMember].[MemberContactKey] = @toContactKey AND [fromGroupMember].[MemberContactKey] = @fromContactKey AND ([fromGroupMemberDetail].[ExpirationDate] IS NULL OR [fromGroupMemberDetail].[ExpirationDate] > @currentDate) AND ([toGroupMemberDetail].[ExpirationDate] IS NULL OR [toGroupMemberDetail].[ExpirationDate] > @currentDate);
    
    --update group active flag where fromParty and toParty have matching groups  
    UPDATE [toGroupMember]
       SET [DropDate] = CASE WHEN [FromGroupMember].[DropDate] IS NOT NULL AND [toGroupMember].[DropDate] IS NOT NULL AND [fromGroupMember].[DropDate] > [toGroupMember].[DropDate]
                             THEN [fromGroupMember].[DropDate] WHEN [fromGroupMember].[DropDate] IS NULL AND [fromGroupMember].[IsActive] = 1
                             THEN [fromGroupMember].[DropDate]
                             ELSE [toGroupMember].[DropDate]
                        END,
           [IsActive] = CASE WHEN [fromGroupMember].[IsActive] = 1
                             THEN 1
                             ELSE [toGroupMember].[IsActive]
                        END
      FROM [dbo].[GroupMember] [toGroupMember]
           INNER JOIN [dbo].[GroupMember] [fromGroupMember] ON [toGroupMember].[GroupKey] = [fromGroupMember].[GroupKey]
     WHERE [toGroupMember].[MemberContactKey] = @toContactKey AND [fromGroupMember].[MemberContactKey] = @fromContactKey;

    --add roles where fromParty and toParty share groups but fromParty has extra roles
    UPDATE [fromGroupMemberDetail]
       SET [GroupMemberKey] = [toGroupMemberDetail].[GroupMemberKey]
      FROM [dbo].[GroupMemberDetail] [fromGroupMemberDetail]
           INNER JOIN [dbo].[GroupMemberDetail] [toGroupMemberDetail] ON [fromGroupMemberDetail].[GroupKey] = [toGroupMemberDetail].[GroupKey]
           INNER JOIN [dbo].[GroupMember] [toGroupMember] ON [toGroupMember].[GroupMemberKey] = [toGroupMemberDetail].[GroupMemberKey]
           INNER JOIN [dbo].[GroupMember] [fromGroupMember] ON [fromGroupMember].[GroupMemberKey] = [fromGroupMemberDetail].[GroupMemberKey]
     WHERE [toGroupMember].[MemberContactKey] = @toContactKey 
       AND [fromGroupMember].[MemberContactKey] = @fromContactKey 
       AND ([fromGroupMemberDetail].[ExpirationDate] IS NULL 
         OR [fromGroupMemberDetail].[ExpirationDate] > @currentDate) AND ([toGroupMemberDetail].[ExpirationDate] IS NULL 
         OR [toGroupMemberDetail].[ExpirationDate] > @currentDate) AND NOT EXISTS (SELECT TOP 1 [GroupRoleKey]
                                                                                     FROM [dbo].[GroupMemberDetail] AS [dd]
                                                                                          INNER JOIN [dbo].[GroupMember] AS [gm] ON [gm].[GroupMemberKey] = [dd].[GroupMemberKey]
                                                                                    WHERE [gm].[MemberContactKey] = @toContactKey AND [dd].[GroupRoleKey] = [fromGroupMemberDetail].[GroupRoleKey]
           );

    --now transfer any historical memberships as is - even if duplicate
    --also transfer future memberships if the current membership has expired
    UPDATE [fromGroupMemberDetail]
       SET [GroupMemberKey] = [toGroupMemberDetail].[GroupMemberKey]
      FROM [dbo].[GroupMemberDetail] [fromGroupMemberDetail]
           INNER JOIN [dbo].[GroupMemberDetail] [toGroupMemberDetail] ON [fromGroupMemberDetail].[GroupKey] = [toGroupMemberDetail].[GroupKey]
           INNER JOIN [dbo].[GroupMember] [toGroupMember] ON [toGroupMember].[GroupMemberKey] = [toGroupMemberDetail].[GroupMemberKey]
           INNER JOIN [dbo].[GroupMember] [fromGroupMember] ON [fromGroupMember].[GroupMemberKey] = [fromGroupMemberDetail].[GroupMemberKey]
     WHERE [toGroupMember].[MemberContactKey] = @toContactKey 
       AND [fromGroupMember].[MemberContactKey] = @fromContactKey 
       AND ( ( --this picks up historical records
               [fromGroupMemberDetail].[ExpirationDate] IS NOT NULL 
           AND [fromGroupMemberDetail].[EffectiveDate] IS NOT NULL 
           AND [fromGroupMemberDetail].[ExpirationDate] <= @currentDate 
           AND [fromGroupMemberDetail].[EffectiveDate] != [toGroupMemberDetail].[EffectiveDate]) 
          OR ( --this brings over future records where existing role will expire
               [toGroupMemberDetail].[ExpirationDate] IS NOT NULL 
           AND [fromGroupMemberDetail].[EffectiveDate] IS NOT NULL 
           AND [toGroupMemberDetail].[ExpirationDate] <= [fromGroupMemberDetail].[EffectiveDate] 
           AND [fromGroupMemberDetail].[EffectiveDate] > @currentDate)
           );

    --add the groups that the fromParty has but the toParty doesn't have
    UPDATE [fromGroupMember]
       SET [MemberContactKey] = @toContactKey
      FROM [dbo].[GroupMember] [fromGroupMember]
     WHERE [fromGroupMember].[MemberContactKey] = @fromContactKey AND NOT EXISTS (SELECT [MemberContactKey]
                                                                                    FROM [dbo].[GroupMember]
                                                                                   WHERE [MemberContactKey] = @toContactKey AND [GroupKey] = [fromGroupMember].[GroupKey]
    );

    --delete the fromParty memberships
    DELETE FROM [dbo].[GroupMemberDetail]
     WHERE [GroupMemberKey] IN (SELECT [GroupMemberKey]
                                  FROM [dbo].[GroupMember]
                                 WHERE [MemberContactKey] = @fromContactKey
                                );
    DELETE FROM [dbo].[GroupMember]
     WHERE [MemberContactKey] = @fromContactKey;
END;


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_MergeMultiInstanceUserDefinedData]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_MergeMultiInstanceUserDefinedData]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


CREATE PROCEDURE [dbo].[asi_MergeMultiInstanceUserDefinedData] 
    @fromContactId varchar(10), 
    @toContactId varchar(10)
AS
BEGIN
    SET NOCOUNT ON;
    
    -- First move across multi-instance records the toParty doesn't have
    UPDATE fromParty
       SET fromParty.[RowID] = @toContactId
      FROM [dbo].[UserDefinedMultiInstanceProperty] fromParty
     WHERE fromParty.[RowID] = @fromContactId
       AND NOT EXISTS (SELECT 1 FROM [dbo].[UserDefinedMultiInstanceProperty] 
                        WHERE [RowID] = @toContactId 
                          AND [TableName] = fromParty.[TableName]
                          AND [PropertyName] = fromParty.[PropertyName])
                          
    -- Next, merge in common rows mindful of keeping the sequence numbers unique
    INSERT INTO dbo.UserDefinedMultiInstanceProperty (TableName, PropertyName, RowID, RowKey, RowSequence, PropertyIntValue,
                                                      PropertyDateTimeValue, PropertyGuidValue, PropertyDecimalValue,
                                                      PropertyBooleanValue, PropertyStringValue)
        SELECT udm.TableName, udm.PropertyName, @toContactId, udm.RowKey, 
               (SELECT MAX(RowSequence) FROM dbo.UserDefinedMultiInstanceProperty udm2
                 WHERE udm2.TableName = udm.TableName AND udm2.PropertyName = udm.PropertyName AND udm2.RowID = @toContactId
                ) + ROW_NUMBER() OVER (PARTITION BY RowID, TableName, PropertyName ORDER BY RowSequence), 
               udm.PropertyIntValue, udm.PropertyDateTimeValue, udm.PropertyGuidValue, 
               udm.PropertyDecimalValue, udm.PropertyBooleanValue, udm.PropertyStringValue
          FROM dbo.UserDefinedMultiInstanceProperty udm
         WHERE RowID = @fromContactId
         ORDER BY udm.TableName, udm.PropertyName, udm.RowSequence
      
    -- Now remove any remaining fromParty records
    DELETE FROM [dbo].[UserDefinedMultiInstanceProperty]
     WHERE [RowID] = @fromContactId
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_MergePartyReferences]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_MergePartyReferences]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_MergePartyReferences]
       @fromContactId varchar(10), 
       @toContactId varchar(10)
AS
BEGIN
    DECLARE @tempProcessingStatement nvarchar(max);
    DECLARE @errorMessage nvarchar(max);
    SET @errorMessage = '';
    DECLARE @fromContactKey uniqueidentifier ;
    DECLARE @toContactKey uniqueidentifier;
    DECLARE @toKey nvarchar(50);
    DECLARE @fromKey nvarchar(50);
    DECLARE @tempReferencesRowCount int;
    DECLARE @currentTable sysname;
    DECLARE @currentColumn sysname;
    DECLARE @currentOperation nvarchar(10);

    SET @tempReferencesRowCount = (SELECT MAX([ProcessingOrder]) FROM [dbo].[PartyMergeSchemaReference]);
    SET @fromContactKey = (SELECT [ContactKey] FROM [dbo].[ContactMain] WHERE [SyncContactID] = @fromContactId AND [IsInstitute] = 0);
    SET @toContactKey = (SELECT [ContactKey] FROM [dbo].[ContactMain] WHERE [SyncContactID] = @toContactId AND [IsInstitute] = 0);


    DECLARE @counter int;
    SET @counter = 0;

    WHILE (@counter < @tempReferencesRowCount)
    BEGIN
        SET @counter += 1;
        --The following processing types explained:
        -- DATAUPDATE - Replace to-party's data column value if NULL with from-party data column value.
        -- NODUPEKEY - If previous to-party record exists, we keep it and delete from-party or else switch keys.  This prevents duplicate key errors in certain tables.
        -- NOCOMBOKEY - Similar to NODUPEKEY but the value of two columns is used to determine the key
        -- UPDATE - Switched out the from-party's key with the to-party's key without any checks
        -- DELETE - Deletes the from-part record so order of table in list is important
        BEGIN TRY
            SELECT
               @currentColumn = [ColumnName],
               @currentTable = [TableName],
               @currentOperation = [ProcessingType],
               @toKey = CASE WHEN [UseGuidKey] = 1 THEN  CONVERT(nvarchar(50), @toContactKey) ELSE @toContactId END,
               @fromKey = CASE WHEN [UseGuidKey] = 1 THEN  CONVERT(nvarchar(50), @fromContactKey) ELSE @fromContactId END,
               @tempProcessingStatement = 
               CASE WHEN [ProcessingType] = N'NODUPEKEY' THEN N'IF NOT EXISTS (SELECT * FROM '
                        + '[dbo].' + QUOTENAME([TableName]) 
                        + ' WHERE ' + QUOTENAME([ColumnName]) + ' = '''  
                        + @toKey + ''''
                        + ') BEGIN UPDATE'
                        + ' [dbo].' + QUOTENAME([TableName]) 
                        + ' SET ' + QUOTENAME([ColumnName]) + ' = ''' 
                        + @toKey + ''' WHERE ' 
                        + QUOTENAME([ColumnName]) + ' = ''' 
                        + @fromKey + ''''
                        + ' END ELSE BEGIN DELETE FROM [dbo].'
                        + QUOTENAME([TableName])
                        + ' WHERE ' + QUOTENAME([ColumnName]) + ' = ''' 
                        + @fromKey + ''' END'
                    WHEN [ProcessingType] = N'NOCOMBOKEY' THEN N'UPDATE '
                        + ' [dbo].' + QUOTENAME([TableName])
                        + ' SET ' + QUOTENAME([ColumnName]) + ' = ''' 
                        + @toKey + ''' WHERE ' 
                        + QUOTENAME([DataColumnName]) + ' NOT IN ( SELECT fromTable.'
                        + QUOTENAME([DataColumnName]) + ' FROM '
                        + ' [dbo].' + QUOTENAME([TableName]) + ' fromTable JOIN '
                        + ' [dbo].' + QUOTENAME([TableName]) +' toTable ON toTable.'
                        + QUOTENAME([DataColumnName]) + ' = fromTable.'
                        + QUOTENAME([DataColumnName]) + ' WHERE fromTable.'
                        + QUOTENAME([ColumnName]) + ' = ''' + @fromKey + ''' AND toTable.'
                        + QUOTENAME([ColumnName]) + ' = ''' + @toKey + ''') AND '
                        + QUOTENAME([ColumnName])  + ' = ''' + @fromKey + '''; DELETE '
                        + ' [dbo].' + QUOTENAME([TableName])
                        + ' WHERE ' + QUOTENAME([ColumnName]) + ' = '''  
                        + @fromKey + ''''
                    WHEN [ProcessingType] = N'UPDATE' THEN N'UPDATE' 
                        + ' [dbo].' + QUOTENAME([TableName]) 
                        + ' SET ' + QUOTENAME([ColumnName]) + ' = ''' 
                        + @toKey + ''' WHERE ' 
                        + QUOTENAME([ColumnName]) + ' = ''' 
                        + @fromKey + ''''
                   WHEN [ProcessingType] = N'DELETE' THEN N'DELETE'
                        + ' FROM [dbo].' + QUOTENAME([TableName]) + ' WHERE ' 
                        + QUOTENAME([ColumnName]) + ' = ''' + @fromKey + ''''
                   WHEN [ProcessingType] = N'DATAUPDATE' THEN N'UPDATE toTable SET '
                        + QUOTENAME([DataColumnName]) + ' = fromTable.'
                        + QUOTENAME([DataColumnName]) 
                        + ' FROM [dbo].' + QUOTENAME([TableName]) + ' fromTable,'
                        + ' [dbo].' + QUOTENAME([TableName]) + ' toTable'
                       + ' WHERE fromTable.' + QUOTENAME([ColumnName]) + ' = '''
                        + @fromKey + ''''
                        + ' AND toTable.'+ QUOTENAME([ColumnName]) + ' = '''
                        + @toKey + ''''
                        + ' AND (toTable.'+ QUOTENAME([DataColumnName]) + ' IS NULL OR' 
                        + ' DATALENGTH(toTable.'+ QUOTENAME([DataColumnName]) + ') = 0 OR'
                        + ' (ISNUMERIC(toTable.' + QUOTENAME([DataColumnName]) +') = 1 AND' 
                        + ' toTable.' + QUOTENAME([DataColumnName]) + ' = ''0''))'
              END 
              FROM [dbo].[PartyMergeSchemaReference] 
             WHERE [ProcessingOrder] = @counter;
            --PRINT @tempProcessingStatement;
            EXEC (@tempProcessingStatement);
        END TRY
        BEGIN CATCH
           SET @errorMessage  += '**' + 'Number = ' + convert(nvarchar(4), ERROR_NUMBER())
                                + ', ' + 'Severity = ' + convert(nvarchar(4), ERROR_SEVERITY())
                               + ', ' + 'Message = ' + convert(nvarchar(max), ERROR_MESSAGE())
                               + ' : ' + @currentTable + ' - ' + @currentColumn + ' - ' + @currentOperation
                                + CHAR(13);
            
            CONTINUE;
        END CATCH
    END

    IF (@errorMessage <> '')
        RAISERROR(@errorMessage, 16, 1);
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_MergePartyReferencesCustom]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_MergePartyReferencesCustom]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO




--================================================
--This is a blank stored procedure for customer use when
--custom operations are required during the merge of
--two party records.  This stored procedure is called
--'from' contact record and after all references such
--as addresses have been assigned to the gaining contact
--(ToContactKey)
--
--This is an execute-only operation that must only
--hand back an exception if it fails.  The Party 
--Merge service will not handle returned data.
--================================================ 
CREATE PROCEDURE [dbo].[asi_MergePartyReferencesCustom] 
       @FromContactId varchar(10), 
       @ToContactId varchar(10)
AS
BEGIN
    -- placeholder for user-defined code
       SET NOCOUNT ON;

   
       
END;





GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_MergeSingleInstanceUserDefinedData]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_MergeSingleInstanceUserDefinedData]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_MergeSingleInstanceUserDefinedData] 
    @fromContactId varchar(10), 
    @toContactId varchar(10)
AS
BEGIN
    SET NOCOUNT ON;
    -- First move across single instance missing business object entries
    UPDATE fromParty
       SET fromParty.[RowID] = @toContactId
      FROM [dbo].[UserDefinedSingleInstanceProperty] fromParty
     WHERE fromParty.[RowID] = @fromContactId
       AND NOT EXISTS (SELECT 1 FROM [dbo].[UserDefinedSingleInstanceProperty] 
                        WHERE [RowID] = @toContactId 
                          AND [TableName] = fromParty.[TableName])

    -- Now move across single instance properties that exist in fromParty but not in toParty
    UPDATE toParty
       SET [PropertyIntValue] = COALESCE(toParty.[PropertyIntValue], fromParty.[PropertyIntValue]),
           [PropertyDateTimeValue] = COALESCE(toParty.[PropertyDateTimeValue], fromParty.[PropertyDateTimeValue]),
           [PropertyGuidValue] = COALESCE(toParty.[PropertyGuidValue], fromParty.[PropertyGuidValue]),
           [PropertyDecimalValue] = COALESCE(toParty.[PropertyDecimalValue], fromParty.[PropertyDecimalValue]),
           [PropertyBooleanValue] = COALESCE(toParty.[PropertyBooleanValue], fromParty.[PropertyBooleanValue]),
           [PropertyStringValue] = COALESCE(toParty.[PropertyStringValue], fromParty.[PropertyStringValue])
      FROM [dbo].[UserDefinedSingleInstanceProperty] fromParty 
           LEFT JOIN [dbo].[UserDefinedSingleInstanceProperty] toParty ON toParty.[TableName] = fromParty.[TableName] 
                                                                      AND toParty.[PropertyName] = fromParty.[PropertyName]
     WHERE fromParty.[RowID] = @fromContactId
       AND toParty.[RowID] = @toContactId

    -- Finally remove any remaining fromParty records
    DELETE FROM  [dbo].[UserDefinedSingleInstanceProperty]
         WHERE [RowID] = @fromContactId
END


GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_MergeStaticUserDefinedSources]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_MergeStaticUserDefinedSources]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_MergeStaticUserDefinedSources] (@fromID varchar(12), @toID varchar(12))
AS
BEGIN
   /* DECLARE @toID varchar(12), @fromID varchar(12); SET @toID = '1234'; SET @fromID = '4321'; */
    DECLARE @sql nvarchar(max);
    SET @sql = N'';
    
    SELECT @sql +=
    N'INSERT INTO [' + ObjectName + N'] (' + 
    (SELECT STUFF((SELECT N'], [' + name
                FROM sys.columns
               WHERE object_id = (select top 1 object_id FROM sys.objects where name = ObjectName) 
               ORDER BY column_id
                 FOR XML PATH('')), 1, 2, '') + ']') + N')
     SELECT ''' + @toID + N''',' +
    (SELECT STUFF((SELECT N'], [' + name
                FROM sys.columns
               WHERE object_id = (select top 1 object_id FROM sys.objects where name = ObjectName) 
                AND name NOT IN ('ID', 'RowID', 'ContactKey')
               ORDER BY column_id
                 FOR XML PATH('')), 1, 2, '') + ']') + N'
       FROM [' + ObjectName + N']  
      WHERE ID = ''' + @fromID + N'''; 
DELETE FROM [' + ObjectName + N']
WHERE ID = ''' + @fromID + N''';

'
      FROM [dbo].[ObjectMetaData]
     WHERE [IsUserDefined] = 0 AND [IsMultiInstance] = 1
       AND [ObjectName] IN (SELECT [name] FROM sys.tables WHERE [type] = 'U')
       AND [ObjectName] IN (SELECT OBJECT_NAME([parent_id]) FROM sys.triggers WHERE OBJECT_NAME([object_id]) LIKE 'asiUDMBO%')
    
    EXEC (@sql);
END


GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_MergeUserLogin]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_MergeUserLogin]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
----------------------------------------------------------------------------------------------
-- Stored procedure to transfer all references to @fromUserKey to @toUserkey and then
-- delete the @fromUserKey, effectively merging @fromUserKey into @toUserKey.
----------------------------------------------------------------------------------------------
CREATE PROCEDURE [dbo].[asi_MergeUserLogin](@fromUserId varchar(10), @toUserId varchar(10))
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @purgeASPNetTables bit;
    DECLARE @fromUserKey uniqueidentifier;
    DECLARE @toUserKey uniqueidentifier;

    SET @fromUserKey = (SELECT [ContactKey]
                          FROM [dbo].[ContactMain]
                         WHERE [SyncContactID] = @fromUserId);
    SET @toUserKey = (SELECT [ContactKey]
                        FROM [dbo].[ContactMain]
                       WHERE [SyncContactID] = @toUserId);
    SET @purgeASPNetTables = 1;

    -- Bail if parameters are dangerous or make no sense... should probably raise an exception
    IF EXISTS (SELECT 1
                 FROM [dbo].[UserMain]
                WHERE [UserKey] = @fromUserKey AND [UserId] IN ('ADMINISTRATOR', 'GUEST', 'MANAGER', 'SYSTEM', 'IMISLOG'))
        BEGIN 
            RAISERROR('Attempted to merge an administrator, guest, manager, system user, or iMIS log', 16, 1)
            RETURN
        END;
    IF EXISTS (SELECT 1
                 FROM [dbo].[UserMain]um
                      INNER JOIN [dbo].[Users] u ON um.UserId = u.UserId
                WHERE [UserKey] = @fromUserKey
                   OR [UserKey] = @toUserKey)
        BEGIN 
            RAISERROR('Merging a Staff user is not currently supported', 16, 1)
            RETURN
        END;

    IF NOT EXISTS (SELECT 1
                     FROM [dbo].[UserMain]
                    WHERE [UserKey] = @toUserKey)
        BEGIN
            -- We don't have a user for the To Party. Create a new one that's exactly the same
            -- as the From User except its user key points to the To Party.
            INSERT INTO [dbo].[UserMain]
            SELECT @toUserKey,
                   @toUserId,
                   um.UserId,
                   um.IsDisabled,
                   um.EffectiveDate,
                   um.ExpirationDate,
                   um.UpdatedByUserKey,
                   um.UpdatedOn,
                   um.CreatedByUserKey,
                   um.CreatedOn,
                   um.MarkedForDeleteOn,
                   um.DefaultDepartmentGroupKey,
                   um.DefaultPerspectiveKey,
                   um.ProviderKey,
                   um.MultiFactorInfo
              FROM [dbo].[UserMain] AS um
             WHERE um.[UserKey] = @fromUserKey;

            INSERT INTO [dbo].[UserRole]
            SELECT @toUserKey,
                   ur.RoleKey,
                   ur.MarkedForDeleteOn
              FROM [dbo].[UserRole] ur
             WHERE [UserKey] = @fromUserKey;

            -- Don't purge ASP NET Tables because they will now point to the new To User
            SET @purgeASPNetTables = 0;
        END;

    -- Update all references to @fromUserKey to be @toUserKey
    DECLARE @sql nvarchar(max);
    DECLARE @cr nchar(2);
    SET @cr = NCHAR(13);
    SET @sql = N'';
    WITH UserKeyColumns
        AS (
        SELECT cu.TABLE_SCHEMA AS [Schema],
               cu.TABLE_NAME AS [TableName],
               cu.COLUMN_NAME AS [ColumnName]
          FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS AS fk
               INNER JOIN INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE AS cu ON fk.CONSTRAINT_NAME = cu.CONSTRAINT_NAME
         WHERE fk.CONSTRAINT_SCHEMA = N'dbo' AND fk.UNIQUE_CONSTRAINT_NAME = N'PK_UserMain' AND cu.TABLE_NAME NOT IN (N'UserRole', 'UserToken')
        )
        SELECT @sql += N'UPDATE ' + QUOTENAME([Schema]) + N'.' + QUOTENAME([TableName]) + N' SET ' + QUOTENAME([ColumnName]) + N' = ''' + CAST(@toUserKey AS nvarchar(40)) + N'''' + N' WHERE ' + QUOTENAME([ColumnName]) + N' = ''' + CAST(@fromUserKey AS nvarchar(40)) + ''';' + @cr
          FROM UserKeyColumns
         ORDER BY [Schema], [TableName], [ColumnName];
    EXEC (@sql);

    -- handle the non-fk columns for updated-by and such
    SET @sql = N'';
    WITH UserByColumns
      AS (
          SELECT c.[TABLE_NAME] AS [TableName],
                 c.[COLUMN_NAME] AS [ColumnName],
                 t.TABLE_SCHEMA AS [Schema]
            FROM INFORMATION_SCHEMA.COLUMNS c
                 INNER JOIN INFORMATION_SCHEMA.TABLES t ON c.TABLE_NAME = t.TABLE_NAME
           WHERE c.[COLUMN_NAME] IN ('CREATED_BY', 'UPDATED_BY', 'ENTERED_BY', 'MODIFIED_BY')
                 AND c.[DATA_TYPE] = 'varchar'
                 AND c.[CHARACTER_MAXIMUM_LENGTH] > 40
                 AND t.TABLE_TYPE = 'BASE TABLE'
      )
      SELECT @sql += N'UPDATE ' + QUOTENAME([Schema]) + N'.' + QUOTENAME([TableName]) + N' SET ' + QUOTENAME([ColumnName]) + N' = ''' + CAST(@toUserKey AS nvarchar(40)) + N'''' + N' WHERE ' + QUOTENAME([ColumnName]) + N' = ''' + CAST(@fromUserKey AS nvarchar(40)) + ''';' + @cr
        FROM UserByColumns
    ORDER BY [Schema], [TableName], [ColumnName];
    EXEC (@sql);

    -- Merge UserRoles
    INSERT INTO [dbo].[UserRole] (UserKey, RoleKey)
    SELECT r.[UserKey],
           r.[RoleKey]
      FROM [dbo].[UserRole] AS r
     WHERE r.[UserKey] = @fromUserKey 
           AND NOT EXISTS (SELECT 1
                             FROM [dbo].[UserRole]
                            WHERE [UserKey] = @toUserKey 
                                  AND [RoleKey] = r.[RoleKey]) 
           AND NOT EXISTS (SELECT 1
                             FROM [dbo].[UserRole]
                            WHERE [UserKey] = @fromUserKey 
                                  AND [RoleKey] = r.[RoleKey]);
    DELETE FROM [dbo].[UserRole]
     WHERE [UserKey] = @fromUserKey;

    -- Purge UserToken table
    DELETE FROM [dbo].[UserToken]
    WHERE [UserKey] IN (@fromUserKey, @toUserKey);

    -- Purge aspnet tables
    IF(@purgeASPNetTables = 1)
        BEGIN
            DECLARE @applicationKey uniqueidentifier;
            DECLARE @providerKey nvarchar(100);
            SELECT @providerKey = [ProviderKey]
              FROM [dbo].[UserMain]
             WHERE [UserKey] = @fromUserKey;
            SELECT @applicationKey = [ApplicationId]
              FROM [aspnet_Applications]
             WHERE [LoweredApplicationName] = 'imis';
            DELETE a
              FROM aspnet_Profile a
             WHERE a.[UserId] = @providerKey;
            DELETE a
              FROM aspnet_Membership a
             WHERE a.[ApplicationId] = @applicationKey AND a.[UserId] = @providerKey;
            DELETE a
              FROM aspnet_Users a
             WHERE a.[ApplicationId] = @applicationKey AND a.[UserId] = @providerKey;
        END;

    --Update Name_Security for the to-party in case it was blank before
    UPDATE [dbo].[Name_Security]
       SET [WEB_LOGIN] = COALESCE((SELECT [UserId] FROM  [dbo].[UserMain] WHERE [UserKey] =  @toUserKey),[WEB_LOGIN])
    WHERE [ID] = @toUserId

    -- Ensure that the delete trigger for Name_Security will never wipe out our new id when it is called/deleted from MergePartyReferences
    UPDATE [dbo].[Name_Security]
       SET [WEB_LOGIN] = ''
      WHERE [ID] = @fromUserId

    --Get rid of the old record
    DELETE [dbo].[Name_Security]
    WHERE [ID] = @fromUserId

    -- Purge the @fromUserKey
    DELETE FROM [dbo].[UserMain]
     WHERE [UserKey] = @fromUserKey;
END;








GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_MergeV2UserDefinedData]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_MergeV2UserDefinedData]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_MergeV2UserDefinedData]
    @fromContactId varchar(10),
    @toContactId varchar(10)
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE @fieldCount int;
    DECLARE @allFields nvarchar(max);
    DECLARE @i int;
    DECLARE @sql nvarchar(max);
    DECLARE @crlf nvarchar(2);
    
    SET @fieldCount = 500;
    SET @crlf = NCHAR(13) + NCHAR(10);

    -- First move across single instance missing business object entries
    UPDATE fromParty
       SET fromParty.[RowID] = @toContactId
      FROM [dbo].[UserDefinedTableStorage] fromParty
           INNER JOIN ObjectMetaData o ON o.ObjectName = fromParty.TableName
     WHERE fromParty.[RowID] = @fromContactId 
          AND COALESCE(o.[Version], N'V1') = N'V2' 
          AND o.IsMultiInstance = 0 
          AND NOT EXISTS (SELECT 1
                          FROM [dbo].[UserDefinedTableStorage]
                         WHERE [RowID] = @toContactId AND [TableName] = fromParty.[TableName]);

    -- Now move across single instance properties that exist in fromParty but not in toParty
    DECLARE @setClause nvarchar(max);
    SET @i = 0;
    SET @setClause = N'   SET ';
    DECLARE @first bit;
    DECLARE @fieldName nvarchar(10);
    WHILE @i < @fieldCount
    BEGIN
        IF @i != 0
        BEGIN 
            SET @setClause = @setClause + N', ';
        END;
        SET @i = @i + 1;
        SET @fieldName = N'[Value' + CAST(@i AS nvarchar(3)) + ']';
        SET @setClause = @setClause + @fieldName + N'=COALESCE(toParty.' + @fieldName + N', fromParty.' + @fieldName + N')';
    END;
    SET @sql = N'UPDATE toParty' + @crlf;
    SET @sql = @sql + @setClause + @crlf;
    SET @sql = @sql + N'  FROM [dbo].[UserDefinedTableStorage] fromParty' + @crlf;
    SET @sql = @sql + N'         INNER JOIN ObjectMetaData o ON o.ObjectName = fromParty.TableName' + @crlf;
    SET @sql = @sql + N'         LEFT JOIN [dbo].[UserDefinedTableStorage] toParty ON toParty.[TableName] = fromParty.[TableName]' + @crlf;
    SET @sql = @sql + N' WHERE fromParty.[RowID] = ''' + @fromContactId + N'''' + @crlf;
    SET @sql = @sql + N'   AND toParty.[RowID] = ''' + @toContactId + N'''' + @crlf;
    SET @sql = @sql + N'     AND COALESCE(o.[Version],''V1'') = ''V2'' AND o.IsMultiInstance = 0' + @crlf;
    EXECUTE sp_executesql @sql;

    -- Finally remove any remaining fromParty records
    DELETE s
      FROM  [dbo].[UserDefinedTableStorage] s
            INNER JOIN ObjectMetaData o ON o.ObjectName = s.TableName
     WHERE [RowID] = @fromContactId 
          AND COALESCE(o.[Version], N'V1') = N'V2' 
          AND o.IsMultiInstance = 0;

    -- First move across multi-instance records the toParty doesn't have
    UPDATE fromParty
    SET fromParty.[RowID] = @toContactId
      FROM [dbo].[UserDefinedTableStorage] fromParty
           INNER JOIN ObjectMetaData o ON o.ObjectName = fromParty.TableName
     WHERE fromParty.[RowID] = @fromContactId 
          AND NOT EXISTS (SELECT 1
                         FROM [dbo].[UserDefinedTableStorage]
                        WHERE [RowID] = @toContactId AND [TableName] = fromParty.[TableName] AND [RowKey] = fromParty.[RowKey]) AND COALESCE(o.[Version], 'V1') = 'V2' AND o.IsMultiInstance = 1;

    -- Next, merge in common rows mindful of keeping the sequence numbers unique
       SET @i = 0;
    SET @allFields = '';
    WHILE @i < @fieldCount
        BEGIN
            IF @i != 0
                BEGIN SET @allFields = @allFields + ', '
                END;
            SET @i = @i + 1;
            SET @allFields = @allFields + N'[Value' + CAST(@i AS nvarchar(3)) + N']';
        END;
    SET @sql = N'INSERT INTO dbo.[UserDefinedTableStorage] (TableName, RowID, RowKey, RowSequence, CreatedOn, UpdatedOn, ' + @allFields + ')' + @crlf;
    SET @sql = @sql + N'   SELECT udm.TableName, ''' + @toContactId + ''', udm.RowKey,' + @crlf;
    SET @sql = @sql + N'             (SELECT COALESCE(MAX(RowSequence),0) FROM dbo.UserDefinedTableStorage udm2' + @crlf;
    SET @sql = @sql + N'                 WHERE udm2.TableName = udm.TableName AND udm2.RowID = ''' + @toContactId + '''' + @crlf;
    SET @sql = @sql + N'                 ) + ROW_NUMBER() OVER (PARTITION BY RowID, TableName ORDER BY RowSequence),' + @crlf;
    SET @sql = @sql + N'                 CreatedOn, UpdatedOn, ' + @allFields + @crlf;
    SET @sql = @sql + N'     FROM dbo.[UserDefinedTableStorage] udm' + @crlf;
    SET @sql = @sql + N'          INNER JOIN ObjectMetaData o ON o.ObjectName = udm.TableName' + @crlf;
    SET @sql = @sql + N'   WHERE RowID = ''' + @fromContactId + '''' + @crlf;
    SET @sql = @sql + N'      AND COALESCE(o.[Version],''V1'') = ''V2'' AND o.IsMultiInstance = 1' + @crlf;
    SET @sql = @sql + N'   ORDER BY udm.TableName, udm.RowSequence' + @crlf;
    EXECUTE sp_executesql @sql;

    -- Now remove any remaining fromParty records
    DELETE  s
      FROM [dbo].[UserDefinedTableStorage] s
           INNER JOIN ObjectMetaData o ON o.ObjectName = s.TableName
     WHERE [RowID] = @fromContactId 
          AND COALESCE(o.[Version], N'V1') = N'V2' 
          AND o.IsMultiInstance = 1;

END;

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_UpdateSingleFullName]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_UpdateSingleFullName]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_UpdateSingleFullName]
                @ID varchar(10)
AS 
    BEGIN

        DECLARE @prefixes varchar(1000)
        SELECT @prefixes = ShortValue from System_Params where ParameterName = 'Member_Control.IncludePrefixString'

        SET NOCOUNT ON 

        UPDATE [dbo].[Name]
           SET FULL_NAME = ISNULL(LTRIM(
                                       ISNULL( CASE WHEN CHARINDEX(',' + PREFIX + ',' ,',' + ISNULL(@prefixes,'') + ',') > 0 
                                                    THEN ISNULL(SUBSTRING(SUBSTRING(@prefixes, 
                                                         CHARINDEX(',' + PREFIX + ',' ,',' + @prefixes + ','), 
                                                         DATALENGTH(PREFIX)),1,
                                                         DATALENGTH(SUBSTRING(@prefixes,CHARINDEX(','+PREFIX+',' , ',' + (@prefixes)+','),
                                                         DATALENGTH(PREFIX)))
                                                         * ABS(SIGN(SIGN(DATALENGTH(SUBSTRING(@prefixes,
                                                         CHARINDEX(','+PREFIX+',' , ',' + @prefixes+','),
                                                         DATALENGTH(PREFIX)))-1) + 
                                                         SIGN(ASCII(SUBSTRING(@prefixes,
                                                         CHARINDEX(','+PREFIX+',' , ',' + @prefixes+','),
                                                         DATALENGTH(PREFIX)))-32)))) +
                                                         SUBSTRING(' ', 1, ABS(SIGN(SIGN(DATALENGTH(SUBSTRING(@prefixes, CHARINDEX(','+PREFIX+',' , ',' + @prefixes + ','),
                                                         DATALENGTH(PREFIX)))-1) + SIGN(ASCII(SUBSTRING(@prefixes, CHARINDEX(',' + PREFIX + ',' , ',' + @prefixes + ','), DATALENGTH(PREFIX)))-32)))),'') 
                                                     END ,'')
                                        +
                                         SUBSTRING(FIRST_NAME, 1 ,DATALENGTH(FIRST_NAME) * ABS(SIGN(SIGN(DATALENGTH(FIRST_NAME)-1) + COALESCE(SIGN(ASCII(FIRST_NAME)-32), 0))))
                                        + SUBSTRING(' ', 1, ABS(SIGN(SIGN(DATALENGTH(FIRST_NAME)-1) + COALESCE(SIGN(ASCII(FIRST_NAME)-32), 0)))) 
                                        + SUBSTRING(MIDDLE_NAME, 1, DATALENGTH(MIDDLE_NAME) * ABS(SIGN(SIGN(DATALENGTH(MIDDLE_NAME)-1) + COALESCE(SIGN(ASCII(MIDDLE_NAME)-32), 0)))) 
                                        + SUBSTRING(' ', 1, ABS(SIGN(SIGN(DATALENGTH(MIDDLE_NAME)-1) + COALESCE(SIGN(ASCII(MIDDLE_NAME)-32), 0)))) 
                                        + SUBSTRING(LAST_NAME, 1, DATALENGTH(LAST_NAME) * ABS(SIGN(SIGN(DATALENGTH(LAST_NAME)-1) + COALESCE(SIGN(ASCII(LAST_NAME)-32), 0)))) 
                                        + SUBSTRING(', ', 1, 2 * ABS(SIGN(SIGN(DATALENGTH(LTRIM(RTRIM(SUFFIX))))))) 
                                        + SUBSTRING(SUFFIX, 1, DATALENGTH(SUFFIX) * ABS(SIGN(SIGN(DATALENGTH(LTRIM(RTRIM(SUFFIX))))))) 
                                        + SUBSTRING(', ', 1 ,2 * ABS(SIGN(SIGN(DATALENGTH(LTRIM(RTRIM(DESIGNATION))))))) 
                                        + SUBSTRING(DESIGNATION, 1, DATALENGTH(DESIGNATION) * ABS(SIGN(SIGN(DATALENGTH(DESIGNATION)-1) + COALESCE(SIGN(ASCII(DESIGNATION)-32), 0))))
                                        ),'')
                WHERE ID = @ID  
                AND   FULL_NAME <> ISNULL(LTRIM(
                                       ISNULL( CASE WHEN CHARINDEX(',' + PREFIX + ',' ,',' + ISNULL(@prefixes,'') + ',') > 0 
                                             THEN ISNULL(SUBSTRING(SUBSTRING(@prefixes, 
                                                  CHARINDEX(',' + PREFIX + ',' ,',' + @prefixes + ','), 
                                                  DATALENGTH(PREFIX)),
                                                  1,
                                                  DATALENGTH(SUBSTRING(@prefixes,
                                                  CHARINDEX(','+PREFIX+',' , ',' + (@prefixes)+','),
                                                  DATALENGTH(PREFIX)))
                                                  * ABS(SIGN(SIGN(DATALENGTH(SUBSTRING(@prefixes,
                                                  CHARINDEX(','+PREFIX+',' , ',' + @prefixes+','),
                                                  DATALENGTH(PREFIX)))-1) + 
                                                  SIGN(ASCII(SUBSTRING(@prefixes,
                                                  CHARINDEX(','+PREFIX+',' , ',' + @prefixes+','),
                                                  DATALENGTH(PREFIX)))-32)))) +
                                                  SUBSTRING(' ', 1, ABS(SIGN(SIGN(DATALENGTH(SUBSTRING(@prefixes, CHARINDEX(','+PREFIX+',' , ',' + @prefixes + ','),
                                                  DATALENGTH(PREFIX)))-1) + SIGN(ASCII(SUBSTRING(@prefixes, CHARINDEX(',' + PREFIX + ',' , ',' + @prefixes + ','), DATALENGTH(PREFIX)))-32)))),'') 
                                             END ,'')
                                        +
                                         SUBSTRING(FIRST_NAME, 1 ,DATALENGTH(FIRST_NAME) * ABS(SIGN(SIGN(DATALENGTH(FIRST_NAME)-1) + COALESCE(SIGN(ASCII(FIRST_NAME)-32), 0))))
                                        + SUBSTRING(' ', 1, ABS(SIGN(SIGN(DATALENGTH(FIRST_NAME)-1) + COALESCE(SIGN(ASCII(FIRST_NAME)-32), 0)))) 
                                        + SUBSTRING(MIDDLE_NAME, 1, DATALENGTH(MIDDLE_NAME) * ABS(SIGN(SIGN(DATALENGTH(MIDDLE_NAME)-1) + COALESCE(SIGN(ASCII(MIDDLE_NAME)-32), 0)))) 
                                        + SUBSTRING(' ', 1, ABS(SIGN(SIGN(DATALENGTH(MIDDLE_NAME)-1) + COALESCE(SIGN(ASCII(MIDDLE_NAME)-32), 0)))) 
                                        + SUBSTRING(LAST_NAME, 1, DATALENGTH(LAST_NAME) * ABS(SIGN(SIGN(DATALENGTH(LAST_NAME)-1) + COALESCE(SIGN(ASCII(LAST_NAME)-32), 0)))) 
                                        + SUBSTRING(', ', 1, 2 * ABS(SIGN(SIGN(DATALENGTH(LTRIM(RTRIM(SUFFIX))))))) 
                                        + SUBSTRING(SUFFIX, 1, DATALENGTH(SUFFIX) * ABS(SIGN(SIGN(DATALENGTH(LTRIM(RTRIM(SUFFIX))))))) 
                                        + SUBSTRING(', ', 1 ,2 * ABS(SIGN(SIGN(DATALENGTH(LTRIM(RTRIM(DESIGNATION))))))) 
                                        + SUBSTRING(DESIGNATION, 1, DATALENGTH(DESIGNATION) * ABS(SIGN(SIGN(DATALENGTH(DESIGNATION)-1) + COALESCE(SIGN(ASCII(DESIGNATION)-32), 0))))
                                        ),'')
    END



GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_MergePerson]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_MergePerson]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO










-- =============================================
-- This is the driver procedure for merging a person.
-- =============================================
CREATE PROCEDURE [dbo].[asi_MergePerson] 
    @fromContactId varchar(10), 
    @toContactId varchar(10),
    @userName varchar(60)
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @errorMessage nvarchar(max);
    DECLARE @stage nvarchar(100);
    SET @errorMessage = '';

    BEGIN TRY
        BEGIN TRANSACTION;
            --execute any customer custom operation
            SET @stage = 'asi_MergePartyReferencesCustom: ';
            EXEC dbo.asi_MergePartyReferencesCustom @fromContactId, @toContactId;
            --log merge
            SET @stage = 'asi_LogMerge'
            EXEC dbo.asi_LogMerge @fromContactId, @toContactId, @userName;
            SET @stage = 'asi_MergeFullAddressesDeleteDuplicatePurposes';
            EXEC dbo.asi_MergeFullAddressesDeleteDuplicatePurposes @fromContactId, @toContactId;
            --merge groups - must always be ahead of merge references
            SET @stage = 'asi_MergeFinancialGroups';
            EXEC dbo.asi_MergeFinancialGroups @fromContactId, @toContactId;            
            SET @stage = 'asi_MergeGroups';
            EXEC dbo.asi_MergeGroups @fromContactId, @toContactId;
            --merge user-defined objects
            SET @stage = 'asi_MergeSingleInstanceUserDefinedData';
            EXEC dbo.asi_MergeSingleInstanceUserDefinedData  @fromContactId, @toContactId;
            SET @stage = 'asi_MergeMultiInstanceUserDefinedData';
            EXEC dbo.asi_MergeMultiInstanceUserDefinedData  @fromContactId, @toContactId;
            SET @stage = 'asi_MergeStaticUserDefinedSources';
            EXEC dbo.asi_MergeStaticUserDefinedSources  @fromContactId, @toContactId;
            SET @stage = 'asi_MergeCustomizerUDTables';
            EXEC dbo.asi_MergeCustomizerUDTables  @fromContactId, @toContactId;
            SET @stage = 'asi_MergeV2UserDefinedData';
            EXEC dbo.asi_MergeV2UserDefinedData  @fromContactId, @toContactId;
            --merge login records - must always be after merge groups
            SET @stage = 'asi_MergeUserLogin';
            EXEC dbo.asi_MergeUserLogin @fromContactId, @toContactId;
            SET @stage = 'asi_MergeEngagementScores';
            EXEC dbo.asi_MergeEngagementScores @fromContactId, @toContactId;
            SET @stage = 'asi_MergePartyReferences: ';
            EXEC dbo.asi_MergePartyReferences @fromContactId, @toContactId;
            SET @stage = 'asi_MergeRebuildGiftHistory: ';
            EXEC dbo.asi_MergeRebuildGiftHistory @toContactId;
            SET @stage = 'asi_UpdateSingleFullName';
            EXEC dbo.asi_UpdateSingleFullName @toContactId;
        COMMIT TRANSACTION;
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0 ROLLBACK;
        
        SET @errorMessage  += 'Message = ' + @stage + CONVERT(nvarchar(max), ERROR_MESSAGE());
        RAISERROR(@errorMessage, 16, 1);
    END CATCH
END



GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_NewAccessArea]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_NewAccessArea]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_NewAccessArea]
       @isSharedACLOnly  bit,
       @sysEntityKey     uniqueidentifier,
       @userKey          uniqueidentifier,
       @name             varchar(50),
       @description      varchar(250),
       @accessAreaKey    uniqueidentifier OUTPUT,
       @accessKeyForArea uniqueidentifier OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @now datetime;
    SELECT @now = dbo.asi_GetAppDatetime();
    
    IF (@accessKeyForArea IS NULL)
    BEGIN
        SELECT @accessKeyForArea = NEWID();
    END;
    
    SELECT @accessAreaKey = NEWID();

    -- The ACL that the access area represents (protects):
    INSERT INTO [AccessMain] ([AccessKey],
                              [AccessScope],
                              [CreatedByUserKey],
                              [CreatedOn],
                              [UpdatedByUserKey],
                              [UpdatedOn]
                             )
           SELECT @accessKeyForArea,
                  'Area',
                  @userKey,
                  @now,
                  @userKey,
                  @now;

    -- The access area:
    INSERT INTO [AccessArea] ([AccessAreaKey],
                              [Name],
                              [Description],
                              [IsSystem],
                              [ProtectedAccessKey],
                              [UpdatedByUserKey],
                              [UpdatedOn],
                              [IsSharedACLOnly],
                              [CreatedByUserKey],
                              [CreatedOn]
                             )
           SELECT @accessAreaKey,
                  @name,
                  @description,
                  1,
                  @accessKeyForArea,
                  @userKey,
                  @now,
                  @isSharedACLOnly,
                  @userKey,
                  @now;
END;


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_NewGenTablesRecord]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_NewGenTablesRecord]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_NewGenTablesRecord    Script Date: 7/3/2003 4:58:04 PM ******/

CREATE PROCEDURE dbo.asi_NewGenTablesRecord
@Code nvarchar(60),
@TableName nvarchar(30),
@Sub nvarchar(255),
@Desc nvarchar(255)
AS
BEGIN
insert into Gen_Tables  
(TABLE_NAME, CODE, SUBSTITUTE, UPPER_CODE, DESCRIPTION)
values (@TableName, @Code, @Sub, Upper(@Code), @Desc)
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_NewQueryResultItem]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_NewQueryResultItem]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_NewQueryResultItem    Script Date: 7/3/2003 4:58:04 PM ******/

CREATE PROCEDURE dbo.asi_NewQueryResultItem
@jobKey uniqueidentifier,
@anyKey nvarchar(50)
AS
BEGIN
insert into QueryResultItem values (@jobKey, @anyKey);
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_NewQueryResultMain]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_NewQueryResultMain]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_NewQueryResultMain]
    @userKey uniqueidentifier,
    @jobKey uniqueidentifier
AS
BEGIN
    SET NOCOUNT ON;
    INSERT INTO [dbo].[QueryResultMain] ([QueryResultKey], [CreatedByUserKey], [CreatedOn])
    VALUES (@jobKey, @userKey, dbo.asi_GetAppDatetime());
END;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_NextSequenceValue]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_NextSequenceValue]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROC [dbo].[asi_NextSequenceValue]
       @sequenceName    nvarchar(30),
       @userKey         uniqueidentifier,
       @systemEntityKey uniqueidentifier = '00000000-0000-0000-0000-000000000000',
       @increment       int              = 1,
       @startValue      int              = 0
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @lastValue int;
    DECLARE @now datetime;
    
    SELECT @now = dbo.asi_GetAppDatetime();

    --Check to make sure the counter exists - create it if not
    IF NOT EXISTS (SELECT 1 FROM [SequenceCounter] WHERE [CounterName] = @sequenceName AND [SystemEntityKey] = @systemEntityKey)
    BEGIN
        INSERT INTO [SequenceCounter] ([SystemEntityKey],
                                       [CounterName],
                                       [CurrentValue],
                                       [UpdatedOn],
                                       [UpdatedByUserKey],
                                       [CreatedOn],
                                       [CreatedByUserKey]
                                      )
        VALUES (@systemEntityKey,
                @sequenceName,
                @startValue,
                @now,
                @userKey,
                @now,
                @userKey
               )
    END;

    --Increment the current value
    UPDATE [SequenceCounter]
       SET @lastValue = [CurrentValue] = ([CurrentValue] + @increment),
           [UpdatedOn] = @now,
           [UpdatedByUserKey] = @userKey
     WHERE [CounterName] = @sequenceName AND [SystemEntityKey] = @systemEntityKey;

    --Return the last value of the assigned counter range
    SELECT @lastValue AS [CurrentValue];
END;


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_NextSequenceValueOut]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_NextSequenceValueOut]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROC [dbo].[asi_NextSequenceValueOut]
    @lastValue       int OUT,
    @sequenceName    nvarchar(30),
    @userKey         uniqueidentifier,
    @systemEntityKey uniqueidentifier = '00000000-0000-0000-0000-000000000000',
    @increment       int              = 1,
    @startValue      int              = 0
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @now datetime;
    
    SELECT @now = dbo.asi_GetAppDatetime();

    --Check to make sure the counter exists - create it if not
    IF NOT EXISTS (SELECT 1
                     FROM [SequenceCounter]
                    WHERE [CounterName] = @sequenceName AND [SystemEntityKey] = @systemEntityKey
    )
    BEGIN
        INSERT INTO [SequenceCounter] ([SystemEntityKey],
                                       [CounterName],
                                       [CurrentValue],
                                       [UpdatedOn],
                                       [UpdatedByUserKey],
                                       [CreatedOn],
                                       [CreatedByUserKey]
                                      )
        VALUES (@systemEntityKey,
                @sequenceName,
                @startValue,
                @now,
                @userKey,
                @now,
                @userKey
               )

    --Increment the current value and return it
    UPDATE [SequenceCounter]
       SET @lastValue = [CurrentValue] = ([CurrentValue] + @increment),
           [UpdatedOn] = @now,
           [UpdatedByUserKey] = @userKey
     WHERE [CounterName] = @sequenceName AND [SystemEntityKey] = @systemEntityKey;

    END;
END;


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_NextSequenceValueSub]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_NextSequenceValueSub]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROC [dbo].[asi_NextSequenceValueSub]
       @sequenceName    nvarchar(30),
       @userKey         uniqueidentifier,
       @systemEntityKey uniqueidentifier = '00000000-0000-0000-0000-000000000000',
       @increment       int              = 1,
       @startValue      int              = 0,
       @lastValue       int              = 0 OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @now datetime;
    SELECT @now = dbo.asi_GetAppDatetime();

    --Check to make sure the counter exists - create it if not
    IF NOT EXISTS (SELECT 1
                     FROM [SequenceCounter]
                    WHERE [CounterName] = @sequenceName AND [SystemEntityKey] = @systemEntityKey
    )
    BEGIN
        INSERT INTO [SequenceCounter] ([SystemEntityKey],
                                       [CounterName],
                                       [CurrentValue],
                                       [UpdatedOn],
                                       [UpdatedByUserKey]
                                      )
        VALUES (@systemEntityKey,
                @sequenceName,
                @startValue,
                @now,
                @userKey
               )
    END;

    --Increment the current value
    UPDATE [SequenceCounter]
       SET
           @lastValue = [CurrentValue] = ([CurrentValue] + @increment),
           [UpdatedOn] = @now,
           [UpdatedByUserKey] = @userKey
     WHERE [CounterName] = @sequenceName AND [SystemEntityKey] = @systemEntityKey;
END;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_NextSequenceValueTest]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_NextSequenceValueTest]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


CREATE proc [dbo].[asi_NextSequenceValueTest]
  @sequenceName nvarchar(30),
  @userKey uniqueidentifier,
  @systemEntityKey uniqueidentifier = '00000000-0000-0000-0000-000000000000',
  @increment int = 1,
  @startValue int = 0 as

declare @lastValue int

set nocount on

exec asi_NextSequenceValueSub @sequenceName, @userKey, @systemEntityKey, @increment, @startValue, @lastValue output

set nocount off

--Return the last value of the assigned counter range
select @lastValue CurrentValue



GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_OpportunityActionPlanUpgradeReport]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_OpportunityActionPlanUpgradeReport]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_OpportunityActionPlanUpgradeReport] 
AS

IF EXISTS(SELECT 1 FROM sys.objects WHERE name='ActionPlan')
EXEC
('
DECLARE @idoc int
DECLARE @doc varchar(8000)
DECLARE @planName nvarchar(50)
DECLARE @ActionPlanKey uniqueidentifier

SET NOCOUNT ON

SELECT ActionPlanKey, Name, ActionManifest
INTO #Plans
FROM ActionPlan

CREATE TABLE #Assignee
(
	ActionPlanKey uniqueidentifier,
	PlanName nvarchar(50),
	taskId uniqueidentifier,
	taskSubject nvarchar(50),
	taskDescription nvarchar(100),
	Id uniqueidentifier,
	userKey uniqueidentifier,
	assigneeType nvarchar(50),
	groupTag nvarchar(50)
)

SELECT TOP 1 @doc = convert(varchar(8000), ActionManifest), @planName = [Name], @ActionPlanKey = ActionPlanKey
FROM #Plans

WHILE (@@ROWCOUNT <> 0)
BEGIN
	EXEC sp_xml_preparedocument @idoc output, @doc

	INSERT INTO #Assignee
	SELECT ActionPlanKey = @ActionPlanKey, PlanName = @planName, *
	FROM OPENXML(@idoc, ''/ActionManifest/Stage/EmailAction/Assignee'', 2)
		WITH (
			taskId		uniqueidentifier	''../@Id'',
			taskSubject	nvarchar(100)		''../@taskSubject'',
			taskDescription	nvarchar(100)		''../@description'',
			Id 		uniqueidentifier	''@Id'',
			userKey 	uniqueidentifier	''@userKey'',
			assigneeType 	nvarchar(100)		''@assigneeType'',
			groupTag 	nvarchar(100)		''@groupTag''
		)	

	INSERT INTO #Assignee
	SELECT ActionPlanKey = @ActionPlanKey, PlanName = @planName, *
	FROM OPENXML(@idoc, ''/ActionManifest/Stage/TaskAction/Assignee'', 2)
		WITH (
			taskId		uniqueidentifier	''../@Id'',
			taskSubject	nvarchar(100)		''../@taskSubject'',
			taskDescription	nvarchar(100)		''../@description'',
			Id 		uniqueidentifier	''@Id'',
			userKey 	uniqueidentifier	''@userKey'',
			assigneeType 	nvarchar(100)		''@assigneeType'',
			groupTag 	nvarchar(100)		''@groupTag''
		)	

	EXEC sp_xml_removedocument @idoc
	
	DELETE FROM #Plans WHERE ActionPlanKey = @ActionPlanKey

	SELECT TOP 1 @doc = convert(nvarchar(4000), ActionManifest), @planName = [Name], @ActionPlanKey = ActionPlanKey
	FROM #Plans
END

SET NOCOUNT OFF

DROP TABLE #Plans

SELECT * FROM #Assignee
WHERE assigneeType <> ''Group''

DROP TABLE #Assignee')


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_OpportunityTypes]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_OpportunityTypes]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_OpportunityTypes    Script Date: 7/3/2003 4:58:04 PM ******/

CREATE   PROC [dbo].[asi_OpportunityTypes]
	AS
BEGIN
	SELECT OpportunityTypeKey, OpportunityClass, Name, Description 
	FROM OpportunityType
	ORDER BY Name
	
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_OrganizationSettings]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_OrganizationSettings]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_OrganizationSettings] 
      @RootPath varchar(100),
      @VirtualDirectory varchar(100),
      @EmailAddress varchar(100),
      @OrganizationName varchar(100),
      @OrganizationAbbrev varchar(100),
      @WebCustomerType varchar(5)
AS
BEGIN
   UPDATE System_Variable
      SET Value = @VirtualDirectory
    WHERE Name = 'VirtualDirectoryPath'

   UPDATE System_Variable
      SET Value = @RootPath
    WHERE Name in ('RootPath', 'SecurePath')
   
   UPDATE Website
      SET DefaultSectionURL = REPLACE(DefaultSectionURL,WebsiteRootURL,@RootPath)
    WHERE IsiMISWebsite = 0
 
   UPDATE Website
      SET WebsiteRootURL = @RootPath,
          SecureWebsiteRootURL = @RootPath
    WHERE IsiMISWebsite = 0

          
   UPDATE SystemConfig
      SET ParameterValue = @EmailAddress
    WHERE ParameterName in (
			'Webmaster',
			'OrderWebmaster',
			'BillingMembershipContactEmailAddress',
			'LogonChangesEmailFrom',
			'ProductSaleEmailTo')

   UPDATE SystemConfig
      SET ParameterValue = @OrganizationName
    WHERE ParameterName = 'OrganizationName'

   UPDATE SystemConfig
      SET ParameterValue = @OrganizationAbbrev
    WHERE ParameterName = 'OrganizationAbbrev'

   UPDATE System_Params
      SET ShortValue = @WebCustomerType
    WHERE ParameterName = 'Member_Control.AnonymousSignUpMemberType'

   IF @@ROWCOUNT = 0
      INSERT INTO System_Params(ParameterName, ShortValue) VALUES ('Member_Control.AnonymousSignUpMemberType', @WebCustomerType)

END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_PareDownMailingListForPreview]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_PareDownMailingListForPreview]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- This stored procedure pares down a mailing list for previewing a Package.
-- After run, the only records remaining is the one at 'startRecord' and every 
-- 'recordInterval'th record after that.  The index starts at one, so if both
-- startRecord and recordInterval are one, no records will be removed.
CREATE PROCEDURE [dbo].[asi_PareDownMailingListForPreview]
   @tableName sysname,
   @keyFieldName sysname,
   @startRecord integer,
   @recordInterval integer
AS
BEGIN
   DECLARE @sql nvarchar(800)
   DECLARE @startRecordString nvarchar(30)
   DECLARE @recordIntervalString nvarchar(30)

   CREATE TABLE #MailingListTable
   (
      MailingListTableKey uniqueidentifier,
      IntId int IDENTITY(1, 1)
   )
   
   SET @startRecordString = CAST(@startRecord AS nvarchar(30))
   SET @recordIntervalString = CAST(@recordInterval AS nvarchar(30))
	   
   SET @sql = 'INSERT #MailingListTable (MailingListTableKey) SELECT [' + @keyFieldName + '] FROM [' + @tableName + ']'
   EXEC(@sql)
	
   SET @sql = 'DELETE [' + @tableName + '] FROM #MailingListTable WHERE #MailingListTable.MailingListTableKey=[' + @tableName + '].[' + @keyFieldName + '] AND (((#MailingListTable.IntId-' + @startRecordString + ')%' + @recordIntervalString + '!=0) OR #MailingListTable.IntId<' + @startRecordString + ')'
   EXEC(@sql)
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_PasswordHistoryTrim]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_PasswordHistoryTrim]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE asi_PasswordHistoryTrim
    @userName nvarchar(256),
    @numberOfRecentPasswordsToKeep int
AS
BEGIN
   DECLARE @userId uniqueidentifier    
   SELECT @userId = [UserId]
     FROM [dbo].[aspnet_Users]
    WHERE [UserName] = @userName
      
   IF( @userId = NULL) RETURN

   --every time we reset a password, we create two records so adjust accordingly
   SET @numberOfRecentPasswordsToKeep = @numberOfRecentPasswordsToKeep * 2;

   WITH UsersPasswordHistory AS (
     SELECT PasswordHistoryId, ROW_NUMBER() OVER (PARTITION BY UserId ORDER BY CreatedOn DESC) AS RowNumber
      FROM [dbo].[PasswordHistory]
     WHERE [UserId] = @userId
   )
   DELETE FROM UsersPasswordHistory
    WHERE RowNumber > @numberOfRecentPasswordsToKeep;
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_PciBlankExpiredCardsInBasketPayments]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_PciBlankExpiredCardsInBasketPayments]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE asi_PciBlankExpiredCardsInBasketPayments
    @numberOfRowsToProcess int,
    @retentionDate datetime
AS
BEGIN
    DECLARE @paymentVar TABLE ( Id varchar(10),
                                IpAddress varchar(30),
                                PRIMARY KEY (Id, IpAddress)
                              );

    WITH payRecordsToProcess AS (
        SELECT payments.[ID], payments.[IP_ADDRESS], ROW_NUMBER() OVER (ORDER BY ord.[BASKET_DATE]) AS RowNum
          FROM [dbo].[Basket_Payment] payments
               INNER JOIN [dbo].[Basket_Order] ord ON payments.[ID]  = ord.[ID]
         WHERE ord.[BASKET_DATE] < @retentionDate
           AND LEN(ENCRYPT_PAY_NUMBER) > 5
    )
    INSERT INTO @paymentVar(Id, IpAddress)
        SELECT [ID], [IP_ADDRESS]
          FROM payRecordsToProcess
          WHERE [RowNum] <= @numberOfRowsToProcess;

    UPDATE pay
       SET [ENCRYPT_CREDIT_CARD_EXPIRES] = '',
           [ENCRYPT_CSC] = '',
           [ENCRYPT_PAY_NUMBER] = ''
      FROM [dbo].[Basket_Payment] pay
           INNER JOIN @paymentVar varTable ON varTable.[ID] = pay.[ID]  
                                          AND varTable.[IPAddress] = pay.[IP_ADDRESS]                      
END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_PciBlankExpiredCardsInOrderPayments]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_PciBlankExpiredCardsInOrderPayments]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE asi_PciBlankExpiredCardsInOrderPayments 
    @numberOfRowsToProcess int,
    @retentionDate datetime
AS
BEGIN
    DECLARE @orderVar TABLE ( OrderNumber numeric(15,2),
                              PaymentNumber numeric(15,2)
                              PRIMARY KEY(OrderNumber) 
                            );
    
    WITH payRecordsToProcess AS (
        SELECT payments.[ORDER_NUMBER], payments.[PAYMENT_NUMBER], ROW_NUMBER() OVER (ORDER BY ord.[UPDATED_DATE_TIME]) AS RowNum 
          FROM [dbo].[Order_Payments] payments
               INNER JOIN [dbo].[Orders] ord ON payments.[ORDER_NUMBER] = ord.[ORDER_NUMBER]
         WHERE ord.[UPDATED_DATE_TIME] < @retentionDate
           AND LEN(payments.[ENCRYPT_PAY_NUMBER]) > 5
    )
    INSERT INTO @orderVar(OrderNumber, PaymentNumber)
        SELECT [ORDER_NUMBER], [PAYMENT_NUMBER]
          FROM payRecordsToProcess
         WHERE [RowNum] <= @numberOfRowsToProcess;

    UPDATE ord
       SET ENCRYPT_CREDIT_CARD_EXPIRES = '',
           ENCRYPT_CSC = '',
           ENCRYPT_PAY_NUMBER  = ''
      FROM [dbo].[Order_Payments] ord
           INNER JOIN @orderVar track ON track.[OrderNumber] = ord.[ORDER_NUMBER]                                                       
                                     AND track.[PaymentNumber] = ord.[PAYMENT_NUMBER]                     
     
END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_PciBlankExpiredCardsInOrders]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_PciBlankExpiredCardsInOrders]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE asi_PciBlankExpiredCardsInOrders 
    @numberOfRowsToProcess int,
    @retentionDate datetime
AS
BEGIN
    DECLARE @orderTableVar TABLE (OrderNumber numeric(15,2) PRIMARY KEY);

    WITH ordRecordsToProcess AS (
        SELECT [ORDER_NUMBER], ROW_NUMBER() OVER (ORDER BY [UPDATED_DATE_TIME]) AS RowNum
          FROM [dbo].[Orders]
         WHERE [UPDATED_DATE_TIME] < @retentionDate
           AND [STAGE] IN ('CLOSED', 'COMPLETED', 'CANCELED', 'QUOTEREADY', 'PRINTQUOTE')
           AND LEN([ENCRYPT_PAY_NUMBER]) > 5
    )
    INSERT INTO @orderTableVar(OrderNumber)
        SELECT [ORDER_NUMBER]
          FROM ordRecordsToProcess
         WHERE [RowNum] <= @numberOfRowsToProcess;

    UPDATE ord 
       SET [ENCRYPT_CREDIT_CARD_EXPIRES] = '',
           [ENCRYPT_CSC] = '',
           [ENCRYPT_PAY_NUMBER] = ''
      FROM [dbo].[Orders] ord
           INNER JOIN @orderTableVar varTable ON varTable.[OrderNumber] = ord.[ORDER_NUMBER]                      
                       
END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_PciBlankExpiredCardsInTrans]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_PciBlankExpiredCardsInTrans]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE asi_PciBlankExpiredCardsInTrans  
    @numberOfRowsToProcess int,
    @retentionDate datetime
AS
BEGIN
    DECLARE @transTableVar TABLE ( [TransNumber] int,
                                   [LineNumber] int,
                                   [SubLineNumber] int
                                   PRIMARY KEY ([TransNumber], [LineNumber], [SubLineNumber]) 
                                  );

    WITH transRecordsToProcess AS (
        SELECT [TRANS_NUMBER], [LINE_NUMBER], [SUB_LINE_NUMBER], ROW_NUMBER() OVER (ORDER BY [TRANSACTION_DATE]) AS RowNum
          FROM [dbo].[Trans]
         WHERE [TRANSACTION_DATE] < @retentionDate
           AND LEN([ENCRYPT_CC_NUMBER]) > 5
    )
    INSERT INTO @transTableVar([TransNumber], [LineNumber], [SubLineNumber])
        SELECT [TRANS_NUMBER], [LINE_NUMBER], [SUB_LINE_NUMBER]
          FROM transRecordsToProcess
         WHERE [RowNum] <= @numberOfRowsToProcess;

    UPDATE tr 
       SET [ENCRYPT_CC_NUMBER] = '',
           [ENCRYPT_CC_EXPIRE] = '',
           [ENCRYPT_CSC] = ''
      FROM [dbo].[Trans] tr
           INNER JOIN @transTableVar varTable ON varTable.[TransNumber] = tr.[TRANS_NUMBER]
                                             AND varTable.[LineNumber] = tr.[LINE_NUMBER]
                                             AND varTable.[SubLineNumber] = tr.[SUB_LINE_NUMBER];
END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_PciBlankCreditCardInfo]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_PciBlankCreditCardInfo]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_PciBlankCreditCardInfo] 
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @dataRetentionDays int;
    DECLARE @numberOfRowsToProcess int;
    DECLARE @retentionDate datetime;
    DECLARE @now datetime;
    
    SELECT @dataRetentionDays = [ParameterValue] FROM [dbo].[SystemConfig] WHERE [ParameterName] = 'PCI.CCardRetentionDays';
    SELECT @numberOfRowsToProcess = [ParameterValue] FROM [dbo].[SystemConfig] WHERE [ParameterName] = 'PCI.CCardRetentionRowLimit';
    SELECT @now = dbo.asi_GetAppDatetime();

    IF @dataRetentionDays IS NULL
    BEGIN
        SET @dataRetentionDays = 0;
    END

    IF @numberOfRowsToProcess  = 0 OR @numberOfRowsToProcess IS NULL
    BEGIN
        SET @numberOfRowsToProcess = 5000; -- default amount of rows we will process at one call
    END

    -- Using a zero as one year (not assuming a 365 day year by default)
    SELECT @retentionDate = CASE WHEN @dataRetentionDays = 0 
                                 THEN DATEADD(YY, -1, @now)
                                 ELSE DATEADD(DD, -1 * @dataRetentionDays, @now)
                             END;

    EXEC dbo.asi_PciBlankExpiredCardsInTrans @numberofRowsToProcess, @retentionDate;
    EXEC dbo.asi_PciBlankExpiredCardsInOrders @numberofRowsToProcess, @retentionDate;
    EXEC dbo.asi_PciBlankExpiredCardsInBasketPayments @numberofRowsToProcess, @retentionDate;
    EXEC dbo.asi_PciBlankExpiredCardsInOrderPayments @numberofRowsToProcess, @retentionDate;
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_PopulateEngagementScorePercentiles]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_PopulateEngagementScorePercentiles]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


CREATE PROCEDURE [dbo].[asi_PopulateEngagementScorePercentiles]
@engagementScoreKey uniqueidentifier
AS
BEGIN
    
    -- The idea here is that we do not attempt to calculate the percentiles at
    -- the contact level.  There will probably be many contacts with identical scores, especially for the lower scores.  Instead
    -- we calculate what the percentile is for each unique score.  We can then look up a contact's percentile by matching their
    -- score (with or without year/month/week) to the score in the EngagementPercentile table and reading out the calculated
    -- percentile.
    -- 
    -- Get rid of the old data for this engagement score formula
    DELETE [dbo].[EngagementPercentile] WHERE [EngagementScoreKey] = @engagementScoreKey
    --TRUNCATE TABLE [dbo].[EngagementPercentile]
      
    -- Then we populate EngagementPercentile in four steps.
    -- 1) the rollups without time components - the overall scores
    INSERT INTO [dbo].[EngagementPercentile] ([EngagementScoreKey], [Score], [ScoreYear], [ScoreMonth], [ScoreWeek], [Frequency])
        SELECT DISTINCT ces.[EngagementScoreKey], ces.[Score], 0,0,0, COUNT(ces.[Score]) 
               OVER (PARTITION BY ces.[Score])
          FROM [dbo].[CalculatedEngagementScore] ces
         WHERE  ces.[EngagementScoreKey] = @engagementScoreKey AND ces.[ScoreYear] IS NULL AND ces.[ContactKey] IS NOT NULL AND ces.[ScoreComponentKey] IS NULL
     
     -- 2) rollups by year
    INSERT INTO [dbo].[EngagementPercentile] ([EngagementScoreKey], [Score], [ScoreYear], [ScoreMonth], [ScoreWeek], [Frequency])
        SELECT DISTINCT ces.[EngagementScoreKey], ces.[Score], ces.[ScoreYear], 0,0, COUNT(ces.[Score]) 
               OVER (PARTITION BY ces.[Score], ces.[ScoreYear])
          FROM [dbo].[CalculatedEngagementScore] ces
         WHERE ces.[EngagementScoreKey] = @engagementScoreKey AND ces.[ScoreYear] IS NOT NULL AND ces.[ScoreMonth] IS NULL AND ces.[ContactKey] IS NOT NULL AND ces.[ScoreComponentKey] IS NULL

    -- 3) rollups by month     
    INSERT INTO [dbo].[EngagementPercentile] ([EngagementScoreKey], [Score], [ScoreYear], [ScoreMonth], [ScoreWeek], [Frequency])
        SELECT DISTINCT ces.[EngagementScoreKey], ces.[Score], ces.[ScoreYear], ces.[ScoreMonth], 0, COUNT(ces.[Score]) 
               OVER (PARTITION BY ces.[Score], ces.[ScoreYear],ces.[ScoreMonth])
          FROM [dbo].[CalculatedEngagementScore] ces
         WHERE ces.[EngagementScoreKey] = @engagementScoreKey AND  ces.[ScoreMonth] IS NOT NULL AND ces.[ScoreWeek] IS  NULL AND ces.[ContactKey] IS NOT NULL AND ces.[ScoreComponentKey] IS NULL
     
     -- 4) populate down to the week level.
    INSERT INTO [dbo].[EngagementPercentile] ([EngagementScoreKey], [Score], [ScoreYear], [ScoreMonth], [ScoreWeek], [Frequency])
        SELECT DISTINCT ces.[EngagementScoreKey], ces.[Score], ces.[ScoreYear], ces.[ScoreMonth], ces.[ScoreWeek], COUNT(ces.[Score]) 
               OVER (PARTITION BY ces.[Score], ces.[ScoreYear],ces.[ScoreMonth],ces.[ScoreWeek]) -- todo - add scoremonth/week here?
          FROM [dbo].[CalculatedEngagementScore] ces
         WHERE ces.[EngagementScoreKey] = @engagementScoreKey AND ces.[ScoreWeek] IS NOT NULL  AND ces.[ContactKey] IS NOT NULL AND ces.[ScoreComponentKey] IS NULL
     
     -- Finally we use the asi_GetPercentileRank function to calculate the percentiles for each row.
    UPDATE [dbo].[EngagementPercentile] 
       SET [Percentile] = [dbo].[asi_GetPercentileRank](EngagementScoreKey, Score, ScoreYear, ScoreMonth, ScoreWeek)
      FROM [dbo].[EngagementPercentile] original
     WHERE [EngagementScoreKey] =  @engagementScoreKey
       AND [Score] = original.[Score]
       AND [ScoreYear] = original.[ScoreYear]
       AND [ScoreMonth] = original.[ScoreMonth]
       AND [ScoreWeek] = original.[ScoreWeek]
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_PopulateRollupsForSampledComponent]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_PopulateRollupsForSampledComponent]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_PopulateRollupsForSampledComponent]
    @engagementScoreKey uniqueidentifier
AS
BEGIN
    -- create a temporary table to hold all the component keys we are interested in -
    -- those for this engagement score that are sampled.
    DECLARE @sampledComponents TABLE (ScoreComponentKey uniqueidentifier PRIMARY KEY)
    INSERT INTO @sampledComponents
        SELECT [ScoreComponentKey]
          FROM [dbo].[ScoreComponent]
         WHERE [EngagementScoreKey] = @engagementScoreKey
           AND [IsSampled] = 1

    DELETE FROM [dbo].[CalculatedEngagementScore] 
     WHERE [ScoreComponentKey] IN (SELECT [ScoreComponentKey] FROM @sampledComponents)   
       AND ScoreWeek IS NULL

    INSERT INTO [dbo].[CalculatedEngagementScore] ([CalculatedEngagementScoreKey], [EngagementScoreKey], [ScoreComponentKey], [ContactKey], [Score], [ScoreYear], [ScoreMonth], [ScoreWeek])
        SELECT NEWID(), [EngagementScoreKey], [ScoreComponentKey], [ContactKey], MAX([Score]), [ScoreYear],[ScoreMonth], NULL
          FROM [dbo].[CalculatedEngagementScore] score
         WHERE [ScoreComponentKey] IN (SELECT [ScoreComponentKey] FROM @sampledComponents) 
         GROUP BY [EngagementScoreKey], [ScoreComponentKey], [ContactKey],[ScoreYear],[ScoreMonth]

    INSERT INTO [dbo].[CalculatedEngagementScore] ([CalculatedEngagementScoreKey], [EngagementScoreKey], [ScoreComponentKey], [ContactKey], [Score], [ScoreYear], [ScoreMonth], [ScoreWeek])
        SELECT NEWID(), [EngagementScoreKey], [ScoreComponentKey], [ContactKey], MAX([Score]), [ScoreYear], NULL, NULL
          FROM [dbo].[CalculatedEngagementScore]
         WHERE [ScoreComponentKey] IN (SELECT [ScoreComponentKey] FROM @sampledComponents)  
           AND [ScoreWeek] IS NULL
         GROUP BY [EngagementScoreKey], [ScoreComponentKey], [ContactKey],[ScoreYear]

    INSERT INTO [dbo].[CalculatedEngagementScore] ([CalculatedEngagementScoreKey], [EngagementScoreKey], [ScoreComponentKey] ,[ContactKey], [Score], [ScoreYear], [ScoreMonth], [ScoreWeek])
        SELECT NEWID(), [EngagementScoreKey], [ScoreComponentKey], [ContactKey], MAX([Score]), NULL, NULL, NULL
          FROM [dbo].[CalculatedEngagementScore]
         WHERE [ScoreComponentKey] IN (SELECT [ScoreComponentKey] FROM @sampledComponents) 
           AND [ScoreMonth] IS NULL
         GROUP BY [EngagementScoreKey], [ScoreComponentKey], [ContactKey]

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_PrepareDatabaseForLegacyCertificationMigration]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_PrepareDatabaseForLegacyCertificationMigration]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_PrepareDatabaseForLegacyCertificationMigration] 
AS
BEGIN
    SET NOCOUNT ON;

    -- Create a queue table for processing registrations
    IF  EXISTS (SELECT * FROM sys.objects WHERE [object_id] = OBJECT_ID(N'[dbo].[TempMigration_Cert_Register]') AND [type] in (N'U'))
    DROP TABLE [dbo].[TempMigration_Cert_Register];

    SELECT CONVERT(int, ROW_NUMBER() OVER (ORDER BY [STUDENT_ID] ASC, [REQUIREMENT_TYPE] ASC, [REG_TYPE] DESC, [SEQN] ASC)) AS [MIGRATION_ID], * 
      INTO [dbo].[TempMigration_Cert_Register] 
      FROM [dbo].[Cert_Register];

    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = 'dbo' AND TABLE_NAME = 'TempMigration_Cert_Register')
    BEGIN
        IF EXISTS(SELECT 1 FROM INFORMATION_SCHEMA.COLUMNS 
                   WHERE TABLE_SCHEMA = 'dbo' AND TABLE_NAME = 'TempMigration_Cert_Register' AND COLUMN_NAME = 'MIGRATION_ID')
        BEGIN
            ALTER TABLE [dbo].[TempMigration_Cert_Register] ALTER COLUMN [MIGRATION_ID] int NOT NULL;
        END
    END


    IF NOT EXISTS (SELECT * FROM sysindexes WHERE [id] = OBJECT_ID(N'[dbo].[TempMigration_Cert_Register]') AND [name] = N'PK_TempMigration_Cert_Register')
    BEGIN
        ALTER TABLE [dbo].[TempMigration_Cert_Register]
        ADD CONSTRAINT PK_TempMigration_Cert_Register PRIMARY KEY CLUSTERED (MIGRATION_ID);
    END
    
    -- Table for generic data collected during migration
    IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[TempMigration_Certification]') AND type in (N'U'))
    DROP TABLE [dbo].[TempMigration_Certification];
    
    CREATE TABLE [dbo].[TempMigration_Certification](
        [Name] varchar(50) NOT NULL,
        [Value] nvarchar(MAX) NULL,
     CONSTRAINT [PK_TempMigration_Certification] PRIMARY KEY NONCLUSTERED 
    (
         [Name] ASC
    )WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON)
    );
    
    INSERT INTO [dbo].[TempMigration_Certification]([Name], [Value])
    VALUES ('InitializationTime',  CONVERT(nvarchar(30), dbo.asi_GetAppDatetime(), 121))
    
    INSERT INTO [dbo].[TempMigration_Certification]([Name])
    VALUES ('StartTime')
    
    INSERT INTO [dbo].[TempMigration_Certification]([Name])
    VALUES ('ProgramIndex')
    
    INSERT INTO [dbo].[TempMigration_Certification]([Name])
    VALUES ('Items')
    
    INSERT INTO [dbo].[TempMigration_Certification]([Name])
    VALUES ('ProgramDeadlineMonths')
    
    INSERT INTO [dbo].[TempMigration_Certification]([Name])
    VALUES ('ProgramGracePeriodMonths')
    
    INSERT INTO [dbo].[TempMigration_Certification]([Name])
    VALUES ('NonRequiredSubcomponents')
    
    INSERT INTO [dbo].[TempMigration_Certification]([Name])
    VALUES ('CategoryComponents')
    
    INSERT INTO [dbo].[TempMigration_Certification]([Name])
    VALUES ('ComponentComponents')
    
    INSERT INTO [dbo].[TempMigration_Certification]([Name])
    VALUES ('ComponentComponentsByProgram')
    
    INSERT INTO [dbo].[TempMigration_Certification]([Name])
    VALUES ('Locations')
        
    INSERT INTO [dbo].[TempMigration_Certification]([Name])
    VALUES ('ProgramRegistrationBySeqn')
    
    INSERT INTO [dbo].[TempMigration_Certification]([Name])
    VALUES ('ProgramRegistrationStatuses')
    
    INSERT INTO [dbo].[TempMigration_Certification]([Name])
    VALUES ('ComponentRegistrationsWithNoProgram')
    
    INSERT INTO [dbo].[TempMigration_Certification]([Name])
    VALUES ('LastRowProcessed')
    
    INSERT INTO [dbo].[TempMigration_Certification]([Name])
    VALUES ('Results')
    
    INSERT INTO [dbo].[TempMigration_Certification]([Name])
    VALUES ('PauseTime')
    
    -- Table for location offerings collected during migration
    IF  EXISTS (SELECT 1 FROM sys.objects WHERE [object_id] = OBJECT_ID(N'[dbo].[TempMigration_CertificationLocationOfferings]') AND [type] in (N'U'))
    DROP TABLE [dbo].[TempMigration_CertificationLocationOfferings];
    
    CREATE TABLE [dbo].[TempMigration_CertificationLocationOfferings](
        [LocationCode] varchar(50) NOT NULL,
        [LocationOfferings] nvarchar(MAX) NULL,
     CONSTRAINT [PK_TempMigration_CertificationLocationOfferings] PRIMARY KEY NONCLUSTERED 
    (
         [LocationCode] ASC
    )WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON)
    );

END



GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_PrepareDatabaseForReEncryption]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_PrepareDatabaseForReEncryption]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO



CREATE PROCEDURE [dbo].[asi_PrepareDatabaseForReEncryption] 
AS
BEGIN
    SET NOCOUNT ON 
      --===========================================================================
      -- Create some temporary indexes on for the purpose of enhancing performance
      --===========================================================================
      IF  EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[Trans]') AND name = N'iTransENCRYPT_CC_NUMBER')
            DROP INDEX [iTransENCRYPT_CC_NUMBER] ON [dbo].[Trans] WITH ( ONLINE = OFF )
      CREATE NONCLUSTERED INDEX [iTransENCRYPT_CC_NUMBER]
      ON [dbo].[Trans] ([ENCRYPT_CC_NUMBER])
      INCLUDE ([TRANS_NUMBER], [LINE_NUMBER], [SUB_LINE_NUMBER])
      WHERE [ENCRYPT_CC_NUMBER] > '';

      IF  EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[Trans]') AND name = N'iTransENCRYPT_CSC')
            DROP INDEX [iTransENCRYPT_CSC] ON [dbo].[Trans] WITH ( ONLINE = OFF )
      CREATE NONCLUSTERED INDEX [iTransENCRYPT_CSC]
      ON [dbo].[Trans] ([ENCRYPT_CSC])
      WHERE [ENCRYPT_CSC] > '';

      IF  EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[Trans]') AND name = N'iTransENCRYPT_CC_EXPIRE')
            DROP INDEX [iTransENCRYPT_CC_EXPIRE] ON [dbo].[Trans] WITH ( ONLINE = OFF )
      CREATE NONCLUSTERED INDEX [iTransENCRYPT_CC_EXPIRE]
      ON [dbo].[Trans] ([ENCRYPT_CC_EXPIRE])
      INCLUDE ([TRANS_NUMBER], [LINE_NUMBER], [SUB_LINE_NUMBER])
      WHERE [ENCRYPT_CC_EXPIRE] > '';

      --====================================================================================
      -- Create [dbo].[DictionaryLookupForEncryption_*] tables to fill with Encrypted values
      --====================================================================================

      -- Trans column tables
      IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'DictionaryLookupForEncryption_Trans_CCNumber') 
            DROP TABLE [dbo].[DictionaryLookupForEncryption_Trans_CCNumber];
      CREATE TABLE [dbo].[DictionaryLookupForEncryption_Trans_CCNumber] (
            [TRANS_NUMBER] int,
            [LINE_NUMBER] int,
            [SUB_LINE_NUMBER] int,
            [OldCCNumberValue] varchar(150) NOT NULL,
            [NewCCNumberValue] varchar(150) NOT NULL
            CONSTRAINT [PK_DictionaryLookupForEncryption_Trans_CCNumber] PRIMARY KEY CLUSTERED ( [TRANS_NUMBER] ASC, [LINE_NUMBER] ASC, [SUB_LINE_NUMBER] ASC )
      );

      IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'DictionaryLookupForEncryption_Trans_CSC') 
            DROP TABLE [dbo].[DictionaryLookupForEncryption_Trans_CSC];
      CREATE TABLE [dbo].[DictionaryLookupForEncryption_Trans_CSC] (
            [TRANS_NUMBER] int,
            [LINE_NUMBER] int,
            [SUB_LINE_NUMBER] int,
            [OldCSCValue] varchar(150) NOT NULL,
            [NewCSCValue] varchar(150) NOT NULL,
            CONSTRAINT [PK_DictionaryLookupForEncryption] PRIMARY KEY CLUSTERED ( [TRANS_NUMBER] ASC, [LINE_NUMBER] ASC, [SUB_LINE_NUMBER] ASC )
      );

      IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'DictionaryLookupForEncryption_Trans_CCExpire') 
            DROP TABLE [dbo].[DictionaryLookupForEncryption_Trans_CCExpire];
      CREATE TABLE [dbo].[DictionaryLookupForEncryption_Trans_CCExpire] (
            [TRANS_NUMBER] int,
            [LINE_NUMBER] int,
            [SUB_LINE_NUMBER] int,
            [OldCCExpireValue] varchar(150) NOT NULL,
            [NewCCExpireValue] varchar(150) NOT NULL
            CONSTRAINT [PK_DictionaryLookupForEncryption_Trans_CCExpire] PRIMARY KEY CLUSTERED ( [TRANS_NUMBER] ASC, [LINE_NUMBER] ASC, [SUB_LINE_NUMBER] ASC )
      );

      -- Orders column tables
      IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'DictionaryLookupForEncryption_Orders_PayNumber') 
            DROP TABLE [dbo].[DictionaryLookupForEncryption_Orders_PayNumber];
      CREATE TABLE [dbo].[DictionaryLookupForEncryption_Orders_PayNumber] (
            [ORDER_NUMBER] numeric(15,2),
            [OldPayNumberValue] varchar(150) NOT NULL,
            [NewPayNumberValue] varchar(150) NOT NULL
            CONSTRAINT [PK_DictionaryLookupForEncryption_Orders_PayNumber] PRIMARY KEY CLUSTERED ( [ORDER_NUMBER] ASC )
      );

      IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'DictionaryLookupForEncryption_Orders_CSC') 
            DROP TABLE [dbo].[DictionaryLookupForEncryption_Orders_CSC];
      CREATE TABLE [dbo].[DictionaryLookupForEncryption_Orders_CSC] (
            [ORDER_NUMBER] numeric(15,2),
            [OldCSCValue] varchar(150) NOT NULL,
            [NewCSCValue] varchar(150) NOT NULL
            CONSTRAINT [PK_DictionaryLookupForEncryption_Orders_CSC] PRIMARY KEY CLUSTERED ( [ORDER_NUMBER] ASC )
      );

      IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'DictionaryLookupForEncryption_Orders_CCExpires') 
            DROP TABLE [dbo].[DictionaryLookupForEncryption_Orders_CCExpires];
      CREATE TABLE [dbo].[DictionaryLookupForEncryption_Orders_CCExpires] (
            [ORDER_NUMBER] numeric(15,2),
            [OldCCExpiresValue] varchar(150) NOT NULL,
            [NewCCExpiresValue] varchar(150) NOT NULL
            CONSTRAINT [PK_DictionaryLookupForEncryption_Orders_CCExpires] PRIMARY KEY CLUSTERED ( [ORDER_NUMBER] ASC )
      );

      -- Order_Payments tables
      IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'DictionaryLookupForEncryption_OrderPayments_PayNumber') 
            DROP TABLE [dbo].[DictionaryLookupForEncryption_OrderPayments_PayNumber];
      CREATE TABLE [dbo].[DictionaryLookupForEncryption_OrderPayments_PayNumber] (
            [ORDER_NUMBER] numeric(15,2),
            [PAYMENT_NUMBER] numeric(15,2),
            [OldPayNumberValue] varchar(150) NOT NULL,
            [NewPayNumberValue] varchar(150) NOT NULL
            CONSTRAINT [PK_DictionaryLookupForEncryption_OrderPayments_PayNumber] PRIMARY KEY CLUSTERED ( [ORDER_NUMBER] ASC, [PAYMENT_NUMBER] ASC)
      );

      IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'DictionaryLookupForEncryption_OrderPayments_CSC') 
            DROP TABLE [dbo].[DictionaryLookupForEncryption_OrderPayments_CSC];
      CREATE TABLE [dbo].[DictionaryLookupForEncryption_OrderPayments_CSC] (
            [ORDER_NUMBER] numeric(15,2),
            [PAYMENT_NUMBER] numeric(15,2),
            [OldCSCValue] varchar(150) NOT NULL,
            [NewCSCValue] varchar(150) NOT NULL
            CONSTRAINT [PK_DictionaryLookupForEncryption_OrderPayments_CSC] PRIMARY KEY CLUSTERED ( [ORDER_NUMBER] ASC, [PAYMENT_NUMBER] ASC)
      );

      IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'DictionaryLookupForEncryption_OrderPayments_CCExpires') 
            DROP TABLE [dbo].[DictionaryLookupForEncryption_OrderPayments_CCExpires];
      CREATE TABLE [dbo].[DictionaryLookupForEncryption_OrderPayments_CCExpires] (
            [ORDER_NUMBER] numeric(15,2),
            [PAYMENT_NUMBER] numeric(15,2),
            [OldCCExpiresValue] varchar(150) NOT NULL,
            [NewCCExpiresValue] varchar(150) NOT NULL
            CONSTRAINT [PK_DictionaryLookupForEncryption_OrderPayments_CCExpires] PRIMARY KEY CLUSTERED ( [ORDER_NUMBER] ASC, [PAYMENT_NUMBER] ASC)
      );

      -- Basket_Payment tables
      IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'DictionaryLookupForEncryption_BasketPayment_PayNumber') 
            DROP TABLE [dbo].[DictionaryLookupForEncryption_BasketPayment_PayNumber];
      CREATE TABLE [dbo].[DictionaryLookupForEncryption_BasketPayment_PayNumber] (
            [ID] varchar(10),
            [IP_ADDRESS] varchar(30),
            [OldPayNumberValue] varchar(150) NOT NULL,
            [NewPayNumberValue] varchar(150) NOT NULL
            CONSTRAINT [PK_DictionaryLookupForEncryption_BasketPayment_PayNumber] PRIMARY KEY CLUSTERED ( [ID] ASC, [IP_ADDRESS] ASC)
      );

      IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'DictionaryLookupForEncryption_BasketPayment_CSC') 
            DROP TABLE [dbo].[DictionaryLookupForEncryption_BasketPayment_CSC];
      CREATE TABLE [dbo].[DictionaryLookupForEncryption_BasketPayment_CSC] (
            [ID] varchar(10),
            [IP_ADDRESS] varchar(30),
            [OldCSCValue] varchar(150) NOT NULL,
            [NewCSCValue] varchar(150) NOT NULL
            CONSTRAINT [PK_DictionaryLookupForEncryption_BasketPayment_CSC] PRIMARY KEY CLUSTERED ( [ID] ASC, [IP_ADDRESS] ASC)
      );

      IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'DictionaryLookupForEncryption_BasketPayment_CCExpires') 
            DROP TABLE [dbo].[DictionaryLookupForEncryption_BasketPayment_CCExpires];
      CREATE TABLE [dbo].[DictionaryLookupForEncryption_BasketPayment_CCExpires] (
            [ID] varchar(10),
            [IP_ADDRESS] varchar(30),
            [OldCCExpiresValue] varchar(150) NOT NULL,
            [NewCCExpiresValue] varchar(150) NOT NULL
            CONSTRAINT [PK_DictionaryLookupForEncryption_BasketPayment_CCExpires] PRIMARY KEY CLUSTERED ( [ID] ASC, [IP_ADDRESS] ASC)
      );

      -- PCIAuditLog table
      IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'DictionaryLookupForEncryption_PciAuditLog_CCNumber') 
            DROP TABLE [dbo].[DictionaryLookupForEncryption_PciAuditLog_CCNumber];
      CREATE TABLE [dbo].[DictionaryLookupForEncryption_PciAuditLog_CCNumber] (
            [PciAuditLogId] int,
            [OldCCNumberValue] varchar(150) NOT NULL,
            [NewCCNumberValue] varchar(150) NOT NULL
            CONSTRAINT [PK_DictionaryLookupForEncryption_PciAuditLog_CCNumber] PRIMARY KEY CLUSTERED ( [PciAuditLogId] ASC )
      );

      -- UserMain table
      IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'DictionaryLookupForEncryption_UserMain_MultiFactorInfo') 
            DROP TABLE [dbo].[DictionaryLookupForEncryption_UserMain_MultiFactorInfo];
      CREATE TABLE [dbo].[DictionaryLookupForEncryption_UserMain_MultiFactorInfo] (
            [UserKey] uniqueidentifier,
            [OldMultiFactorInfoValue] nvarchar(max) NULL,
            [NewMultiFactorInfoValue] nvarchar(max) NULL
            CONSTRAINT [PK_DictionaryLookupForEncryption_UserMain_MultiFactorInfo] PRIMARY KEY CLUSTERED ( [UserKey] ASC )
      );
      
      -- CCAuthAcct table
      IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'DictionaryLookupForEncryption_CCAuthAcct_CCAuthPassword') 
            DROP TABLE [dbo].[DictionaryLookupForEncryption_CCAuthAcct_CCAuthPassword];
      CREATE TABLE [dbo].[DictionaryLookupForEncryption_CCAuthAcct_CCAuthPassword] (
            [CCAuthAcctCode] varchar(20),
            [OldCCAuthPasswordValue] varchar(255) NULL,
            [NewCCAuthPasswordValue] varchar(255) NULL
            CONSTRAINT [PK_DictionaryLookupForEncryption_CCAuthAcct_CCAuthPassword] PRIMARY KEY CLUSTERED ( [CCAuthAcctCode] ASC )
      );
      
      -- SystemConfigXml table
      IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'DictionaryLookupForEncryption_SystemConfigXml_ConfigValue') 
            DROP TABLE [dbo].[DictionaryLookupForEncryption_SystemConfigXml_ConfigValue];
      CREATE TABLE [dbo].[DictionaryLookupForEncryption_SystemConfigXml_ConfigValue] (
            [SystemConfigXmlCode] nvarchar(100),
            [OldConfigValue] nvarchar(max) NULL,
            [NewConfigValue] nvarchar(max) NULL
            CONSTRAINT [PK_DictionaryLookupForEncryption_SystemConfigXml_ConfigValue] PRIMARY KEY CLUSTERED ( [SystemConfigXmlCode] ASC )
      );
      
      -- Cart table
      IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'DictionaryLookupForEncryption_Cart_ComboOrder') 
            DROP TABLE [dbo].[DictionaryLookupForEncryption_Cart_ComboOrder];
      CREATE TABLE [dbo].[DictionaryLookupForEncryption_Cart_ComboOrder] (
            [CartKey] [uniqueidentifier],
            [OldComboOrderValue] nvarchar(max) NULL,
            [NewComboOrderValue] nvarchar(max) NULL
            CONSTRAINT [PK_DictionaryLookupForEncryption_Cart_ComboOrder] PRIMARY KEY CLUSTERED ( [CartKey] ASC )
      );
      
      --==============================================================================
      -- Insert encrypted values for [dbo].[Trans].[ENCRYPT_CC_NUMBER] 
      --==============================================================================
      BEGIN TRANSACTION;
      INSERT INTO [dbo].[DictionaryLookupForEncryption_Trans_CCNumber] ([TRANS_NUMBER], [LINE_NUMBER], [SUB_LINE_NUMBER], [OldCCNumberValue], [NewCCNumberValue]) 
            SELECT tbl.[TRANS_NUMBER], tbl.[LINE_NUMBER], tbl.[SUB_LINE_NUMBER], tbl.[ENCRYPT_CC_NUMBER], '' 
                  FROM [dbo].[Trans] tbl 
                  WHERE tbl.[ENCRYPT_CC_NUMBER] > ''; 
      COMMIT TRANSACTION;
      
      --==============================================================================
      -- Insert encrypted values for [dbo].[Trans].[ENCRYPT_CSC] 
      --==============================================================================
      BEGIN TRANSACTION;
      INSERT INTO [dbo].[DictionaryLookupForEncryption_Trans_CSC] ([TRANS_NUMBER], [LINE_NUMBER], [SUB_LINE_NUMBER], [OldCSCValue], [NewCSCValue]) 
            SELECT tbl.[TRANS_NUMBER], tbl.[LINE_NUMBER], tbl.[SUB_LINE_NUMBER], 
                        tbl.[ENCRYPT_CSC], '' 
                  FROM [dbo].[Trans] tbl 
                  WHERE tbl.[ENCRYPT_CSC] > ''; 
      COMMIT TRANSACTION;
      
      --==============================================================================
      -- Insert encrypted values for [dbo].[Trans].[ENCRYPT_CC_EXPIRE] 
      --==============================================================================
      BEGIN TRANSACTION;
      INSERT INTO [dbo].[DictionaryLookupForEncryption_Trans_CCExpire] ([TRANS_NUMBER], [LINE_NUMBER], [SUB_LINE_NUMBER], [OldCCExpireValue], [NewCCExpireValue]) 
            SELECT tbl.[TRANS_NUMBER], tbl.[LINE_NUMBER], tbl.[SUB_LINE_NUMBER], tbl.[ENCRYPT_CC_EXPIRE], '' 
                  FROM [dbo].[Trans] tbl 
                  WHERE tbl.[ENCRYPT_CC_EXPIRE] > ''; 
      COMMIT TRANSACTION;
      
      --==============================================================================
      -- Insert encrypted values for [dbo].[Orders].[ENCRYPT_PAY_NUMBER] 
      --==============================================================================
      BEGIN TRANSACTION;
      INSERT INTO [dbo].[DictionaryLookupForEncryption_Orders_PayNumber] ([ORDER_NUMBER], [OldPayNumberValue],[NewPayNumberValue]) 
            SELECT [ORDER_NUMBER], tbl.[ENCRYPT_PAY_NUMBER], '' 
                  FROM [dbo].[Orders] tbl 
                  WHERE tbl.[ENCRYPT_PAY_NUMBER] > '';
      COMMIT TRANSACTION;
      
      --==============================================================================
      -- Insert encrypted values for [dbo].[Orders].[ENCRYPT_CSC] 
      --==============================================================================
      BEGIN TRANSACTION;
      INSERT INTO [dbo].[DictionaryLookupForEncryption_Orders_CSC] ([ORDER_NUMBER], [OldCSCValue],[NewCSCValue]) 
            SELECT [ORDER_NUMBER], tbl.[ENCRYPT_CSC],'' 
                  FROM [dbo].[Orders] tbl 
                  WHERE tbl.[ENCRYPT_CSC] > '';
      COMMIT TRANSACTION;

      --==============================================================================
      -- Insert encrypted values for [dbo].[Orders].[ENCRYPT_CREDIT_CARD_EXPIRES] 
      --==============================================================================

      BEGIN TRANSACTION;
      INSERT INTO [dbo].[DictionaryLookupForEncryption_Orders_CCExpires] ([ORDER_NUMBER], [OldCCExpiresValue],[NewCCExpiresValue]) 
            SELECT [ORDER_NUMBER], tbl.[ENCRYPT_CREDIT_CARD_EXPIRES], '' 
                  FROM [dbo].[Orders] tbl 
                  WHERE tbl.[ENCRYPT_CREDIT_CARD_EXPIRES] > '';
      COMMIT TRANSACTION;

      --==============================================================================
      -- Insert encrypted values for [dbo].[Order_Payments].[ENCRYPT_PAY_NUMBER] 
      --==============================================================================
      BEGIN TRANSACTION;
      INSERT INTO [dbo].[DictionaryLookupForEncryption_OrderPayments_PayNumber] ([ORDER_NUMBER], [PAYMENT_NUMBER], [OldPayNumberValue], [NewPayNumberValue]) 
            SELECT [ORDER_NUMBER], [PAYMENT_NUMBER], tbl.[ENCRYPT_PAY_NUMBER], '' 
                  FROM [dbo].[Order_Payments] tbl 
                  WHERE tbl.[ENCRYPT_PAY_NUMBER] > '';
      COMMIT TRANSACTION;
      
      --==============================================================================
      -- Insert encrypted values for [dbo].[Order_Payments].[ENCRYPT_CSC] 
      --==============================================================================

      BEGIN TRANSACTION;
      INSERT INTO [dbo].[DictionaryLookupForEncryption_OrderPayments_CSC] ([ORDER_NUMBER], [PAYMENT_NUMBER], [OldCSCValue],[NewCSCValue]) 
            SELECT [ORDER_NUMBER], [PAYMENT_NUMBER], tbl.[ENCRYPT_CSC], '' 
            FROM [dbo].[Order_Payments] tbl 
            WHERE tbl.[ENCRYPT_CSC] > '';
      COMMIT TRANSACTION;

      --==============================================================================
      -- Insert encrypted values for [dbo].[Order_Payments].[ENCRYPT_CREDIT_CARD_EXPIRES] 
      --==============================================================================
      BEGIN TRANSACTION;
      INSERT INTO [dbo].[DictionaryLookupForEncryption_OrderPayments_CCExpires] ([ORDER_NUMBER], [PAYMENT_NUMBER], [OldCCExpiresValue],[NewCCExpiresValue]) 
            SELECT [ORDER_NUMBER], [PAYMENT_NUMBER], tbl.[ENCRYPT_CREDIT_CARD_EXPIRES], '' 
                  FROM [dbo].[Order_Payments] tbl 
                  WHERE tbl.[ENCRYPT_CREDIT_CARD_EXPIRES] > ''; 
      COMMIT TRANSACTION;

      --==============================================================================
      -- Insert encrypted values for [dbo].[Basket_Payment].[ENCRYPT_PAY_NUMBER] 
      --==============================================================================
      BEGIN TRANSACTION;
      INSERT INTO [dbo].[DictionaryLookupForEncryption_BasketPayment_PayNumber] ([ID], [IP_ADDRESS], [OldPayNumberValue], [NewPayNumberValue]) 
            SELECT [ID], [IP_ADDRESS], tbl.[ENCRYPT_PAY_NUMBER], '' 
                  FROM [dbo].[Basket_Payment] tbl 
                  WHERE tbl.[ENCRYPT_PAY_NUMBER] > '';
      COMMIT TRANSACTION;

      --==============================================================================
      -- Insert encrypted values for [dbo].[Basket_Payment].[ENCRYPT_CSC] 
      --==============================================================================
      BEGIN TRANSACTION;
      INSERT INTO [dbo].[DictionaryLookupForEncryption_BasketPayment_CSC] ([ID], [IP_ADDRESS], [OldCSCValue], [NewCSCValue]) 
            SELECT [ID], [IP_ADDRESS], tbl.[ENCRYPT_CSC], '' 
                  FROM [dbo].[Basket_Payment] tbl 
                  WHERE tbl.[ENCRYPT_CSC] > '';
      COMMIT TRANSACTION;

      --==============================================================================
      -- Insert encrypted values for [dbo].[Basket_Payment].[ENCRYPT_CREDIT_CARD_EXPIRES] 
      --==============================================================================
      BEGIN TRANSACTION;
      INSERT INTO [dbo].[DictionaryLookupForEncryption_BasketPayment_CCExpires] ([ID], [IP_ADDRESS], [OldCCExpiresValue], [NewCCExpiresValue]) 
            SELECT [ID], [IP_ADDRESS], tbl.[ENCRYPT_CREDIT_CARD_EXPIRES], '' 
                  FROM [dbo].[Basket_Payment] tbl 
                  WHERE tbl.[ENCRYPT_CREDIT_CARD_EXPIRES] > '';
      COMMIT TRANSACTION;

      --==============================================================================
      -- Insert encrypted values for [dbo].[PciAuditLog].[ENCRYPT_CC_NUMBER] 
      --==============================================================================
      BEGIN TRANSACTION;
      INSERT INTO [dbo].[DictionaryLookupForEncryption_PciAuditLog_CCNumber] ([PciAuditLogId], [OldCCNumberValue], [NewCCNumberValue]) 
            SELECT [PciAuditLogId], tbl.[ENCRYPT_CC_NUMBER], '' 
                  FROM [dbo].[PciAuditLog] tbl 
                  WHERE tbl.[ENCRYPT_CC_NUMBER] > '';
      COMMIT TRANSACTION;
      
      --==============================================================================
      -- Insert encrypted values for [dbo].[UserMain].[MultiFactorInfo] 
      --==============================================================================
      BEGIN TRANSACTION;
      INSERT INTO [dbo].[DictionaryLookupForEncryption_UserMain_MultiFactorInfo] ([UserKey], [OldMultiFactorInfoValue], [NewMultiFactorInfoValue]) 
            SELECT [UserKey], tbl.[MultiFactorInfo], '' 
                  FROM [dbo].[UserMain] tbl 
                  WHERE tbl.[MultiFactorInfo] > '';
      COMMIT TRANSACTION;
      
      --==============================================================================
      -- Insert encrypted values for [dbo].[CCAuthAcct].[CCAuthPassword] 
      --==============================================================================
      BEGIN TRANSACTION;
      INSERT INTO [dbo].[DictionaryLookupForEncryption_CCAuthAcct_CCAuthPassword] ([CCAuthAcctCode], [OldCCAuthPasswordValue], [NewCCAuthPasswordValue]) 
            SELECT [CCAuthAcctCode], tbl.[CCAuthPassword], '' 
                  FROM [dbo].[CCAuthAcct] tbl 
                  WHERE tbl.[CCAuthPassword] > '';
      COMMIT TRANSACTION;
      
      --==============================================================================
      -- Insert encrypted values for [dbo].[SystemConfigXml].[ConfigValue] 
      --==============================================================================
      BEGIN TRANSACTION;
      INSERT INTO [dbo].[DictionaryLookupForEncryption_SystemConfigXml_ConfigValue] ([SystemConfigXmlCode], [OldConfigValue], [NewConfigValue]) 
            SELECT [SystemConfigXmlCode], tbl.[ConfigValue], '' 
                  FROM [dbo].[SystemConfigXml] tbl 
                  WHERE tbl.[ConfigValue] > '';
      COMMIT TRANSACTION;
      
      --==============================================================================
      -- Insert encrypted values for [dbo].[Cart].[ComboOrder] 
      --==============================================================================
      BEGIN TRANSACTION;
      INSERT INTO [dbo].[DictionaryLookupForEncryption_Cart_ComboOrder] ([CartKey], [OldComboOrderValue], [NewComboOrderValue]) 
            SELECT [CartKey], tbl.[ComboOrder], '' 
                  FROM [dbo].[Cart] tbl 
                  WHERE tbl.[ComboOrder] > '';
      COMMIT TRANSACTION;
      
      ---------------------------
      -- Drop temporary indexes
      ---------------------------
      IF  EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[Trans]') AND name = N'iTransENCRYPT_CSC')
            DROP INDEX [iTransENCRYPT_CSC] ON [dbo].[Trans] WITH ( ONLINE = OFF );
      IF  EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[Trans]') AND name = N'iTransENCRYPT_CC_NUMBER')
            DROP INDEX [iTransENCRYPT_CC_NUMBER] ON [dbo].[Trans] WITH ( ONLINE = OFF );
      IF  EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[Trans]') AND name = N'iTransENCRYPT_CC_EXPIRE')
            DROP INDEX [iTransENCRYPT_CC_EXPIRE] ON [dbo].[Trans] WITH ( ONLINE = OFF );



END





GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ProcessContactFormula]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ProcessContactFormula]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE proc [dbo].[asi_ProcessContactFormula]
	(@inputFormula nvarchar(1000),
	@inputSourceTable nvarchar(200),
	@inputColumnName nvarchar(200),
	@inputColumnValue uniqueidentifier)
as
begin

set nocount on

declare @sqlStmt nvarchar(2000)
declare @substr1 nvarchar(1000)
declare @substr2 nvarchar(1000)
declare @substrPreField nvarchar(100)
declare @substrPostField nvarchar(100)
declare @substrPreStmt nvarchar(1000)
declare @substrPostStmt nvarchar(1000)

declare @pos1 int
declare @pos2 int
declare @pos3 int
declare @pos4 int
declare @pos5 int

declare @firstchar nvarchar(1)
declare @done bit

select @sqlStmt = 'select '

select @substrPreStmt = left (@inputFormula, 1)
if @substrPreStmt = '{' or @substrPreStmt = '['
	select @substrPreStmt = ''
else
	begin
	select @substrPreStmt = @inputFormula
	select @pos4 = charindex ('[', @substrPreStmt)
	select @pos5 = charindex ('{', @substrPreStmt)
	if @pos5 < @pos4 and @pos5 <> 0
	 	select @pos4 = @pos5
	select @substrPreStmt = left (@substrPreStmt, @pos4 - 1)
	end

select @sqlStmt = @sqlStmt + '''' + @substrPreStmt + '''' + ' + '

select @substrPostStmt = left (reverse(@inputFormula), 1)
if @substrPostStmt = '}' or @substrPostStmt = ']'
	select @substrPostStmt = ''
else
	begin
	select @substrPostStmt = reverse(@inputFormula)
	select @pos4 = charindex (']', @substrPostStmt)
	select @pos5 = charindex ('}', @substrPostStmt)
	if @pos5 < @pos4 and @pos5 <> 0
	 	select @pos4 = @pos5
	select @substrPostStmt = left (@substrPostStmt, @pos4 - 1)
	select @substrPostStmt = reverse(@substrPostStmt)
	end

select @substr1 = substring (@inputFormula, datalength (@substrPreStmt)/2 + 1, 
	datalength (@inputFormula)/2 - datalength (@substrPreStmt)/2 - datalength (@substrPostStmt)/2)

select @done = 0

while @done = 0
begin
select @firstchar = left (@substr1, 1)
if @firstchar = '{'
	begin	-- find a matching curly bracket
		select @substr2 = substring (@substr1, 1, charindex ('}', @substr1))
		select @pos2 = datalength (@substr2)/2
		select @substrPreField = substring (@substr1, 2, charindex ('[', @substr1) - 2)
		select @substrPostField = substring (@substr1, charindex (']', @substr1) + 1, 
			(charindex ('}', @substr1) -  charindex (']', @substr1) - 1))
		select @pos3 = (datalength (@substr2)/2) - 4 - (datalength (@substrPreField)/2) - (datalength (@substrPostField)/2)
		select @substr2 = substring (@substr2, charindex ('[', @substr2) + 1, @pos3)
		if exists (select 1 from INFORMATION_SCHEMA.COLUMNS 
				where TABLE_NAME = @inputSourceTable
				and COLUMN_NAME = @substr2)
			select @sqlStmt = @sqlStmt + ' case when ' + @substr2 + ' is null then '''' else ' + '''' + @substrPreField + '''' + ' + ' + @substr2 + ' + ' + '''' + @substrPostField + '''' + ' end '  + ' + '
		else
			select @sqlStmt = @sqlStmt + '''' + @substrPreField + '''' + ' + ' + '''[' + @substr2 + ']''' + ' + ' + '''' + @substrPostField + '''' + ' + '

		select @substr1 = right (@substr1, datalength (@substr1)/2 - @pos2)
	end
else if @firstchar = '['
	begin	-- find a matching square bracket
		select @substr2 = substring (@substr1, 1, charindex (']', @substr1))
		select @substr2 = substring (@substr2, 2, datalength (@substr2)/2 -2)	

		if exists (select 1 from INFORMATION_SCHEMA.COLUMNS 
			where TABLE_NAME = @inputSourceTable
			and COLUMN_NAME = @substr2)
			select @sqlStmt = @sqlStmt + ' case when ' + @substr2 + ' is null then '''' else ' + @substr2 + ' end '  + ' + '
		else
			select @sqlStmt = @sqlStmt + '''' + @substr2 + '''' + ' + '
		select @substr1 = right (@substr1, datalength (@substr1)/2 - datalength (@substr2) /2 - 2)
	end
else
	begin	-- find everything up to the next curly or square bracket, and treat it as a literal
		select @pos4 = charindex ('[', @substr1)
		select @pos5 = charindex ('{', @substr1)
		if @pos5 < @pos4 and @pos5 <> 0
		 	select @pos4 = @pos5
		select @substr2 = left (@substr1, @pos4)

		if (datalength (@substr2) / 2) > 0
			begin
			select @substr2 = left (@substr2, datalength (@substr2)/2 - 1)
			select @sqlStmt = @sqlStmt + '''' + @substr2 + '''' + ' + '
			end
		else
			select @done = 1
		select @substr1 = right (@substr1, datalength (@substr1)/2 - datalength (@substr2) /2)
	end

end -- while @done = 0

if substring (@sqlStmt, (datalength (@sqlStmt)/2) - 1, 1) = '+'
	select @sqlStmt = substring (@sqlStmt, 1, (datalength (@sqlStmt)/2) - 2)

if (datalength (@substrPostStmt)/2 > 0)
 	select @sqlStmt = @sqlStmt + ' + ' + '''' + @substrPostStmt + ''''

-- support <n> for embedded newline, <t> for embedded tab anywhere in formula
while (charindex ('<n>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<n>', ''' + char(13) + ''')

while (charindex ('<t>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<t>', ''' + char(9) + ''')

-- support <[> and <]> to embed square brackets anywhere in formula
while (charindex ('<[>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<[>', '[')

while (charindex ('<]>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<]>', ']')

-- support <{> and <}> to embed curly brackets anywhere in formula
while (charindex ('<{>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<{>', '{')

while (charindex ('<}>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<}>', '}')

select @sqlStmt = @sqlStmt + ' from ' + @inputSourceTable + ' where ' + @inputColumnName + ' = ' 
	+ '''' + convert (nvarchar(50), @inputColumnValue) + ''''

create table #tmptbl (formattedOutput nvarchar(1000))
insert into #tmptbl  exec (@sqlStmt)

select formattedOutput from #tmptbl

set nocount off

END -- create proc ProcessContactFormula

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ProcessContactFormulaCopy]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ProcessContactFormulaCopy]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 
CREATE proc [dbo].[asi_ProcessContactFormulaCopy]
	(@inputFormula nvarchar(1000),
	@inputSourceTable nvarchar(200),
	@inputColumnName nvarchar(200),
	@inputColumnValue uniqueidentifier)
as
begin

set nocount on

declare @sqlStmt nvarchar(2000)
declare @substr1 nvarchar(1000)
declare @substr2 nvarchar(1000)
declare @substrPreField nvarchar(100)
declare @substrPostField nvarchar(100)
declare @substrPreStmt nvarchar(1000)
declare @substrPostStmt nvarchar(1000)

declare @pos1 int
declare @pos2 int
declare @pos3 int
declare @pos4 int
declare @pos5 int

declare @firstchar nvarchar(1)
declare @done bit

select @sqlStmt = 'select '

select @substrPreStmt = left (@inputFormula, 1)
if @substrPreStmt = '{' or @substrPreStmt = '['
	select @substrPreStmt = ''
else
	begin
	select @substrPreStmt = @inputFormula
	select @pos4 = charindex ('[', @substrPreStmt)
	select @pos5 = charindex ('{', @substrPreStmt)
	if @pos5 < @pos4 and @pos5 <> 0
	 	select @pos4 = @pos5
	select @substrPreStmt = left (@substrPreStmt, @pos4 - 1)
	end

select @sqlStmt = @sqlStmt + '''' + @substrPreStmt + '''' + ' + '

select @substrPostStmt = left (reverse(@inputFormula), 1)
if @substrPostStmt = '}' or @substrPostStmt = ']'
	select @substrPostStmt = ''
else
	begin
	select @substrPostStmt = reverse(@inputFormula)
	select @pos4 = charindex (']', @substrPostStmt)
	select @pos5 = charindex ('}', @substrPostStmt)
	if @pos5 < @pos4 and @pos5 <> 0
	 	select @pos4 = @pos5
	select @substrPostStmt = left (@substrPostStmt, @pos4 - 1)
	select @substrPostStmt = reverse(@substrPostStmt)
	end

select @substr1 = substring (@inputFormula, datalength (@substrPreStmt)/2 + 1, 
	datalength (@inputFormula)/2 - datalength (@substrPreStmt)/2 - datalength (@substrPostStmt)/2)

select @done = 0

while @done = 0
begin
select @firstchar = left (@substr1, 1)
if @firstchar = '{'
	begin	-- find a matching curly bracket
		select @substr2 = substring (@substr1, 1, charindex ('}', @substr1))
		select @pos2 = datalength (@substr2)/2
		select @substrPreField = substring (@substr1, 2, charindex ('[', @substr1) - 2)
		select @substrPostField = substring (@substr1, charindex (']', @substr1) + 1, 
			(charindex ('}', @substr1) -  charindex (']', @substr1) - 1))
		select @pos3 = (datalength (@substr2)/2) - 4 - (datalength (@substrPreField)/2) - (datalength (@substrPostField)/2)
		select @substr2 = substring (@substr2, charindex ('[', @substr2) + 1, @pos3)
		if exists (select 1 from INFORMATION_SCHEMA.COLUMNS 
				where TABLE_NAME = @inputSourceTable
				and COLUMN_NAME = @substr2)
			select @sqlStmt = @sqlStmt + ' case when ' + @substr2 + ' is null then '''' else ' + '''' + @substrPreField + '''' + ' + ' + @substr2 + ' + ' + '''' + @substrPostField + '''' + ' end '  + ' + '
		else
			select @sqlStmt = @sqlStmt + '''' + @substrPreField + '''' + ' + ' + '''[' + @substr2 + ']''' + ' + ' + '''' + @substrPostField + '''' + ' + '

		select @substr1 = right (@substr1, datalength (@substr1)/2 - @pos2)
	end
else if @firstchar = '['
	begin	-- find a matching square bracket
		select @substr2 = substring (@substr1, 1, charindex (']', @substr1))
		select @substr2 = substring (@substr2, 2, datalength (@substr2)/2 -2)	

		if exists (select 1 from INFORMATION_SCHEMA.COLUMNS 
			where TABLE_NAME = @inputSourceTable
			and COLUMN_NAME = @substr2)
			select @sqlStmt = @sqlStmt + ' case when ' + @substr2 + ' is null then '''' else ' + @substr2 + ' end '  + ' + '
		else
			select @sqlStmt = @sqlStmt + '''' + @substr2 + '''' + ' + '
		select @substr1 = right (@substr1, datalength (@substr1)/2 - datalength (@substr2) /2 - 2)
	end
else
	begin	-- find everything up to the next curly or square bracket, and treat it as a literal
		select @pos4 = charindex ('[', @substr1)
		select @pos5 = charindex ('{', @substr1)
		if @pos5 < @pos4 and @pos5 <> 0
		 	select @pos4 = @pos5
		select @substr2 = left (@substr1, @pos4)

		if (datalength (@substr2) / 2) > 0
			begin
			select @substr2 = left (@substr2, datalength (@substr2)/2 - 1)
			select @sqlStmt = @sqlStmt + '''' + @substr2 + '''' + ' + '
			end
		else
			select @done = 1
		select @substr1 = right (@substr1, datalength (@substr1)/2 - datalength (@substr2) /2)
	end

end -- while @done = 0

if substring (@sqlStmt, (datalength (@sqlStmt)/2) - 1, 1) = '+'
	select @sqlStmt = substring (@sqlStmt, 1, (datalength (@sqlStmt)/2) - 2)

if (datalength (@substrPostStmt)/2 > 0)
 	select @sqlStmt = @sqlStmt + ' + ' + '''' + @substrPostStmt + ''''

-- support <n> for embedded newline, <t> for embedded tab anywhere in formula
while (charindex ('<n>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<n>', ''' + char(13) + ''')

while (charindex ('<t>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<t>', ''' + char(9) + ''')

-- support <[> and <]> to embed square brackets anywhere in formula
while (charindex ('<[>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<[>', '[')

while (charindex ('<]>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<]>', ']')

-- support <{> and <}> to embed curly brackets anywhere in formula
while (charindex ('<{>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<{>', '{')

while (charindex ('<}>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<}>', '}')

select @sqlStmt = @sqlStmt + ' from ' + @inputSourceTable + ' where ' + @inputColumnName + ' = ' 
	+ '''' + convert (nvarchar(50), @inputColumnValue) + ''''

print @sqlStmt

create table #tmptbl (formattedOutput nvarchar(1000))
insert into #tmptbl  exec (@sqlStmt)

declare @formattedOutput nvarchar(2000)

select @formattedOutput = formattedOutput from #tmptbl
print @formattedOutput

select formattedOutput from #tmptbl

set nocount off

END -- create proc ProcessContactFormula

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ProcessContactFormulaOutput]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ProcessContactFormulaOutput]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE proc [dbo].[asi_ProcessContactFormulaOutput]
	(@inputTempKey uniqueidentifier,
	@inputFormula nvarchar(1000),
	@inputSourceTable nvarchar(200),
	@inputColumnName nvarchar(200),
	@inputColumnValue uniqueidentifier)

as

begin

set nocount on

declare @sqlStmt nvarchar(2000)
declare @substr1 nvarchar(1000)
declare @substr2 nvarchar(1000)
declare @substrPreField nvarchar(100)
declare @substrPostField nvarchar(100)
declare @substrPreStmt nvarchar(1000)
declare @substrPostStmt nvarchar(1000)

declare @pos1 int
declare @pos2 int
declare @pos3 int
declare @pos4 int
declare @pos5 int

declare @firstchar nvarchar(1)
declare @done bit

select @sqlStmt = 'select '

select @substrPreStmt = left (@inputFormula, 1)
if @substrPreStmt = '{' or @substrPreStmt = '['
	select @substrPreStmt = ''
else
	begin
	select @substrPreStmt = @inputFormula
	select @pos4 = charindex ('[', @substrPreStmt)
	select @pos5 = charindex ('{', @substrPreStmt)
	if @pos5 < @pos4 and @pos5 <> 0
	 	select @pos4 = @pos5
	select @substrPreStmt = left (@substrPreStmt, @pos4 - 1)
	end

select @sqlStmt = @sqlStmt + '''' + @substrPreStmt + '''' + ' + '

select @substrPostStmt = left (reverse(@inputFormula), 1)
if @substrPostStmt = '}' or @substrPostStmt = ']'
	select @substrPostStmt = ''
else
	begin
	select @substrPostStmt = reverse(@inputFormula)
	select @pos4 = charindex (']', @substrPostStmt)
	select @pos5 = charindex ('}', @substrPostStmt)
	if @pos5 < @pos4 and @pos5 <> 0
	 	select @pos4 = @pos5
	select @substrPostStmt = left (@substrPostStmt, @pos4 - 1)
	select @substrPostStmt = reverse(@substrPostStmt)
	end

select @substr1 = substring (@inputFormula, datalength (@substrPreStmt)/2 + 1, 
	datalength (@inputFormula)/2 - datalength (@substrPreStmt)/2 - datalength (@substrPostStmt)/2)

select @done = 0

while @done = 0
begin
select @firstchar = left (@substr1, 1)
if @firstchar = '{'
	begin	-- find a matching curly bracket
		select @substr2 = substring (@substr1, 1, charindex ('}', @substr1))
		select @pos2 = datalength (@substr2)/2
		select @substrPreField = substring (@substr1, 2, charindex ('[', @substr1) - 2)
		select @substrPostField = substring (@substr1, charindex (']', @substr1) + 1, 
			(charindex ('}', @substr1) -  charindex (']', @substr1) - 1))
		select @pos3 = (datalength (@substr2)/2) - 4 - (datalength (@substrPreField)/2) - (datalength (@substrPostField)/2)
		select @substr2 = substring (@substr2, charindex ('[', @substr2) + 1, @pos3)
		if exists (select 1 from INFORMATION_SCHEMA.COLUMNS 
				where TABLE_NAME = @inputSourceTable
				and COLUMN_NAME = @substr2)
			select @sqlStmt = @sqlStmt + ' case when ' + @substr2 + ' is null then '''' else ' + '''' + @substrPreField + '''' + ' + ' + @substr2 + ' + ' + '''' + @substrPostField + '''' + ' end '  + ' + '
		else
			select @sqlStmt = @sqlStmt + '''' + @substrPreField + '''' + ' + ' + '''[' + @substr2 + ']''' + ' + ' + '''' + @substrPostField + '''' + ' + '

		select @substr1 = right (@substr1, datalength (@substr1)/2 - @pos2)
	end
else if @firstchar = '['
	begin	-- find a matching square bracket
		select @substr2 = substring (@substr1, 1, charindex (']', @substr1))
		select @substr2 = substring (@substr2, 2, datalength (@substr2)/2 -2)	

		if exists (select 1 from INFORMATION_SCHEMA.COLUMNS 
			where TABLE_NAME = @inputSourceTable
			and COLUMN_NAME = @substr2)
			select @sqlStmt = @sqlStmt + ' case when ' + @substr2 + ' is null then '''' else ' + @substr2 + ' end '  + ' + '
		else
			select @sqlStmt = @sqlStmt + '''' + @substr2 + '''' + ' + '
		select @substr1 = right (@substr1, datalength (@substr1)/2 - datalength (@substr2) /2 - 2)
	end
else
	begin	-- find everything up to the next curly or square bracket, and treat it as a literal
		select @pos4 = charindex ('[', @substr1)
		select @pos5 = charindex ('{', @substr1)
		if @pos5 < @pos4 and @pos5 <> 0
		 	select @pos4 = @pos5
		select @substr2 = left (@substr1, @pos4)

		if (datalength (@substr2) / 2) > 0
			begin
			select @substr2 = left (@substr2, datalength (@substr2)/2 - 1)
			select @sqlStmt = @sqlStmt + '''' + @substr2 + '''' + ' + '
			end
		else
			select @done = 1
		select @substr1 = right (@substr1, datalength (@substr1)/2 - datalength (@substr2) /2)
	end

end -- while @done = 0

if substring (@sqlStmt, (datalength (@sqlStmt)/2) - 1, 1) = '+'
	select @sqlStmt = substring (@sqlStmt, 1, (datalength (@sqlStmt)/2) - 2)

if (datalength (@substrPostStmt)/2 > 0)
 	select @sqlStmt = @sqlStmt + ' + ' + '''' + @substrPostStmt + ''''

-- support <n> for embedded newline, <t> for embedded tab anywhere in formula
while (charindex ('<n>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<n>', ''' + char(13) + ''')

while (charindex ('<t>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<t>', ''' + char(9) + ''')

-- support <[> and <]> to embed square brackets anywhere in formula
while (charindex ('<[>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<[>', '[')

while (charindex ('<]>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<]>', ']')

-- support <{> and <}> to embed curly brackets anywhere in formula
while (charindex ('<{>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<{>', '{')

while (charindex ('<}>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<}>', '}')

select @sqlStmt = @sqlStmt + ' from ' + @inputSourceTable + ' where ' + @inputColumnName + ' = ' 
	+ '''' + convert (nvarchar(50), @inputColumnValue) + ''''

create table #tmptbl (formattedOutput nvarchar(1000))
insert into #tmptbl  exec (@sqlStmt)

insert tempFormula (tempKey, tempValue) 
	select @inputTempKey, formattedOutput from #tmptbl

set nocount off

END -- create proc ProcessContactFormula

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ProcessDynamicGroup]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ProcessDynamicGroup]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_ProcessDynamicGroup]
    @groupName nvarchar(65),
    @userKey   uniqueidentifier
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @viewName sysname;
    DECLARE @groupKey uniqueidentifier;
    DECLARE @sql nvarchar(2000);
    DECLARE @newMembersSQL nvarchar(2000);
    DECLARE @leavingMembersSql nvarchar(2000);
    DECLARE @now datetime;
    
    SELECT @now = dbo.asi_GetAppDatetime();
    
    SELECT @viewName = [ViewName],
           @groupKey = [GroupKey]
      FROM [dbo].[DynamicGroup]
     WHERE [GroupName] = @groupName;
     
    IF @groupKey IS NULL
    BEGIN
        RAISERROR('No matching row was found in the DynamicGroup table', 16, 1);
        RETURN;
    END;
    
    IF NOT EXISTS (SELECT 1
                     FROM [INFORMATION_SCHEMA].[VIEWS]
                    WHERE [TABLE_NAME] = @viewName
    )
    BEGIN
        RAISERROR('Invalid ViewName specified in the DynamicGroup table', 16, 1);
        RETURN;
    END;
    
    IF NOT EXISTS (SELECT 1
                     FROM [dbo].[UserMain]
                    WHERE [UserKey] = @userKey
    )
    BEGIN
        RAISERROR('Invalid UserKey specified', 16, 1);
        RETURN;
    END;
    
    IF OBJECT_ID('tempdb..#DynamicGroupChanges') IS NOT NULL
    BEGIN
        DROP TABLE [#DynamicGroupChanges]
    END;
    CREATE TABLE [#DynamicGroupChanges] (
                 [ContactKey] uniqueidentifier PRIMARY KEY
    );

    -- New members joining the group 
    SET @newMembersSQL = N'SELECT v.[DynamicGroupMemberContactKey] FROM [dbo].[' + @viewName + '] v INNER JOIN [dbo].[ContactMain] c ON v.[DynamicGroupMemberContactKey] = c.[ContactKey] '+N'WHERE NOT EXISTS (SELECT 1 FROM [dbo].[GroupMember] gm WHERE v.[DynamicGroupMemberContactKey] = gm.[MemberContactKey] AND gm.[GroupKey] = @groupKey) ' + N'GROUP BY v.[DynamicGroupMemberContactKey]';
    INSERT INTO [#DynamicGroupChanges] ([ContactKey])
        EXEC [sp_executesql]
             @newMembersSQL,
             N'@groupKey uniqueidentifier',
             @groupKey;
             
    INSERT INTO [dbo].[GroupMember] ([GroupMemberKey],
                                     [GroupKey],
                                     [MemberContactKey],
                                     [IsActive],
                                     [CreatedByUserKey],
                                     [CreatedOn],
                                     [UpdatedByUserKey],
                                     [UpdatedOn],
                                     [JoinDate]
                                    )
           SELECT NEWID(),
                  @groupKey,
                  [ContactKey],
                  1,
                  @userKey,
                  @now,
                  @userKey,
                  @now,
                  @now
             FROM [#DynamicGroupChanges];
             
    TRUNCATE TABLE [#DynamicGroupChanges];

    -- Old member leaving the group
    SET @leavingMembersSql = N'SELECT gm.[MemberContactKey] FROM [dbo].[GroupMember] gm ' + N'WHERE gm.[GroupKey] = @groupKey AND NOT EXISTS (SELECT 1 FROM [dbo].[' + @viewName + '] v WHERE gm.[MemberContactKey] = v.[DynamicGroupMemberContactKey])';
    INSERT INTO [#DynamicGroupChanges] ([ContactKey])
        EXEC [sp_executesql]
             @leavingMembersSql,
             N'@groupKey uniqueidentifier',
             @groupKey;
         
    DELETE [gm]
      FROM [dbo].[GroupMember] [gm]
           INNER JOIN [#DynamicGroupChanges] [dgc] ON [gm].[MemberContactKey] = [dgc].[ContactKey]
     WHERE [gm].[GroupKey] = @groupKey;
     
    IF OBJECT_ID('tempdb..#DynamicGroupChanges') IS NOT NULL
    BEGIN
        DROP TABLE [#DynamicGroupChanges]
    END;
    
    UPDATE [dbo].[GroupMain]
       SET [UpdatedOn] = @now
     WHERE [GroupKey] = @groupKey;
     
    SET NOCOUNT OFF;
END; -- create proc asi_ProcessDynamicGroup


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ProcessEngineTypeByKey]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ProcessEngineTypeByKey]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_ProcessEngineTypeByKey    Script Date: 7/3/2003 4:58:04 PM ******/
CREATE   PROC [dbo].[asi_ProcessEngineTypeByKey]
	@typeKey uniqueidentifier
	AS
BEGIN
	SET ROWCOUNT 1
	SELECT	ProcessEngineType.ProcessEngineTypeKey, 
			ProcessEngineType.Name, 
			ProcessEngineType.Assembly, 
			ProcessEngineType.QualifiedName, 
			ProcessEngineType.HasTemplate,
			ProcessEngineType.HasDesigner

	 FROM	ProcessEngineType
			
	 WHERE	ProcessEngineType.ProcessEngineTypeKey = @typeKey
	SET ROWCOUNT 0
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ProcessEngineTypeByName]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ProcessEngineTypeByName]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_ProcessEngineTypeByName    Script Date: 7/3/2003 4:58:04 PM ******/
CREATE   PROC [dbo].[asi_ProcessEngineTypeByName]
	@processEngineType nvarchar(100)
	AS
BEGIN
	SET ROWCOUNT 1
	SELECT	ProcessEngineType.ProcessEngineTypeKey, 
			ProcessEngineType.Name, 
			ProcessEngineType.Assembly, 
			ProcessEngineType.QualifiedName, 
			ProcessEngineType.HasTemplate,
			ProcessEngineType.HasDesigner

	 FROM	ProcessEngineType
			
	 WHERE	ProcessEngineType.Name = @processEngineType
	SET ROWCOUNT 0
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ProcessFormula]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ProcessFormula]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE proc [dbo].[asi_ProcessFormula]
	(@inputFormula nvarchar(1000),
	@inputSourceTable nvarchar(200),
	@inputColumnName nvarchar(200),
	@inputColumnValue uniqueidentifier)
as
begin

set nocount on

declare @sqlStmt nvarchar(2000)
declare @substr1 nvarchar(1000)
declare @substr2 nvarchar(1000)
declare @substr3 nvarchar(1000)
declare @substrPreField nvarchar(100)
declare @substrPostField nvarchar(100)
declare @substrPreStmt nvarchar(1000)
declare @substrPostStmt nvarchar(1000)

declare @pos1 int
declare @pos2 int
declare @pos3 int
declare @pos4 int
declare @pos5 int

declare @firstchar nvarchar(1)
declare @done bit

if charindex('[', @inputFormula) > 0
begin

select @sqlStmt = 'select '

select @substrPreStmt = left (@inputFormula, 1)
if @substrPreStmt = '{' or @substrPreStmt = '['
	select @substrPreStmt = ''
else
	begin
	select @substrPreStmt = @inputFormula
	select @pos4 = charindex ('[', @substrPreStmt)
	select @pos5 = charindex ('{', @substrPreStmt)
	if @pos5 < @pos4 and @pos5 <> 0
	 	select @pos4 = @pos5
	select @substrPreStmt = left (@substrPreStmt, @pos4 - 1)
	end

select @sqlStmt = @sqlStmt + '''' + @substrPreStmt + '''' + ' + '

select @substrPostStmt = left (reverse(@inputFormula), 1)
if @substrPostStmt = '}' or @substrPostStmt = ']'
	select @substrPostStmt = ''
else
	begin
	select @substrPostStmt = reverse(@inputFormula)
	select @pos4 = charindex (']', @substrPostStmt)
	select @pos5 = charindex ('}', @substrPostStmt)
	if @pos5 < @pos4 and @pos5 <> 0
	 	select @pos4 = @pos5
	select @substrPostStmt = left (@substrPostStmt, @pos4 - 1)
	select @substrPostStmt = reverse(@substrPostStmt)
	end

select @substr1 = substring (@inputFormula, datalength (@substrPreStmt)/2 + 1, 
	datalength (@inputFormula)/2 - datalength (@substrPreStmt)/2 - datalength (@substrPostStmt)/2)

select @done = 0

while @done = 0
begin
select @firstchar = left (@substr1, 1)
if @firstchar = '{'
	begin	-- find a matching curly bracket
		select @substr3 = substring (@substr1, 1, charindex ('}', @substr1))
		select @pos2 = datalength (@substr3)/2
		select @substrPreField = substring (@substr1, 2, charindex ('[', @substr1) - 2)
		select @substrPostField = substring (@substr1, charindex (']', @substr1) + 1, 
			(charindex ('}', @substr1) -  charindex (']', @substr1) - 1))
		select @pos3 = (datalength (@substr3)/2) - 4 - (datalength (@substrPreField)/2) - (datalength (@substrPostField)/2)
		select @substr2 = substring (@substr3, charindex ('[', @substr3) + 1, @pos3)
		if exists (select 1 from INFORMATION_SCHEMA.COLUMNS 
				where TABLE_NAME = @inputSourceTable
				and COLUMN_NAME = @substr2)
			select @sqlStmt = @sqlStmt + ' case when ' + @substr2 + ' is null then '''' else ' + '''' + @substrPreField + '''' + ' + ' + @substr2 + ' + ' + '''' + @substrPostField + '''' + ' end '  + ' + '
		else
			select @sqlStmt = @sqlStmt + '''' + @substr3 + '''' + ' + '

		select @substr1 = right (@substr1, datalength (@substr1)/2 - @pos2)
	end
else if @firstchar = '['
	begin	-- find a matching square bracket
		select @substr3 = substring (@substr1, 1, charindex (']', @substr1))
		select @substr2 = substring (@substr3, 2, datalength (@substr3)/2 -2)	

		if exists (select 1 from INFORMATION_SCHEMA.COLUMNS 
			where TABLE_NAME = @inputSourceTable
			and COLUMN_NAME = @substr2)
			select @sqlStmt = @sqlStmt + ' case when ' + @substr2 + ' is null then '''' else ' + @substr2 + ' end '  + ' + '
		else
			select @sqlStmt = @sqlStmt + '''' + @substr3 + '''' + ' + '
		select @substr1 = right (@substr1, datalength (@substr1)/2 - datalength (@substr2) /2 - 2)
	end
else
	begin	-- find everything up to the next curly or square bracket, and treat it as a literal
		select @pos4 = charindex ('[', @substr1)
		select @pos5 = charindex ('{', @substr1)
		if @pos5 < @pos4 and @pos5 <> 0
		 	select @pos4 = @pos5
		select @substr2 = left (@substr1, @pos4)

		if (datalength (@substr2) / 2) > 0
			begin
			select @substr2 = left (@substr2, datalength (@substr2)/2 - 1)
			select @sqlStmt = @sqlStmt + '''' + @substr2 + '''' + ' + '
			end
		else
			select @done = 1
		select @substr1 = right (@substr1, datalength (@substr1)/2 - datalength (@substr2) /2)
	end

end -- while @done = 0

if substring (@sqlStmt, (datalength (@sqlStmt)/2) - 1, 1) = '+'
	select @sqlStmt = substring (@sqlStmt, 1, (datalength (@sqlStmt)/2) - 2)

if (datalength (@substrPostStmt)/2 > 0)
 	select @sqlStmt = @sqlStmt + ' + ' + '''' + @substrPostStmt + ''''

-- support <n> for embedded newline, <t> for embedded tab anywhere in formula
while (charindex ('<n>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<n>', ''' + char(13) + char(10) + ''')

while (charindex ('<t>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<t>', ''' + char(9) + ''')

-- support <[> and <]> to embed square brackets anywhere in formula
while (charindex ('<[>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<[>', '[')

while (charindex ('<]>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<]>', ']')

-- support <{> and <}> to embed curly brackets anywhere in formula
while (charindex ('<{>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<{>', '{')

while (charindex ('<}>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<}>', '}')

select @sqlStmt = @sqlStmt + ' from ' + @inputSourceTable + ' where ' + @inputColumnName + ' = ' 
	+ '''' + convert (nvarchar(50), @inputColumnValue) + ''''

create table #tmptbl (formattedOutput nvarchar(1000))
insert into #tmptbl  exec (@sqlStmt)

select formattedOutput from #tmptbl
end
else
select formattedOutput = @inputFormula

set nocount off

END -- create proc ProcessContactFormula

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ProcessFormulaOutput]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ProcessFormulaOutput]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROC [dbo].[asi_ProcessFormulaOutput] (
	@inputTempKey uniqueidentifier,
	@inputFormula nvarchar(1000),
	@inputSourceTable nvarchar(200),
	@inputColumnName nvarchar(200),
	@inputColumnValue uniqueidentifier
	)
AS
BEGIN

	SET NOCOUNT ON

	DECLARE @sqlStmt nvarchar(2000)
	DECLARE @substr1 nvarchar(1000)
	DECLARE @substr2 nvarchar(1000)
	DECLARE @substr3 nvarchar(1000)
	DECLARE @substrPreField nvarchar(100)
	DECLARE @substrPostField nvarchar(100)
	DECLARE @substrPreStmt nvarchar(1000)
	DECLARE @substrPostStmt nvarchar(1000)

	DECLARE @pos1 int
	DECLARE @pos2 int
	DECLARE @pos3 int
	DECLARE @pos4 int
	DECLARE @pos5 int

	DECLARE @firstchar nvarchar(1)
	DECLARE @done bit

	IF charindex('[', @inputFormula) > 0
	BEGIN
		-- There are field place-holders to process
		SELECT @sqlStmt = 'select '

		SELECT @substrPreStmt = left (@inputFormula, 1)
		IF @substrPreStmt = '{' or @substrPreStmt = '['
			BEGIN
			SELECT @substrPreStmt = ''
			END
		ELSE
			BEGIN
			SELECT @substrPreStmt = @inputFormula
			SELECT @pos4 = charindex ('[', @substrPreStmt)
			SELECT @pos5 = charindex ('{', @substrPreStmt)
			IF @pos5 < @pos4 and @pos5 <> 0
	 			select @pos4 = @pos5
			SELECT @substrPreStmt = left (@substrPreStmt, @pos4 - 1)
			END

		SELECT @sqlStmt = @sqlStmt + '''' + @substrPreStmt + '''' + ' + '

		SELECT @substrPostStmt = left (reverse(@inputFormula), 1)
		IF @substrPostStmt = '}' or @substrPostStmt = ']'
			BEGIN
			SELECT @substrPostStmt = ''
			END
		ELSE
			BEGIN
			SELECT @substrPostStmt = reverse(@inputFormula)
			SELECT @pos4 = charindex (']', @substrPostStmt)
			SELECT @pos5 = charindex ('}', @substrPostStmt)
			IF @pos5 < @pos4 and @pos5 <> 0
				BEGIN
	 			SELECT @pos4 = @pos5
	 			END
			SELECT @substrPostStmt = left (@substrPostStmt, @pos4 - 1)
			SELECT @substrPostStmt = reverse(@substrPostStmt)
			END

		SELECT @substr1 = substring (@inputFormula, datalength (@substrPreStmt)/2 + 1, 
			datalength (@inputFormula)/2 - datalength (@substrPreStmt)/2 - datalength (@substrPostStmt)/2)

		SELECT @done = 0

		WHILE @done = 0
		BEGIN
			SELECT @firstchar = left (@substr1, 1)
			IF @firstchar = '{'
			BEGIN	-- find a matching curly bracket
				SELECT @substr3 = substring (@substr1, 1, charindex ('}', @substr1))
				SELECT @pos2 = datalength (@substr3)/2
				SELECT @substrPreField = substring (@substr1, 2, charindex ('[', @substr1) - 2)
				SELECT @substrPostField = substring (@substr1, charindex (']', @substr1) + 1, 
					(charindex ('}', @substr1) -  charindex (']', @substr1) - 1))
				SELECT @pos3 = (datalength (@substr3)/2) - 4 - (datalength (@substrPreField)/2) - (datalength (@substrPostField)/2)
				SELECT @substr2 = substring (@substr3, charindex ('[', @substr3) + 1, @pos3)
				IF EXISTS (select 1 FROM INFORMATION_SCHEMA.COLUMNS 
						WHERE TABLE_NAME = @inputSourceTable
						AND COLUMN_NAME = @substr2)
					SELECT @sqlStmt = @sqlStmt + ' case when ' + @substr2 + ' is null then '''' else ' + '''' + @substrPreField + '''' + ' + ' + @substr2 + ' + ' + '''' + @substrPostField + '''' + ' end '  + ' + '
				ELSE
					SELECT @sqlStmt = @sqlStmt + '''' + @substr3 + '''' + ' + '

				SELECT @substr1 = right (@substr1, datalength (@substr1)/2 - @pos2)
			END
			ELSE IF @firstchar = '['
			BEGIN	-- find a matching square bracket
				SELECT @substr3 = substring (@substr1, 1, charindex (']', @substr1))
				SELECT @substr2 = substring (@substr3, 2, datalength (@substr3)/2 -2)	

				IF EXISTS (select 1 from INFORMATION_SCHEMA.COLUMNS 
					WHERE TABLE_NAME = @inputSourceTable
					AND COLUMN_NAME = @substr2)
					SELECT @sqlStmt = @sqlStmt + ' case WHEN ' + @substr2 + ' IS NULL THEN '''' ELSE ' + @substr2 + ' end '  + ' + '
				ELSE
					SELECT @sqlStmt = @sqlStmt + '''' + @substr3 + '''' + ' + '
				SELECT @substr1 = right (@substr1, datalength (@substr1)/2 - datalength (@substr2) /2 - 2)
			END
			ELSE
			BEGIN	-- find everything up to the next curly or square bracket, and treat it as a literal
				SELECT @pos4 = charindex ('[', @substr1)
				SELECT @pos5 = charindex ('{', @substr1)
				IF @pos5 < @pos4 and @pos5 <> 0
		 			SELECT @pos4 = @pos5
				SELECT @substr2 = left (@substr1, @pos4)

				IF (datalength (@substr2) / 2) > 0
					BEGIN
					SELECT @substr2 = left (@substr2, datalength (@substr2)/2 - 1)
					SELECT @sqlStmt = @sqlStmt + '''' + @substr2 + '''' + ' + '
					END
				ELSE
					SELECT @done = 1
				SELECT @substr1 = right (@substr1, datalength (@substr1)/2 - datalength (@substr2) /2)
			END

		END -- while @done = 0

		IF substring (@sqlStmt, (datalength (@sqlStmt)/2) - 1, 1) = '+'
			SELECT @sqlStmt = substring (@sqlStmt, 1, (datalength (@sqlStmt)/2) - 2)

		IF (datalength (@substrPostStmt)/2 > 0)
 			SELECT @sqlStmt = @sqlStmt + ' + ' + '''' + @substrPostStmt + ''''

		-- support <n> for embedded newline, <t> for embedded tab anywhere in formula
		WHILE (charindex ('<n>', @sqlStmt) > 0)
			SELECT @sqlStmt = replace (@sqlStmt, '<n>', ''' + char(13) + char(10) + ''')

		WHILE (charindex ('<t>', @sqlStmt) > 0)
			SELECT @sqlStmt = replace (@sqlStmt, '<t>', ''' + char(9) + ''')

		-- support <[> and <]> to embed square brackets anywhere in formula
		WHILE (charindex ('<[>', @sqlStmt) > 0)
			SELECT @sqlStmt = replace (@sqlStmt, '<[>', '[')

		WHILE (charindex ('<]>', @sqlStmt) > 0)
			SELECT @sqlStmt = replace (@sqlStmt, '<]>', ']')

		-- support <{> and <}> to embed curly brackets anywhere in formula
		WHILE (charindex ('<{>', @sqlStmt) > 0)
			SELECT @sqlStmt = replace (@sqlStmt, '<{>', '{')

		WHILE (charindex ('<}>', @sqlStmt) > 0)
			SELECT @sqlStmt = replace (@sqlStmt, '<}>', '}')

		SELECT @sqlStmt = @sqlStmt + ' from ' + @inputSourceTable + ' where ' + @inputColumnName + ' = ' 
			+ '''' + convert (nvarchar(50), @inputColumnValue) + ''''

		CREATE TABLE #tmptbl (formattedOutput nvarchar(1000))
		INSERT INTO #tmptbl  exec (@sqlStmt)
		INSERT tempFormula (tempKey, tempValue) 
			SELECT @inputTempKey, formattedOutput FROM #tmptbl
	END
	ELSE
	BEGIN
		-- There are no field place-holders to process, so just return the formula
		INSERT tempFormula VALUES (@inputTempKey, @inputFormula)
	END

	SET NOCOUNT OFF

END -- create proc ProcessContactFormula

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_PurgeCalculatedScoresForFormula]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_PurgeCalculatedScoresForFormula]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_PurgeCalculatedScoresForFormula]
@engagementScoreKey uniqueidentifier
AS
BEGIN
    DELETE FROM [dbo].[CalculatedEngagementScore] WHERE [EngagementScoreKey] = @engagementScoreKey;
    DELETE FROM [dbo].[EngagementPercentile] WHERE [EngagementScoreKey] = @engagementScoreKey;
    DELETE FROM [dbo].[EngagementCategoryContact] WHERE [EngagementScoreKey] = @engagementScoreKey;
    UPDATE [dbo].[ScoreComponent] SET [LastRunOn] = NULL WHERE [EngagementScoreKey] = @engagementScoreKey;
END
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_PurgeExpiredAnonymousCarts]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_PurgeExpiredAnonymousCarts]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_PurgeExpiredAnonymousCarts]
AS
BEGIN

    SET NOCOUNT ON

    -- calculate the purge date
    DECLARE @purgeDate datetime
    SET @purgeDate = DATEADD(DAY,-15,GETUTCDATE())

    -- delete Carts that only have a CreatedOn date
    DELETE
      FROM [dbo].[Cart]
     WHERE [CreatedOn] <= @purgeDate
           AND [UserId] = 'anonymous'
           AND [UpdatedOn] IS NULL

    -- delete Carts that have an UpdatedOn date
    DELETE 
      FROM [dbo].[Cart]
     WHERE [UpdatedOn] <= @purgeDate
           AND [UserId] = 'anonymous'

END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_PurgeInactiveCampaigns]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_PurgeInactiveCampaigns]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_PurgeInactiveCampaigns    Script Date: 7/3/2003 4:58:05 PM ******/
CREATE PROCEDURE [dbo].[asi_PurgeInactiveCampaigns] 

AS

declare @campaignKey uniqueidentifier
declare @appealKey uniqueidentifier
declare @solicitationKey uniqueidentifier
declare @sourceCodeKey uniqueidentifier
declare @campaignCode nvarchar(10)

set ROWCOUNT 1

--Select an inactive Campaign for deletion
SELECT @campaignKey = CampaignKey, @campaignCode = LegacyCampaignCode FROM vBoCampaign WHERE CampaignStatusCode = 1

while @@ROWCOUNT > 0
begin
	set ROWCOUNT 0
	--Start a transaction
	begin tran

	--Select an Appeal for deletion
	SELECT @appealKey = AppealKey FROM vBoAppeal WHERE CampaignKey = @campaignKey
	while @@ROWCOUNT > 0
	begin
		--Select a Solicitation for deletion
		SELECT @solicitationKey = SolicitationKey FROM vBoSolicitation WHERE AppealKey = @appealKey
		while @@ROWCOUNT > 0
		begin
			--Select a SourceCode for deletion
			SELECT @sourceCodeKey = SourceCodeKey FROM vBoSourceCode WHERE SolicitationKey = @solicitationKey
			while @@ROWCOUNT > 0
			begin
				--Delete related rows
				DELETE FROM ListItem WHERE ListKey = @sourceCodeKey
				DELETE FROM ListMain WHERE ListKey = @sourceCodeKey
				DELETE FROM SolicitationSource WHERE SourceCodeKey = @sourceCodeKey

				--Delete the Source Code
				DELETE FROM SourceCode WHERE SourceCodeKey = @sourceCodeKey
				DELETE FROM UniformRegistry WHERE UniformKey = @sourceCodeKey
				--Select the next Source Code for deletion
				SELECT @sourceCodeKey = SourceCodeKey FROM vBoSourceCode WHERE SolicitationKey = @solicitationKey
			end
			
			--Delete the Solicitation
			DELETE FROM SolicitationMain WHERE SolicitationKey = @solicitationKey
			DELETE FROM UniformRegistry WHERE UniformKey = @solicitationKey
			--Select the next Solicitation for deletion
			SELECT @solicitationKey = SolicitationKey FROM vBoSolicitation WHERE AppealKey = @appealKey
		end

		--Delete the Appeal
		DELETE FROM AppealMain WHERE AppealKey = @appealKey
		DELETE FROM UniformRegistry WHERE UniformKey = @appealKey
		--Select the next Appeal for deletion
		SELECT @appealKey = AppealKey FROM vBoAppeal WHERE CampaignKey = @campaignKey	
	end

	--Delete the Campaign
	DELETE FROM CampaignMain WHERE CampaignKey = @campaignKey
	DELETE FROM UniformRegistry WHERE UniformKey = @campaignKey
	DELETE FROM Campaign WHERE CAMPAIGN_CODE = @campaignCode
	
	--Finalize the transaction
	commit tran

	--Select the next inactive Campaign for deletion
	set ROWCOUNT 1
	SELECT @campaignKey = CampaignKey, @campaignCode = LegacyCampaignCode FROM vBoCampaign WHERE CampaignStatusCode = 1
end

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_PurgeInactiveSegmentationJobs]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_PurgeInactiveSegmentationJobs]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_PurgeInactiveSegmentationJobs    Script Date: 7/3/2003 4:58:05 PM ******/
CREATE PROCEDURE [dbo].[asi_PurgeInactiveSegmentationJobs] 

AS

DECLARE @jobKey uniqueidentifier
DECLARE @defKey uniqueIdentifier

SET ROWCOUNT  1

SELECT @jobKey = SegmentationJobKey FROM vBoSegmentationJob WHERE SegmentationJobStatusCode=1
while @@ROWCOUNT > 0
begin

	SET ROWCOUNT 1

	--Create a loop to delete all Segmentation Definitions associated with the selected Segmentation Job
	SELECT @defKey = SegmentDefinitionKey FROM vBoSegmentationDef WHERE SegmentationJobKey = @jobKey
	while @@ROWCOUNT > 0
	begin
		--Delete the rows that comprise the selected Segmentation Definition
		SET ROWCOUNT 0
		DELETE FROM ListItem WHERE ListKey = @defKey		
		DELETE FROM ListMain WHERE ListKey = @defKey
		DELETE FROM SegmentDefinition WHERE SegmentDefinitionKey = @defKey
		DELETE FROM UniformRegistry WHERE UniformKey = @defKey

		--Attempt to select the next Segmentation Definition for deletion
		SELECT @defKey = SegmentDefinitionKey FROM vBoSegmentationDef WHERE SegmentationJobKey = @jobKey
	end

	--Delete the rows that comprise the selected Segmentation Job
	DELETE FROM SegmentationJob WHERE SegmentationJobKey = @jobKey
	DELETE FROM UniformRegistry WHERE UniformKey = @jobKey

	--Attempt to select the next Segmentation Job for deletion		
	SELECT @jobKey = SegmentationJobKey FROM vBoSegmentationJob WHERE SegmentationJobStatusCode=1
 
end

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_QueryExportTypes]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_QueryExportTypes]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_QueryExportTypes    Script Date: 7/3/2003 4:58:05 PM ******/


/****** Object:  Stored Procedure dbo.asi_QueryExportTypes    Script Date: 6/13/2003 9:53:37 AM ******/
CREATE   PROC asi_QueryExportTypes
	AS
BEGIN
	select ExportTypeKey, ExportType, Name, NavMarker, ProcessEngineTypeKey from ExportType where IsQueryExport=1 order by Name
	
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ReApplyPayments]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ReApplyPayments]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE                                            PROCEDURE [dbo].[asi_ReApplyPayments]
@creditInvDistCreated bit = 0 output,
@debugging	bit = 0 --False
AS
DECLARE @pmtKey uniqueidentifier
DECLARE @srcInvoiceKey uniqueidentifier
DECLARE @srcInvLineKey uniqueidentifier
DECLARE @pmtAppKey uniqueidentifier
DECLARE @orderNumber nvarchar(50)
DECLARE @orderLineNumber int
DECLARE @paymentScheduleLineKey uniqueidentifier
DECLARE @paymentNumber int
DECLARE @dueDate datetime
DECLARE @amountDue decimal(18,4)
DECLARE @outstandingBalance decimal(18,4)
DECLARE @glAccountKey uniqueidentifier
DECLARE @invoiceKey uniqueidentifier
DECLARE @invoiceLineKey uniqueidentifier
DECLARE @invoiceKeyTarget uniqueidentifier
DECLARE @invoiceLineKeyTarget uniqueidentifier
DECLARE @pmtAmt decimal(18,4)
DECLARE @quantitySold decimal(18,4)
DECLARE @finUnitKey uniqueidentifier
DECLARE @incomeAcctKey uniqueidentifier
DECLARE @ARAcctKey uniqueidentifier
DECLARE @amtAppliedToParentLine decimal(18,4)
DECLARE @amtToApplyToDistLine decimal(18,4)
DECLARE @invDistKey uniqueidentifier
DECLARE @priority int
DECLARE @lineAmountRemaining decimal(18,4)
DECLARE @applicationAmtRemaining decimal(18,4)
DECLARE @extIncome decimal(18,4)
DECLARE @extIncomeRecognized decimal(18,4)
DECLARE @acctMethod nvarchar(50)
DECLARE @appliedTotal decimal(18,4)
DECLARE @applyingCredit bit
DECLARE @componentIncome decimal(18,4)
DECLARE @unitIncome decimal(18,4)
DECLARE @actualAmount decimal(18,4)
DECLARE @discountTaken decimal(18,4)
DECLARE @monetaryAppKey uniqueidentifier
DECLARE @appAmount decimal(18,4)
DECLARE @discountRemaining decimal(18,4)
DECLARE @proportionedDiscount decimal(18,4)
DECLARE @zeroApplication bit
DECLARE @amountToApplyToScheduleLine decimal(18,4)
DECLARE @amountToApplyToDistribution  decimal(18,4)
DECLARE @minOfScheduleLineDistributionAmounts decimal(18,4)
DECLARE @amountToApply  decimal(18,4)
DECLARE @applyToPaymentScheduleFirst bit
DECLARE @transactionType int
DECLARE @transactionDate datetime
DECLARE @batchKey uniqueidentifier
DECLARE @invoiceNumber nvarchar(50)
SET @zeroApplication = 0
SET @applicationAmtRemaining = 0
set @lineAmountRemaining = 0
SET @amtAppliedToParentLine = 0
SET @pmtAmt = 0
/*
Read through the payments applied (at the order, invoice, order line, or invoice line level).
For each one:
	1. Create cursors to iterate over PaymentScheduleLines and #tmpInvoice lines -- the details of the 
	   cursors depends on whether the distribution is being done to an Invoice, Order, InvoiceLine, 
	   or OrderLine.
	2. If we are applying to Invoice or Order ("normal" application):
		a) for each PaymentScheduleLine with unrecognized income:
			i)  Note how much needs to be paid
			ii) For each InvoiceDistribution line, where the GLAccount matches the PaymentScheduleLine:
				- figure out how much to apply.  Each application is made to both a schedule line and an
				  distribution line, so the amount of each application is the lesser of the amount owed
				  for the current schedule line and the amount for the current distribution line
	Get the invoice distribution lines, ordered by pay priority of the invoice lines, for the invoice.
	For each line:
		- Create a new payment application for the line, for an amount up to
		the the non-recognized total income.
		- Decrement the counter keeping track of how much of the original
		application has been re-applied.
		- Make sure to also re-apply the unearned income (DiscountTaken) amounts
	End
	Delete the original application line.

   04/14/05 - rrk - Allow zero-amount monetary applications to create sales history
   06/24/05 - rrk - Re-worked so that there are two methods of applying payments:
                    1) The "normal" way, which is to apply to the PaymentScheduleLines in numerical order.
                       For each PaymentScheduleLine application, we
   
*/
		
DECLARE Get_Pmts CURSOR FOR 
SELECT SrcPaymentKey, SrcInvoiceLineKey, ISNULL(Amount,0), MonetaryApplicationKey, ISNULL(AppliedAmount,0), OrderNumber,
OrderLineNumber,InvoiceKey,InvoiceLineKey,InvoiceDistributionKey, SrcInvoiceKey, DiscountTaken, 
TransactionDate, TransactionType, ApplicationBatchKey
FROM #tmpPayments
WHERE OrderNumber IS NOT NULL OR OrderLineNumber IS NOT NULL OR InvoiceKey IS NOT NULL OR InvoiceLineKey IS NOT NULL
ORDER BY OrderNumber asc, OrderLineNumber desc, PaymentTypePriority asc, InvoiceLineKey desc
OPEN Get_Pmts
FETCH NEXT FROM Get_Pmts INTO @pmtKey,@srcInvLineKey, @pmtAmt,@pmtAppKey, @amtAppliedToParentLine,
@orderNumber, @orderLineNumber, @invoiceKey, @invoiceLineKey, @invDistKey, @srcInvoiceKey, @discountTaken,
@transactionDate, @transactionType, @batchKey
WHILE @@FETCH_STATUS = 0
BEGIN
   /* IF @amtAppliedToParentLine = 0
	    SET @zeroApplication = 1
    ELSE
	    SET @zeroApplication = 0 */
	SET @zeroApplication = 0
	
	SET @actualAmount = @amtAppliedToParentLine - @discountTaken
	SET @applicationAmtRemaining = @actualAmount
	SET @discountRemaining = @discountTaken
	IF @invDistKey is not null
		GOTO nextPmtApp
	
		
	IF @invoiceKey is not null AND @invoiceLineKey is null
	BEGIN
		-- Create cursors to iterate over PaymentScheduleLines and InvoiceDistributions, based on 
		-- invoice key.
		SET @applyToPaymentScheduleFirst = 1
		DECLARE ApplyToScheduleLines CURSOR FOR
			SELECT PaymentScheduleLineKey, PaymentNumber, DueDate, AmountDue, OutstandingBalance, GLAccountKey
			FROM PaymentScheduleLine psl
			INNER JOIN InvoiceMain im on psl.InvoiceKey = im.InvoiceKey
			WHERE im.InvoiceKey =  @invoiceKey AND OutstandingBalance > 0
			ORDER BY PaymentNumber ASC, PayPriority ASC
		
	    DECLARE ApplyToDistributionLines cursor for
			SELECT InvoiceKey, InvoiceLineKey, InvoiceDistributionKey, ISNULL(ExtendedIncome,0), ISNULL(ExtendedIncomeRecognized,0), AccountingMethodCode, AppliedTotal, ApplyingCredit, QuantitySold, FinancialEntityKey, IncomeGLAccountKey, ARGLAccountKey, UnitIncome, OrderLineNumber, InvoiceNumber
			FROM #tmpInvoice
			WHERE #tmpInvoice.InvoiceKey =  @invoiceKey
			ORDER BY PayPriority ASC
	END
	ELSE IF @orderNumber is not null AND LEN(@orderNumber) > 0 AND (@orderLineNumber is null OR @orderLineNumber <= 0)
	BEGIN
		SET @applyToPaymentScheduleFirst = 1
		-- Create cursors to iterate over PaymentScheduleLines and InvoiceDistributions, based on 
		-- invoice key.
		DECLARE ApplyToScheduleLines CURSOR FOR
			SELECT PaymentScheduleLineKey, PaymentNumber, DueDate, AmountDue, OutstandingBalance, GLAccountKey
			FROM  PaymentScheduleLine psl
			INNER JOIN InvoiceMain im on psl.InvoiceKey = im.InvoiceKey
			WHERE im.OrderNumber = @orderNumber AND OutstandingBalance > 0
			ORDER BY PaymentNumber ASC, PayPriority ASC
		
	    DECLARE ApplyToDistributionLines cursor for
			SELECT InvoiceKey, InvoiceLineKey, InvoiceDistributionKey, ISNULL(ExtendedIncome,0), ISNULL(ExtendedIncomeRecognized,0), AccountingMethodCode, AppliedTotal, ApplyingCredit, QuantitySold, FinancialEntityKey, IncomeGLAccountKey, ARGLAccountKey, UnitIncome, OrderLineNumber, InvoiceNumber
			FROM #tmpInvoice
			WHERE OrderNumber = @orderNumber
			ORDER BY PayPriority ASC
	END
	ELSE IF @invoiceLineKey is not null 
	BEGIN
		SET @applyToPaymentScheduleFirst = 0
		SELECT @componentIncome = SUM(ISNULL(ExtendedIncome,0)) from #tmpInvoice
		WHERE ParentInvoiceLineKey = @invoiceLineKey
		IF @componentIncome > 0
		BEGIN
			DECLARE GetApplyToLines cursor for
				SELECT InvoiceKey, InvoiceLineKey, InvoiceDistributionKey, PayPriority, ISNULL(ExtendedIncome,0), ISNULL(ExtendedIncomeRecognized,0), AccountingMethodCode, AppliedTotal, ApplyingCredit, QuantitySold, FinancialEntityKey, IncomeGLAccountKey, ARGLAccountKey, UnitIncome, OrderLineNumber, InvoiceNumber
				FROM #tmpInvoice
				WHERE ParentInvoiceLineKey = @invoiceLineKey
				ORDER BY PayPriority ASC
		END
		ELSE
		BEGIN
			DECLARE GetApplyToLines cursor for
				SELECT InvoiceKey, InvoiceLineKey, InvoiceDistributionKey, PayPriority, ISNULL(ExtendedIncome,0), ISNULL(ExtendedIncomeRecognized,0), AccountingMethodCode, AppliedTotal, ApplyingCredit, QuantitySold, FinancialEntityKey, IncomeGLAccountKey, ARGLAccountKey, UnitIncome, OrderLineNumber, InvoiceNumber
				FROM #tmpInvoice
				WHERE InvoiceLineKey = @invoiceLineKey
				ORDER BY PayPriority ASC
		END
		DECLARE ApplyToScheduleLines CURSOR FOR
			SELECT PaymentScheduleLineKey, PaymentNumber, DueDate, AmountDue, OutstandingBalance, GLAccountKey
			FROM  InvoiceLine il
			INNER JOIN PaymentScheduleLine psl on psl.InvoiceKey = il.InvoiceKey
			WHERE il.InvoiceLineKey = @invoiceLineKey AND OutstandingBalance > 0
			ORDER BY psl.PaymentNumber ASC, psl.PayPriority ASC
	END
	ELSE IF @orderLineNumber is not null AND @orderLineNumber > 0
	BEGIN
		SET @applyToPaymentScheduleFirst = 0
		SELECT @componentIncome = SUM(ISNULL(ExtendedIncome,0)) from #tmpInvoice
		WHERE ParentInvoiceLineKey in
		(SELECT InvoiceLineKey
		FROM #tmpInvoice WHERE OrderLineNumber = @orderLineNumber AND OrderNumber = @orderNumber)
		IF @componentIncome > 0
		BEGIN
			DECLARE GetApplyToLines cursor for
				SELECT InvoiceKey, InvoiceLineKey, InvoiceDistributionKey, PayPriority, ISNULL(ExtendedIncome,0), ISNULL(ExtendedIncomeRecognized,0), AccountingMethodCode, AppliedTotal, ApplyingCredit, QuantitySold, FinancialEntityKey, IncomeGLAccountKey, ARGLAccountKey, UnitIncome, @orderLineNumber, InvoiceNumber
				FROM #tmpInvoice
				WHERE ParentInvoiceLineKey in
				(SELECT InvoiceLineKey FROM #tmpInvoice WHERE OrderLineNumber = @orderLineNumber AND OrderNumber = @orderNumber)
				ORDER BY PayPriority ASC
		END
		ELSE
		BEGIN
			DECLARE GetApplyToLines cursor for
				SELECT InvoiceKey, InvoiceLineKey, InvoiceDistributionKey, PayPriority, ISNULL(ExtendedIncome,0), ISNULL(ExtendedIncomeRecognized,0), AccountingMethodCode, AppliedTotal, ApplyingCredit, QuantitySold, FinancialEntityKey, IncomeGLAccountKey, ARGLAccountKey, UnitIncome, @orderLineNumber, InvoiceNumber
				FROM #tmpInvoice
				WHERE OrderLineNumber = @orderLineNumber  AND OrderNumber = @orderNumber
				ORDER BY PayPriority ASC
		END
		DECLARE ApplyToScheduleLines CURSOR FOR
			SELECT PaymentScheduleLineKey, PaymentNumber, DueDate, AmountDue, OutstandingBalance, GLAccountKey
			FROM  InvoiceLine il
			INNER JOIN PaymentScheduleLine psl on psl.InvoiceKey = il.InvoiceKey
			WHERE il.InvoiceLineKey in 
				(SELECT InvoiceLineKey from #tmpInvoice 
					WHERE OrderLineNumber = @orderLineNumber)
				AND OutstandingBalance > 0
			ORDER BY psl.PaymentNumber ASC, psl.PayPriority ASC
	END
	ELSE 
		GOTO nextPmtApp
		
	IF 	@applyToPaymentScheduleFirst = 1
	BEGIN
		/* Method 1: apply to payment schedule lines in order, and then to distributions.
		*/
		OPEN ApplyToScheduleLines
		FETCH next from ApplyToScheduleLines into
			@paymentScheduleLineKey, @paymentNumber, @dueDate, @amountDue, @outstandingBalance, @glAccountKey
		WHILE @@FETCH_STATUS = 0 AND (ABS(@applicationAmtRemaining) > 0 OR ABS(@discountRemaining) > 0 OR @zeroApplication = 1)
		BEGIN
			SET @amountToApplyToScheduleLine = @outstandingBalance
				
 			OPEN ApplyToDistributionLines
			FETCH next from ApplyToDistributionLines into
				@invoiceKeyTarget, @invoiceLineKeyTarget, @invDistKey, @extIncome, @extIncomeRecognized, @acctMethod, 
				@appliedTotal, @applyingCredit, @quantitySold, @finUnitKey, @incomeAcctKey, @ARAcctKey, 
				@unitIncome, @orderLineNumber, @invoiceNumber
			WHILE @@FETCH_STATUS = 0 AND 
				@amountToApplyToScheduleLine > 0 AND 
				(ABS(@applicationAmtRemaining) > 0 OR ABS(@discountRemaining) > 0 OR @zeroApplication = 1)
			BEGIN
				IF @invDistKey is null OR @ARAcctKey != @glAccountKey
					GOTO FetchNextDistribution
			
				IF @applicationAmtRemaining > 0 OR @discountRemaining > 0
					SET @amountToApplyToDistribution = @extIncome - @appliedTotal
				ELSE    /* (@applicationAmtRemaining < 0 OR @discountRemaining < 0 - this is a negative payment) */
					SET @amountToApplyToDistribution = @appliedTotal
				
				/* nothing more to do with this distribution */
				IF @amountToApplyToDistribution = 0
					GOTO FetchNextDistribution
				
				/* find the minium of schedule line and distribution amounts */
				IF ABS(@amountToApplyToScheduleLine) <= ABS(@amountToApplyToDistribution)
					SET @minOfScheduleLineDistributionAmounts = @amountToApplyToScheduleLine
				ELSE
					SET @minOfScheduleLineDistributionAmounts = @amountToApplyToDistribution
									
				SET @amountToApply = @minOfScheduleLineDistributionAmounts
			
				IF ABS(@applicationAmtRemaining) < ABS(@amountToApply)
					SET @amountToApply = @applicationAmtRemaining
				
				
				/* Handle early payment discounts */
				IF ABS(@discountRemaining) > 0		/* (could be a reversal of discount - on a negative pmt) */
				BEGIN
					IF @discountRemaining > 0
						SET @proportionedDiscount = @minOfScheduleLineDistributionAmounts - @amountToApply
					ELSE /* (negative / reversal of discount... - note that this is assuming a zero or negative amount being applied by @amtToApplyToDistLine) */
						SET @proportionedDiscount = -1 * (@minOfScheduleLineDistributionAmounts + @amountToApply)
					IF ABS(@proportionedDiscount) > ABS(@discountRemaining)
						SET @proportionedDiscount = @discountRemaining
			
					SET @discountRemaining = @discountRemaining - @proportionedDiscount
				END
				ELSE
					SET @proportionedDiscount = 0	
					
		
				INSERT MonetaryApplication
					(MonetaryApplicationKey, SrcPaymentKey, SrcInvoiceLineKey, Amount, InvoiceKey, InvoiceLineKey, 
						InvoiceDistributionKey, DiscountTaken, OrderNumber, OrderLineNumber, PaymentScheduleLineKey,
						TransactionDate, TransactionType, BatchKey, InvoiceNumber)
				VALUES (NEWID(), @pmtKey, @srcInvLineKey, @amountToApply, @invoiceKeyTarget, @invoiceLineKeyTarget, 
						@invDistKey, @proportionedDiscount, @orderNumber, @orderLineNumber, @paymentScheduleLineKey,
						@transactionDate, @transactionType, @batchKey, @invoiceNumber)
				SET @applicationAmtRemaining = @applicationAmtRemaining - @amountToApply
				SET @amountToApplyToScheduleLine = @amountToApplyToScheduleLine - @amountToApply
				UPDATE #tmpInvoice SET AppliedTotal = AppliedTotal + @amountToApply
					WHERE InvoiceDistributionKey = @invDistKey
				UPDATE PaymentScheduleLine SET OutstandingBalance = OutstandingBalance - (@amountToApply + @proportionedDiscount)
					WHERE PaymentScheduleLineKey = @paymentScheduleLineKey
				
				FetchNextDistribution:
				FETCH next from ApplyToDistributionLines into
					@invoiceKeyTarget, @invoiceLineKeyTarget, @invDistKey, @extIncome, @extIncomeRecognized, @acctMethod, 
					@appliedTotal, @applyingCredit, @quantitySold, @finUnitKey, @incomeAcctKey, @ARAcctKey,
					@unitIncome, @orderLineNumber, @invoiceNumber
			END
			CLOSE ApplyToDistributionLines
		
			FETCH next from ApplyToScheduleLines into
				@paymentScheduleLineKey, @paymentNumber, @dueDate, @amountDue, @outstandingBalance, @glAccountKey
		END
		CLOSE ApplyToScheduleLines
		DEALLOCATE ApplyToScheduleLines
		DEALLOCATE ApplyToDistributionLines
	
	END
	ELSE
	BEGIN
		/* Method 2: apply to distributions by invoice line, then to payment schedule lines
		*/
		OPEN GetApplyToLines
		FETCH next from GetApplyToLines into
		@invoiceKeyTarget, @invoiceLineKeyTarget, @invDistKey, @priority, @extIncome, @extIncomeRecognized, @acctMethod, @appliedTotal, @applyingCredit, @quantitySold, @finUnitKey, @incomeAcctKey, @ARAcctKey, @unitIncome, @orderLineNumber, @invoiceNumber
			/* These will be ordered by pay priority... */
		WHILE @@FETCH_STATUS = 0 AND (ABS(@applicationAmtRemaining) > 0 OR ABS(@discountRemaining) > 0 OR @zeroApplication = 1)
		BEGIN
			IF @invDistKey is null
				GOTO nextApplyToLine
					
			OPEN ApplyToScheduleLines
			FETCH next from ApplyToScheduleLines into
				@paymentScheduleLineKey, @paymentNumber, @dueDate, @amountDue, @outstandingBalance, @glAccountKey
			WHILE @@FETCH_STATUS = 0
			BEGIN
			
				IF @applicationAmtRemaining > 0 OR @discountRemaining > 0
					SET @lineAmountRemaining = @extIncome - @appliedTotal
				ELSE    /* (@applicationAmtRemaining < 0 OR @discountRemaining < 0 - this is a negative payment) */
					SET @lineAmountRemaining = @appliedTotal
			
				IF @lineAmountRemaining <=0 AND @zeroApplication = 0 
					GOTO nextApplyToLine   /* can't apply any amount(s) to this line... */
				/*
				   If the distribution line amount yet to be applied is greater than or equal to 
				   (in absolute value) the payment being applied, then we can apply *all* of the 
				   payment being applied  so init the "amount to apply to the distribution line"
				   to the entire payment being applied.
				*/	
				IF @lineAmountRemaining >= ABS(@applicationAmtRemaining)
					SET @amtToApplyToDistLine = @applicationAmtRemaining
				ELSE
				/*
					Otherwise, the distribution line amount yet to be applied is less than 
					(in absolute value) the payment being applied, so we can only apply 
					some of the payment
				*/
				BEGIN
					SET @amtToApplyToDistLine = @lineAmountRemaining
					IF @applicationAmtRemaining < 0
						SET @amtToApplyToDistLine = -1 * @amtToApplyToDistLine
				END
				
			
				IF @outstandingBalance < @amtToApplyToDistLine
					SET @amtToApplyToDistLine = @outstandingBalance
				
					/* Handle early payment discounts */
				IF ABS(@discountRemaining) > 0		/* (could be a reversal of discount - on a negative pmt) */
				BEGIN
					IF @discountRemaining > 0
						SET @proportionedDiscount = @lineAmountRemaining - @amtToApplyToDistLine
					ELSE /* (negative / reversal of discount... - note that this is assuming a zero or negative amount being applied by @amtToApplyToDistLine) */
						SET @proportionedDiscount = -1 * (@lineAmountRemaining + @amtToApplyToDistLine)
					IF ABS(@proportionedDiscount) > ABS(@discountRemaining)
						SET @proportionedDiscount = @discountRemaining
			
					SET @discountRemaining = @discountRemaining - @proportionedDiscount
				END
				ELSE
					SET @proportionedDiscount = 0
				
			
				INSERT MonetaryApplication
					(MonetaryApplicationKey, SrcPaymentKey, SrcInvoiceLineKey, Amount, InvoiceKey, InvoiceLineKey, 
					InvoiceDistributionKey, DiscountTaken, OrderNumber, OrderLineNumber, PaymentScheduleLineKey,
					TransactionDate, TransactionType, BatchKey, InvoiceNumber)
					VALUES (NEWID(), @pmtKey, @srcInvLineKey, @amtToApplyToDistLine, @invoiceKeyTarget, @invoiceLineKeyTarget, 
					@invDistKey, @proportionedDiscount, @orderNumber, @orderLineNumber, @paymentScheduleLineKey,
					@transactionDate, @transactionType, @batchKey, @invoiceNumber)
				SET @applicationAmtRemaining = @applicationAmtRemaining - @amtToApplyToDistLine
				-- update the amount of this distribution we applied to this schedule line
				SET @appliedTotal = @appliedTotal + @amtToApplyToDistLine
				UPDATE #tmpInvoice SET AppliedTotal = AppliedTotal + @amtToApplyToDistLine
					WHERE InvoiceDistributionKey = @invDistKey
				UPDATE PaymentScheduleLine SET OutstandingBalance = OutstandingBalance - (@amtToApplyToDistLine + @proportionedDiscount)
					WHERE PaymentScheduleLineKey = @paymentScheduleLineKey
				/* If this 'payment' line is actually a credit invoice line being applied, we need to insert a distribution line for the */
				/* credit invoice line to correspond to the amount being applied to the target invoice distribution line. */
				IF @applyingCredit = 1 AND @amtToApplyToDistLine != 0
				BEGIN
					SET @creditInvDistCreated = 1
					INSERT InvoiceDistribution (InvoiceDistributionKey, InvoiceKey, InvoiceLineKey, QuantitySold,
					FinancialEntityKey, UnitIncome, ExtendedIncome, ExtendedIncomeRecognized, IncomeGLAccountKey, ARGLAccountKey)
					VALUES (NEWID(), @srcInvoiceKey, @srcInvLineKey, @quantitySold, @finUnitKey, -1 * @unitIncome, -1 * @amtToApplyToDistLine, 0, @incomeAcctKey, @ARAcctKey)
				END
				FETCH next from ApplyToScheduleLines into
					@paymentScheduleLineKey, @paymentNumber, @dueDate, @amountDue, @outstandingBalance, @glAccountKey
			END
			CLOSE ApplyToScheduleLines
			nextApplyToLine:
			FETCH next from GetApplyToLines into
			@invoiceKeyTarget, @invoiceLineKeyTarget, @invDistKey, @priority, @extIncome, @extIncomeRecognized, @acctMethod, @appliedTotal, @applyingCredit, @quantitySold, @finUnitKey, @incomeAcctKey, @ARAcctKey, @unitIncome, @orderLineNumber, @invoiceNumber
		END
		CLOSE GetApplyToLines
		DEALLOCATE GetApplyToLines
		DEALLOCATE ApplyToScheduleLines
	END
	-- -------------------------------------------------------------
	
	IF ABS(@applicationAmtRemaining) <= 0 AND ABS(@discountRemaining) <= 0
		DELETE FROM MonetaryApplication WHERE MonetaryApplicationKey = @pmtAppKey
	ELSE IF ABS(@applicationAmtRemaining) < ABS(@actualAmount) OR ABS(@discountRemaining) < ABS(@discountTaken)
		UPDATE MonetaryApplication SET Amount = @applicationAmtRemaining, DiscountTaken = @discountRemaining WHERE MonetaryApplicationKey = @pmtAppKey
nextPmtApp:
FETCH NEXT FROM Get_Pmts INTO @pmtKey,@srcInvLineKey, @pmtAmt,@pmtAppKey, @amtAppliedToParentLine,
@orderNumber, @orderLineNumber, @invoiceKey, @invoiceLineKey, @invDistKey, @srcInvoiceKey, @discountTaken,
@transactionDate, @transactionType, @batchKey
END
CLOSE Get_Pmts
DEALLOCATE Get_Pmts
IF @debugging = 1
BEGIN
PRINT 'MonetaryApplication: '
SELECT * from MonetaryApplication
END  --IF @debugging

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_RebuildCounters]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_RebuildCounters]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =================================================
-- Author:      Paul Bradshaw
-- Create date: 29-Nov-2006
-- Description: Resets all the counters in the 
--              Counter table, based on the values
--              in the appropriate tables
-- =================================================
CREATE PROCEDURE [dbo].[asi_RebuildCounters]
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @now datetime;
    SELECT @now = dbo.asi_GetAppDatetime();
    
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Activity' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(SEQN), 1) FROM Activity), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
         WHERE [COUNTER_NAME] = 'Activity'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Activity_Attach' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(ATTACH_SEQN), 1) FROM Activity_Attach), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
         WHERE [COUNTER_NAME] = 'Activity_Attach'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Batch' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        IF EXISTS (SELECT 1 FROM System_Params WHERE ParameterName = 'AR_Control.UseBatches' AND ShortValue = '2')
        BEGIN
            IF EXISTS (SELECT 1 FROM System_Params WHERE ParameterName = 'IgnoreNonNumericBatchNumbersForCounter' AND ShortValue <> '0')
            BEGIN
                UPDATE [dbo].[Counter] 
                   SET [LAST_VALUE] = (SELECT MAX(COALESCE (CASE WHEN ISNUMERIC(BATCH_NUM) = 1 THEN CONVERT(bigint, BATCH_NUM) ELSE 0 END, 1)) 
                                         FROM Batch), 
                       [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
                 WHERE [COUNTER_NAME] = 'Batch'
            END
            ELSE
            BEGIN
                UPDATE [dbo].[Counter] 
                   SET [LAST_VALUE] = (SELECT COALESCE (MAX(CAST(SUBSTRING([BATCH_NUM], 1, CASE WHEN CHARINDEX('-', [BATCH_NUM]) > 0 THEN CHARINDEX('-', [BATCH_NUM])- 1 ELSE LEN([BATCH_NUM]) END) AS bigint)), 1) 
                                         FROM Batch 
                                        WHERE SUBSTRING([BATCH_NUM], 1, CASE WHEN CHARINDEX('-', [BATCH_NUM]) > 0 THEN CHARINDEX('-', [BATCH_NUM])- 1 ELSE LEN([BATCH_NUM]) END) NOT LIKE '%[^0-9]%'), 
                       [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
                 WHERE [COUNTER_NAME] = 'Batch'
            END
        END
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Cert_Register' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(SEQN), 1) FROM Cert_Register), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
         WHERE [COUNTER_NAME] = 'Cert_Register'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Cmty_Discussion_Forums' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(FORUM_SEQ), 1) FROM Cmty_Discussion_Forums), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
         WHERE [COUNTER_NAME] = 'Cmty_Discussion_Forums'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Cmty_Discussion_Posts' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(POST_SEQ), 1) FROM Cmty_Discussion_Posts), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
         WHERE [COUNTER_NAME] = 'Cmty_Discussion_Posts'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Cmty_Discussion_Posts' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(TOPIC_SEQ), 1) FROM Cmty_Discussion_Posts), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
         WHERE [COUNTER_NAME] = 'Cmty_Discussion_Topics'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Cmty_Discussion_Forums' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(FORUM_SEQ), 1) FROM Cmty_Discussion_Forums), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
         WHERE [COUNTER_NAME] = 'Cmty_Forum'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Cmty_News' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(NEWS_SEQ), 1) FROM Cmty_News), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
         WHERE [COUNTER_NAME] = 'Cmty_News'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Cmty_Shared_Files' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(FILE_SEQ), 1) FROM Cmty_Shared_Files), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
         WHERE [COUNTER_NAME] = 'Cmty_Shared_Files'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Cmty_Shared_Folders' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
       UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(FOLDER_SEQ), 1) FROM Cmty_Shared_Folders), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
        WHERE [COUNTER_NAME] = 'Cmty_Shared_Folders'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Comment_Log' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
       UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(COMMENT_LOG_NUM), 1) FROM Comment_Log), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
        WHERE [COUNTER_NAME] = 'Comment_Log'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Community' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
       UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(COMMUNITY_SEQ), 1) FROM Community), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
        WHERE [COUNTER_NAME] = 'Community'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Content_Pages' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
       UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(PAGE_NUM), 1) FROM Content_Pages), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
        WHERE [COUNTER_NAME] = 'Content_Pages'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Country_Addr_Layouts' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
       UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(ADDRESS_FORMAT), 1) FROM Country_Addr_Layouts), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
        WHERE [COUNTER_NAME] = 'Country_Addr_Layouts'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Exhb_Form_Master' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
       UPDATE [dbo].[Counter] SET [LAST_VALUE] = (COALESCE((SELECT MAX(CAST(SEQN AS INT)) 
                                                     FROM (SELECT FORM_ID as SEQN FROM Exhb_Form_Master WHERE ISNUMERIC(FORM_ID) = 1 
                                                   UNION 
                                                   SELECT PRODUCT_ID as SEQN FROM Exhb_Prod_Mast WHERE ISNUMERIC(PRODUCT_ID) = 1) AS Q
                                        ), 0)), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
        WHERE [COUNTER_NAME] = 'Exhb_Form_Master'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'ExpenseItem' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(EXPENSE_SEQN), 1) FROM ExpenseItem), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
        WHERE [COUNTER_NAME] = 'Expense'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Hotel_Log' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(HOTEL_LOG_NUMBER), 1) FROM Hotel_Log), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
        WHERE [COUNTER_NAME] = 'HotelLog'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Invoice' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(INVOICE_NUM), 1) FROM Invoice), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
        WHERE [COUNTER_NAME] = 'Invoice'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Invoice' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(REFERENCE_NUM), 1) FROM Invoice), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
        WHERE [COUNTER_NAME] = 'Invoice_Ref'
        UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(Trans.INVOICE_REFERENCE_NUM), 1) FROM Trans), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
        WHERE [COUNTER_NAME] = 'Invoice_Ref' AND (SELECT COALESCE(MAX(Trans.INVOICE_REFERENCE_NUM), 1) FROM Trans) > LAST_VALUE
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Job_Record' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(JobId), 1) FROM Job_Record), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
        WHERE [COUNTER_NAME] = 'Job_Record'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Name' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(CAST(ID AS INT)), 1) FROM [Name] WHERE ISNUMERIC(ID) = 1), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
        WHERE [COUNTER_NAME] = 'Name'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Name_Address' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(ADDRESS_NUM), 1) FROM Name_Address), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
        WHERE [COUNTER_NAME] = 'Name_Address'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Name_MatchPlan' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(SEQN), 1) FROM Name_MatchPlan), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
        WHERE [COUNTER_NAME] = 'Name_MatchPlan'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Name_Note' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(NOTE_NUM), 1) FROM Name_Note), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
        WHERE [COUNTER_NAME] = 'Name_Note'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Name_Picture' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(PICTURE_NUM), 1) FROM Name_Picture), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
        WHERE [COUNTER_NAME] = 'Name_Picture'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Orders' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(ORDER_NUMBER), 1) FROM Orders), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
        WHERE [COUNTER_NAME] = 'Orders'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Product_Kit' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(SEQN), 1) FROM Product_Kit), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
        WHERE [COUNTER_NAME] = 'Product_Kit'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Product_Substitute' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(SEQN), 1) FROM Product_Substitute), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
        WHERE [COUNTER_NAME] = 'Product_Substitute'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Product_Trans' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(PTRANS_NUMBER), 1) FROM Product_Trans), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
        WHERE [COUNTER_NAME] = 'Product_Trans'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Product_Trans' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(TRANS_GROUP_NUMBER), 1) FROM Product_Trans), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
        WHERE [COUNTER_NAME] = 'ProductGroupTrans'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Prospect' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COUNT(1) FROM Prospect), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
        WHERE [COUNTER_NAME] = 'Prospect'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Receipt' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(Auto_Receipt_Num), 1) FROM Receipt), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
        WHERE [COUNTER_NAME] = 'Receipt'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Receipt' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(ID), 1) FROM Receipt), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
        WHERE [COUNTER_NAME] = 'Receipt_ID'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Ref_Client' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(CAST(CLIENT_ID AS int)), 1) FROM Ref_Client WHERE ISNUMERIC(CLIENT_ID) = 1), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
        WHERE [COUNTER_NAME] = 'Ref_Client'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Referral' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(CAST(REFERRAL_ID AS int)), 1) FROM Referral WHERE ISNUMERIC(REFERRAL_ID) = 1), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
        WHERE [COUNTER_NAME] = 'Referral'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Relationship' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(SEQN), 1) FROM Relationship), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
        WHERE [COUNTER_NAME] = 'Relationship'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Service_Request' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(CAST(ServiceReference AS int)), 1) FROM Service_Request WHERE ISNUMERIC(ServiceReference) = 1), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
        WHERE [COUNTER_NAME] = 'Service_Request'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Stored_List' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(NumberSequence), 1) FROM Stored_List), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
        WHERE [COUNTER_NAME] = 'Stored_List'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Trans' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(TRANS_NUMBER), 1) FROM Trans), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
        WHERE [COUNTER_NAME] = 'Trans'
    END
    ------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'User_Tab_Pref_Detail' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(PREF_ID), 1) - 1 FROM User_Tab_Pref_Detail), [LAST_UPDATED] = @now, [UPDATED_BY] = 'MANAGER'
        WHERE [COUNTER_NAME] = 'TabProfile'
    END
    ------------------------------------------------------------------------------

    -- Now set the counters for any User Defined Tables
    DECLARE @tableName nvarchar(50);
    DECLARE @sql nvarchar(1000);
    DECLARE theCursor CURSOR FORWARD_ONLY FOR
        SELECT TABLE_NAME FROM UD_Table WHERE ALLOW_MULTIPLE_INSTANCES = 1;

    OPEN theCursor;
    FETCH NEXT FROM theCursor INTO @tableName;
    WHILE (@@FETCH_STATUS = 0)
    BEGIN
        IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = @tableName
                   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
        BEGIN
            SET @sql = 'UPDATE [dbo].[Counter] SET [LAST_VALUE] = (SELECT COALESCE(MAX(SEQN), 1) FROM ' +
                       @tableName + '), [LAST_UPDATED] = dbo.asi_GetAppDatetime(), [UPDATED_BY] = ''MANAGER''
            WHERE [COUNTER_NAME] = ''' + @tableName + ''''

            EXEC (@sql);
        END
        FETCH NEXT FROM theCursor INTO @tableName;
    END
    CLOSE theCursor;
    DEALLOCATE theCursor;
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_SetNameAllViewPermissions]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_SetNameAllViewPermissions]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- Author:		Paul Bradshaw
-- Create date: Jan 30th, 2007
-- Description:	Set Name_All View permissions
-- =============================================
CREATE PROCEDURE asi_SetNameAllViewPermissions 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	GRANT INSERT, DELETE, REFERENCES, SELECT, UPDATE ON Name_All TO IMIS
END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_RebuildNameAllView]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_RebuildNameAllView]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- Author:		Paul Bradshaw
-- Create date: Jan 30th, 2007
-- Description:	Rebuild Name_All View
-- =============================================
CREATE PROCEDURE asi_RebuildNameAllView 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	EXEC asi_DropNameAllView
	EXEC asi_BuildNameAllView
	EXEC asi_SetNameAllViewPermissions
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_RenameTable]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_RenameTable]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


CREATE PROCEDURE [dbo].[asi_RenameTable] @oldTableName sysname, @newTableName sysname AS
BEGIN
	DECLARE @oldName sysname
	DECLARE @newName sysname
	DECLARE @type nvarchar(6)

	-- cursor gets all of the children of table and renames them too
	DECLARE GetChildren CURSOR FOR
	    SELECT [name], 'OBJECT'
	      FROM sys.objects
	     WHERE parent_object_id = OBJECT_ID(@oldTableName)
	       AND type = 'D' AND [name] IS NOT NULL
	    UNION
	    SELECT [name], 'INDEX'
	      FROM sys.indexes
	     WHERE object_id = OBJECT_ID(@oldTableName) 
	           AND [name] IS NOT NULL AND ([name] NOT LIKE '_WA_Sys%' AND name NOT LIKE '_dta_stat%')

	OPEN GetChildren

	FETCH GetChildren INTO @oldName, @type

	-- rename all of the table's child objects (keys, indexes, constraints)
	WHILE @@FETCH_STATUS = 0
	BEGIN
		SET @newName = REPLACE(@oldName, @oldTableName, @newTableName)
		IF @newName = @oldName OR @newName IS NULL
			SET @newName = @oldName + '_OLD'

		-- renaming index has to have old table name and [ ] around column to avoid ambiguity
		IF @type = 'INDEX'
			SET @oldName = @oldTableName + '.' + '[' + @oldName + ']' 

		PRINT 'sp_rename ''' + @oldName + ''', ''' + @newName + ''',''' + @type + ''''
		EXEC ('sp_rename ''' + @oldName + ''', ''' + @newName + ''',''' + @type + '''')

		FETCH GetChildren INTO @oldName, @type
	END

	CLOSE GetChildren
	DEALLOCATE GetChildren

	-- finally, rename the able itself
	EXEC ('sp_rename ''' + @oldTableName + ''', ''' + @newTableName + ''',''OBJECT''')
END



GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ResultPage]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ResultPage]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_ResultPage    Script Date: 7/3/2003 4:58:05 PM ******/



CREATE    proc [dbo].[asi_ResultPage]
            @select nvarchar(4000),
            @offset int = 0,
            @pageSize int = 10,
            @returnRowCount bit = 0 As
begin
-- ***************************************************************************************
-- Declare variables
-- ***************************************************************************************
declare @countSelect nvarchar(4000)
declare @limiter int
declare @posFrom int
declare @posOrderBy int
declare @posSelectList int
declare @tmp nvarchar(4000)
declare @tmpTable char(38)
-- <SQL_7>
declare @tmpTable2 char(38)
-- </SQL_7>
declare @tmpTable3 char(38)
declare @upperSelect nvarchar(4000)
-- ***************************************************************************************
-- Calculate Limiter Value
-- ***************************************************************************************
set @limiter = 500
if (@offset) >= (@limiter - @pageSize)
begin
set @limiter = @offset + (@pageSize * 2)
end
-- ***************************************************************************************
-- Name Temp Tables
-- ***************************************************************************************
set @tmpTable = N'#z' + replace(cast(newid() As nchar(36)),N'-',N'')
-- <SQL_7> 
set @tmpTable2 = N'#z' + replace(cast(newid() As nchar(36)),N'-',N'')
-- </SQL_7>
set @tmpTable3 = N'#z' + replace(cast(newid() as nchar(36)),N'-',N'')
-- ***************************************************************************************
-- Clean up select statement
-- ***************************************************************************************
set @select = ltrim(@select)
set @select = replace(@select,nchar(9),N' ')
set @select = replace(@select,nchar(10),N' ')
set @select = replace(@select,nchar(13),N' ')
-- ***************************************************************************************
-- Convert to uppercase for pattern searching
-- ***************************************************************************************
set @upperSelect = upper(@select)
-- ***************************************************************************************
-- Find position of first item to be displayed in resultset
-- ***************************************************************************************
if charindex(' DISTINCT ', @upperSelect) = 0 
begin 
	set @posSelectList = charindex(N' ', @upperSelect) + 1 
end
else 
begin 
	set @posSelectList = charindex(N' DISTINCT ', @upperSelect) + 10 
end
-- ***************************************************************************************
-- Find position of first object in from clause
-- ***************************************************************************************
set @posFrom = charindex(N' FROM ', @upperSelect)
-- ***************************************************************************************
-- Find position order by clause
-- ***************************************************************************************
set @posOrderBy = charindex(N' ORDER BY ', @upperSelect)
-- ***************************************************************************************
-- Copy select statment without the order by clause to be used for returning a count
-- ***************************************************************************************
set @countSelect = @select
if  @posOrderBy > 0 
begin 
	set @countSelect = left(@countSelect, @posOrderBy) 
end
set @countSelect = stuff(@countSelect, @posSelectList, @posFrom - @posSelectList, N' count(*) AS Row_Count ')
-- ***************************************************************************************
-- If @pageSize = 0 or @offset = 0 
-- ***************************************************************************************
if @offset = 0 or @pageSize = 0
begin
	set @tmp = @select
	set @tmp = stuff(@tmp,@posSelectList,0,N'cast(0 as int) As ResultRow,')
	if @pageSize > 0
	begin
		set @tmp = stuff(@tmp,@posSelectList,0,N'TOP ' + cast(@pageSize As varchar(10)) + N' ')
	end
	set @tmp = N'set nocount on'+nchar(13)+nchar(10)+@tmp
	if  @returnRowCount <> 0 and @pageSize = 0
	begin 
		set @tmp = @tmp+nchar(13)+nchar(10)+N'select @@ROWCOUNT AS Row_Count'
	end
	if  @returnRowCount <> 0 and @pageSize <> 0 
	begin
		set @countSelect = @select
		if  @posOrderBy > 0 
		begin 
			set @countSelect = left(@countSelect,@posOrderBy) 
		end
		set @countSelect = stuff(@countSelect,@posSelectList,@posFrom - @posSelectList,N' TOP '+cast(@limiter As varchar(10))+N' 0 AS rc INTO '+@tmpTable3)
		set @countSelect = @countSelect+nchar(13)+nchar(10)+N'select @@ROWCOUNT AS Row_Count'
		set @countSelect = @countSelect+nchar(13)+nchar(10)+N'drop table '+@tmpTable3
		--set @countSelect = stuff(@countSelect,@posSelectList,@posFrom - @posSelectList,N' count(*) AS Row_Count ')
		set @tmp = @tmp+nchar(13)+nchar(10)+@countSelect
	end
	set @tmp = @tmp+nchar(13)+nchar(10)+N'set nocount off'
end
else
begin --@offset <> 0 and @pageSize <> 0
-- ***************************************************************************************
-- Copy select statement for inserting into the temp table
-- ***************************************************************************************
set @tmp = @select
set @tmp = stuff(@tmp,@posFrom,0,N' into '+@tmpTable)
-- <SQL_7> 
set @tmp = stuff(@tmp,@posSelectList,0,N'top '+convert(nvarchar(10),(@offset+@pageSize))+N' ')
-- </SQL_7> 
-- <SQL_2000> 
-- set @tmp = stuff(@tmp,@posSelectList,0,N'top '+convert(nvarchar(10),(@offset+@pageSize))+N' identity(int,1,1) As ResultRow,')
-- </SQL_2000> 
-- ***************************************************************************************
-- Create the statement that will do the work
-- ***************************************************************************************
set @tmp = N'set nocount on'+nchar(13)+nchar(10)+@tmp
-- <SQL_7>
set @tmp = @tmp+nchar(13)+nchar(10)+N'select identity(int,1,1) As ResultRow,* into '+@tmpTable2+N' from '+@tmpTable
set @tmp = @tmp+nchar(13)+nchar(10)+N'drop table '+@tmpTable
set @tmp = @tmp+nchar(13)+nchar(10)+N'set rowcount '+cast(@pageSize As varchar(10))
set @tmp = @tmp+nchar(13)+nchar(10)+N'select * from '+@tmpTable2+N' where ResultRow > '+convert(nvarchar(10),@offset)
-- </SQL_7>
-- <SQL_2000>
-- set @tmp = @tmp+char(13)+char(10)+'select * from '+@tmpTable+' where ResultRow > '+convert(varchar(10),@offset)
-- </SQL_2000>
set @tmp = @tmp+nchar(13)+nchar(10)+N'set rowcount 0'
-- <SQL_7>
set @tmp = @tmp+nchar(13)+nchar(10)+N'drop table '+@tmpTable2
-- </SQL_7>
-- <SQL_2000>
-- set @tmp = @tmp+nchar(13)+nchar(10)+N'drop table '+@tmpTable
-- <SQL_2000>
if  @returnRowCount <> 0 
begin 
	set @tmp = @tmp+nchar(13)+nchar(10)+@countSelect 
end
set @tmp = @tmp+nchar(13)+nchar(10)+N'set nocount off'
end --@offset <> 0 and @pageSize <> 0
-- ***************************************************************************************
-- Execute
-- ***************************************************************************************
exec(@tmp)
end

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_RosterManagementCreateCompanyAdministrators]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_RosterManagementCreateCompanyAdministrators]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE asi_RosterManagementCreateCompanyAdministrators 
@MEMBER_TYPE varchar(50)
AS
/*
This Stored Procedure will add all members that have the specified member type
and are a member of a company to the Company Administrator Role, allowing 
them to edit other members of thier company
*/
INSERT INTO UserRole([UserKey],[RoleKey])
SELECT [UserKey],'4f0f93a9-00ee-40ba-bcbc-99a5beb21179' FROM UserMain
INNER JOIN [Name] ON [Name].[ID] = [UserMain].[ContactMaster]
WHERE [Name].[MEMBER_TYPE] = @MEMBER_TYPE AND [Name].[CO_ID] <> ''
AND [UserKey] NOT IN (Select [UserKey] FROM [UserRole] WHERE [RoleKey] = '4f0f93a9-00ee-40ba-bcbc-99a5beb21179')

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_SalesTeamAddDateRange]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_SalesTeamAddDateRange]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_SalesTeamAddDateRange](
       @salesTeamKey uniqueidentifier,
       @newStartDate datetime,
       @userKey      uniqueidentifier)
AS
    --This storage procedure is used by Asi.Business.Commerce.SalesTeam.SalesTeamUtilities.AddRange method
    --to add a new date range for an existing Sales Team.
    --Parameters:
    --    @salesTeamKey is Guid of the Group object that a new Date Rage is to be added.
    --    @newStartDate is a DateTime value that the new Date Range is to start from
    --    @userKey is the Guid of the User object who is creating the new Date Range.
    --Return values:
    --    -1 - There are no existing GroupMemberDetails for the Group specified
    --    -2 - The new Date Range occurs prior to the first GroupMemberDetails date range
    --    -4 - The Start Date specified is either
    --         a. the date directly preceeding an existing start date
    --         b. the date of an existing start date
    --         c. the date directly following an existing start date
BEGIN
    SET NOCOUNT ON;
    DECLARE @detailCount int;

    -- Determine if there are any existing GroupMemberDetail records for this sales team if not return an error code of -1
    IF (SELECT COUNT(1) FROM [GroupMemberDetail] WHERE [GroupKey] = @salesTeamKey ) < 1
    BEGIN
        SELECT-1;
        RETURN -1;
    END;
    
    -- Determine if @newStartDate occurs prior to the first date range for the sales team and if so return an error code of -2
    IF (DATEDIFF(DAY, @newStartDate, (
                                      SELECT MIN([EffectiveDate])
                                        FROM [GroupMemberDetail]
                                       WHERE [GroupKey] = @salesTeamKey
    ) ) > 0)
    BEGIN
        SELECT-2;
        RETURN -2;
    END;
    -- Determine if @newStartDate equals an existing start date, the date following an existing start date, or an existing expiration date for this Sales Team
    SELECT @detailCount = COUNT(1)
      FROM [GroupMemberDetail]
     WHERE [GroupKey] = @salesTeamKey AND DATEDIFF(DAY, [EffectiveDate], @newStartDate) IN (0, 1) OR DATEDIFF(DAY, @newStartDate, [ExpirationDate]) = 0;
    -- If we find existing Detail records that means the @newStartDate is invalid.
    IF @detailCount > 0
    BEGIN
        SELECT-4;
        RETURN -4;
    END;
    
    BEGIN TRANSACTION;
    CREATE TABLE [#tmpGroupMemberDetail] (
                 [GroupMemberKey]        uniqueidentifier,
                 [GroupRoleKey]          uniqueidentifier,
                 [EffectiveDate]         datetime,
                 [ExpirationDate]        datetime,
                 [TypeSpecificData]      nvarchar(250),
                 [TypeSpecificKey]       uniqueidentifier,
                 [TypeSpecificFlag]      bit,
                 [CreatedOn]             datetime,
                 [CreatedByUserKey]      uniqueidentifier,
                 [UpdatedOn]             datetime,
                 [UpdatedByUserKey]      uniqueidentifier,
                 [TypeSpecificInt]       int,
                 [GroupMemberStatusCode] nvarchar(4),
                 [IsActive]              bit,
                 [GroupMemberDetailKey]  uniqueidentifier,
                 [GroupKey]              uniqueidentifier
    );

    -- Get the EffectiveDate of the next range if one exists
    DECLARE @nextEffectiveDate datetime;
    DECLARE @now datetime;
    SELECT @nextEffectiveDate = MIN([EffectiveDate])
      FROM [GroupMemberDetail]
     WHERE [GroupKey] = @salesTeamKey AND [EffectiveDate] > @newStartDate;
    SELECT @now = dbo.asi_GetAppDatetime();

    -- Create the new range records in the temp table
    INSERT INTO [#tmpGroupMemberDetail] ([GroupMemberKey],
                                         [GroupRoleKey],
                                         [EffectiveDate],
                                         [ExpirationDate],
                                         [TypeSpecificData],
                                         [TypeSpecificKey],
                                         [TypeSpecificFlag],
                                         [CreatedOn],
                                         [CreatedByUserKey],
                                         [UpdatedOn],
                                         [UpdatedByUserKey],
                                         [TypeSpecificInt],
                                         [GroupMemberStatusCode],
                                         [IsActive],
                                         [GroupMemberDetailKey],
                                         [GroupKey]
                                        )
           SELECT [GroupMemberKey],
                  [GroupRoleKey],
                  @newStartDate,
                  DATEADD(day, -1, @nextEffectiveDate),
                  [TypeSpecificData],
                  [TypeSpecificKey],
                  [TypeSpecificFlag],
                  @now,
                  @userKey,
                  @now,
                  @userKey,
                  [TypeSpecificInt],
                  [GroupMemberStatusCode],
                  [IsActive],
                  NEWID(),
                  [GroupKey]
             FROM [GroupMemberDetail]
            WHERE [GroupKey] = @salesTeamKey AND (@newStartDate BETWEEN [EffectiveDate] AND [ExpirationDate] OR ([ExpirationDate] IS NULL AND DATEDIFF(day, [EffectiveDate], @newStartDate) > 0) )
            ORDER BY [EffectiveDate],
                     [GroupMemberKey];

    -- Set the expiration date of the existing records with the @newStartDate less 1 day
    UPDATE [GroupMemberDetail]
       SET
           [ExpirationDate] = DATEADD(day, -1, @newStartDate),
           [UpdatedOn] = @now,
           [UpdatedByUserKey] = @userKey
     WHERE [GroupKey] = @salesTeamKey AND (@newStartDate BETWEEN [EffectiveDate] AND [ExpirationDate] OR ([ExpirationDate] IS NULL AND DATEDIFF(day, [EffectiveDate], @newStartDate) > 0) );

    -- Insert the new records into the database table
    INSERT INTO [GroupMemberDetail] ([GroupMemberKey],
                                     [GroupRoleKey],
                                     [EffectiveDate],
                                     [ExpirationDate],
                                     [TypeSpecificData],
                                     [TypeSpecificKey],
                                     [TypeSpecificFlag],
                                     [CreatedOn],
                                     [CreatedByUserKey],
                                     [UpdatedOn],
                                     [UpdatedByUserKey],
                                     [TypeSpecificInt],
                                     [GroupMemberStatusCode],
                                     [IsActive],
                                     [GroupMemberDetailKey],
                                     [GroupKey]
                                    )
           SELECT [GroupMemberKey],
                  [GroupRoleKey],
                  [EffectiveDate],
                  [ExpirationDate],
                  [TypeSpecificData],
                  [TypeSpecificKey],
                  [TypeSpecificFlag],
                  [CreatedOn],
                  [CreatedByUserKey],
                  [UpdatedOn],
                  [UpdatedByUserKey],
                  [TypeSpecificInt],
                  [GroupMemberStatusCode],
                  [IsActive],
                  [GroupMemberDetailKey],
                  [GroupKey]
             FROM [#tmpGroupMemberDetail];
    COMMIT;
    SELECT 0;
    DROP TABLE [#tmpGroupMemberDetail];
    SET NOCOUNT OFF;
END;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_SalesTeamChangeRange]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_SalesTeamChangeRange]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_SalesTeamChangeRange]
       @salesTeamKey uniqueidentifier,
       @oldStartDate datetime,
       @newStartDate datetime,
       @userKey      uniqueidentifier
AS
BEGIN
    SET NOCOUNT ON;

    -- Check if there are any existing GroupMemberDetail records for this Group, if no records are found return with an error code of -1
    IF (SELECT COUNT(1) FROM [GroupMemberDetail] WHERE [GroupKey] = @salesTeamKey) < 1
    BEGIN
        SELECT-1;
        RETURN -1;
    END;
    
    IF (SELECT COUNT(1) FROM [GroupMemberDetail] WHERE [GroupKey] = @salesTeamKey AND [EffectiveDate] = @oldStartDate) < 1
    BEGIN
        SELECT-2;
        RETURN -2;
    END;

    -- Verify that @newStartDate is valid
    IF ( (
          SELECT DATEADD(day, 1, MAX([EffectiveDate]))
            FROM [GroupMemberDetail]
           WHERE [GroupKey] = @salesTeamKey AND [EffectiveDate] < @oldStartDate
    ) < @newStartDate OR (
                          SELECT DATEADD(day, 1, MAX([EffectiveDate]))
                            FROM [GroupMemberDetail]
                           WHERE [GroupKey] = @salesTeamKey AND [EffectiveDate] < @oldStartDate
    ) IS NULL) AND (@newStartDate < (
                                     SELECT DISTINCT
                                            [ExpirationDate]
                                       FROM [GroupMemberDetail]
                                      WHERE [GroupKey] = @salesTeamKey AND [EffectiveDate] = @oldStartDate
    ) OR (SELECT DISTINCT
                 [ExpirationDate]
            FROM [GroupMemberDetail]
           WHERE [GroupKey] = @salesTeamKey AND [EffectiveDate] = @oldStartDate
    ) IS NULL)
    BEGIN
        BEGIN TRANSACTION;
        DECLARE @now datetime;
        SELECT @now = dbo.asi_GetAppDatetime();
        
        --Previous Range
        UPDATE [GroupMemberDetail]
           SET
               [ExpirationDate] = DATEADD(DAY, -1, @newStartDate),
               [UpdatedOn] = @now,
               [UpdatedByUserKey] = @userKey
         WHERE [GroupKey] = @salesTeamKey AND [EffectiveDate] = (
                                                                 SELECT MAX([EffectiveDate])
                                                                   FROM [GroupMemberDetail]
                                                                  WHERE [GroupKey] = @salesTeamKey AND [EffectiveDate] < @oldStartDate
        );
     
        --Current Range
        UPDATE [GroupMemberDetail]
           SET
               [EffectiveDate] = @newStartDate,
               [UpdatedOn] = @now,
               [UpdatedByUserKey] = @userKey
         WHERE [GroupKey] = @salesTeamKey AND [EffectiveDate] = @oldStartDate;
        SELECT 0;
        COMMIT;
    END;
    ELSE
    BEGIN
        SELECT-2;
        RETURN -2;
    END;
    SET NOCOUNT OFF;
END;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ScheduledTaskAcquire]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ScheduledTaskAcquire]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_ScheduledTaskAcquire]
    @lockKey  uniqueidentifier = NULL,
    @category nvarchar(50)     = NULL
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @tmp nvarchar(800);
    SET @tmp = N'SELECT ScheduledTaskKey, SelectionLock INTO #pick ';
    SET @tmp = @tmp + N'FROM ScheduledTask ';
    SET @tmp = @tmp + N'WHERE IsDisabled = 0 AND (SelectionLock IS NULL OR SelectionLock = ''' + CAST(@lockKey AS nvarchar(40))+N''' OR KeepAlive < dateadd(mi, -15, dbo.asi_GetAppDatetime())) ';
    IF DATALENGTH(@category) > 0
    BEGIN
        SET @tmp = @tmp + N'AND Category LIKE ''' + @category + N'%'' ';
    END;
    SET @tmp = @tmp + N'UPDATE ScheduledTask SET SelectionLock = ''' + CAST(@lockKey AS nvarchar(40)) + N''', KeepAlive = dbo.asi_GetAppDatetime() ';
    SET @tmp = @tmp + N'FROM ScheduledTask INNER JOIN #pick ON ScheduledTask.ScheduledTaskKey = #pick.ScheduledTaskKey ';
    SET @tmp = @tmp + N'WHERE (ScheduledTask.SelectionLock IS NULL OR ScheduledTask.SelectionLock = #pick.SelectionLock) ';
    SET @tmp = @tmp + N'DROP TABLE #pick ';
    SET @tmp = @tmp + N'SELECT count(1) FROM ScheduledTask WHERE SelectionLock = ''' + CAST(@lockKey AS nvarchar(40)) + N'''';
    EXEC (@tmp);
END;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ScheduledTaskHistoryAppendLog]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ScheduledTaskHistoryAppendLog]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE  proc [dbo].[asi_ScheduledTaskHistoryAppendLog]
 @key uniqueidentifier,
 @textToAppend nvarchar(4000) as

DECLARE @ptr varbinary(16)

SELECT  @ptr = TEXTPTR(LogText)
 FROM   ScheduledTaskHistory
 WHERE  ScheduledTaskHistoryKey = @key
IF TEXTVALID('ScheduledTaskHistory.LogText', @ptr) = 1
BEGIN
   UPDATETEXT ScheduledTaskHistory.LogText @ptr NULL 0 @textToAppend --Append to end
   --UPDATETEXT ScheduledTaskHistory.LogText @ptr 0 0 @textToAppend --Insert at beginning
END
ELSE
BEGIN
   UPDATE ScheduledTaskHistory
      SET LogText = @textToAppend
    WHERE ScheduledTaskHistoryKey = @key
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ScheduleWorkflow]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ScheduleWorkflow]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_ScheduleWorkflow]
    @itemCount int = 4
AS
BEGIN
------------------------------------------------------------------------------------------
--Update the appropriate number of rows with a UniqueIdentifier to mark them as 'Selected'
------------------------------------------------------------------------------------------

--Get a new GUID
DECLARE @id uniqueidentifier
SET @id = NEWID()

DECLARE @sql nvarchar(400);
DECLARE @sqlParams nvarchar(40);

SET @sqlParams = N'@key uniqueidentifier';

SET @sql = N'UPDATE [dbo].[WorkflowQueue]' + 
           N'   SET [SelectionKey] = @key' +
           N'  FROM [dbo].[WorkflowQueue] wfq' +
           N' WHERE wfq.[WorkFlowQueueKey] IN (' +
                 N' SELECT TOP ' + CAST(@itemCount AS nvarchar(10)) + ' WorkFlowQueueKey' +
                 N'   FROM [dbo].[WorkflowQueue]' +
                 N'  WHERE [SelectionKey] IS NULL' +
                 N' ORDER BY [CreatedOn] ASC)' +
           N'   AND wfq.[SelectionKey] IS NULL';

--Update the values of up to the top three rows
EXECUTE sp_executesql @sql, @sqlParams, @key = @id

-------------------------------------------------------------------------------
--Select the rows previously marked for execution and return them to the client
-------------------------------------------------------------------------------
SELECT [WorkFlowQueueKey] FROM [dbo].[WorkflowQueue] WHERE [SelectionKey] = @id

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_SearchGetEvents]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_SearchGetEvents]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_SearchGetEvents]
    @timeStamp bigint = null,
    @lastTimeStamp bigint OUTPUT
AS
----------------------------------------------------------
-- Returns events 
-- Called by the Search Indexer
----------------------------------------------------------

SELECT 
    CONVERT(bigint, MM.TIME_STAMP) AS [TimeStamp]
    , MM.ADDRESS_1 AS Address1
    , MM.ADDRESS_2 AS Address2
    , MM.ADDRESS_3 AS Address3
    , MM.BEGIN_DATE AS BeginDate
    , MM.CITY AS City
    , MM.CONTACT_ID AS ContactId
    , MM.COORDINATORS AS Coordinators
    , MM.COUNTRY AS Country
    , MM.DESCRIPTION AS [Description]
    , MM.DIRECTIONS AS Directions
    , MM.EARLY_CUTOFF AS EarlyCutoff
    , MM.EMAIL_REGISTRATION AS EmailRegistration
    , MM.END_DATE AS EndDate
    , MM.HEAD_COUNT AS Attendees
    , MM.IS_FR_MEET AS IsFrMeeting
    , MM.LATE_CUTOFF AS LateCutoff
    , MM.MAX_REGISTRANTS AS MaxRegistrants
    , MM.MEET_APPEAL AS MeetAppeal
    , MM.MEET_CAMPAIGN AS MeetCampaign
    , MM.MEETING AS EventCode
    , MM.MEETING_IMAGE_NAME AS MeetingImageName
    , MM.MEETING_TYPE AS MeetingType
    , MM.MEETING_URL AS MeetingUrl
    , MM.NOTES AS Notes
    , MM.ORG_CODE AS EntityCode
    , MM.REG_CUTOFF AS RegCutoff
    , MM.STATE_PROVINCE AS StateProvince
    , MM.STATUS AS Status
    , MM.TITLE AS Title
    , MM.TOTAL_CANCELATIONS AS TotalCancelations
    , MM.TOTAL_REGISTRANTS AS TotalRegistrants
    , MM.TOTAL_REVENUE AS TotalRevenue
    , MM.WEB_ENABLED AS WebEnabled
    , MM.WEB_VIEW_ONLY AS WebViewOnly
    , MM.ZIP AS Zip
    , MM.PUBLISH_START_DATE AS PublishStartDate
    , MM.PUBLISH_END_DATE AS PublishEndDate
    , MM.TEMPLATE_STATE_CODE AS TemplateStateCode 
FROM Meet_Master MM
WHERE ( CONVERT(bigint, MM.TIME_STAMP) > COALESCE(@timeStamp, 0) )

SELECT @lastTimeStamp = MAX(CONVERT(bigint, MM.TIME_STAMP)) 
FROM Meet_Master MM

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_SearchGetProducts]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_SearchGetProducts]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


CREATE PROCEDURE [dbo].[asi_SearchGetProducts]
    @timeStamp bigint = null,
    @lastTimeStamp bigint OUTPUT
AS
----------------------------------------------------------
-- Returns the legacy and the gift products 
-- Called by the Search Indexer
----------------------------------------------------------
SELECT        
    CONVERT(bigint, p.TIME_STAMP) AS [TimeStamp]
    , p.DEFERRED_INCOME_ACCOUNT AS DeferredIncomeAccount
    , p.DESCRIPTION
    , p.INCOME_ACCOUNT AS IncomeAccount
    , p.PRICE_1 AS Price1
    , p.PRICE_2 AS Price2
    , p.PRICE_3 AS Price3
    , p.PROD_TYPE AS ProductType
    , p.PRODUCT_CODE AS ProductCode
    , p.PRODUCT_MAJOR AS ProductMajor
    , p.PRODUCT_MINOR AS ProductMinor
    , p.STATUS
    , p.TITLE
    , p.TITLE_KEY AS TitleKey
    , p.CATEGORY AS ProductCategory
    , p.APPLY_IMAGE
    , p.APPLY_THUMBNAIL
    , p.IMAGE_URL
    , p.THUMBNAIL_URL
    , p.WEB_DESC
    , p.WEB_OPTION
    , p.PUBLISH_START_DATE as PublishStartDate
    , p.PUBLISH_END_DATE   as PublishEndDate
    , op.IsSuperProduct
    , op.SellOnWeb
    , opcl.IsFeatured
    , p.TIME_STAMP
FROM 
    dbo.Product AS p 
        LEFT OUTER JOIN dbo.OrderProduct AS op ON p.PRODUCT_CODE = op.ProductCode 
        LEFT OUTER JOIN dbo.OrderProductCategoryLookup AS opcl ON op.OrderProductID = opcl.OrderProductID
WHERE 
    (( p.PROD_TYPE = 'SALES') 
        OR
    (p.PROD_TYPE = 'GIFT'))
    AND ( CONVERT(bigint, p.TIME_STAMP) > COALESCE(@timeStamp, 0) )

SELECT @lastTimeStamp = MAX(CONVERT(bigint, p.TIME_STAMP)) 
FROM Product p



GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_SeasonalAddress]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_SeasonalAddress]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

--  asi_SeasonalAddress
--  Updates AddressToUse.FullAddressKey values
--  based on the SeasonalFullAddress table.

CREATE PROCEDURE [dbo].[asi_SeasonalAddress]
AS
BEGIN
    SET NOCOUNT ON;
    -- Variables used by Procedure
    DECLARE @now datetime;
    SET @now = dbo.asi_GetAppDatetime();
    DECLARE @notSeasonalInstances int;

    -- Select all SeasonalFullAddress -> curSeasonalFullAddress
    DECLARE curSeasonalFullAddress CURSOR
    FOR SELECT [FullAddressKey],
               [ReplacesFullAddressKey],
               [BeginDate],
               [EndDate],
               [IsSeasonalAnnually]
          FROM [SeasonalFullAddress]
         --    A non-annual address will override an annual address in the same timeframe.
         --    Ordering by IsSeasonalAnnually DESC will let non-annual addresses do this.
         --    Ordering by BeginDate ASC allows one seasonal address to transparently follow another.
         ORDER BY [IsSeasonalAnnually] DESC,
                  [BeginDate] ASC;

    -- Variables used by a SeasonalFullAddress
    DECLARE @fullAddressKey uniqueidentifier;
    DECLARE @replacesFullAddressKey uniqueidentifier;
    DECLARE @beginDate datetime;
    DECLARE @endDate datetime;
    DECLARE @isSeasonalAnnually bit;

    -- Open: curSeasonalFullAddress
    OPEN curSeasonalFullAddress;
    FETCH NEXT FROM curSeasonalFullAddress INTO @fullAddressKey,
                                                @replacesFullAddressKey,
                                                @beginDate,
                                                @endDate,
                                                @isSeasonalAnnually;

    -- Iterate: curSeasonalFullAddress
    WHILE @@fetch_Status = 0
    BEGIN
        -- If it's seasonal annually, bring the year up to this year
        IF (@isSeasonalAnnually = 1)
        BEGIN
            SET @beginDate = CAST(CAST(DATEPART([mm], @beginDate) AS nvarchar(2))+'/'+CAST(DATEPART([dd], @beginDate) AS nvarchar(2))+'/'+CAST(DATEPART([yyyy], @now) AS nvarchar(4)) AS datetime);
            SET @endDate = CAST(CAST(DATEPART([mm], @endDate) AS nvarchar(2))+'/'+CAST(DATEPART([dd], @endDate) AS nvarchar(2))+'/'+CAST(DATEPART([yyyy], @now) AS nvarchar(4)) AS datetime);
        END;

        -- Is this SeasonalFullAddress valid?
        IF (@beginDate <= @now AND (@now < @endDate OR @endDate IS NULL) )
        -- Is valid, make the seasonal change
        BEGIN
            -- Now, Swap the actual pointer
            UPDATE [AddressToUse]
               SET [FullAddressKey] = @replacesFullAddressKey,
                   [SeasonalRevertFullAddressKey] = [FullAddressKey]
             WHERE [FullAddressKey] = @fullAddressKey;
        END;
        ELSE
        -- Not valid, reverse the seasonal change
        BEGIN
            UPDATE [AddressToUse]
               SET [FullAddressKey] = [SeasonalRevertFullAddressKey],
                   [SeasonalRevertFullAddressKey] = NULL
             WHERE [FullAddressKey] = @replacesFullAddressKey
                   --          Only revert if this one is the cause
                   AND [SeasonalRevertFullAddressKey] = @fullAddressKey
                   --          If this address is in AddressToUse but isn't seasonal,
                   --          we don't want to revert.
                   AND [SeasonalRevertFullAddressKey] IS NOT NULL;
        END;

        -- Get next row
        FETCH NEXT FROM curSeasonalFullAddress INTO @fullAddressKey,
                                                    @replacesFullAddressKey,
                                                    @beginDate,
                                                    @endDate,
                                                    @isSeasonalAnnually;
    END;
    -- End iterate: curSeasonalFullAddress
    -- Close and Dealloc: curSeasonalFullAddress
    CLOSE curSeasonalFullAddress;
    DEALLOCATE curSeasonalFullAddress;
END;


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_SequencePeek]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_SequencePeek]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_SequencePeek]
	@SequenceName nvarchar(30) AS

SELECT CurrentValue FROM SequenceCounter WHERE CounterName = @SequenceName

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_SetAppealParticipationResponseTypeCodes]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_SetAppealParticipationResponseTypeCodes]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- Author:		Paul Rogers
-- Create date: August 2006
-- Description:	Obtain the campaign for a given
-- appeal and set the ResponseTypeCode for all
-- AppealParticipation records that are associated
-- with the campaign for the particular respondent.
-- =============================================

CREATE PROCEDURE [dbo].[asi_SetAppealParticipationResponseTypeCodes]
	@respondentKey uniqueidentifier,
	@appealKey uniqueidentifier,
	@responseTypeCode int
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

BEGIN TRAN

	DECLARE @campaignKey UNIQUEIDENTIFIER
	DECLARE @returnCount int
	SET @returnCount = 0

	-- Given an Appeal, figure out the Campaign
	SELECT @campaignKey = cm.CampaignKey
	FROM CampaignMain cm
	INNER JOIN AppealMain am ON am.CampaignKey = cm.CampaignKey
	WHERE am.AppealKey=@appealKey

	-- Set the response type code for all
	-- AppealParticipation records involving
	-- the Campaign and the Respondent
	UPDATE AppealParticipation
	SET
		ResponseTypeCode=@responseTypeCode
	FROM AppealParticipation ap
	INNER JOIN AppealMain am ON ap.AppealKey = am.AppealKey
	INNER JOIN CampaignMain cm ON am.CampaignKey = cm.CampaignKey
	WHERE ap.RespondentUserKey=@respondentKey
	AND cm.CampaignKey = @campaignKey

	SET @returnCount = @@ROWCOUNT

	
	SELECT @returnCount AS ReturnCount
COMMIT TRAN
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_SetDatabaseVersion]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_SetDatabaseVersion]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:      Paul Bradshaw
-- Create date: Sept 19, 2006
-- Updated On:  Feb  24, 2016
-- Description: Set DB Version string
-- =============================================
CREATE PROCEDURE [dbo].[asi_SetDatabaseVersion]
	@newVersion nvarchar(20) = '' -- Specify the version string
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @version nvarchar(24);
    DECLARE @major nvarchar(10);
    DECLARE @minor nvarchar(10);
    DECLARE @revision nvarchar(10);
    DECLARE @build nvarchar(10);
    DECLARE @systemEntity uniqueidentifier;
    DECLARE @type nvarchar(20);
    DECLARE @pos1 int;
    DECLARE @pos2 int;
    DECLARE @pos3 int;
    DECLARE @pos4 int;

    SET @version = UPPER(LTRIM(RTRIM(@newVersion)));

    SELECT @systemEntity = [SystemEntityKey] FROM [dbo].[SystemEntity] WHERE [SystemKeyword] = 'Organization';

    SELECT @major = [ParameterValue] FROM [dbo].[SystemConfig]
     WHERE [ParameterName] = 'System.Database.Version.Major'
       AND [OrganizationKey] = '00000000-0000-0000-0000-000000000000' AND [SystemEntityKey] = @systemEntity;
    SELECT @minor = [ParameterValue] FROM [dbo].[SystemConfig] 
     WHERE [ParameterName] = 'System.Database.Version.Minor'
       AND [OrganizationKey] = '00000000-0000-0000-0000-000000000000' AND [SystemEntityKey] = @systemEntity;
    SELECT @revision = [ParameterValue] FROM [dbo].[SystemConfig] 
     WHERE [ParameterName] = 'System.Database.Version.Patch'
       AND [OrganizationKey] = '00000000-0000-0000-0000-000000000000' AND [SystemEntityKey] = @systemEntity;
    SELECT @build = [ParameterValue] FROM [dbo].[SystemConfig] 
     WHERE [ParameterName] = 'System.Database.Version.Build'
       AND [OrganizationKey] = '00000000-0000-0000-0000-000000000000' AND [SystemEntityKey] = @systemEntity;

    IF @version IS NOT NULL AND @version <> '' AND
       @major IS NOT NULL AND @minor IS NOT NULL AND @revision IS NOT NULL AND @build IS NOT NULL
    BEGIN
    IF @version <> 'INCBUILD'
    BEGIN
        SET @pos1 = CHARINDEX('.', @version, 1)
        IF (@pos1 > 0) 
        BEGIN
            SET @major = SUBSTRING(@version, 1, @pos1 - 1)
            SET @pos2 = CHARINDEX('.', @version, @pos1 + 1)
            IF (@pos2 > 0)
            BEGIN
                SET @minor = SUBSTRING(@version, @pos1 + 1, (@pos2 - @pos1) -1)
                SET @pos3 = CHARINDEX('.', @version, @pos2 + 1)
                IF (@pos3 > 0)
                BEGIN
                    SET @revision = SUBSTRING(@version, @pos2 + 1, (@pos3 - @pos2) -1)
                    SET @pos4 = CHARINDEX('.', @version, @pos3 + 1)
                    IF (@pos4 > 0)
                    BEGIN
	                    SET @build = SUBSTRING(@version, @pos3 + 1, (@pos4 - @pos3) -1)
                    END
                    ELSE
                    BEGIN
	                    SET @build = SUBSTRING(@version, @pos3 + 1, LEN(@version))
                    END
                END
                ELSE
                BEGIN
                    SET @revision = SUBSTRING(@version, @pos2 + 1, LEN(@version))
                END
            END
            ELSE
            BEGIN
                SET @minor = SUBSTRING(@version, @pos1 + 1, LEN(@version))
            END
        END
        ELSE
        BEGIN
            SET @major = @version
        END
    END
    ELSE IF @version = 'INCBUILD'
    BEGIN
        SET @build = CAST(CAST(COALESCE(CASE WHEN @build = '' THEN '0' ELSE @build END, '0') AS int) + 1 AS nvarchar(10));
    END

    IF (@major IS NOT NULL AND @major <> '')
        UPDATE [SystemConfig] SET [ParameterValue] = @major 
         WHERE [ParameterName] = 'System.Database.Version.Major'
           AND [OrganizationKey] = '00000000-0000-0000-0000-000000000000' AND SystemEntityKey = @systemEntity
    IF (@minor IS NOT NULL AND @minor <> '')
        UPDATE [SystemConfig] SET [ParameterValue] = @minor 
         WHERE [ParameterName] = 'System.Database.Version.Minor'
           AND [OrganizationKey] = '00000000-0000-0000-0000-000000000000' AND SystemEntityKey = @systemEntity
    IF (@revision IS NOT NULL AND @revision <> '')
        UPDATE [SystemConfig] SET [ParameterValue] = @revision 
         WHERE [ParameterName] = 'System.Database.Version.Patch'
           AND [OrganizationKey] = '00000000-0000-0000-0000-000000000000' AND SystemEntityKey = @systemEntity
    IF (@build IS NOT NULL AND @build <> '')
        UPDATE [SystemConfig] SET [ParameterValue] = @build 
         WHERE [ParameterName] = 'System.Database.Version.Build'
           AND [OrganizationKey] = '00000000-0000-0000-0000-000000000000' AND SystemEntityKey = @systemEntity

    UPDATE [dbo].[System_Params] 
       SET [ShortValue] = [dbo].[asi_DatabaseVersion]('') 
     WHERE [ParameterName] = 'System_Control.Version'

    END

END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_SetEventConfirmationDateTime]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_SetEventConfirmationDateTime]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

/****** Object:  Stored Procedure dbo.asi_SetEventConfirmationDateTime    ******/


CREATE PROCEDURE [dbo].[asi_SetEventConfirmationDateTime]
@triggerid numeric
AS
BEGIN    
    
    UPDATE [dbo].[Orders] 
       SET [CONFIRMATION_DATE_TIME] = dbo.asi_GetAppDatetime() 
     WHERE [ORDER_NUMBER] =  @triggerid

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_SetMailingListIdentityField]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_SetMailingListIdentityField]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- This stored procedure assigns the identity field in temporary mailing list
-- tables in the order that the mailing list table should be queried.
CREATE PROCEDURE [dbo].[asi_SetMailingListIdentityField]
   @tableName sysname,
   @fieldName sysname,
   @keyFieldName sysname,
   @orderByClause nvarchar(256)
AS
BEGIN
   DECLARE @sql nvarchar(800)

   CREATE TABLE #SetIdentityTable
   (
      SetIdentityTableKey uniqueidentifier,
      IntId int IDENTITY(1, 1)
   )
	   
   SET @sql = 'INSERT #SetIdentityTable (SetIdentityTableKey) SELECT [' + @keyFieldName + '] FROM [' + @tableName + '] ' + @orderByClause
   EXEC(@sql)
	
   SET @sql = 'UPDATE [' + @tableName + '] SET [' + @fieldName + ']=#SetIdentityTable.IntId FROM #SetIdentityTable WHERE #SetIdentityTable.SetIdentityTableKey=[' + @tableName + '].[' + @keyFieldName + ']'
   EXEC(@sql)
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_SyncMemberTypeSecurityGroups]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_SyncMemberTypeSecurityGroups]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- Synchronize the Member Type Security Groups with Member_Types
CREATE PROCEDURE [dbo].[asi_SyncMemberTypeSecurityGroups]
AS
BEGIN
    SET NOCOUNT ON;
    -- Declare all variables needed
    DECLARE @now datetime;
    DECLARE @userKey uniqueidentifier;
    DECLARE @accessKey uniqueidentifier;
    DECLARE @groupTypeKey uniqueidentifier;
    DECLARE @systemEntityKey uniqueidentifier;
    DECLARE @groupComponentKey uniqueidentifier;
    DECLARE @groups TABLE ([GroupKey] uniqueidentifier, [Name] nvarchar(65), [Description] nvarchar(250));

    -- Grab some constant values
    SELECT @now = dbo.asi_GetAppDatetime();
    SELECT @userKey = [UserKey] FROM [dbo].[UserMain] WHERE [UserId] = 'SYSTEM';
    IF @userKey IS NULL SELECT @userKey = [UserKey] FROM [dbo].[UserMain] WHERE [UserId] = 'MANAGER';
    SELECT @accessKey = [ProtectedAccessKey] FROM [dbo].[AccessArea] WHERE [Name] = 'Everyone Full Control';
    SET @groupTypeKey = '636A1E55-38BC-4A8F-AC8D-A6873D697F18';
    SELECT @systemEntityKey = [SystemEntityKey] FROM [dbo].[SystemEntity] WHERE [SystemKeyword] = 'Organization';
    SELECT @groupComponentKey = [ComponentKey] FROM [dbo].[ComponentRegistry] WHERE [Name] = 'Group' AND [InterfaceName] = 'BusinessController';

    -- Create Group Type if it doesn't already exist
    IF NOT EXISTS (SELECT 1 FROM [dbo].[GroupTypeRef] WHERE [GroupTypeName] = 'Member Type Security')
    BEGIN
        INSERT INTO [dbo].[GroupTypeRef] ([GroupTypeKey], [GroupTypeName], [IsSystem], [IsPaymentRequired], [IsDateLimited], 
                                          [GroupMemberBranchName], [IsInvitationOnly], [DefaultGroupStatusCode], [IsSimpleGroup],
                                          [MemberQueryFolderKey], [InheritRolesFlag], [IsSingleRole], [GroupTypeDesc],
                                          [CreatedByUserKey], [UpdatedByUserKey], [CreatedOn], [UpdatedOn])
        VALUES (@groupTypeKey, 'Member Type Security', 1, 0, 0,
                NULL, 0, 'A', 1, NULL, 0, 0, 'Member Type Security Group Type',
                @userKey, @userKey, @now, @now) 
    END

    -- Get a list of all the groups we should have, one for each member type
    INSERT INTO @groups ([GroupKey], [Name], [Description])
        SELECT COALESCE(gm.GroupKey, NEWID()), mt.[DESCRIPTION], 'Security Group for ' + mt.[DESCRIPTION] + ' users'
          FROM [dbo].[Member_Types] mt LEFT OUTER JOIN [dbo].[GroupMain] gm ON gm.[Name] = mt.[DESCRIPTION]

    -- Remove any Members of Member Type Security groups that don't have a corresponding member type in Member_Types
    DELETE m 
      FROM [dbo].[GroupMember] m 
           INNER JOIN [dbo].[GroupMain] gm ON m.GroupKey = gm.[GroupKey]
           LEFT OUTER JOIN @groups g ON gm.[Name] = g.[Name]
     WHERE gm.[GroupTypeKey] = @groupTypeKey
       AND g.[Name] IS NULL

    -- Remove any Member Type Security groups that don't have a corresponding member type in Member_Types
    DELETE gm
      FROM [dbo].[GroupMain] gm 
           LEFT OUTER JOIN @groups g ON gm.[Name] = g.[Name]
           INNER JOIN [dbo].[UniformRegistry] ON gm.[GroupKey] = gm.[GroupKey]
     WHERE gm.[GroupTypeKey] = @groupTypeKey
       AND g.[Name] IS NULL

    -- Remove Uniform Registry entries for the deleted groups
    DELETE ur
      FROM [dbo].[UniformRegistry] ur 
           LEFT OUTER JOIN [dbo].[GroupMain] gm ON ur.[UniformKey] = gm.[GroupKey]
     WHERE ur.[ComponentKey] = @groupComponentKey AND gm.[GroupKey] IS NULL

    -- Create Uniform Registry entry for each new security group
    INSERT INTO [dbo].[UniformRegistry] ([UniformKey], [ComponentKey])
        SELECT g.[GroupKey], @groupComponentKey 
          FROM @groups g LEFT OUTER JOIN [dbo].[UniformRegistry] ur ON ur.[UniformKey] = g.[GroupKey] AND ur.[ComponentKey] = @groupComponentKey
         WHERE  ur.[UniformKey] IS NULL

    -- Create a new Member Type Security group for each member type in Member_Types
    INSERT INTO [dbo].[GroupMain] ([GroupKey], [Name], [Description], [UpdatedByUserKey], [UpdatedOn], [IsSystem], [IsAutoGenerated], 
                                   [GroupTypeKey], [Priority], [OwnerAccessKey], [OverrideOwnerGroupKey], [AccessKey], 
                                   [CreatedByUserKey], [CreatedOn], [SystemEntityKey],
                                   [IsInvitationOnly], [GroupStatusCode], [IsSimpleGroup], [InheritRolesFlag], [IsSingleRole])
        SELECT g.[GroupKey], g.[Name], g.[Description], @userKey, @now, 1, 1,
               @groupTypeKey, NULL, NULL, NULL, @accessKey, @userKey, @now, @systemEntityKey, 0, 'A', 1, 0, 0
          FROM @groups g
         WHERE NOT EXISTS (SELECT 1 FROM [dbo].[GroupMain] gm WHERE g.[Name] = gm.[Name] AND gm.[GroupTypeKey] = @groupTypeKey)

    -- Populate the new Security Groups
    INSERT INTO [dbo].[GroupMember] ([GroupMemberKey], [GroupKey], [MemberContactKey], [IsActive],
                                     [CreatedByUserKey], [CreatedOn], [UpdatedByUserKey], [UpdatedOn],
                                     [DropDate], [JoinDate], [MarkedForDeleteOn])
        SELECT NEWID(), g.GroupKey, cm.ContactKey, 1, @userKey, @now, @userKey, @now, NULL, NULL, NULL  
          FROM [dbo].[Name] n INNER JOIN [Member_Types] mt ON n.MEMBER_TYPE = mt.[MEMBER_TYPE]
               INNER JOIN [dbo].[ContactMain] cm ON n.[ID] = cm.[SyncContactID]
               INNER JOIN [dbo].[UserMain] um ON um.UserKey = cm.ContactKey
               INNER JOIN [dbo].[GroupMain] g ON g.[Name] = mt.[DESCRIPTION]
         WHERE NOT EXISTS (SELECT 1 FROM [dbo].[GroupMember] gm WHERE gm.GroupKey = g.GroupKey AND gm.MemberContactKey = um.UserKey)
    SET NOCOUNT OFF
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_SyncNetContacts]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_SyncNetContacts]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- sync them, 1000 per transaction, to the new tables
CREATE PROCEDURE [dbo].[asi_SyncNetContacts] AS
BEGIN
    SET NOCOUNT ON
    DECLARE @isDone bit
    DECLARE @count int
    DECLARE @rowcount int
    DECLARE @totalCount int
    DECLARE @msg nvarchar(255)
    
    SET @count = 0
    SELECT @totalCount = COUNT(1) 
      FROM Name c LEFT OUTER JOIN ContactMain d
        ON c.ID = d.SyncContactID
     WHERE d.SyncContactID IS NULL
     
    SET @msg = 'Total contact records to sync: ' + CAST(@totalCount AS nvarchar(12))
    RAISERROR (@msg, 0, 1) WITH NOWAIT;
    
    SET @isDone = 0
    WHILE @isDone = 0
    BEGIN
        BEGIN TRANSACTION
        UPDATE a 
           SET LAST_FIRST = LAST_FIRST
          FROM Name a INNER JOIN (
                SELECT TOP 2000 c.ID
                  FROM Name c LEFT OUTER JOIN ContactMain d
                    ON c.ID = d.SyncContactID
                 WHERE d.SyncContactID IS NULL) b
            ON a.ID = b.ID

        SET @rowcount = @@ROWCOUNT
        IF @rowcount = 0 
        BEGIN
            SET @isDone = 1
        END
        ELSE
        BEGIN
            SET @count = @count + @rowcount
            SET @msg = '   Contacts synced: ' + CAST(@count AS nvarchar(12))  
            RAISERROR (@msg, 0, 1) WITH NOWAIT;
        END
        COMMIT
    END

	-- fix up the problem where the company a person works for is in a later block than the 
	-- person is.  e.g., the CO_ID > the ID
	INSERT INTO GroupMember 
		   (GroupMemberKey, GroupKey, MemberContactKey, IsActive, CreatedByUserKey, CreatedOn, UpdatedByUserKey, UpdatedOn)
	SELECT NewId(), d.InstituteGroupKey, b.ContactKey, 1, b.CreatedByUserKey, b.CreatedOn, b.CreatedByUserKey, b.CreatedOn
	  FROM Name a inner join ContactMain b ON a.ID = b.ID 
	  	   inner join ContactMain c ON a.CO_ID = c.ID
		   inner join Institute d ON c.ContactKey = d.ContactKey
		   left outer join GroupMember e ON d.InstituteGroupKey = e.GroupKey AND b.ContactKey = e.MemberContactKey
	 WHERE e.GroupKey IS NULL

	INSERT INTO GroupMemberDetail 
		   (GroupMemberDetailKey, GroupMemberKey, GroupKey, GroupRoleKey, EffectiveDate, 
			CreatedByUserKey, CreatedOn, UpdatedByUserKey, UpdatedOn, GroupMemberStatusCode, IsActive)
	SELECT newid(), c.GroupMemberKey, c.GroupKey, f.GroupRoleKey, c.CreatedOn, 
		   c.CreatedByUserKey, c.CreatedOn, c.CreatedByUserKey, c.CreatedOn, f.DefaultMemberStatusCode, 1
	  FROM GroupMain a 
	  	   inner join ContactTypeRef b ON a.GroupTypeKey = b.GroupTypeKey and b.ContactTypeDesc = 'Company'
	       inner join GroupMember c ON a.GroupKey = c.GroupKey
	       left outer join GroupMemberDetail d ON c.GroupMemberKey = d.GroupMemberKey
		   inner join GroupTypeRole f on b.GroupTypeKey = f.GroupTypeKey AND f.IsDefault = 1
	 WHERE d.GroupMemberKey IS NULL

    RAISERROR ('Sync complete', 0, 1) WITH NOWAIT;
    SET NOCOUNT OFF
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TaskRemoveTrigger]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TaskRemoveTrigger]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- Remove a specified task trigger 
CREATE PROCEDURE [dbo].[asi_TaskRemoveTrigger]
    @tableName sysname,
    @action nvarchar(10)
AS 
BEGIN
    SET @action = LTRIM(RTRIM(COALESCE(@action, N'')));
    IF (LEN(LTRIM(RTRIM(@action))) <> 6)
    BEGIN
        RAISERROR ('Invalid action specified', 16, 1);
        RETURN;
    END
    SET @action = UPPER(LEFT(@action, 1)) + LOWER(RIGHT(@action, LEN(@action) - 1))  
    IF (@action <> 'Insert' AND @action <> 'Update' AND @action <> 'Delete')
    BEGIN
        RAISERROR ('Invalid action specified', 16, 1);
        RETURN;
    END;
    IF NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = @tableName AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        RAISERROR ('Invalid table name specified', 16, 1);
        RETURN;
    END;

    -- If the specified trigger exists, then drop it
    DECLARE @statement nvarchar(MAX)
    IF EXISTS (SELECT 1 FROM sys.triggers WHERE object_id = OBJECT_ID(N'[dbo].[asiTask_' + @tableName + N'_' + @action + N']'))
    BEGIN
        SET @statement = N'DROP TRIGGER [dbo].[asiTask_' + @tableName + N'_' + @action + N']'
        EXECUTE sp_executesql @statement
    END    
END


GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TaskCreateTrigger]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TaskCreateTrigger]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- Create the specified Task Trigger
CREATE PROCEDURE [dbo].[asi_TaskCreateTrigger]
    @tableName sysname,
    @action nvarchar(20)
AS 
BEGIN
    SET NOCOUNT ON;
    -- Validate Parameters
    SET @action = LTRIM(RTRIM(COALESCE(@action, N'')));
    IF (LEN(LTRIM(RTRIM(@action))) <> 6)
    BEGIN
        RAISERROR ('Invalid action specified', 16, 1);
        RETURN;
    END
    SET @action = UPPER(LEFT(@action, 1)) + LOWER(RIGHT(@action, LEN(@action) - 1))  
    IF (@action <> 'Insert' AND @action <> 'Update' AND @action <> 'Delete')
    BEGIN
        RAISERROR ('Invalid action specified', 16, 1);
        RETURN;
    END;
    IF NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = @tableName AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        RAISERROR ('Invalid table name specified', 16, 1);
        RETURN;
    END;

    -- Get the 'order by primary key' info for the specified table... fail if there is no Primary Key
    DECLARE @orderByKey nvarchar(MAX);
    SELECT @orderByKey = STUFF( (SELECT '], [' + c.[name]   
      FROM sys.indexes AS i
           INNER JOIN sys.index_columns AS ic ON i.[object_id] = ic.[object_id] AND i.[index_id] = ic.[index_id]
           INNER JOIN sys.columns AS c ON ic.[object_id] = c.[object_id] AND c.[column_id] = ic.[column_id]
     WHERE i.[is_primary_key] = 1 AND i.[object_id] = OBJECT_ID(@tableName)
     ORDER BY [key_ordinal] FOR XML PATH('')), 1, 2, '') + ']';
    IF (@orderByKey IS NULL)
    BEGIN
        RAISERROR ('Table Must Have a Primary Key', 16, 1);
        RETURN;
    END;
        
    -- Grab a list of the columns we're going to be inserting into the xmlblob
    DECLARE @columnList nvarchar(MAX);
    SELECT @columnList = STUFF ( ( SELECT N'], [' + name
                FROM sys.columns
               WHERE [object_id] = (SELECT TOP 1 [object_id] FROM sys.objects WHERE name = @tableName) 
                    AND [system_type_id] NOT IN (SELECT [system_type_id] FROM sys.types WHERE [name] IN ('image', 'ntext', 'text', 'timestamp'))
               ORDER BY column_id
                 FOR XML PATH('')), 1, 2, '') + ']';

    -- Get primary key join clause
    DECLARE @joinClause nvarchar(MAX);
    SELECT @joinClause = STUFF( (SELECT N' AND ' + c.Name + N' = t1.' + c.Name  
      FROM sys.indexes AS i
           INNER JOIN sys.index_columns AS ic ON i.[object_id] = ic.[object_id] AND i.index_id = ic.index_id
           INNER JOIN sys.columns AS c ON ic.[object_id] = c.[object_id] AND c.column_id = ic.column_id
     WHERE i.is_primary_key = 1 AND i.[object_id] = OBJECT_ID(@tableName)
     ORDER BY key_ordinal FOR XML PATH('')), 1, 5, '')

    -- Finally, get the primary key info for the XML header
    DECLARE @primaryKey nvarchar(MAX);
    SELECT @primaryKey = STUFF( (SELECT ', ''' + c.Name + N''' AS ''@PrimaryKey' + CAST(key_ordinal AS nvarchar(3))  + N''''  
      FROM sys.indexes AS i
           INNER JOIN sys.index_columns AS ic ON i.[object_id] = ic.[object_id] AND i.index_id = ic.index_id
           INNER JOIN sys.columns AS c ON ic.[object_id] = c.[object_id] AND c.column_id = ic.column_id
     WHERE i.is_primary_key = 1 AND i.[object_id] = OBJECT_ID(@tableName)
     ORDER BY key_ordinal FOR XML PATH('')), 1, 2, '')

    -- Compute the trigger name, and if it already exists, drop it so we can replace it
    DECLARE @triggerName sysname
    SET @triggerName = N'asiTask_' + @tableName + N'_' + @action
    IF EXISTS (SELECT * FROM sys.triggers WHERE [object_id] = OBJECT_ID(N'[dbo].[' + @triggerName + N']'))
    BEGIN
        EXEC dbo.asi_TaskRemoveTrigger @tableName, @action;
    END
    
    -- Get the proper change type, based on whether this is an Insert, Update, or Delete
    DECLARE @changeTypeId nvarchar(1)
    SELECT @changeTypeId = (SELECT CAST(TaskQueueChangeTypeId AS nvarchar(1)) FROM TaskQueueChangeTypeRef WHERE ChangeTypeName = @action);
    
    -- Get the primary table we're working from here... inserted or deleted
    DECLARE @fromTable sysname;
    SELECT @fromTable = CASE WHEN @action = N'Insert' THEN 'inserted'
                             WHEN @action = N'Update' THEN 'inserted'
                             WHEN @action = N'Delete' THEN 'deleted'
                        END;

    -- Build dynamic SQL to create the trigger
    DECLARE @triggerBody nvarchar(MAX);
    DECLARE @triggerStatement nvarchar(MAX);   

    SET @triggerBody = N'
    -- Declare necessary variables
    DECLARE @now datetime;
    DECLARE @taskKey uniqueidentifier;
    DECLARE @rowInfo xml;
    DECLARE @updateSql nvarchar(MAX);
  
    -- Get necessary data
    SELECT @now = dbo.asi_GetAppDatetime();

    -- Create temp table with INSERTED collection, adding row number and persistent guid key
    IF OBJECT_ID(''tempdb..#asiTaskTemp_' + @tableName + N''') IS NOT NULL
        DROP TABLE #asiTaskTemp_' + @tableName + N'' + N' 
    SELECT ' + @columnList + N' INTO #asiTaskTemp_' + @tableName + N' FROM ' + @fromTable + N' 
    
    IF OBJECT_ID(''tempdb..#asiTaskTemp_Data_' + @tableName + N''') IS NOT NULL
        DROP TABLE #asiTaskTemp_Data_' + @tableName + N'' + N' 
    CREATE TABLE #asiTaskTemp_Data_' + @tableName + N' ([TaskQueueId] bigint, [XmlBlob] xml)    

    -- Finally, insert the data into the TaskQueue tables
    MERGE [dbo].[TaskQueue]
    USING (SELECT (' + N'SELECT ' + @primaryKey + N', 
     ' +
    CASE WHEN @action = N'Insert' THEN
    N' (SELECT ' + @columnList + N' FROM inserted t2 WHERE ' + @joinClause + N' FOR XML PATH (''inserted''), type, ELEMENTS XSINIL) '
         WHEN @action = N'Delete' THEN 
    N' (SELECT ' + @columnList + N' FROM deleted t2 WHERE ' + @joinClause + N' FOR XML PATH (''deleted''), type, ELEMENTS XSINIL) '
         WHEN @action = N'Update' THEN 
    N' (SELECT ' + @columnList + N' FROM deleted t2 WHERE ' + @joinClause + N' FOR XML PATH (''deleted''), type, ELEMENTS XSINIL), 
       (SELECT ' + @columnList + N' FROM inserted t2 WHERE ' + @joinClause + N' FOR XML PATH (''inserted''), type, ELEMENTS XSINIL) '
    END + N'
         FOR XML PATH (''' + @tableName + N'''), ELEMENTS XSINIL) AS [XmlBlob]
         FROM #asiTaskTemp_' + @tableName + N' t1) AS src ON (1 = 0)
    WHEN NOT MATCHED THEN
        INSERT ([TaskQueueTypeId], [RequestedOn])
        VALUES (2, @now)
        OUTPUT inserted.[TaskQueueId], src.[XmlBlob]
        INTO #asiTaskTemp_Data_' + @tableName + ';

    INSERT INTO [dbo].[TaskQueueTriggerDetail] ([TaskQueueId], [TaskQueueStatusId], [StatusUpdatedOn], [ChangeRow], [TaskQueueChangeTypeId])
        SELECT TaskQueueId, 1, @now, XmlBlob, CAST(' + @changeTypeId + N' AS INT) FROM #asiTaskTemp_Data_' + @tableName + N';
                                                 
    -- Drop the temp tables
    IF OBJECT_ID(''tempdb..#asiTaskTemp_Data_' + @tableName + N''') IS NOT NULL
        DROP TABLE #asiTaskTemp_Data_' + @tableName + N'' + N' 
    
    IF OBJECT_ID(''tempdb..#asiTaskTemp_' + @tableName + N''') IS NOT NULL
        DROP TABLE #asiTaskTemp_' + @tableName + N'; 
    '          
                     
    SET @triggerStatement = N'
    CREATE TRIGGER [dbo].[' + @triggerName + N']
    ON [dbo].[' + @tableName + N']
    AFTER ' + UPPER(@action) + N'
    AS
    BEGIN
      ' + @triggerBody + N'
    END                
    '
       
    EXECUTE sp_executesql @triggerStatement
                             
END 


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TaskRecreateTriggers]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TaskRecreateTriggers]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


-- Remove a specified task trigger 
CREATE PROCEDURE [dbo].[asi_TaskRecreateTriggers]
AS
BEGIN

    SET NOCOUNT ON;

    -- Grab all the trigger info we have
    DECLARE @taskTriggers TABLE([TableName] sysname, [Action] nvarchar(10));
    INSERT INTO @taskTriggers
        SELECT OBJECT_NAME(parent_object_id) AS [TableName],
               CASE WHEN OBJECTPROPERTY([object_id], 'ExecIsUpdateTrigger') = 1 THEN N'Update'
                    WHEN OBJECTPROPERTY([object_id], 'ExecIsDeleteTrigger') = 1 THEN N'Delete'
                    WHEN OBJECTPROPERTY([object_id], 'ExecIsInsertTrigger') = 1 THEN N'Insert'
                    ELSE NULL END AS [Action]
          FROM sys.objects 
         WHERE type = 'TR' AND OBJECT_NAME([object_id]) LIKE N'asiTask_%'
    
    -- Declare a cursor to loop through all the tables
    DECLARE @tableName sysname;
    DECLARE @action nvarchar(10);
    DECLARE theCursor CURSOR LOCAL
        FOR SELECT [TableName],
                   [Action]
              FROM @taskTriggers
             WHERE [Action] IS NOT NULL;
    OPEN theCursor;
    FETCH NEXT FROM theCursor INTO @tableName, @action;

    -- Call the remove/create stored procedures for each trigger found
    WHILE @@FETCH_STATUS = 0
    BEGIN
        EXEC [dbo].[asi_TaskRemoveTrigger] @tableName, @action
        EXEC [dbo].[asi_TaskCreateTrigger] @tableName, @action

        FETCH NEXT FROM theCursor INTO @tableName, @action;
    END;

    CLOSE theCursor;
    DEALLOCATE theCursor;    
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEValidateCultureExists]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEValidateCultureExists]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:      <Author,,Name>
-- Create date: <Create Date,,>
-- Description: <Description,,>
-- version 1.0
-- =============================================
CREATE procedure [dbo].[asi_TEValidateCultureExists]
    @LocalizationCultureId nvarchar(50)
AS
BEGIN 
    SET NOCOUNT ON

    DECLARE @ncount int
    DECLARE @ret_value  int
    DECLARE @error_code  int

    SET @error_code = 0

    SELECT @ncount = COUNT(1) 
      FROM [dbo].[LocalizationCulture]
     WHERE [LocalizationCultureId] = @LocalizationCultureId

    IF @ncount = 0 
    BEGIN
        SET @error_code = -25
        GOTO error_handler
    END


    error_handler:
    SET @ret_value = @error_code

    endit:
    RETURN  @ret_value

    SET NOCOUNT OFF
    END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEValidateStatusExists]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEValidateStatusExists]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:      <Author,,Name>
-- Create date: <Create Date,,>
-- Description: <Description,,>
-- version 1.0
-- =============================================
CREATE PROCEDURE [dbo].[asi_TEValidateStatusExists]
(
    @Status nvarchar(5)
)
AS
BEGIN 
    SET NOCOUNT ON

    DECLARE @ncount int
    DECLARE @ret_value  int
    DECLARE @error_code  int

    SET @error_code = 0

    SELECT @ncount = COUNT(1) 
      FROM [dbo].[LocalizationLookup]
     WHERE [LocalizationLookup] = 'STATUS' AND [LocalizationCode] = @Status

    IF @ncount = 0 
    BEGIN
        SET @error_code = -25
        GOTO error_handler
    END


    error_handler:
    SET @ret_value = @error_code

    endit:
    RETURN  @ret_value

    SET NOCOUNT OFF
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEValidateUpdateSourceExists]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEValidateUpdateSourceExists]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:      <Author,,Name>
-- Create date: <Create Date,,>
-- Description: <Description,,>
-- version 1.0
-- =============================================
CREATE PROCEDURE [dbo].[asi_TEValidateUpdateSourceExists]
(
    @UpdateSource nvarchar(250)
)
AS
BEGIN 
    SET NOCOUNT ON

    DECLARE @ncount int
    DECLARE @ret_value  int
    DECLARE @error_code  int

    SET @error_code = 0

    SELECT @ncount = COUNT(1) 
      FROM [dbo].[LocalizationLookup] 
     WHERE [LocalizationLookup] = 'SOURCE' AND [LocalizationCode] = @UpdateSource

    IF @ncount = 0 
    BEGIN
        SELECT @ncount = COUNT(1) 
          FROM [dbo].[Name]
         WHERE [ID] = @UpdateSource

        IF @ncount = 0
        BEGIN
            SET @error_code = -22
            GOTO error_handler
        END
    END

    error_handler:
    SET @ret_value = @error_code

    endit:
    RETURN  @ret_value

    SET NOCOUNT OFF
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEValidateVersionIdExists]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEValidateVersionIdExists]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:        <Author,,Name>
-- Create date: <Create Date,,>
-- Description:   <Description,,>
-- version 1.0
-- =============================================
CREATE PROCEDURE [dbo].[asi_TEValidateVersionIdExists]
    @LocalizationVersionId uniqueidentifier,
    @CheckEmpty bit = 1
AS
BEGIN 
    SET NOCOUNT ON

    DECLARE @ncount int
    DECLARE @ret_value  int
    DECLARE @error_code  int

    SET @error_code = 0

    SELECT @ncount = COUNT(1)
      FROM [dbo].[LocalizationVersion]
    WHERE [LocalizationVersionId] = @LocalizationVersionId

    -- check that the versionid exists before insert
    IF @ncount <> 1
    BEGIN
        SET @error_code = -21
        GOTO error_handler
    END
         
    IF @CheckEmpty = 1 
    BEGIN     
        -- version being inserted, count should be zero or will get duplicate error, check before insert that verion empty
        SELECT @ncount = COUNT(1)
          FROM [dbo].[LocalizationVersionPhrase] as p1
         WHERE LocalizationVersionId = @LocalizationVersionId
           AND EXISTS (SELECT 1 FROM [LocalizationVersionPhrase] p2
                        WHERE p2.[LocalizationPhraseTranslatedId] = p1.[LocalizationPhraseTranslatedId]
                       )

        IF @ncount > 0
        BEGIN
            SET @error_code = -22
            GOTO error_handler
        END
    END     
         
    error_handler:
    SET @ret_value = @error_code

    endit:
    RETURN  @ret_value

    SET NOCOUNT OFF

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionCopyVersion]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionCopyVersion]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_TEVersionCopyVersion]
(
    @LocalizationVersionIdFrom uniqueidentifier,
    @LocalizationVersionIdTo uniqueidentifier,
    @CreatedBy nvarchar(250)
)
AS
BEGIN 
 -- 09/01/2013 - added [DoNotLocalize], [ControlType], [Description]

    SET NOCOUNT ON

    DECLARE @ncount int
    DECLARE @ret_value  int
    DECLARE @error_code  int

    SET @error_code = 0

    SELECT @ncount = COUNT(1)
      FROM [dbo].[LocalizationVersion]
     WHERE [LocalizationVersionId] = @LocalizationVersionIdFrom

    -- check that the versionid exists before insert
    IF @ncount <> 1
    BEGIN
        SET @error_code = -21
        GOTO error_handler
    END

    SELECT @ncount = COUNT(1)
      FROM [dbo].[LocalizationVersion]
     WHERE [LocalizationVersionId] = @LocalizationVersionIdTo

    -- check that the versionid exists before insert
    IF @ncount <> 1
    BEGIN
        SET @error_code = -22
        GOTO error_handler
    END

    -- version being inserted, count should be zero or will get duplicate error, check before insert
    SELECT @ncount = COUNT(1)
      FROM [dbo].[LocalizationVersionPhrase] AS p1
     WHERE [LocalizationVersionId] = @LocalizationVersionIdTo
       AND EXISTS (SELECT 1 FROM [LocalizationVersionPhrase] p2
                    WHERE p2.[LocalizationPhraseTranslatedId] = p1.[LocalizationPhraseTranslatedId]
                   )

    IF @ncount > 0
    BEGIN
        SET @error_code = -23
        GOTO error_handler
    END

    BEGIN TRY
        --********** create version copying of exisitng version - Spanish 1 Version
        --********** created Spanish 2 Version
        -- created PK/FK with [LocalizationVersion] on [LocalizationVersionId]
        INSERT INTO [dbo].[LocalizationVersionPhrase] ([LocalizationVersionPhraseId], [LocalizationVersionId], 
                                                       [LocalizationPhraseTranslatedId], [Phrase], [TranslatedPhrase], 
                                                       [DateCreated], [CreatedBy], [DateUpdated], [UpdatedBy], [LocalizationPhraseId],
                                                       [DoNotLocalize], [ControlType], [Description])

            SELECT NEWID(), @LocalizationVersionIdTo, 
                   [LocalizationPhraseTranslatedId], [Phrase], [TranslatedPhrase], 
                   GETDATE(), @CreatedBy, GETDATE(), @CreatedBy, [LocalizationPhraseId],
                   [DoNotLocalize], [ControlType], [Description]
              FROM [dbo].[LocalizationVersionPhrase]
             WHERE [LocalizationVersionId] = @LocalizationVersionIdFrom 
    END TRY
    BEGIN CATCH
        SET @error_code = @@error
    END CATCH

    --goto endit

    error_handler:
    SET @ret_value = @error_code

    endit:
    RETURN  @ret_value
    --select @ret_value

    SET NOCOUNT OFF

END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionCopyVersionOriginal]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionCopyVersionOriginal]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_TEVersionCopyVersionOriginal]
(
@CultureID nvarchar(50),
@LocalizationVersionIdTo uniqueidentifier,
@CreatedBy nvarchar(250)
)
AS
BEGIN
    -- 09/01/2013 - added [DoNotLocalize], [ControlType]

    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON;

    DECLARE @ncount int;
    DECLARE @ret_value  int;
    DECLARE @error_code  int;

    SET @error_code = 0;

    SELECT @ncount = COUNT(*)
      FROM [dbo].[LocalizationVersion]
     WHERE [LocalizationVersionId] = @LocalizationVersionIdTo;

    -- check that the versionid exists before insert
    IF @ncount <> 1
        BEGIN
            SET @error_code = -22;
            GOTO error_handler;
        END;

    -- version being inserted, count should be zero or will get duplicate error, check before insert
    SELECT @ncount = COUNT(*)
      FROM [dbo].[LocalizationVersionPhrase] AS p1
     WHERE LocalizationVersionId = @LocalizationVersionIdTo AND EXISTS (SELECT 1
                                                                          FROM [LocalizationVersionPhrase] AS p2
                                                                         WHERE p2.[LocalizationPhraseTranslatedId] = p1.[LocalizationPhraseTranslatedId]
           );

    IF @ncount > 0
        BEGIN
            SET @error_code = -23;
            GOTO error_handler;
        END;

    BEGIN TRY

        IF EXISTS (SELECT TOP 1 *
                     FROM [dbo].[LocalizationPhraseTranslated]
                    WHERE LocalizationCultureId = @CultureID)
            BEGIN
                -- created PK/FK with [LocalizationVersion] on [LocalizationVersionId]
                INSERT INTO [dbo].[LocalizationVersionPhrase] ([LocalizationVersionPhraseId],
                                                               [LocalizationVersionId],
                                                               [LocalizationPhraseTranslatedId],
                                                               [Phrase],
                                                               [TranslatedPhrase],
                                                               [DateCreated],
                                                               [CreatedBy],
                                                               [DateUpdated],
                                                               [UpdatedBy],
                                                               [LocalizationPhraseId],
                                                               [DoNotLocalize],
                                                               [ControlType])

                SELECT NEWID(),
                       @LocalizationVersionIdTo,
                       lpt.LocalizationPhraseTranslatedId,
                       lp.Phrase,
                       lpt.TranslatedPhrase,
                       GETDATE(),
                       @CreatedBy,
                       GETDATE(),
                       @CreatedBy,
                       lp.LocalizationPhraseId,
                       DoNotLocalize,
                       ControlType
                  FROM [dbo].[LocalizationPhraseTranslated] AS lpt
                       LEFT OUTER JOIN LocalizationPhrase AS lp ON lp.LocalizationPhraseId = lpt.LocalizationPhraseId
                 WHERE lpt.LocalizationCultureId = @CultureID;
            END;
        ELSE
            BEGIN
                INSERT INTO [dbo].[LocalizationVersionPhrase] ([LocalizationVersionPhraseId],
                                                               [LocalizationVersionId],
                                                               [Phrase],
                                                               [DateCreated],
                                                               [CreatedBy],
                                                               [DateUpdated],
                                                               [UpdatedBy],
                                                               [LocalizationPhraseId],
                                                               [DoNotLocalize],
                                                               [ControlType])

                SELECT NEWID(),
                       @LocalizationVersionIdTo,
                       lp.Phrase,
                       GETDATE(),
                       @CreatedBy,
                       GETDATE(),
                       @CreatedBy,
                       lp.LocalizationPhraseId,
                       lp.DoNotLocalize,
                       lp.ControlType
                  FROM [dbo].[LocalizationPhrase] AS lp;
            END;

    END TRY
    BEGIN CATCH

        SET @error_code = @@error;

    END CATCH;

    --goto endit

    error_handler:
    SET @ret_value = @error_code;

    endit:
    RETURN  @ret_value;
    --select @ret_value

    SET NOCOUNT OFF;
END;


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionCreate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionCreate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:        <Author,,Name>
-- Create date: <Create Date,,>
-- Description:   <Description,,>
-- version 1.0
-- =============================================
CREATE PROCEDURE [dbo].[asi_TEVersionCreate]
(
    @LocalizationVersionId [uniqueidentifier] output,
    @Name nvarchar(250),
    @Description nvarchar(400),
    @Note nvarchar(400),
    @CreatedBy nvarchar(250),
    @UpdatedBy nvarchar(250),
    @CultureId nvarchar(50),
    @Status nvarchar(5)
)
AS
BEGIN 
    SET NOCOUNT ON

    DECLARE @ncount int
    DECLARE @ret_value  int
    DECLARE @error_code  int

    SET @error_code = 0

    SELECT @ncount = COUNT(1)
      FROM [dbo].[LocalizationVersion] as p1
     WHERE LocalizationVersionName = @Name

    IF @ncount > 0
    BEGIN
        SET @error_code = -21
        GOTO error_handler
    END

    SET @LocalizationVersionId = NEWID()

    BEGIN TRY
        -- created PK/FK with [LocalizationCulture] on [CultureId] - de, es, ar - FK error if not valid entry on PK table
        INSERT INTO [dbo].[LocalizationVersion] ([LocalizationVersionId], [LocalizationVersionName], [LocalizationVersionDesc], [Note], 
                                                 [DateCreated], [CreatedBy], [DateUpdated], [UpdatedBy], 
                                                 [CultureId], ActiveVersion, ActiveVersionLoaded, StatusID)
            SELECT @LocalizationVersionId, @Name, @Description, @Note, 
                   GETDATE(), @CreatedBy,  GETDATE(), @UpdatedBy,  
                   @CultureId, 0, null, @Status 
    END TRY
    BEGIN CATCH
        SET @error_code = @@error

        --if @@error <> 0
        --          begin
        --          set @error_code = @@error
        --          goto error_handler
        --          end
    END CATCH

    --if @inv_num = 0 
    --         goto error_handler

    --if @@error <> 0
    --         begin
    --         set @error_hold = @@error
    --         goto error_handler
    --         end

    --goto endit

    error_handler:
    SET @ret_value = @error_code

    endit:
    RETURN  @ret_value
    --select @ret_value

    SET NOCOUNT OFF

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionCultureCreate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionCultureCreate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_TEVersionCultureCreate]
(
    @CultureID nvarchar(50),
    @Name nvarchar(50),
    @DisplayName nvarchar(50)
)
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @ncount int
    DECLARE @ret_value  int
    DECLARE @error_code  int

    SET @error_code = 0

    SELECT @ncount = COUNT(*)
      FROM [dbo].[LocalizationVersion] as p1
     WHERE LocalizationVersionName  = @Name

    IF @ncount > 0
    BEGIN
        SET @error_code = -21
        GOTO error_handler
    END

    BEGIN TRY
    -- created PK/FK with [LocalizationCulture] on [CultureId] - de, es, ar - FK error if not valid entry on PK table
        INSERT INTO [dbo].[LocalizationCulture] ([LocalizationCultureId], [LocalizationCultureName], [LocalizationCultureDisplayName])
        VALUES (@CultureID, @Name, @DisplayName)
    END TRY
    BEGIN CATCH
        SET @error_code = @@error
    END CATCH

    error_handler:
    SET @ret_value = @error_code

    endit:
    RETURN  @ret_value
    --select @ret_value

    SET NOCOUNT OFF
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionCultureDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionCultureDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:      <Author,,Name>
-- Create date: <Create Date,,>
-- Description: <Description,,>
-- version 1.0
-- =============================================
CREATE PROCEDURE [dbo].[asi_TEVersionCultureDelete]
(
    @CultureID nvarchar(50)
)
AS
BEGIN
    SET NOCOUNT ON;

    --DECLARE @LocalizationPhraseTranslatedId UNIQUEIDENTIFIER
    DECLARE @ncount int
    DECLARE @ret_value  int
    DECLARE @error_code  int

    SET @error_code = 0

    SELECT @ncount = COUNT(1)
      FROM [dbo].[LocalizationCulture]
     WHERE [LocalizationCultureId] = @CultureID

    -- check that the versionid exists before insert
    IF @ncount <> 1
    BEGIN
        SET @error_code = -21
        GOTO error_handler
    END

    BEGIN TRY
        BEGIN TRANSACTION
        -- DELETE ALL VERSION TRANSLATED PHRASES
        DELETE FROM [dbo].[LocalizationVersionPhrase]
         WHERE [LocalizationVersionId] IN (SELECT [LocalizationVersionId] FROM [LocalizationVersion] WHERE [CultureId] = @CultureID)

        -- DELETE ALL TRANSLATED PHRASES
        DELETE FROM [dbo].[LocalizationPhraseTranslated]
         WHERE [LocalizationCultureId] = @CultureID 

        -- DELETE ALL VERSIONS FOR THIS CULTURE ID
        DELETE FROM [dbo].[LocalizationVersion] 
         WHERE [CultureId] = @CultureID

        -- FINALLY, DELETE CULTURE
        DELETE FROM [dbo].[LocalizationCulture]
         WHERE [LocalizationCultureId] = @CultureID

        COMMIT TRANSACTION
    END TRY
    BEGIN CATCH
        ROLLBACK TRANSACTION
        SET @error_code = @@error
    END CATCH

    --goto endit

    error_handler:
    SET @ret_value = @error_code

    endit:
    RETURN  @ret_value
    --select @ret_value

    SET NOCOUNT OFF
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionCultureUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionCultureUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_TEVersionCultureUpdate]
(
    @LocalizationCultureId nvarchar(50),
    @Name nvarchar(50),
    @DisplayName nvarchar(50)
)
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @ncount int
    DECLARE @ret_value  int
    DECLARE @error_code  int

    SET @error_code = 0

    SELECT @ncount = COUNT(*) FROM LocalizationCulture AS p1
    WHERE [LocalizationCultureId] = @LocalizationCultureId

    IF @ncount <> 1
    BEGIN
        SET @error_code = -21
        GOTO error_handler
    END

    BEGIN TRY
        UPDATE [LocalizationCulture] 
           SET [LocalizationCultureName] = @Name, 
               [LocalizationCultureDisplayName] = @DisplayName
         WHERE [LocalizationCultureId] = @LocalizationCultureId

        IF @@ROWCOUNT <> 1
        BEGIN
            SET @error_code = -22
            GOTO error_handler
        END

    END TRY
    BEGIN CATCH
        SET @error_code = @@error
    END CATCH

    --goto endit
    error_handler:
    SET @ret_value = @error_code

    endit:
    RETURN  @ret_value
    --select @ret_value

    SET NOCOUNT off
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionDeactivate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionDeactivate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:      <Author,,Name>
-- Create date: <Create Date,,>
-- Description: <Description,,>
-- version 1.1
-- =============================================
CREATE PROCEDURE [dbo].[asi_TEVersionDeactivate]
(
    @CultureID nvarchar(50),
    @UpdatedBy nvarchar(250)
)
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON;

    DECLARE @ncount int
    DECLARE @ret_value  int
    DECLARE @error_code  int

    SET @error_code = 0

    --SELECT @ncount = COUNT(*)
    --FROM [LocalizationVersion]
    --WHERE LocalizationVersionId =  @LocalizationVersionId

    ---- check that the versionid exists before update
    --IF @ncount <> 1
    --BEGIN
    --    SET @error_code = -21
    --    GOTO error_handler
    --END


    BEGIN TRY
        BEGIN TRANSACTION

        -- 1) DEACTIVATE ACTIVE Version if exists
        UPDATE [dbo].[LocalizationVersion]
           SET ActiveVersion = 0, 
               ActiveVersionLoaded = NULL,
               DateUpdated = GETDATE(), 
               UpdatedBy = @UpdatedBy
         WHERE ActiveVersion = 1 AND CultureId = @CultureID

        -- 2) SET NULL TO field LocalizationTranslatedPhraseId for ALL RECORDS IN LocalizationVersionPhrase table for this culture ID
        --    this required because of foreign key in the table and all phrases in translated table for this culture would be deleted

        --UPDATE lvp    -- turned off, not required
        --    SET lvp.LocalizationPhraseTranslatedId = NULL
        --FROM LocalizationVersionPhrase as lvp
        --LEFT OUTER JOIN LocalizationVersion AS lv ON lv.LocalizationVersionId = lvp.LocalizationVersionId
        --WHERE lv.CultureId = @CultureID

        -- 3) DELETING ALL RECORDS IN Translated table for this Culture ID

        --DELETE FROM LocalizationPhraseTranslated  -- turned off, not required
        --WHERE LocalizationCultureId = @CultureID

        COMMIT TRANSACTION

    END TRY
    BEGIN CATCH
        ROLLBACK TRANSACTION
        SET @error_code = @@error
    END CATCH

    --goto endit

    error_handler:
    SET @ret_value = @error_code

    endit:
    RETURN  @ret_value
    --select @ret_value

    SET NOCOUNT OFF
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:      <Author,,Name>
-- Create date: <Create Date,,>
-- Description: <Description,,>
-- version 1.0
-- =============================================
CREATE PROCEDURE [dbo].[asi_TEVersionDelete]
(
    @LocalizationVersionId uniqueidentifier
)
AS
BEGIN 
    SET NOCOUNT ON

    DECLARE @ncount int
    DECLARE @ret_value  int
    DECLARE @error_code  int

    SET @error_code = 0

    SELECT @ncount = COUNT(1)
      FROM [dbo].[LocalizationVersion]
     WHERE [LocalizationVersionId] =  @LocalizationVersionId

    -- check that the versionid exists before insert
    IF @ncount <> 1
    BEGIN
        SET @error_code = -21
        GOTO error_handler
    END

    BEGIN TRY
        BEGIN TRANSACTION
        DELETE FROM [dbo].[LocalizationVersionPhrase] 
        WHERE [LocalizationVersionId] = @LocalizationVersionId 

        DELETE FROM [dbo].[LocalizationVersion] 
         WHERE [LocalizationVersionId] = @LocalizationVersionId 

        COMMIT TRANSACTION
    END TRY
    BEGIN CATCH
        ROLLBACK TRANSACTION
        SET @error_code = @@error
    END CATCH

    --goto endit

    error_handler:
    SET @ret_value = @error_code

    endit:
    RETURN  @ret_value
    --select @ret_value

    SET NOCOUNT OFF
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionGetCulture]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionGetCulture]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author: <Author,,Name>
-- Create date: <Create Date,,>
-- Description: <Description,,>
-- version 1.0
-- =============================================
CREATE PROCEDURE [dbo].[asi_TEVersionGetCulture]
(
    @cultureID nvarchar(50)
)
AS
BEGIN
    SET NOCOUNT ON;

    SELECT lc.LocalizationCultureId AS [CultureId],
           lc.LocalizationCultureName AS [CultureName],
           (SELECT COUNT(1) 
              FROM dbo.LocalizationVersion 
             WHERE CultureId = lc.LocalizationCultureId
            ) AS [Versions],
           ISNULL(lv.LocalizationVersionName,'')            AS [ActiveVersion]
      FROM [dbo].[LocalizationCulture] AS lc
           LEFT JOIN dbo.LocalizationVersion AS lv ON lv.CultureId = lc.LocalizationCultureId AND lv.ActiveVersion = 1
     WHERE lc.LocalizationCultureId = @cultureID
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionGetCultures]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionGetCultures]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_TEVersionGetCultures]
AS
BEGIN
    SET NOCOUNT ON;

    SELECT lc.LocalizationCultureId AS [CultureId],
           lc.LocalizationCultureName AS [CultureName],
           lc.LocalizationCultureDisplayName AS [DisplayName],
           (SELECT COUNT(1) 
              FROM dbo.LocalizationVersion 
             WHERE CultureId = lc.LocalizationCultureId
            ) AS [Versions],
           ISNULL(lv.LocalizationVersionName,'') AS [ActiveVersion]
    FROM [dbo].[LocalizationCulture] AS lc
         LEFT JOIN dbo.LocalizationVersion AS lv ON lv.CultureId = lc.LocalizationCultureId AND lv.ActiveVersion = 1

END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionGetCulturesNew]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionGetCulturesNew]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:      <Author,,Name>
-- Create date: <Create Date,,>
-- Description: <Description,,>
-- Get cultures from LocalizationPhraseTranslated table 
-- which would be used in Culture table for new created records
-- version 1.0
-- =============================================
CREATE PROCEDURE [dbo].[asi_TEVersionGetCulturesNew]
AS
BEGIN
    SET NOCOUNT ON;

    SELECT [CultureID] 
      FROM (SELECT DISTINCT(LocalizationCultureId) AS [CultureID] 
              FROM LocalizationPhraseTranslated) AS lpt
     WHERE lpt.CultureID NOT IN (SELECT [LocalizationCultureId] FROM LocalizationCulture)
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionGetCultureVersions]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionGetCultureVersions]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:      <Author,,Name>
-- Create date: <Create Date,,>
-- Description: <Description,,>
-- version 1.0
-- =============================================
CREATE PROCEDURE [dbo].[asi_TEVersionGetCultureVersions]
(
    @CultureID nvarchar(50)
)
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON;

    SELECT lv.[LocalizationVersionId] AS [LocalizationVersionId],
           lv.[LocalizationVersionName] AS [LocalizationVersionName],
           lv.[LocalizationVersionDesc] AS [LocalizationVersionDesc],
           lv.[Note] AS [Note],
           lv.[DateCreated] AS [DateCreated],
           lv.[CreatedBy] AS [CreatedBy],
           lv.[DateUpdated] AS [DateUpdated],
           lv.[UpdatedBy] AS [UpdatedBy],
           lv.[CultureId] AS [CultureId],
           lv.[ActiveVersion] AS [ActiveVersion],
           lv.[ActiveVersionLoaded] AS [ActiveVersionLoaded],
           lv.[StatusID] AS [StatusID],
           lc.[LocalizationCultureName] AS [CultureName], 
           ls.[LocalizationDesc] AS [StatusName],
           (SELECT COUNT(1) FROM [dbo].[LocalizationVersionPhrase] WHERE [LocalizationVersionId] = lv.LocalizationVersionId
            ) AS [Phrases]
      FROM [dbo].[LocalizationVersion] AS lv
           LEFT OUTER JOIN LocalizationCulture AS lc ON lv.CultureId = lc.LocalizationCultureId 
           LEFT OUTER JOIN LocalizationLookup  AS ls ON ls.LocalizationCode = lv.StatusID AND ls.[LocalizationLookup] = 'SOURCE'
     WHERE lv.CultureId = @CultureID

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionGetLookup]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionGetLookup]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:      <Author,,Name>
-- Create date: <Create Date,,>
-- Description: <Description,,>
-- version 1.1
-- =============================================
CREATE PROCEDURE [dbo].[asi_TEVersionGetLookup] 
(
    @lookupType nvarchar(50)
)
AS
BEGIN
    SET NOCOUNT ON;

    SELECT [LocalizationLookup],
           [LocalizationCode],
           [LocalizationDesc],
           [IsActive]
      FROM [dbo].[LocalizationLookup]
     WHERE [LocalizationLookup] = @lookupType
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionGetTransferPhrases]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionGetTransferPhrases]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_TEVersionGetTransferPhrases]
AS
BEGIN
-- 09/01/2013 - added [DoNotLocalize] and [VersionPhraseTransferDesc]
    SET NOCOUNT ON;

    SELECT [LocalizationVersionPhraseId],
           [Phrase],
           [TranslatedPhrase],
           [Result],
           [DoNotLocalize],
           [VersionPhraseTransferDesc]
      FROM [dbo].[LocalizationVersionPhraseTransfer]
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionGetVersion]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionGetVersion]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:        <Author,,Name>
-- Create date: <Create Date,,>
-- Description:   <Description,,>
-- version 1.1
-- =============================================
CREATE PROCEDURE [dbo].[asi_TEVersionGetVersion] 
(
    @LocalizationVersionId uniqueidentifier
)
AS
BEGIN
    SET NOCOUNT ON;

    SELECT [LocalizationVersionId],
           [LocalizationVersionName],
           [LocalizationVersionDesc],
           [Note],
           [DateCreated],
           [CreatedBy],
          [DateUpdated],
           [UpdatedBy],
           [CultureId],
           [ActiveVersion],
           [ActiveVersionLoaded],
           [StatusID],
           (SELECT COUNT(1) FROM [dbo].[LocalizationVersionPhrase] WHERE LocalizationVersionId = LocalizationVersion.LocalizationVersionId
            ) AS [Phrases]
      FROM [dbo].[LocalizationVersion]
     WHERE [LocalizationVersionId] = @LocalizationVersionId

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionGetVersionPhrases]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionGetVersionPhrases]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_TEVersionGetVersionPhrases]
(
    @LocalizationVersionId uniqueidentifier
)
AS
BEGIN
    SET NOCOUNT ON;
-- 09/01/2013 - added [DoNotLocalize], [Description] and [ControlType]
    SELECT [LocalizationVersionPhraseId],
           [LocalizationVersionId],
           [LocalizationPhraseTranslatedId],
           [LocalizationPhraseId],
           [Phrase],
           [TranslatedPhrase],
           [DateCreated],
           [CreatedBy],
           [DateUpdated],
           [UpdatedBy],
               [DoNotLocalize],
               [Description],          
               [ControlType]                      
      FROM [dbo].[LocalizationVersionPhrase]
     WHERE [LocalizationVersionId] = @LocalizationVersionId
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionGetVersionPhrasesLiveCount]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionGetVersionPhrasesLiveCount]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:      <Author,,Name>
-- Create date: <Create Date,,>
-- Description: <Description,,>
-- version 1.0
-- =============================================
CREATE PROCEDURE [dbo].[asi_TEVersionGetVersionPhrasesLiveCount]
(
    @LocalizationCultureId nvarchar(50)
)
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @retValue INT

    SELECT @retValue = COUNT(1) 
      FROM [dbo].[LocalizationPhraseTranslated]
     WHERE [LocalizationCultureId] = @LocalizationCultureId

    RETURN @retValue
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionGetVersionPhrasesPage]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionGetVersionPhrasesPage]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_TEVersionGetVersionPhrasesPage]
(
    @LocalizationVersionId uniqueidentifier,
    @PageSize int = NULL,
    @CurrentPage int = NULL,
    @Search nvarchar(250),
    @ShowAll bit = 1
)
AS
BEGIN
    SET NOCOUNT ON;


    DECLARE @UpperBand int
    DECLARE @LowerBand int        

    SET @LowerBand  = (@CurrentPage - 1) * @PageSize
    SET @UpperBand  = (@CurrentPage * @PageSize) + 1

    IF (@Search<>'')
    BEGIN
    -- 09/01/2013 - added [DoNotLocalize], [ControlType] and [Description] to selects
        WITH tempPhrases AS (  
            SELECT [LocalizationVersionPhraseId],
                   [LocalizationVersionId],
                   [LocalizationPhraseTranslatedId],
                   [LocalizationPhraseId],
                   [Phrase],
                   [TranslatedPhrase],
                   [DateCreated],
                   [CreatedBy],
                   [DateUpdated],
                   [UpdatedBy],
                   [Status],
                   [DoNotLocalize],
                   [Description],
                   [ControlType],
                   ROW_NUMBER() OVER (ORDER BY [Phrase] ASC ) AS [RowNumber]
              FROM [dbo].[LocalizationVersionPhrase]
             WHERE [LocalizationVersionId] = @LocalizationVersionId
               AND ([Phrase] LIKE ('%' + @Search + '%') OR [TranslatedPhrase] LIKE ('%' + @Search + '%'))
               AND (@ShowAll = 1 OR [Status] = 'N')
        ) 
        SELECT [LocalizationVersionPhraseId], [LocalizationVersionId], [LocalizationPhraseTranslatedId],
               [LocalizationPhraseId], [Phrase], [TranslatedPhrase], [DateCreated], [CreatedBy],
               [DateUpdated], [UpdatedBy], [Status], [DoNotLocalize], [Description], [ControlType], [RowNumber]
          FROM tempPhrases 
         WHERE RowNumber > @LowerBand AND RowNumber <= @UpperBand
    END
    ELSE
    BEGIN
        WITH tempPhrases AS (  
        SELECT [LocalizationVersionPhraseId],
               [LocalizationVersionId],
               [LocalizationPhraseTranslatedId],
               [LocalizationPhraseId],
               [Phrase],
               [TranslatedPhrase],
               [DateCreated],
               [CreatedBy],
               [DateUpdated],
               [UpdatedBy],
               [Status],
               [DoNotLocalize],
               [Description],
               [ControlType],
               ROW_NUMBER() OVER (ORDER BY [Phrase] ASC ) AS [RowNumber]
          FROM [LocalizationVersionPhrase]
         WHERE [LocalizationVersionId] = @LocalizationVersionId
           AND (@ShowAll = 1 OR [Status] = 'N')
        ) 
        SELECT [LocalizationVersionPhraseId], [LocalizationVersionId], [LocalizationPhraseTranslatedId],
               [LocalizationPhraseId], [Phrase], [TranslatedPhrase], [DateCreated], [CreatedBy],
               [DateUpdated], [UpdatedBy], [Status], [DoNotLocalize], [Description], [ControlType], [RowNumber] 
          FROM tempPhrases 
         WHERE RowNumber > @LowerBand AND RowNumber <= @UpperBand
    END
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionGetVersionPhrasesPageCount]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionGetVersionPhrasesPageCount]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:      <Author,,Name>
-- Create date: <Create Date,,>
-- Description: <Description,,>
-- version 1.1
-- =============================================
CREATE PROCEDURE [dbo].[asi_TEVersionGetVersionPhrasesPageCount]
(
    @LocalizationVersionId uniqueidentifier,
    @Search nvarchar(250),
    @ShowAll bit = 1
)
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @RET_VALUE INT

    IF (@Search<>'')
    BEGIN
        SELECT @RET_VALUE = COUNT(1) 
          FROM [dbo].[LocalizationVersionPhrase]
         WHERE [LocalizationVersionId] = @LocalizationVersionId
           AND ([Phrase] LIKE ('%' + @Search + '%') OR [TranslatedPhrase] LIKE ('%' + @Search + '%'))
           AND (@ShowAll = 1 OR [Status] = 'N')
    END
    ELSE
    BEGIN
        SELECT @RET_VALUE = COUNT(1) 
          FROM [dbo].[LocalizationVersionPhrase]
         WHERE [LocalizationVersionId] = @LocalizationVersionId
           AND (@ShowAll = 1 OR [Status] = 'N')
    END

    RETURN @RET_VALUE
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionRefeshNew]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionRefeshNew]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO



CREATE PROCEDURE [dbo].[asi_TEVersionRefeshNew]
(
    @CultureID nvarchar(50),
    @LocalizationVersionId uniqueidentifier,
    @UpdatedBy nvarchar(250)
)
AS
BEGIN
    SET NOCOUNT ON;


    -- First, update any nulls in the LocalizationVersionPhrase table 
    -- (some imported phrases may not have LocalizationPhraseTranslatedId populated yet)
    UPDATE lvp
       SET lvp.[LocalizationPhraseTranslatedId] = lpt.[LocalizationPhraseTranslatedId]
      FROM [dbo].[LocalizationVersionPhrase] AS lvp INNER JOIN [dbo].[LocalizationPhraseTranslated] AS lpt 
        ON lvp.[LocalizationPhraseId] = lpt.[LocalizationPhraseId]
           INNER JOIN [dbo].[LocalizationVersion] AS lv
        ON lv.[LocalizationVersionId] = lvp.[LocalizationVersionId]
     WHERE lvp.[LocalizationPhraseTranslatedId] IS NULL
       AND lvp.[LocalizationVersionId] = @LocalizationVersionId
       AND lv.[CultureId] = @CultureID
       AND lpt.[LocalizationCultureId] = @CultureID

     --add any newly learned phrases to active version
     INSERT INTO [dbo].[LocalizationPhraseTranslated] ([LocalizationPhraseTranslatedId], [LocalizationPhraseId], [LocalizationCultureId])
     SELECT NEWID(), lp.[LocalizationPhraseId], @CultureID 
             FROM [dbo].[LocalizationPhrase] lp
  LEFT OUTER JOIN [dbo].[LocalizationPhraseTranslated] lpt 
               ON (lpt.[LocalizationPhraseId] = lp.[LocalizationPhraseId] AND lpt.LocalizationCultureId = @CultureID)
            WHERE lpt.[LocalizationPhraseId] IS NULL

    INSERT INTO [dbo].[LocalizationVersionPhrase]  
                ([LocalizationVersionPhraseId], [LocalizationVersionId], [LocalizationPhraseTranslatedId],
                [Phrase], [TranslatedPhrase], [DateCreated], [CreatedBy], [DateUpdated], [UpdatedBy], 
                [LocalizationPhraseId], [TranslatedBy], [SystemTranslation], [Status], [StatusDate], [DoNotLocalize], [ControlType])
        SELECT NEWID(), @LocalizationVersionId, lpt.[LocalizationPhraseTranslatedId], 
               lp.[Phrase], lpt.[TranslatedPhrase], GETDATE(), @UpdatedBy, GETDATE(), @UpdatedBy, 
               lp.[LocalizationPhraseId], '', 0, 'N', GETDATE(), [DoNotLocalize], [ControlType]
          FROM [dbo].[LocalizationPhraseTranslated] AS lpt
               LEFT OUTER JOIN [dbo].[LocalizationPhrase] AS lp ON lp.[LocalizationPhraseId] = lpt.[LocalizationPhraseId]
         WHERE lpt.[LocalizationCultureId] = @CultureID
           AND lpt.[LocalizationPhraseTranslatedId] NOT IN 
               (SELECT lvp.[LocalizationPhraseTranslatedId] 
                  FROM [dbo].[LocalizationVersionPhrase] AS lvp LEFT OUTER JOIN [dbo].[LocalizationVersion] AS lv 
                    ON lv.[LocalizationVersionId] = lvp.[LocalizationVersionId]
                 WHERE lv.[CultureId] = @CultureID 
                   AND lvp.[LocalizationVersionId] = @LocalizationVersionId
                   AND lvp.[LocalizationPhraseTranslatedId] IS NOT NULL)
END




GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionLoadLiveNew]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionLoadLiveNew]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_TEVersionLoadLiveNew]
(
      @CultureID nvarchar(50),
      @LocalizationVersionId uniqueidentifier,
      @UpdatedBy nvarchar(250)
)
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @ncount int
    DECLARE @ret_value  int
    DECLARE @error_code  int

    SET @error_code = 0

    SELECT @ncount = COUNT(1)
      FROM [dbo].[LocalizationVersion]
     WHERE [LocalizationVersionId] =  @LocalizationVersionId

    -- check that the versionid exists before update
    IF @ncount <> 1
    BEGIN
        SET @error_code = -21
        GOTO error_handler
    END

    BEGIN TRY
        BEGIN TRANSACTION
        
        -- 1) DEACTIVATE ACTIVE Version
        UPDATE [dbo].[LocalizationVersion]
           SET [ActiveVersion] = 0,
               [ActiveVersionLoaded] = NULL 
         WHERE [ActiveVersion] = 1 AND [CultureId] = @CultureID;
        DELETE FROM [dbo].[LocalizationPhraseTranslated]
         WHERE [LocalizationCultureId] = @CultureID;
         
        -- 2) Update the LocalizationPhraseTranslated table with the current data, inserting new rows, updating existing rows
        UPDATE lpt
           SET lpt.[TranslatedPhrase] = lvp.[TranslatedPhrase]
          FROM [dbo].[LocalizationPhraseTranslated] lpt
               INNER JOIN [dbo].[LocalizationVersionPhrase] lvp ON lpt.[LocalizationPhraseId] = lvp.[LocalizationPhraseId]
         WHERE lvp.[LocalizationVersionId] = @LocalizationVersionId
           AND lpt.LocalizationCultureId = @CultureID
           AND lvp.[TranslatedPhrase] IS NOT NULL
        
         
        INSERT INTO [dbo].[LocalizationPhraseTranslated] ([LocalizationPhraseTranslatedId], 
                                                          [LocalizationPhraseId],
                                                          [LocalizationCultureId], 
                                                          [TranslatedPhrase])
            SELECT COALESCE(lvp.[LocalizationPhraseTranslatedId], NEWID()), 
                   COALESCE(lvp.[LocalizationPhraseId], NEWID()), 
                   @CultureID, 
                   lvp.[TranslatedPhrase]
              FROM [dbo].[LocalizationVersionPhrase] lvp
             WHERE lvp.[LocalizationVersionId] = @LocalizationVersionId AND lvp.[TranslatedPhrase] IS NOT NULL
               AND (   [LocalizationPhraseTranslatedId] IS NULL 
                    OR [LocalizationPhraseTranslatedId] NOT IN (
                        SELECT [LocalizationPhraseTranslatedId] FROM [dbo].[LocalizationPhraseTranslated]
                        )
                    );

        -- 3) Syncronyzing all records from both tables, adding not existiing records from translated to version phrases table
        EXEC [dbo].[asi_TEVersionRefeshNew] @CultureID, @LocalizationVersionId, @UpdatedBy;

        -- 4) ACTIVATING VERSION, set Active to 1, and ActiveVersionLoad to Current Date
        UPDATE [dbo].[LocalizationVersion]
           SET [ActiveVersion] = 1, 
               [ActiveVersionLoaded] = GETDATE(),
               [DateUpdated] = GETDATE(), 
               [UpdatedBy] = @UpdatedBy
         WHERE [LocalizationVersionId] = @LocalizationVersionId;
         
        COMMIT TRANSACTION
    END TRY
    BEGIN CATCH
        ROLLBACK TRANSACTION
        SET @error_code = @@error
    END CATCH

    --goto endit

    error_handler:
    SET @ret_value = @error_code

    endit:
    RETURN  @ret_value
    --select @ret_value

    SET NOCOUNT OFF
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionPhraseDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionPhraseDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:      <Author,,Name>
-- Create date: <Create Date,,>
-- Description: <Description,,>
-- version 1.0
-- =============================================
CREATE PROCEDURE [dbo].[asi_TEVersionPhraseDelete]
(
    @LocalizationVersionPhraseId uniqueidentifier
)
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON;

    DECLARE @LocalizationPhraseTranslatedId uniqueidentifier
    DECLARE @ncount int
    DECLARE @ret_value  int
    DECLARE @error_code  int

    SET @error_code = 0

    SELECT @ncount = COUNT(*)
      FROM [dbo].[LocalizationVersionPhrase]
    WHERE [LocalizationVersionPhraseId] = @LocalizationVersionPhraseId

    -- check that the versionid exists before insert
    IF @ncount <> 1
    BEGIN
        SET @error_code = -21
        GOTO error_handler
    END

    BEGIN TRY
        BEGIN TRANSACTION
        SELECT @LocalizationPhraseTranslatedId = LocalizationPhraseTranslatedId 
          FROM [dbo].[LocalizationVersionPhrase]
         WHERE LocalizationVersionPhraseId = @LocalizationVersionPhraseId 


        DELETE FROM [dbo].[LocalizationVersionPhrase] 
         WHERE LocalizationVersionPhraseId = @LocalizationVersionPhraseId 

        --DELETE LocalizationPhraseTranslated
        --WHERE LocalizationPhraseTranslatedId = @LocalizationPhraseTranslatedId 

        COMMIT TRANSACTION
    END TRY
    BEGIN CATCH
        ROLLBACK TRANSACTION
        SET @error_code = @@error
    END CATCH

    --goto endit

    error_handler:
    SET @ret_value = @error_code

    endit:
    RETURN  @ret_value
    --select @ret_value

    SET NOCOUNT OFF
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionPhraseUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionPhraseUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_TEVersionPhraseUpdate]
(
    @LocalizationVersionPhraseId uniqueidentifier,
    @TranslatedPhrase nvarchar(4000),
    @UpdatedBy nvarchar(250),
    @Status nvarchar(5),
    @DoNotLocalize bit,
    @Description nvarchar(300)
)
AS
BEGIN
    SET NOCOUNT ON;

      -- 09/01/2013 - added [DoNotLocalize] and [Description]
    UPDATE [dbo].[LocalizationVersionPhrase] 
       SET [TranslatedPhrase]= @TranslatedPhrase,
           [UpdatedBy] = @UpdatedBy, 
           [DateUpdated] = GETDATE(),
           [Status] = @Status,
           [DoNotLocalize] = @DoNotLocalize,
           [Description] = @Description
     WHERE [LocalizationVersionPhraseId] = @LocalizationVersionPhraseId
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionTransferClear]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionTransferClear]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:      <Author,,Name>
-- Create date: <Create Date,,>
-- Description: <Description,,>
-- version 1.0
-- =============================================
CREATE PROCEDURE [dbo].[asi_TEVersionTransferClear]
AS
BEGIN
    SET NOCOUNT ON;
    TRUNCATE TABLE [dbo].[LocalizationVersionPhraseTransfer]
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionTransferCreate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionTransferCreate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_TEVersionTransferCreate]
(
    @phraseId uniqueidentifier,
    @phrase nvarchar(4000),
    @translatedPhrase nvarchar(4000),
      @doNotLocalize bit,
    @description nvarchar(300)

)
AS
BEGIN
      -- 09/01/2013 - added columns and params @doNotLocalize, @description
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON;

    INSERT INTO [dbo].[LocalizationVersionPhraseTransfer] (LocalizationVersionPhraseId, Phrase, TranslatedPhrase, DoNotLocalize, [VersionPhraseTransferDesc])
    VALUES (@phraseId, @phrase, @translatedPhrase, @doNotLocalize, @description)
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionTransferIn]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionTransferIn]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_TEVersionTransferIn] 
(
      @LocalizationVersionId uniqueidentifier,
      @UpdatedBy nvarchar(250)
)
AS
BEGIN
-- 08/30/2013 - added logic for @DoNotLocalize/DoNotLocalize 
-- and @Description to move to version tables

    SET NOCOUNT ON

    DECLARE @ncount INT
    DECLARE @ret_value  INT
    DECLARE @error_code  INT

    SET @error_code = 0

    SELECT @ncount = COUNT(*)
      FROM [dbo].[LocalizationVersion]
     WHERE LocalizationVersionId = @LocalizationVersionId

    -- check that the versionid exists before update
    IF @ncount <> 1
    BEGIN
        SET @error_code = -21
        GOTO error_handler
    END

    BEGIN TRY
        DECLARE @PhraseID UNIQUEIDENTIFIER
        DECLARE @TranslatedPhrase NVARCHAR(4000)
        DECLARE @DoNotLocalize bit    
        DECLARE @Description NVARCHAR(300)
        
        DECLARE @OriginalTranslatedPhrase NVARCHAR(4000)
        DECLARE @OriginalPhrase NVARCHAR(4000)   
        DECLARE @OriginalDoNotLocalize bit    
        DECLARE @OriginalDescription NVARCHAR(300)

        DECLARE table1Cursor CURSOR FOR 
            SELECT [LocalizationVersionPhraseId], [Phrase], [TranslatedPhrase], DoNotLocalize, [VersionPhraseTransferDesc]
              FROM [dbo].[LocalizationVersionPhraseTransfer] 

        OPEN table1Cursor

        FETCH NEXT FROM table1Cursor 
         INTO @PhraseID, @OriginalPhrase, @TranslatedPhrase, @DoNotLocalize, @Description

        WHILE @@FETCH_STATUS = 0
        BEGIN
            -- check if exist in original phrase table
            SELECT @ncount = COUNT(1)
              FROM [dbo].[LocalizationPhraseTranslated]
             WHERE [LocalizationPhraseTranslatedId] = @PhraseID

            IF (@ncount = 1) --phrase exists in original phrase table, compare if it changed
            BEGIN
                -- check if phrase exists in version phrase table
                SELECT @ncount = COUNT(1)
                  FROM [dbo].[LocalizationVersionPhrase] 
                 WHERE [LocalizationVersionId] = @LocalizationVersionId AND LocalizationPhraseTranslatedId = @PhraseID 

                IF (@ncount = 1) --phrase exists in version phrase table, 
                BEGIN
                    -- get previous value to compare
                    SELECT    @OriginalTranslatedPhrase = TranslatedPhrase, 
                                          @OriginalDoNotLocalize = DoNotLocalize,
                                          @OriginalDescription = [Description] 
                      FROM [dbo].[LocalizationVersionPhrase]
                     WHERE [LocalizationVersionId] = @LocalizationVersionId AND LocalizationPhraseTranslatedId = @PhraseID 

                    -- compare if it changed
                    IF (@OriginalTranslatedPhrase<>@TranslatedPhrase or 
                                    @OriginalDoNotLocalize <> @DoNotLocalize or
                                    @OriginalDescription <> @Description)
                    BEGIN -- changed
                        -- set result as #1
                        UPDATE [dbo].[LocalizationVersionPhraseTransfer]
                           SET [Result] = 1 
                         WHERE [LocalizationVersionPhraseId] = @PhraseID
                         
                        -- update tranlsated phrase
                        UPDATE [dbo].[LocalizationVersionPhrase] 
                           SET [TranslatedPhrase] = @TranslatedPhrase, 
                               [DateUpdated] = GETDATE(), 
                               [UpdatedBy] = @UpdatedBy,
                               [DoNotLocalize] = @DoNotLocalize,
                               [Description] = @Description
                         WHERE [LocalizationVersionId] = @LocalizationVersionId AND LocalizationPhraseTranslatedId = @PhraseID 
                    END
                    ELSE -- phrase hasn't changed, save result as 2; no changes in versionphrases table
                    BEGIN 
                        UPDATE [dbo].[LocalizationVersionPhraseTransfer]
                           SET [Result] = 2 
                         WHERE [LocalizationVersionPhraseId] = @PhraseID
                    END
                END
                ELSE  -- phrase doesn't exist in version phrase table
                BEGIN
                    -- create new record in versionphrases table
                    
                    INSERT INTO [dbo].[LocalizationVersionPhrase] (LocalizationVersionPhraseId, LocalizationVersionId, 
                                                                   LocalizationPhraseTranslatedId, Phrase, TranslatedPhrase, 
                                                                   DateCreated, CreatedBy, DateUpdated, UpdatedBy, LocalizationPhraseId, 
                                                                   DoNotLocalize, [Description])
                        SELECT NEWID(), @LocalizationVersionId, 
                               @PhraseID, @OriginalPhrase, @TranslatedPhrase, 
                               GETDATE(), @UpdatedBy, GETDATE(), @UpdatedBy, lpt.LocalizationPhraseId, 
                               @DoNotLocalize, @Description
                          FROM [dbo].[LocalizationVersionPhraseTransfer] AS lvpt 
                               LEFT OUTER JOIN dbo.LocalizationPhraseTranslated AS lpt ON lpt.LocalizationPhraseTranslatedId = lvpt.LocalizationVersionPhraseId
                        WHERE lvpt.LocalizationVersionPhraseId = @PhraseID

                    -- set result as #3
                    UPDATE [dbo].[LocalizationVersionPhraseTransfer]
                       SET [Result] = 3 
                     WHERE [LocalizationVersionPhraseId] = @PhraseID
                END
            END
            ELSE
            BEGIN
                -- set result as #4
                UPDATE [dbo].[LocalizationVersionPhraseTransfer]
                   SET [Result] = 4 
                 WHERE [LocalizationVersionPhraseId] = @PhraseID
            END

            FETCH NEXT FROM table1Cursor 
             INTO @PhraseID, @OriginalPhrase, @TranslatedPhrase,  @DoNotLocalize, @Description
        END

        CLOSE table1Cursor
        DEALLOCATE table1Cursor

    END TRY
    BEGIN CATCH
        SET @error_code = @@error
    END CATCH

    --goto endit

    error_handler:
    SET @ret_value = @error_code

    endit:
    RETURN  @ret_value

    SET NOCOUNT OFF
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionTransferInFromExternalDB]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionTransferInFromExternalDB]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO




CREATE PROCEDURE [dbo].[asi_TEVersionTransferInFromExternalDB] 
(
      @LocalizationVersionId uniqueidentifier,
      @UpdatedBy nvarchar(250)
)
AS
BEGIN

    SET NOCOUNT ON
    DECLARE @count int
    DECLARE @retValue int
    DECLARE @errorCode int
    DECLARE @cultureId nvarchar(50)

    SET @errorCode = 0

    -- check that the versionid exists before update and retrieve culture id for processing new phrases
    SELECT @count = COUNT(1), @cultureId = MAX([CultureId])
      FROM [dbo].[LocalizationVersion]
     WHERE LocalizationVersionId = @LocalizationVersionId

    -- check that the versionid exists before update
    IF @count <> 1
    BEGIN
        SET @errorCode = -21
        GOTO errorHandler
    END

    BEGIN TRY
        DECLARE @LocalizationVersionPhraseId uniqueidentifier
        DECLARE @Phrase nvarchar(4000)  
        DECLARE @TranslatedPhrase nvarchar(4000)
        DECLARE @DoNotLocalize bit    
        DECLARE @Description nvarchar(300) 
        
        DECLARE @LocalizationPhraseId uniqueidentifier
        DECLARE @PhraseExists bit
        DECLARE @LocalizationPhraseTranslatedId uniqueidentifier 

        DECLARE table1Cursor CURSOR FOR 
            SELECT [LocalizationVersionPhraseId], [Phrase], [TranslatedPhrase], [DoNotLocalize], [VersionPhraseTransferDesc]
              FROM [dbo].[LocalizationVersionPhraseTransfer] 

        OPEN table1Cursor

        FETCH NEXT FROM table1Cursor 
            INTO @LocalizationVersionPhraseId, @Phrase, @TranslatedPhrase, @DoNotLocalize, @Description

        WHILE @@FETCH_STATUS = 0
        BEGIN
        
            SET @LocalizationPhraseId = NULL
            SELECT @LocalizationPhraseId = [LocalizationPhraseId] 
              FROM [dbo].[LocalizationPhrase]
             WHERE LTRIM(RTRIM([Phrase])) = LTRIM(RTRIM(@Phrase))
             
            IF (@LocalizationPhraseID IS NULL)
            BEGIN
                SET @PhraseExists = 0
                SET @LocalizationPhraseId = NEWID()
            END
            ELSE
            BEGIN
                SET @PhraseExists = 1
            END
        
            -- check if phrase exists in LocalizationVersionPhrase table
            -- as long as the phrase exists (otherwise, the count should be 0)          
            SELECT @count = COUNT(1)
              FROM [dbo].[LocalizationVersionPhrase]
             WHERE [LocalizationVersionId] = @LocalizationVersionId
               AND [LocalizationPhraseId] = @LocalizationPhraseId
               AND @PhraseExists = 1

            IF (@count > 0) --phrase exists in version phrase table
            BEGIN
            
                IF EXISTS(SELECT 1 FROM [dbo].[LocalizationVersionPhrase] 
                                  WHERE [LocalizationVersionId] = @LocalizationVersionId
                                    AND [LocalizationPhraseId] = @LocalizationPhraseId
                                    AND (ISNULL(TranslatedPhrase,'') <> @TranslatedPhrase 
                                         OR [DoNotLocalize] <> @DoNotLocalize 
                                         OR [Description] <> @Description))
                BEGIN
                    -- changes in versionphrases table, save result as 1
                    UPDATE [dbo].[LocalizationVersionPhraseTransfer]
                       SET [Result] = 1 
                     WHERE [LocalizationVersionPhraseId] = @LocalizationVersionPhraseId
                         
                    -- update LocalizationVersionPhrase.  No need to worry about other tables
                    UPDATE [dbo].[LocalizationVersionPhrase] 
                       SET [TranslatedPhrase] = @TranslatedPhrase, 
                           [DateUpdated] = GETDATE(), 
                           [UpdatedBy] = @UpdatedBy,
                           [DoNotLocalize] = @DoNotLocalize,
                           [Description] = @Description
                     WHERE [LocalizationVersionId] = @LocalizationVersionId
                       AND [LocalizationPhraseId] = @LocalizationPhraseId     
                END   
                ELSE -- phrase hasn't changed, save result as 2; no changes in versionphrases table
                BEGIN
                    UPDATE [dbo].[LocalizationVersionPhraseTransfer]
                       SET [Result] = 2 
                     WHERE [LocalizationVersionPhraseId] = @LocalizationVersionPhraseId
                END                                  
            END
            ELSE  -- phrase doesn't exist in version phrase table
            BEGIN        
             
                IF (@PhraseExists = 0)
                BEGIN
                    -- create new record in LocalizationPhrase table
                    INSERT INTO [dbo].[LocalizationPhrase] ([LocalizationPhraseId], [LocalizationApplicationId], 
                                                            [Phrase], [DoNotLocalize], [ControlType])
                         VALUES ( @LocalizationPhraseId, 0, @Phrase, @DoNotLocalize, '')      
                END
                
                -- update existing or create new record in LocalizationPhraseTranslated table
                SET @LocalizationPhraseTranslatedId = NULL
                SELECT @LocalizationPhraseTranslatedId = [LocalizationPhraseTranslatedId] 
                  FROM [dbo].[LocalizationPhraseTranslated] 
                 WHERE [LocalizationPhraseId] = @LocalizationPhraseID AND [LocalizationCultureId] = @cultureId
                   
                -- create new record in LocalizationVersionPhrase table
                INSERT INTO [dbo].[LocalizationVersionPhrase] 
                                  ([LocalizationVersionPhraseId], [LocalizationVersionId], 
                                   [LocalizationPhraseTranslatedId], [Phrase], [TranslatedPhrase], 
                                   [DateCreated], [CreatedBy], [DateUpdated], [UpdatedBy], 
                                   [Description], [LocalizationPhraseId], [DoNotLocalize])
                        SELECT NEWID(), @LocalizationVersionId, 
                               @LocalizationPhraseTranslatedId, @Phrase, @TranslatedPhrase, 
                               GETDATE(), @UpdatedBy, GETDATE(), @UpdatedBy, 
                               @Description, @LocalizationPhraseId, @DoNotLocalize
                          FROM [dbo].[LocalizationVersionPhraseTransfer]
                         WHERE [LocalizationVersionPhraseId] = @LocalizationVersionPhraseId

                    -- set result as #3
                    UPDATE [dbo].[LocalizationVersionPhraseTransfer]
                       SET [Result] = 3 
                     WHERE [LocalizationVersionPhraseId] = @LocalizationVersionPhraseId
            END
            
            FETCH NEXT FROM table1Cursor 
             INTO @LocalizationVersionPhraseId, @Phrase, @TranslatedPhrase, @DoNotLocalize, @Description
        END

        CLOSE table1Cursor
        DEALLOCATE table1Cursor

    END TRY
    
    BEGIN CATCH
        SET @errorCode = @@error
    END CATCH

    errorHandler:
    SET @retValue = @errorCode

    RETURN  @retValue

    SET NOCOUNT OFF
END



GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:      <Author,,Name>
-- Create date: <Create Date,,>
-- Description: <Description,,>
-- version 1.0
-- =============================================
CREATE PROCEDURE [dbo].[asi_TEVersionUpdate]
(
    @LocalizationVersionId uniqueidentifier,
    @Name nvarchar(250),
    @Description nvarchar(400),
    @Note nvarchar(400),
    @UpdatedBy nvarchar(250),
    @Status nvarchar(5)
)
AS
BEGIN 
    SET NOCOUNT ON

    DECLARE @ncount int
    DECLARE @ret_value  int
    DECLARE @error_code  int

    SET @error_code = 0

    SELECT @ncount = COUNT(1) 
      FROM [dbo].[LocalizationVersion] AS p1
     WHERE [LocalizationVersionId] = @LocalizationVersionId

    IF @ncount <> 1
    BEGIN
        SET @error_code = -21
        GOTO error_handler
    END

    BEGIN TRY

        UPDATE [dbo].[LocalizationVersion] 
           SET [LocalizationVersionName] = @Name,
               [LocalizationVersionDesc] = @Description, 
               [Note] = @Note, 
               [DateUpdated] = GETDATE(), 
               [UpdatedBy] = @UpdatedBy, 
               [StatusID] = @Status 
        WHERE [LocalizationVersionId] = @LocalizationVersionId

        IF @@ROWCOUNT <> 1
        BEGIN
            SET @error_code = -22
            GOTO error_handler
        END

    END TRY
    BEGIN CATCH
        SET @error_code = @@error
        --if @@error <> 0
        --          begin
        --          set @error_code = @@error
        --          goto error_handler
        --          end
    END CATCH

    --if @inv_num = 0 
    --         goto error_handler

    --if @@error <> 0
    --         begin
    --         set @error_hold = @@error
    --         goto error_handler
    --         end

    --goto endit

    error_handler:
    SET @ret_value = @error_code

    endit:
    RETURN  @ret_value
    --select @ret_value

    SET NOCOUNT OFF
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_UniformString]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_UniformString]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROC [dbo].[asi_UniformString]
    @organizationKey uniqueidentifier,
    @userKey uniqueidentifier,
    @loggedInUserGroupKey uniqueidentifier = '00000000-0000-0000-0000-000000000000', -- if this is empty, we assume the user is not logged in
    @uniformString nvarchar(850) OUTPUT
AS
BEGIN
    SET @uniformString = N' (UniformMain.OrganizationKey=' + NCHAR(39) + CAST(@organizationKey As nchar(36))+NCHAR(39)+' OR UniformMain.OrganizationKey = ' + NCHAR(39) + N'00000000-0000-0000-0000-000000000000' + NCHAR(39) + ')'
    SET @uniformString = @uniformString + N' AND (EXISTS(SELECT 1 FROM AccessItem INNER JOIN UserToken ON AccessItem.Grantee = UserToken.Grantee WHERE AccessItem.AccessKey = UniformMain.AccessKey AND UserToken.UserKey = '+NCHAR(39)+CAST(@userKey As nchar(36))+NCHAR(39)+' AND (AccessItem.Permission & 3) > 0))'
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_UpdateCampaignResponses]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_UpdateCampaignResponses]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_UpdateCampaignResponses]
    @useImplicit bit, 
    @userKey     uniqueidentifier,
    @debugging   bit = 0  --False
AS
BEGIN
    -- call the CS stored proc
    EXEC asi_CsUpdateCampaignResponses @useImplicit, @userKey;
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_UpdateContactSalutation]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_UpdateContactSalutation]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_UpdateContactSalutation]
	(@inputSalutationKey uniqueidentifier)
AS
BEGIN

SET NOCOUNT ON

DECLARE @sql nvarchar(2000)
DECLARE @contactKey uniqueidentifier
DECLARE @IndividualFormula nvarchar(2000)
DECLARE @InstituteFormula nvarchar(2000)

DECLARE @calcFormula nvarchar(2000) 

DECLARE @tempKey uniqueidentifier
DECLARE @tempValue nvarchar(1000)

DECLARE @isDeletable as bit
DECLARE @autoCreate as bit

SELECT @IndividualFormula = IndividualFormula, @InstituteFormula = InstituteFormula, @autoCreate = AutoCreate
	FROM vBoSalutationRef 
	WHERE SalutationKey = @inputSalutationKey
	
IF @@ROWCOUNT = 0
    RETURN

IF @autoCreate = 1
	select @isDeletable = 0
ELSE
	select @isDeletable = 1

DECLARE theCursor CURSOR FAST_FORWARD FOR 
	SELECT ContactKey
		FROM vBoContactSalutation
		WHERE SalutationKey = @inputSalutationKey
			AND IsOverridden = 0

OPEN theCursor
FETCH NEXT FROM theCursor INTO @contactKey

WHILE @@FETCH_STATUS = 0
BEGIN

	SET @tempKey = newid()
	
	SELECT @sql =  
		CASE 
		WHEN IsInstitute = 1 THEN
			' asi_ProcessFormulaOutput ' 
				+ '''' + convert (nvarchar(100), @tempKey) + ''', '
				+ '''' + @InstituteFormula + ''', '
				+ '''vBoInstitute'', ''ContactKey'', ' 
				+ '''' + convert (nvarchar(50), @contactKey) 
				+ ''''
	
		WHEN IsInstitute = 0 THEN
			' asi_ProcessFormulaOutput ' 
				+ '''' + convert (nvarchar(100), @tempKey) + ''', '
				+ '''' + @IndividualFormula + ''', '
				+ '''vBoIndividual'', ''ContactKey'', ' 
				+ '''' + convert (nvarchar(50), @contactKey) 
				+ ''''
		END
	FROM vBoContact WHERE ContactKey = @contactKey
	
	EXEC (@sql)
	
	SELECT @tempValue = tempValue from tempFormula
		WHERE tempKey = @tempKey
	
	IF datalength (@tempValue) > 0 AND @tempValue IS NOT NULL
		UPDATE vBoContactSalutation SET SalutationText = @tempValue, IsDeletable = @isDeletable
		WHERE ContactKey = @contactKey and SalutationKey = @inputSalutationKey
	
	DELETE FROM tempFormula WHERE tempKey = @tempKey
	
	FETCH NEXT FROM theCursor INTO @contactKey
END

CLOSE theCursor
DEALLOCATE theCursor

UPDATE SalutationRef SET NeedsUpdateFlag = 0 WHERE SalutationKey = @inputSalutationKey

SET NOCOUNT OFF

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_UpdateContactSalutations]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_UpdateContactSalutations]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure [dbo].[asi_UpdateContactSalutations]
	(@inputSalutationKey uniqueidentifier)
as
begin

set nocount on

/* create table tempFormula
	(tempKey uniqueidentifier,
	tempValue nvarchar(1000) )  */

declare @sql nvarchar(2000)
declare @contactKey uniqueidentifier
declare @IndividualFormula nvarchar(2000)
declare @InstituteFormula nvarchar(2000)

declare @calcFormula nvarchar(2000) 

declare @tempKey uniqueidentifier
declare @tempValue nvarchar(1000)

select @IndividualFormula = IndividualFormula, 
	@InstituteFormula = InstituteFormula 
	from vBoSalutationRef where SalutationKey = @inputSalutationKey

declare theCursor cursor for 
	select ContactKey
		from vBoContactSalutation
		where SalutationKey = @inputSalutationKey
			and IsOverridden = 0

open theCursor
fetch next from theCursor into @contactKey

WHILE @@FETCH_STATUS = 0
begin

set @tempKey = newid()

select @sql =  
	case 
	when IsInstitute = 1 then
			' asi_ProcessContactFormulaOutput ' 
				+ '''' + convert (nvarchar(100), @tempKey) + ''', '
				+ '''' + @InstituteFormula + ''', '
				+ '''vBoInstitute'', ''ContactKey'', ' 
				+ '''' + convert (nvarchar(50), @contactKey) 
				+ ''''

	when IsInstitute = 0 then
			' asi_ProcessContactFormulaOutput ' 
				+ '''' + convert (nvarchar(100), @tempKey) + ''', '
				+ '''' + @IndividualFormula + ''', '
				+ '''vBoIndividual'', ''ContactKey'', ' 
				+ '''' + convert (nvarchar(50), @contactKey) 
				+ ''''
	end
from vBoContact where ContactKey = @contactKey

exec (@sql)

select @tempValue = tempValue from tempFormula
	where tempKey = @tempKey

if datalength (@tempValue) > 0 and @tempValue is not null
	update vBoContactSalutation set
		SalutationText = @tempValue
	where ContactKey = @contactKey and SalutationKey = @inputSalutationKey

delete from tempFormula where tempKey = @tempKey

fetch next from theCursor into @contactKey
end

close theCursor
deallocate theCursor

set nocount off

end

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_UpdatePublishRequest]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_UpdatePublishRequest]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_UpdatePublishRequest]
	@PublishRequestKey uniqueidentifier,
	@PublishedDateTime datetime
AS
BEGIN

	SET NOCOUNT ON;
	DECLARE @PendingCount int
	DECLARE @ErrorCount int

	SELECT @PendingCount = Count(*) FROM PublishRequestDetail
	WHERE PublishRequestStatusCode = 0
      AND PublishRequestKey = @PublishRequestKey
	SELECT * FROM PublishRequestDetail
	WHERE PublishRequestStatusCode = 0
      AND PublishRequestKey = @PublishRequestKey

	SELECT @ErrorCount = Count(*) FROM PublishRequestDetail
	WHERE PublishRequestStatusCode = 3
      AND PublishRequestKey = @PublishRequestKey

    if (@PendingCount = 0)
	BEGIN
		UPDATE PublishRequest
		   SET PublishedDateTime = @PublishedDateTime
		 WHERE PublishRequestKey = @PublishRequestKey

		IF (@ErrorCount = 0)
		BEGIN
			UPDATE PublishMessageLog
			   SET DisplayFlag = 0
			 WHERE PublishRequestKey = @PublishRequestKey
		END
	END
END


SET ANSI_NULLS ON

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_UserHasNetSecurity]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_UserHasNetSecurity]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_UserHasNetSecurity]
	@contactMaster varchar(50)
AS
	declare @userKey uniqueidentifier
	select @userKey = UserKey from UserMain where ContactMaster = @contactMaster
	if @@ROWCOUNT = 0
	begin
		select 0
		return
	end

	if exists (select * from UserRole where UserKey = @userKey and RoleKey <> (select RoleKey from RoleMain where Name = 'Everyone' and IsSystem = 1))
	begin
		select 1
		return
	end

	if exists (select * from GroupMember where MemberContactKey = @userKey)
	begin
		select 1
		return
	end

	if exists (
		select 1 from UserMain um left outer join AccessItem ai on um.UserKey = ai.UserKey
		where ai.AccessKey IS NOT NULL AND um.UserKey = @userKey
		GROUP BY um.UserId HAVING COUNT(um.UserId) > 1
	)
	begin
		select 1
		return
	end

	select 0

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_UserTokenUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_UserTokenUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_UserTokenUpdate]
    @userKey uniqueidentifier 
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @now datetime;
    DECLARE @everyoneRoleKey uniqueidentifier;
    DECLARE @loggedInUserGroupKey uniqueidentifier
    DECLARE @guestKey uniqueidentifier
    
    SET @now = dbo.asi_GetAppDatetime();
    SELECT @everyoneRoleKey = [ParameterValue] 
      FROM [dbo].[SystemConfig] 
     WHERE [ParameterName] = N'Security.Token.EveryoneRoleKey'
     
    SELECT @loggedInUserGroupKey = [ParameterValue] 
      FROM [dbo].[SystemConfig] 
     WHERE [ParameterName] = 'CM.LoggedInUserGroupKey'

    -- A Table variable to hold our intermediate results
    DECLARE @token TABLE ([Grantee] uniqueidentifier null, [RoleName] nvarchar(65))

    -- Add Self
    INSERT INTO @token ([Grantee], [RoleName])
    VALUES (@userKey, N'')

    -- Add Everyone Role
    INSERT INTO @token ([Grantee], [RoleName])
    VALUES (@everyoneRoleKey, N'Everyone')
    
    -- Add Logged-in user group except if it is GUEST
    SELECT @guestKey = UserKey 
      FROM UserMain 
     WHERE UserId = 'GUEST'
    IF(@userKey <> @guestKey)
    BEGIN
        INSERT @token(Grantee, RoleName)
        VALUES (@LoggedInUserGroupKey, 'AuthenticatedUsers')
    END

    -- Add Assigned Roles
    INSERT INTO @token ([Grantee], [RoleName])
        SELECT ur.[RoleKey], rm.[Name]
          FROM [dbo].[UserRole] ur
               INNER JOIN [dbo].[RoleMain] rm ON ur.[RoleKey] = rm.[RoleKey]
         WHERE ur.[UserKey] = @userKey
           AND ur.[RoleKey] <> @everyoneRoleKey

    -- Add Effective Group Membership
    INSERT INTO @token ([Grantee], [RoleName])
        SELECT [GroupKey], [Name]
          FROM [dbo].[GroupMain]
         WHERE GroupKey IN ( SELECT DISTINCT GroupKey
                               FROM [dbo].[GroupMember]
                              WHERE [MemberContactKey] = @userKey
                                AND ([JoinDate] <= @now OR [JoinDate] IS NULL)
                                AND ([DropDate] >= @now OR [DropDate] IS NULL)
                           )

    -- Add legacy security group - use newid because it needs to be unique and will never actually be accessed by key
    INSERT INTO @token ([Grantee], [RoleName])
        SELECT NEWID(), nsg.[SECURITY_GROUP]
          FROM [dbo].[Name_Security] ns
                INNER JOIN [dbo].[Name_Security_Groups] nsg ON ns.[ID] = nsg.[ID]
               INNER JOIN [dbo].[UserMain] b ON ns.ID = b.[ContactMaster]
         WHERE b.UserKey = @userKey
           AND LEN(LTRIM(RTRIM(nsg.[SECURITY_GROUP]))) > 0

    -- Add Member type - use newid because it needs to be unique and will never actually be accessed by key
    INSERT INTO @token ([Grantee], [RoleName])
        SELECT NEWID(), n.[MEMBER_TYPE]
          FROM Name n
               INNER JOIN UserMain um ON n.ID = um.ContactMaster
         WHERE um.UserKey = @userKey
           AND LEN(LTRIM(RTRIM(n.[MEMBER_TYPE]))) > 0

    -- Add Member
    DECLARE @memberGroupKey uniqueidentifier
    DECLARE @groupName nvarchar(65)

    SELECT @memberGroupKey = [ParameterValue]
      FROM [dbo].[SystemConfig]
     WHERE [ParameterName] = N'CM.MemberGroupKey'

    SELECT @groupName = [Name] 
      FROM [dbo].[GroupMain]
     WHERE [GroupKey] = @memberGroupKey

    INSERT INTO @token ([Grantee], [RoleName])
        SELECT @memberGroupKey, @groupName
          FROM Name n
               INNER JOIN Member_Types mt ON n.MEMBER_TYPE = mt.MEMBER_TYPE
               INNER JOIN UserMain u ON n.ID = u.ContactMaster
         WHERE mt.MEMBER_RECORD = 1
               AND u.UserKey = @userKey

    -- Remove Expired Records From Persisted Source
    DELETE UserToken
     WHERE UserKey = @userKey AND NOT EXISTS (SELECT 1 FROM @token WHERE Grantee = UserToken.Grantee )

    -- Add Missing Records To Persisted Source
    INSERT INTO [dbo].[UserToken] ([UserKey], [Grantee], [RoleName])
        SELECT @userKey, [Grantee], [RoleName]
          FROM @token t
         WHERE NOT EXISTS (SELECT 1 FROM [dbo].[UserToken] WHERE [UserKey] = @userKey AND [Grantee] = t.Grantee )

    -- Return Tokens
    SELECT Grantee, RoleName
      FROM @token

END


GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_UserMainLogin]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_UserMainLogin]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROC [dbo].[asi_UserMainLogin]
    @ProviderKey nvarchar(100)
AS
BEGIN
    -- Set nocount option to surpress row count messages
    SET NOCOUNT ON;
    
    -- Declare variables
    DECLARE @userKey uniqueidentifier;
    DECLARE @contactMaster varchar(50);
    DECLARE @name nvarchar(60);
    DECLARE @userIdTest nvarchar(60);
    DECLARE @organizationKey uniqueidentifier;
    DECLARE @loggedInUserGroupKey uniqueidentifier;
    DECLARE @now datetime;
    
    SET @now = dbo.asi_GetAppDatetime();
    
    -- Initialize local variables if User/Password combination is valid and user is active
    SELECT TOP 1 @userKey = [UserKey], 
                 @contactMaster = [ContactMaster], 
                 @name = [UserId], 
                 @userIdTest = [UserId]
      FROM [dbo].[UserMain]
     WHERE [ProviderKey] = @ProviderKey
           AND [IsDisabled] = 0
           AND COALESCE([EffectiveDate], DATEADD(DAY,-1,@now)) <= @now
           AND COALESCE([ExpirationDate], DATEADD(DAY,1,@now)) >= @now

    SELECT @organizationKey = [OrganizationKey]
      FROM [dbo].[OrganizationMain]
     WHERE [IsDefault] = 1

    -- If validation succeeded, then continue
    IF @userKey IS NOT NULL
    BEGIN
        -- Return variables as first resultset
        SELECT @userKey AS [UserKey], 
               @contactMaster AS [ContactMaster], 
               @name AS [Name], 
               @userIdTest AS [UserId],
               @organizationKey AS [OrganizationKey]
               
        -- Return roles as second resultset
        EXEC asi_UserTokenUpdate @userKey
        
        -- Return legacy roles as third resultset
        SELECT [UserId], [UserKey], [Role]
          FROM [dbo].[vLegacySecurityRole] 
         WHERE [UserKey] = @userKey
        
        SELECT @loggedInUserGroupKey = [ParameterValue]
          FROM [dbo].[SystemConfig] 
         WHERE [ParameterName] = N'CM.LoggedInUserGroupKey'
         
         -- Create Temporary Table
        DECLARE @token TABLE (Grantee uniqueidentifier NULL, RoleName nvarchar(65))
        
        INSERT INTO @token ([Grantee], [RoleName])
        SELECT [GroupKey], [Name]
          FROM [dbo].[GroupMain] 
         WHERE [GroupKey] = @loggedInUserGroupKey
         
         -- Add a row to represent Content Authority Group membership
        INSERT INTO @token ([Grantee], [RoleName])
        SELECT 'C4D78A02-048A-4D35-8440-74B5C82CF62F', 'ContentAuthority'
         WHERE EXISTS(SELECT 1 
          FROM [dbo].[GroupMember] gm 
                INNER JOIN [dbo].[GroupMain] g ON gm.[GroupKey] = g.[GroupKey]
          WHERE gm.[MemberContactKey] = @userKey
                AND gm.[IsActive] = 1
                AND g.[GroupTypeKey] = 'C4D78A02-048A-4D35-8440-74B5C82CF62F')
                
        -- Return Tokens
        SELECT Grantee, RoleName
          FROM @token
    END

    -- Reset nocount option
    SET NOCOUNT OFF;

END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_UserMainUniqueUserId]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_UserMainUniqueUserId]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

/****** Object:  Stored Procedure dbo.asi_UserMainUniqueUserId    Script Date: 7/3/2003 4:58:05 PM ******/
CREATE PROC [dbo].[asi_UserMainUniqueUserId]
      @userKey uniqueidentifier,
      @userId nvarchar(60)
      AS
BEGIN
      DECLARE @isUnique bit

      SET @isUnique = 1

      SET ROWCOUNT 1

      SELECT      @isUnique = 0
      FROM UserMain
      WHERE      UserId = @userId
         AND      UserKey <> @userKey

      SET ROWCOUNT 0

      SELECT @isUnique AS UserIdIsUnique
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_WorkflowInstanceAppendLog]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_WorkflowInstanceAppendLog]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE  proc [dbo].[asi_WorkflowInstanceAppendLog]
 @instanceKey uniqueidentifier,
 @textToAppend nvarchar(4000) as

DECLARE @ptr varbinary(16)

SELECT  @ptr = TEXTPTR(LogText)
 FROM   WorkflowInstance
 WHERE  WorkflowInstanceKey = @instanceKey
IF TEXTVALID('WorkflowInstance.LogText', @ptr) = 1
BEGIN
   UPDATETEXT WorkflowInstance.LogText @ptr NULL 0 @textToAppend --Append to end
   --UPDATETEXT WorkflowInstance.LogText @ptr 0 0 @textToAppend --Insert at beginning
END
ELSE
BEGIN
   UPDATE WorkflowInstance
      SET LogText = @textToAppend
    WHERE WorkflowInstanceKey = @instanceKey
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_WorkItemQueueFetch]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_WorkItemQueueFetch]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_WorkItemQueueFetch]
    @itemCount int          = 3,
    @category  nvarchar(50) = NULL
AS
BEGIN
    DECLARE @id uniqueidentifier;
    SET @id = NEWID();
    DECLARE @tmp nvarchar(1000);
    SET @tmp = N'DECLARE @now datetime; ';
    SET @tmp = @tmp + N'SELECT @now = dbo.asi_GetAppDatetime(); '; 
    SET @tmp = @tmp + N'SELECT TOP ' + CAST(@itemCount AS nvarchar(10)) + N' WorkItemQueueKey, SelectionLock INTO #pick ';
    SET @tmp = @tmp + N'FROM WorkItemQueue ';
    SET @tmp = @tmp + N'WHERE IsInteractive = 0 AND (SelectionLock IS NULL OR KeepAlive < dateadd(mi, - dbo.asi_GetWorkItemLockDuration(), @now)) AND (BeginOn IS NULL OR BeginOn >= @now) ';
    IF DATALENGTH(@category) > 0
    BEGIN
        SET @tmp = @tmp + N'AND Category LIKE ''' + @category + N'%'' ';
    END;
    SET @tmp = @tmp + N'ORDER BY Priority ASC, EnqueuedOn ASC; ';
    SET @tmp = @tmp + N'UPDATE WorkItemQueue SET SelectionLock = ''' + CAST(@id AS nvarchar(40)) + N''', SelectedOn = @now, KeepAlive = @now ';
    SET @tmp = @tmp + N'FROM WorkItemQueue INNER JOIN #pick ON WorkItemQueue.WorkItemQueueKey = #pick.WorkItemQueueKey ';
    SET @tmp = @tmp + N'WHERE (WorkItemQueue.SelectionLock IS NULL OR WorkItemQueue.SelectionLock = #pick.SelectionLock); ';
    SET @tmp = @tmp + N'DROP TABLE #pick; ';
    SET @tmp = @tmp + N'SELECT WorkItemQueueKey FROM WorkItemQueue WHERE SelectionLock = ''' + CAST(@id AS nvarchar(40)) + N''';';
    EXEC (@tmp);
END;


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_WriteGLTransactionLines]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_WriteGLTransactionLines]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_WriteGLTransactionLines]
@transKey uniqueidentifier,
@sequenceNumber int,
@glEntryType nvarchar(50) 
AS
	DECLARE @glTransactionLineKey uniqueidentifier
	DECLARE @glTransactionKey uniqueidentifier 
	DECLARE @amount decimal (18,4)
	DECLARE @glAccountKey uniqueidentifier 
	DECLARE @description nvarchar(50)
	DECLARE @paymentKey uniqueidentifier 
	DECLARE @productKey uniqueidentifier 
	DECLARE @deferralTermsKey uniqueidentifier 
	DECLARE @targetGLAccountKey uniqueidentifier 
	DECLARE @deferralProcessedFlag bit 
	DECLARE @invoiceLineKey uniqueidentifier 
	DECLARE @transactionSequenceNumber int 
	DECLARE @lineGroup int
	DECLARE @realSequenceNumber int
	DECLARE @lineGroupNumber int
	DECLARE @groupCounter int
	SET @groupCounter = 0
	SET @realSequenceNumber = -1
	SET @transactionSequenceNumber = 0
	
	-- The UniqueLineGroups table variable keeps track of the unique combination of GLAccounts and
	-- PaymentKeys used in the GLTransactionLines.
	-- We need to set different LineGroup values for different combinations.
	DECLARE @UniqueLineGroups TABLE
		(GLAccountKey uniqueidentifier, 
		 PaymentKey uniqueidentifier, 
		 GroupNumber int)

	DECLARE Get_TransactionLines cursor for 
	SELECT  newid(), @transKey, sum(#tmpTransLine.Amount), 
			#tmpTransLine.AccountKey, #tmpTransLine.Description, #tmpTransLine.PaymentKey, 
			#tmpTransLine.ProductKey, #tmpTransLine.DeferralTermsKey, 
			#tmpTransLine.TargetGLAccountKey, 0, #tmpTransLine.InvoiceLineKey,
			MIN(#tmpTransLine.TransactionSequenceNumber)
		FROM #tmpTransLine
		INNER JOIN #tmpTransaction 
			ON (#tmpTransLine.InvoiceKey = #tmpTransaction.InvoiceKey
			   OR #tmpTransLine.PaymentKey = #tmpTransaction.PaymentKey)
			AND #tmpTransLine.FinEntityKey = #tmpTransaction.FinEntityKey
		WHERE #tmpTransaction.TransactionKey = @transKey
			AND #tmpTransLine.GLEntryType = @glEntryType		
		GROUP BY 
			#tmpTransLine.AccountKey, #tmpTransLine.Description, #tmpTransLine.PaymentKey, 
			#tmpTransLine.ProductKey, #tmpTransLine.DeferralTermsKey, 
			#tmpTransLine.TargetGLAccountKey, #tmpTransLine.InvoiceLineKey, 
			#tmpTransLine.GLEntryType,
			#tmpTransLine.InvoiceLineNumber
		ORDER BY #tmpTransLine.InvoiceLineNumber
		

	OPEN Get_TransactionLines
	FETCH NEXT FROM Get_TransactionLines into @glTransactionLineKey, @glTransactionKey, @amount,
		@glAccountKey, @description, @paymentKey, @productKey , @deferralTermsKey, @targetGLAccountKey,
		@deferralProcessedFlag, @invoiceLineKey,  @transactionSequenceNumber
	WHILE @@FETCH_STATUS = 0
	BEGIN
		IF (@glEntryType = 'UnearnedIncome'
		  OR @glEntryType = 'AccountsReceivable')
		BEGIN
			SET @lineGroupNumber = null
			SELECT @lineGroupNumber = GroupNumber from @UniqueLineGroups 
				WHERE GLAccountKey = @glAccountKey
					AND PaymentKey = ISNULL(@paymentKey, '00000000-0000-0000-0000-000000000000')
			IF @lineGroupNumber IS NULL
			BEGIN
			    -- found a new account
				INSERT @UniqueLineGroups(GLAccountKey, GroupNumber, PaymentKey) 
					VALUES(@glAccountKey, @groupCounter, ISNULL(@paymentKey, '00000000-0000-0000-0000-000000000000'))
				SET @lineGroupNumber = @groupCounter
				SET @groupCounter = @groupCounter + 1
			END	
			IF (@realSequenceNumber < 0)
				SET @realSequenceNumber = @transactionSequenceNumber + @sequenceNumber
			ELSE
				SET  @realSequenceNumber =  @realSequenceNumber + 1
		
			INSERT GLTransactionLine(GLTransactionLineKey, GLTransactionKey, Amount, GLAccountKey,
			Description, PaymentKey, ProductKey, DeferralTermsKey, 
			TargetGLAccountKey, DeferralProcessedFlag, InvoiceLineKey, GLEntryType, 
			TransactionSequenceNumber, LineGroup)
			VALUES (@glTransactionLineKey, @glTransactionKey, @amount, @glAccountKey, 
				@description, @paymentKey, @productKey , @deferralTermsKey, @targetGLAccountKey,
				@deferralProcessedFlag, @invoiceLineKey, @glEntryType, @realSequenceNumber, 
				@lineGroupNumber)
		
		END  
		
		ELSE
		BEGIN
			INSERT GLTransactionLine(GLTransactionLineKey, GLTransactionKey, Amount, GLAccountKey,
			Description, PaymentKey, ProductKey, DeferralTermsKey, 
			TargetGLAccountKey, DeferralProcessedFlag, InvoiceLineKey, GLEntryType, 
			TransactionSequenceNumber, LineGroup)
			VALUES (@glTransactionLineKey, @glTransactionKey, @amount, @glAccountKey, 
				@description, @paymentKey, @productKey , @deferralTermsKey, @targetGLAccountKey,
				@deferralProcessedFlag, @invoiceLineKey, @glEntryType, @transactionSequenceNumber + @sequenceNumber, 
				@transactionSequenceNumber)
		
		END
	nextTransactionLine:
	FETCH NEXT FROM Get_TransactionLines into @glTransactionLineKey, @glTransactionKey, @amount,
		@glAccountKey, @description, @paymentKey, @productKey , @deferralTermsKey, @targetGLAccountKey,
		@deferralProcessedFlag, @invoiceLineKey,  @transactionSequenceNumber
	END
	CLOSE Get_TransactionLines
	DEALLOCATE Get_TransactionLines
	DELETE @UniqueLineGroups
		
	SET @sequenceNumber = @sequenceNumber + @transactionSequenceNumber
	RETURN @sequenceNumber

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_WriteReEncryptedValues]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_WriteReEncryptedValues]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_WriteReEncryptedValues] 
AS
BEGIN
    ----------------------------------------------
    -- Disable trigger on tables being updated
    ----------------------------------------------
    ALTER TABLE [dbo].[Trans] DISABLE TRIGGER ALL;
    ALTER TABLE [dbo].[PciAuditLog] DISABLE TRIGGER ALL;
    ALTER TABLE [dbo].[UserMain] DISABLE TRIGGER ALL;

    --==============================================================================
    -- Update Encryption values for [dbo].[Trans].[ENCRYPT_CCNUMBER] 
    --==============================================================================
    BEGIN TRANSACTION;
    UPDATE tbl 
       SET tbl.[ENCRYPT_CC_NUMBER] = lkp.[NewCCNumberValue] 
      FROM [dbo].[Trans] tbl 
           INNER JOIN [dbo].[DictionaryLookupForEncryption_Trans_CCNumber] lkp ON tbl.[TRANS_NUMBER] = lkp.[TRANS_NUMBER] 
           AND tbl.[LINE_NUMBER] = lkp.[LINE_NUMBER] 
           AND tbl.[SUB_LINE_NUMBER] = lkp.[SUB_LINE_NUMBER]
     WHERE lkp.[NewCCNumberValue] > '';
    COMMIT TRANSACTION;

    --==============================================================================
    -- Update Encryption values for [dbo].[Trans].[ENCRYPT_CSC] 
    --==============================================================================
    BEGIN TRANSACTION;
    UPDATE tbl 
       SET tbl.[ENCRYPT_CSC] = lkp.[NewCSCValue] 
      FROM [dbo].[Trans] tbl 
           INNER JOIN [dbo].[DictionaryLookupForEncryption_Trans_CSC] lkp ON tbl.[TRANS_NUMBER] = lkp.[TRANS_NUMBER] 
           AND tbl.[LINE_NUMBER] = lkp.[LINE_NUMBER] 
           AND tbl.[SUB_LINE_NUMBER] = lkp.[SUB_LINE_NUMBER]
     WHERE lkp.[NewCSCValue] > '';
    COMMIT TRANSACTION;

    --==============================================================================
    -- Update Encryption values for [dbo].[Trans].[ENCRYPT_CC_EXPIRE] 
    --==============================================================================
    BEGIN TRANSACTION;
    UPDATE tbl 
       SET tbl.[ENCRYPT_CC_EXPIRE] = lkp.[NewCCExpireValue] 
      FROM [dbo].[Trans] tbl 
           INNER JOIN [dbo].[DictionaryLookupForEncryption_Trans_CCExpire] lkp ON tbl.[TRANS_NUMBER] = lkp.[TRANS_NUMBER] 
           AND tbl.[LINE_NUMBER] = lkp.[LINE_NUMBER] 
           AND tbl.[SUB_LINE_NUMBER] = lkp.[SUB_LINE_NUMBER]
     WHERE lkp.[NewCCExpireValue] > '';
    COMMIT TRANSACTION;

    --==============================================================================
    -- Update Encryption values for [dbo].[Orders].[ENCRYPT_PAY_NUMBER] 
    --==============================================================================
    BEGIN TRANSACTION;
    UPDATE tbl 
       SET tbl.[ENCRYPT_PAY_NUMBER] = lkp.[NewPayNumberValue] 
      FROM [dbo].[Orders] tbl 
           INNER JOIN [dbo].[DictionaryLookupForEncryption_Orders_PayNumber] lkp ON tbl.[ORDER_NUMBER] = lkp.[ORDER_NUMBER]
     WHERE lkp.[NewPayNumberValue] > '';
    COMMIT TRANSACTION;

    --==============================================================================
    -- Update Encryption values for [dbo].[Orders].[ENCRYPT_CSC] 
    --==============================================================================
    BEGIN TRANSACTION;
   UPDATE tbl 
       SET tbl.[ENCRYPT_CSC] = lkp.[NewCSCValue] 
      FROM [dbo].[Orders] tbl 
           INNER JOIN [dbo].[DictionaryLookupForEncryption_Orders_CSC] lkp ON tbl.[ORDER_NUMBER] = lkp.[ORDER_NUMBER]
     WHERE lkp.[NewCSCValue] > '';
    COMMIT TRANSACTION;

    --==============================================================================
    -- Update Encryption values for [dbo].[Orders].[ENCRYPT_CREDIT_CARD_EXPIRES] 
    --==============================================================================
    BEGIN TRANSACTION;
    UPDATE tbl 
       SET tbl.[ENCRYPT_CREDIT_CARD_EXPIRES] = lkp.[NewCCExpiresValue] 
      FROM [dbo].[Orders] tbl 
           INNER JOIN [dbo].[DictionaryLookupForEncryption_Orders_CCExpires] lkp ON tbl.[ORDER_NUMBER] = lkp.[ORDER_NUMBER]
     WHERE lkp.[NewCCExpiresValue] > '';
    COMMIT TRANSACTION;

    --==============================================================================
    -- Update Encryption values for [dbo].[Order_Payments].[ENCRYPT_PAY_NUMBER] 
    --==============================================================================
    BEGIN TRANSACTION;
    UPDATE tbl 
       SET tbl.[ENCRYPT_PAY_NUMBER] = lkp.[NewPayNumberValue] 
      FROM [dbo].[Order_Payments] tbl 
           INNER JOIN [dbo].[DictionaryLookupForEncryption_OrderPayments_PayNumber] lkp ON tbl.[ORDER_NUMBER] = lkp.[ORDER_NUMBER] 
           AND tbl.[PAYMENT_NUMBER] = lkp.[PAYMENT_NUMBER]
     WHERE lkp.[NewPayNumberValue] > '';
    COMMIT TRANSACTION;

    --==============================================================================
    -- Update Encryption values for [dbo].[Order_Payments].[ENCRYPT_CSC] 
    --==============================================================================
    BEGIN TRANSACTION;
    UPDATE tbl 
       SET tbl.[ENCRYPT_CSC] = lkp.[NewCSCValue] 
      FROM [dbo].[Order_Payments] tbl 
           INNER JOIN [dbo].[DictionaryLookupForEncryption_OrderPayments_CSC] lkp ON tbl.[ORDER_NUMBER] = lkp.[ORDER_NUMBER] 
           AND tbl.[PAYMENT_NUMBER] = lkp.[PAYMENT_NUMBER]
     WHERE lkp.[NewCSCValue] > '';
    COMMIT TRANSACTION;

    --==============================================================================
    -- Update Encryption values for [dbo].[Order_Payments].[ENCRYPT_CREDIT_CARD_EXPIRES] 
    --==============================================================================
    BEGIN TRANSACTION;
    UPDATE tbl 
       SET tbl.[ENCRYPT_CREDIT_CARD_EXPIRES] = lkp.[NewCCExpiresValue] 
      FROM [dbo].[Order_Payments] tbl 
           INNER JOIN [dbo].[DictionaryLookupForEncryption_OrderPayments_CCExpires] lkp ON tbl.[ORDER_NUMBER] = lkp.[ORDER_NUMBER] 
           AND tbl.[PAYMENT_NUMBER] = lkp.[PAYMENT_NUMBER]
     WHERE lkp.[NewCCExpiresValue] > '';
    COMMIT TRANSACTION;

    --==============================================================================
    -- Update Encryption values for [dbo].[Basket_Payment].[ENCRYPT_PAY_NUMBER] 
    --==============================================================================
    BEGIN TRANSACTION;
    UPDATE tbl 
       SET tbl.[ENCRYPT_PAY_NUMBER] = lkp.[NewPayNumberValue] 
      FROM [dbo].[Basket_Payment] tbl 
           INNER JOIN [dbo].[DictionaryLookupForEncryption_BasketPayment_PayNumber] lkp ON tbl.[ID] = tbl.[ID]
           AND tbl.[IP_ADDRESS] = tbl.[IP_ADDRESS]
     WHERE lkp.[NewPayNumberValue] > '';
    COMMIT TRANSACTION;

    --==============================================================================
    -- Update Encryption values for [dbo].[Basket_Payment].[ENCRYPT_CSC] 
    --==============================================================================
    BEGIN TRANSACTION;
    UPDATE tbl 
       SET tbl.[ENCRYPT_CSC] = lkp.[NewCSCValue] 
      FROM [dbo].[Basket_Payment] tbl 
           INNER JOIN [dbo].[DictionaryLookupForEncryption_BasketPayment_CSC] lkp ON tbl.[ID] = tbl.[ID]
           AND tbl.[IP_ADDRESS] = tbl.[IP_ADDRESS]
     WHERE lkp.[NewCSCValue] > '';
    COMMIT TRANSACTION;

    --==============================================================================
    -- Update Encryption values for [dbo].[Basket_Payment].[ENCRYPT_CREDIT_CARD_EXPIRES] 
    --==============================================================================
    BEGIN TRANSACTION;
    UPDATE tbl 
       SET tbl.[ENCRYPT_CREDIT_CARD_EXPIRES] = lkp.[NewCCExpiresValue] 
      FROM [dbo].[Basket_Payment] tbl 
           INNER JOIN [dbo].[DictionaryLookupForEncryption_BasketPayment_CCExpires] lkp ON tbl.[ID] = tbl.[ID]
           AND tbl.[IP_ADDRESS] = tbl.[IP_ADDRESS]
     WHERE lkp.[NewCCExpiresValue] > '';
    COMMIT TRANSACTION;

    --==============================================================================
    -- Update Encryption values for [dbo].[PciAuditLog].[ENCRYPT_CC_NUMBER] 
    --==============================================================================
    BEGIN TRANSACTION;
    UPDATE tbl 
       SET tbl.[ENCRYPT_CC_NUMBER] = lkp.[NewCCNumberValue] 
      FROM [dbo].[PciAuditLog] tbl 
           INNER JOIN [dbo].[DictionaryLookupForEncryption_PciAuditLog_CCNumber] lkp ON tbl.[PciAuditLogId] = lkp.[PciAuditLogId]
     WHERE lkp.[NewCCNumberValue] > '';
    COMMIT TRANSACTION;

    --==============================================================================
    -- Update Encryption values for [dbo].[UserMain].[MultiFactorInfo] 
    --==============================================================================
    BEGIN TRANSACTION;
    UPDATE tbl 
       SET tbl.[MultiFactorInfo] = lkp.[NewMultiFactorInfoValue] 
      FROM [dbo].[UserMain] tbl 
           INNER JOIN [dbo].[DictionaryLookupForEncryption_UserMain_MultiFactorInfo] lkp ON tbl.[UserKey] = lkp.[UserKey]
     WHERE lkp.[NewMultiFactorInfoValue] > '';
    COMMIT TRANSACTION;

    --==============================================================================
    -- Update Encryption values for [dbo].[CCAuthAcct].[CCAuthPassword] 
    --==============================================================================
    BEGIN TRANSACTION;
    UPDATE tbl 
       SET tbl.[CCAuthPassword] = lkp.[NewCCAuthPasswordValue] 
      FROM [dbo].[CCAuthAcct] tbl 
           INNER JOIN [dbo].[DictionaryLookupForEncryption_CCAuthAcct_CCAuthPassword] lkp ON tbl.[CCAuthAcctCode] = lkp.[CCAuthAcctCode]
     WHERE lkp.[NewCCAuthPasswordValue] > '';
    COMMIT TRANSACTION;

    --==============================================================================
    -- Update Encryption values for [dbo].[SystemConfigXml].[ConfigValue] 
    --==============================================================================
    BEGIN TRANSACTION;
    UPDATE tbl 
       SET tbl.[ConfigValue] = lkp.[NewConfigValue] 
      FROM [dbo].[SystemConfigXml] tbl 
           INNER JOIN [dbo].[DictionaryLookupForEncryption_SystemConfigXml_ConfigValue] lkp ON tbl.[SystemConfigXmlCode] = lkp.[SystemConfigXmlCode]
     WHERE lkp.[NewConfigValue] > '';
    COMMIT TRANSACTION;

    --==============================================================================
    -- Update Encryption values for [dbo].[Cart].[ComboOrder] 
    --==============================================================================
    BEGIN TRANSACTION;
    UPDATE tbl 
       SET tbl.[ComboOrder] = lkp.[NewComboOrderValue] 
      FROM [dbo].[Cart] tbl 
           INNER JOIN [dbo].[DictionaryLookupForEncryption_Cart_ComboOrder] lkp ON tbl.[CartKey] = lkp.[CartKey]
     WHERE lkp.[NewComboOrderValue] > '';
    COMMIT TRANSACTION;

    ----------------------------------------------
    -- Re-enable trigger on table being updated
    ----------------------------------------------
    ALTER TABLE [dbo].[Trans] ENABLE TRIGGER ALL;
    ALTER TABLE [dbo].[PciAuditLog] ENABLE TRIGGER ALL;
    ALTER TABLE [dbo].[UserMain] ENABLE TRIGGER ALL;

    -- Drop look-up tables no longer needed
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'DictionaryLookupForEncryption_Trans_CSC') 
        DROP TABLE [dbo].[DictionaryLookupForEncryption_Trans_CSC];
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'DictionaryLookupForEncryption_Trans_CCNumber') 
        DROP TABLE [dbo].[DictionaryLookupForEncryption_Trans_CCNumber];
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'DictionaryLookupForEncryption_Trans_CCExpire') 
        DROP TABLE [dbo].[DictionaryLookupForEncryption_Trans_CCExpire];
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'DictionaryLookupForEncryption_Orders_PayNumber') 
        DROP TABLE [dbo].[DictionaryLookupForEncryption_Orders_PayNumber];
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'DictionaryLookupForEncryption_Orders_CSC') 
        DROP TABLE [dbo].[DictionaryLookupForEncryption_Orders_CSC];
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'DictionaryLookupForEncryption_Orders_CCExpires') 
        DROP TABLE [dbo].[DictionaryLookupForEncryption_Orders_CCExpires];
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'DictionaryLookupForEncryption_OrderPayments_PayNumber') 
        DROP TABLE [dbo].[DictionaryLookupForEncryption_OrderPayments_PayNumber];
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'DictionaryLookupForEncryption_OrderPayments_CSC') 
        DROP TABLE [dbo].[DictionaryLookupForEncryption_OrderPayments_CSC];
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'DictionaryLookupForEncryption_OrderPayments_CCExpires') 
        DROP TABLE [dbo].[DictionaryLookupForEncryption_OrderPayments_CCExpires];
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'DictionaryLookupForEncryption_BasketPayment_PayNumber') 
        DROP TABLE [dbo].[DictionaryLookupForEncryption_BasketPayment_PayNumber];
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'DictionaryLookupForEncryption_BasketPayment_CSC') 
        DROP TABLE [dbo].[DictionaryLookupForEncryption_BasketPayment_CSC];
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'DictionaryLookupForEncryption_BasketPayment_CCExpires') 
        DROP TABLE [dbo].[DictionaryLookupForEncryption_BasketPayment_CCExpires];
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'DictionaryLookupForEncryption_PciAuditLog_CCNumber') 
        DROP TABLE [dbo].[DictionaryLookupForEncryption_PciAuditLog_CCNumber];
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'DictionaryLookupForEncryption_UserMain_MultiFactorInfo') 
        DROP TABLE [dbo].[DictionaryLookupForEncryption_UserMain_MultiFactorInfo];
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'DictionaryLookupForEncryption_CCAuthAcct_CCAuthPassword') 
        DROP TABLE [dbo].[DictionaryLookupForEncryption_CCAuthAcct_CCAuthPassword];
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'DictionaryLookupForEncryption_SystemConfigXml_ConfigValue') 
        DROP TABLE [dbo].[DictionaryLookupForEncryption_SystemConfigXml_ConfigValue];
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'DictionaryLookupForEncryption_Cart_ComboOrder') 
        DROP TABLE [dbo].[DictionaryLookupForEncryption_Cart_ComboOrder];

END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AsiGPSAnnualReportPivot]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[AsiGPSAnnualReportPivot]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

--------------------------------------------------------------
-- Create AsiGPSAnnualReportPivot table and populate with defaults
--------------------------------------------------------------
CREATE PROCEDURE [dbo].[AsiGPSAnnualReportPivot]
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @now datetime;
    SELECT @now = dbo.asi_GetAppDatetime();
    ;WITH PivotData AS (
            SELECT YEAR(P.PeriodEnd) AS [Year],
                   Ref.AsiGPSMeasureDesc AS MeasureDescription,
                   P.MeasureName,
                   P.MeasureValue,
                   P.SerialNo,
                   Goal.MeasureName AS GoalMeasureName, Goal.MeasureValue AS GoalMeasureValue,
                   Goal.SerialNo AS GoalSerialNo, Goal.PeriodEnd AS GoalPeriodEnd,
                   CASE  WHEN Goal.MeasureValue <> 0 THEN P.MeasureValue/Goal.MeasureValue END AS GoalPercentage,
                   CASE  WHEN Goal.MeasureValue <> 0 AND P.MeasureValue/Goal.MeasureValue >= .95 THEN 'Green'
                         WHEN Goal.MeasureValue <> 0 AND .90 <= P.MeasureValue/Goal.MeasureValue AND P.MeasureValue/Goal.MeasureValue < .95 THEN 'Yellow'
                         WHEN Goal.MeasureValue <> 0 AND .90 > P.MeasureValue/Goal.MeasureValue THEN 'Red'
                         ELSE 'Gray'
                    END AS GoalColor,
                   Industry.MeasureName AS IndustryMeasureName, Industry.MeasureValue AS IndustryMeasureValue,
                   Industry.SerialNo AS IndustrySerialNo, Industry.PeriodEnd AS IndustryPeriodEnd,
                   CASE  WHEN Industry.MeasureValue <> 0 THEN P.MeasureValue/Industry.MeasureValue END AS IndustryPercentage,
                   CASE  WHEN Industry.MeasureValue <> 0 AND P.MeasureValue/Industry.MeasureValue >= .95 THEN 'Green'
                         WHEN Industry.MeasureValue <> 0 AND .90 <= P.MeasureValue/Industry.MeasureValue AND P.MeasureValue/Industry.MeasureValue < .95 THEN 'Yellow'
                         WHEN Industry.MeasureValue <> 0 AND .90 > P.MeasureValue/Industry.MeasureValue THEN 'Red'
                         ELSE 'Gray'
                    END AS IndustryColor
             FROM AsiGPSPivotData P                    
                  INNER JOIN AsiGPSMeasureRef Ref ON P.MeasureName = Ref.AsiGPSMeasureName AND Ref.IsActive = 1
                  LEFT OUTER JOIN (SELECT     *
                                   FROM       AsiGPSPivotData
                                   WHERE      RowType = 'OrgGoal' -- Goal
                                   AND        YEAR(PeriodEnd)= YEAR(@now)-1) Goal 
                      ON P.MeasureName = Goal.MeasureName AND YEAR(P.PeriodEnd) = YEAR(Goal.PeriodEnd)
                  LEFT OUTER JOIN (SELECT     *
                                   FROM       AsiGPSPivotData
                                   WHERE      RowType = 'Industry' -- Industry
                                   AND        YEAR(PeriodEnd)= YEAR(@now)-1) Industry 
                      ON P.MeasureName = Industry.MeasureName
                      AND YEAR(P.PeriodEnd) = YEAR(Industry.PeriodEnd)                        
            WHERE P.RowType = 'Organization' AND Ref.IsActive = 1
            GROUP BY YEAR(P.PeriodEnd),
                     Ref.AsiGPSMeasureDesc,
                     P.MeasureName,
                     P.MeasureValue,
                     P.SerialNo,
                     Goal.MeasureName, 
                     Goal.MeasureValue,
                     Goal.SerialNo, 
                     Goal.PeriodEnd,
                     CASE  WHEN Goal.MeasureValue <> 0 THEN P.MeasureValue/Goal.MeasureValue END,
                     CASE  WHEN Goal.MeasureValue <> 0 AND P.MeasureValue/Goal.MeasureValue >= .95 THEN 'Green'
                           WHEN Goal.MeasureValue <> 0 AND .90 <= P.MeasureValue/Goal.MeasureValue AND P.MeasureValue/Goal.MeasureValue < .95 THEN 'Yellow'
                           WHEN Goal.MeasureValue <> 0 AND .90 > P.MeasureValue/Goal.MeasureValue THEN 'Red'
                           ELSE 'Gray'
                      END,
                     Industry.MeasureName, Industry.MeasureValue,
                     Industry.SerialNo, Industry.PeriodEnd,
                     CASE  WHEN Industry.MeasureValue <> 0 THEN P.MeasureValue/Industry.MeasureValue END,
                     CASE  WHEN Industry.MeasureValue <> 0 AND P.MeasureValue/Industry.MeasureValue >= .95 THEN 'Green'
                           WHEN Industry.MeasureValue <> 0 AND .90 <= P.MeasureValue/Industry.MeasureValue AND P.MeasureValue/Industry.MeasureValue < .95 THEN 'Yellow'
                           WHEN Industry.MeasureValue <> 0 AND .90 > P.MeasureValue/Industry.MeasureValue THEN 'Red'
                           ELSE 'Gray'
                      END
    ) 
       SELECT MeasureDescription, MeasureName, SerialNo,
         MAX(CASE [Year] WHEN YEAR(@now)-3 THEN MeasureValue END) [3],
         MAX(CASE [Year] WHEN YEAR(@now)-2 THEN MeasureValue END) [2],
         MAX(CASE [Year] WHEN YEAR(@now)-1 THEN MeasureValue END) [1],
         MAX(CASE [Year] WHEN YEAR(@now)-1 THEN GoalMeasureValue END) [Goal],
         MAX(CASE [Year] WHEN YEAR(@now)-1 THEN GoalPercentage END) [GoalPercentage],
         MAX(CASE [Year] WHEN YEAR(@now)-1 THEN GoalColor END) [GoalColor],
         MAX(CASE [Year] WHEN YEAR(@now)-1 THEN IndustryMeasureValue END) [Industry],
         MAX(CASE [Year] WHEN YEAR(@now)-1 THEN IndustryPercentage END) [IndustryPercentage],
         MAX(CASE [Year] WHEN YEAR(@now)-1 THEN IndustryColor END) [IndustryColor]
      FROM PivotData
       GROUP BY MeasureDescription, MeasureName, SerialNo
 
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AsiGPSAnnualUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[AsiGPSAnnualUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

----------------------------------------------------------------
-- Alter AsiGPSAnnualUpdate SP that currently exists on Gold DB
----------------------------------------------------------------
CREATE PROCEDURE [dbo].[AsiGPSAnnualUpdate] (@ThisYear nvarchar(4) = '', @ReCalculate bit = 0) 
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @now datetime;
    SELECT @now = dbo.asi_GetAppDatetime();
    
-- Testing block
-- DECLARE @ThisYear nvarchar(4) = '2013',
--         @ReCalculate bit = 0

    ------------------------------------------------------------------------------------------------------------
    -- The following declaration defines the ActivityType codes that are considered as Financial Activities.  --
    -- Modify this list as needed to reflect any custom ActivityTypes.                                        --
    --    NOTE: Be sure to separate each new value with a comma and keep within the outer quotes              --
    ------------------------------------------------------------------------------------------------------------
    DECLARE @FinancialActivities  varchar(8000);
    SET @FinancialActivities  = 'CEU,DUES,EXPO,GIFT,MEETFUNC,MEETING,ORDER,PLEDGE,REFUND,REQUEST,SALES';

        -- Validate query
        -- SELECT @FinancialActivities

    DECLARE @PrevYearNewMbrs    TABLE (Id varchar(10) NOT NULL, 
                                       JoinDate datetime, 
                                       PaidThru datetime, 
                                       MemberStatus varchar(5) NOT NULL, 
                                       MemberStatusDate datetime)
    DECLARE @CurrYearNewMbrs    TABLE (Id varchar(10) NOT NULL, 
                                       JoinDate datetime, 
                                       PaidThru datetime, 
                                       MemberStatus varchar(5) NOT NULL, 
                                       MemberStatusDate datetime)
    DECLARE @PrevYrNonFinAct    TABLE (Id varchar(10) NOT NULL, 
                                       Seqn int, 
                                       RowType varchar(10), 
                                       RelatedSeqn int, 
                                       KeyValue varchar(255) NULL)
    DECLARE @CurrYrNonFinAct    TABLE (Id varchar(10) NOT NULL, 
                                       Seqn int, 
                                       RowType varchar(10), 
                                       RelatedSeqn int, 
                                       KeyValue varchar(255) NULL)
    DECLARE @PrevYrFinAct       TABLE (Id varchar(10) NOT NULL, 
                                       Seqn int, 
                                       RowType varchar(10), 
                                       RelatedSeqn int, 
                                       KeyValue varchar(255) NULL)
    DECLARE @CurrYrFinAct       TABLE (Id varchar(10) NOT NULL, 
                                       Seqn int, 
                                       RowType varchar(10), 
                                       RelatedSeqn int, 
                                       KeyValue varchar(255) NULL)
    DECLARE @EventRegsCurrYear  TABLE (Id varchar(10) NOT NULL, 
                                       Seqn int, 
                                       RowType varchar(10), 
                                       RelatedSeqn int, 
                                       KeyValue varchar(255) NULL)

    DECLARE @RunDate            datetime,
            @PrevFiscalBegin    datetime,
            @PrevFiscalEnd      datetime,
            @CurrFiscalBegin    datetime,
            @CurrFiscalEnd      datetime,
            @FiscalBegin        int,
            @CurrYear           int,
            @CurrYearText       varchar(4),
            @SerialNo           varchar(255),
            @PrevYearMembers    int,
            @CurrMembers        int,
            @NewMbrPrevYear     int,
            @NewMbrPrevYTD      int,             -- Not Yet Implemented
            @NewMbrCurrYear     int,
            @NewMbrPct          decimal(18,9),
            @RenewMbrCurrYear   int,
            @RenewBillCurrYear  int,
            @RenewRateCurrYr    decimal(18,9),
            @NewUserPrevYear    int,
            @NewUserPrevYTD     int,             -- Not Yet Implemented
            @NewUserCurrYear    int,
            @NewUserPct         decimal(18,9),
            @PrevYrNewRenew     int,
            @PrevYrNewRenewPct  decimal(18,9),
            @NonFinActPrevYr    int,
            @NonFinActCurrYr    int,
            @FinActPrevYr       int,
            @FinActCurrYr       int,
            @CmteActPrevYr      int,             -- Not Yet Implemented
            @CmteActCurrYr      int,
            @WebVisitsPrevYr    int,             -- Not Yet Implemented
            @WebVisitsCurrYr    int,             -- Not Yet Implemented
            @EmailsPrevYr       int,             -- Not Yet Implemented
            @EmailsCurrYr       int,
            @LettersPrevYr      int,             -- Not Yet Implemented
            @LettersCurrYr      int,
            @NonFinActPerMbr    decimal(18,9),
            @FinActPerMbr       decimal(18,9),
            @CmteActPerMbr      decimal(18,9),
            @WebVisitsPerMbr    decimal(18,9),   -- Not Yet Implemented
            @EmailsPerMbr       decimal(18,9),
            @LettersPerMbr      decimal(18,9),
            @EventRegCurrYr     int,
            @AvgEventReg        decimal(18,9),
            @PrevYrAvgEventReg  decimal(18,9),
            @AvgEventRegIncreasePct     decimal(18,9),
            @PrevYearExists     bit,
            @MbrIncreasePct     decimal(18,9),
            @PrevYearRevenue    money,
            @TotalRevenue       money,
            @RevenueIncreasePct decimal(18,9),
            @RevenuePerMember   decimal(18,9),
            @IndexRecruit       decimal(18,9),
            @IndexEngage        decimal(18,9),
            @IndexGrow          decimal(18,9),
            @IndexOverall       decimal(18,9)

    SET @PrevYearExists = 0;
    SET @WebVisitsPerMbr = NULL;
            
    ---------------------------------------------------
    -- Establish the date that this procedure is run --
    ---------------------------------------------------
    SET @RunDate = @now
        
    -------------------------------------------------------------------------
    -- Establish the date ranges for the previous and current Fiscal Years --
    -------------------------------------------------------------------------
    SET @FiscalBegin = 
        CASE WHEN EXISTS(SELECT * FROM System_Params WHERE ParameterName = 'AR_Control.YearBegins') 
            THEN (SELECT ShortValue FROM System_Params WHERE ParameterName = 'AR_Control.YearBegins')
            ELSE 1
        END;

    SET @CurrFiscalBegin = 
    CASE WHEN @ThisYear > '' THEN CAST(@ThisYear + '-' + CAST(@FiscalBegin AS VARCHAR(2)) + '-1' AS datetime)
         WHEN MONTH(@now) >= @FiscalBegin THEN CAST(CAST(YEAR(@now) AS VARCHAR) + '-' + CAST(@FiscalBegin AS VARCHAR(2)) + '-1' AS datetime)
         WHEN MONTH(@now) <  @FiscalBegin THEN CAST(CAST(YEAR(@now)-1 AS VARCHAR) + '-' + CAST(MONTH(@now) AS VARCHAR(2)) + '-1' AS datetime)
    END;
    
    SET @CurrFiscalEnd = DATEADD(DAY,-1,DATEADD(YEAR,1,@CurrFiscalBegin))
    SET @PrevFiscalBegin = DATEADD(YEAR,-1,@CurrFiscalBegin)
    SET @PrevFiscalEnd = DATEADD(YEAR,-1,@CurrFiscalEnd)
    SET @CurrYear = YEAR(@CurrFiscalEnd)                       -- 12/4/2012 JHS: Added
    SET @CurrYearText = CAST(@CurrYear AS varchar(4))          -- 12/4/2012 JHS: Added

    -- Determine whether data exists for previous fiscal year --
    IF EXISTS (SELECT 1 FROM AsiGPSData WHERE PeriodBegin = @PrevFiscalBegin) 
        SET @PrevYearExists = 1

    -- Validation query
    -- SELECT @FiscalBegin , @CurrFiscalBegin , @CurrFiscalEnd , @PrevFiscalBegin , @PrevFiscalEnd

    -------------------------------------------------
    -- Delete existing rows if ReCalculate is True --
    -------------------------------------------------
    IF EXISTS (SELECT 1 FROM AsiGPSData WHERE PeriodBegin = @CurrFiscalBegin) AND @ReCalculate <> 0
      BEGIN
        DELETE AsiGPSData WHERE PeriodBegin = @CurrFiscalBegin 
        DELETE AsiGPSPivotData WHERE PeriodBegin = @CurrFiscalBegin AND RowType = 'Organization'
      END
    --ELSE IF EXISTS (SELECT 1 FROM AsiGPSData WHERE PeriodBegin = @CurrFiscalBegin) AND @ReCalculate = 0
    --  BEGIN
    --    RETURN 2 -- Exit and return a value of 2 which indicates that data for the specified year already exists
    --  END

    ------------------------------------
    -- Identify License Serial Number --
    ------------------------------------
    SELECT  @SerialNo = ShortValue FROM System_Params WHERE ParameterName = 'System_Control.SerialNo'
        
    -------------------------------
    -- Count all current members --
    -------------------------------
    SELECT @CurrMembers = COUNT(n.ID)
      FROM Name n  LEFT JOIN Member_Types mt ON n.MEMBER_TYPE = mt.MEMBER_TYPE 
     WHERE mt.MEMBER_RECORD <> 0 -- 2574

    -- Validation query
    -- SELECT @CurrMembers 

    -----------------------------
    -- BEGIN SECTION   RECRUIT --
    -----------------------------

    ------------------------------------------
    -- Calculate New Members By Fiscal Year --
    ------------------------------------------

    -- Previous Fiscal Year --
    INSERT INTO @PrevYearNewMbrs(Id, JoinDate, PaidThru, MemberStatus, MemberStatusDate)
     SELECT ID, JOIN_DATE, PAID_THRU, MEMBER_STATUS, MEMBER_STATUS_DATE
       FROM Name 
      WHERE JOIN_DATE >= @PrevFiscalBegin 
        AND JOIN_DATE <= @PrevFiscalEnd 

    -- Validate query
    -- SELECT * FROM @PrevYearNewMbrs

    SELECT @NewMbrPrevYear = COUNT(Id) 
      FROM @PrevYearNewMbrs 

    -- Validate query
    -- SELECT @NewMbrPrevYear
 
    SELECT @NewMbrPrevYTD = COUNT(Id) FROM @PrevYearNewMbrs
     WHERE JoinDate <= DATEADD(YEAR,-1,@now)

    -- Current Fiscal Year --
    INSERT INTO @CurrYearNewMbrs(Id, JoinDate, PaidThru, MemberStatus, MemberStatusDate)
     SELECT ID, JOIN_DATE, PAID_THRU, MEMBER_STATUS, MEMBER_STATUS_DATE
       FROM Name 
      WHERE JOIN_DATE >= @CurrFiscalBegin 
        AND JOIN_DATE <= @CurrFiscalEnd 

    -- Validate query
    -- SELECT * FROM @CurrYearNewMbrs

    SELECT @NewMbrCurrYear = COUNT(Id) FROM @CurrYearNewMbrs 

    -- Validate query
    -- SELECT @NewMbrPrevYear , @NewMbrPrevYTD , @NewMbrCurrYear

    -------------------------------------------------       ---------------
    -- Calculate New Members as Pct of All Members --       -- RECRUIT-1 --
    -------------------------------------------------       ---------------
    SELECT @NewMbrPct = 
        CASE WHEN @CurrMembers > 0 
            THEN CAST(@NewMbrCurrYear AS decimal(18,9))/CAST(@CurrMembers AS decimal(18,9))
            ELSE NULL
        END

    -- Validate query
    -- SELECT @NewMbrPct

    -----------------------------------                     ---------------
    -- Calculate Conversion Renewals --                     -- RECRUIT-2 --
    -----------------------------------                     ---------------
    SELECT @PrevYrNewRenew = COUNT(n.ID)
      FROM Name n
           JOIN @PrevYearNewMbrs p  ON n.ID = p.Id
     WHERE n.MEMBER_STATUS = 'R'

    -- Validate query
    -- SELECT @PrevYrNewRenew 

    SELECT @PrevYrNewRenewPct = 
        CASE WHEN @NewMbrPrevYear > 0 
            THEN CAST(@PrevYrNewRenew AS decimal(18,9))/CAST(@NewMbrPrevYear AS decimal(18,9))
            ELSE NULL
        END

    -- Validate query
    -- SELECT @PrevYrNewRenewPct

    ----------------------------------------
    -- Calculate New Users By Fiscal Year --
    ----------------------------------------

    -- Previous Fiscal Year --
    SELECT @NewUserPrevYear = COUNT(UserId) FROM UserMain 
     WHERE CreatedOn >= @PrevFiscalBegin 
       AND CreatedOn <= @PrevFiscalEnd 

    SELECT @NewUserPrevYTD = COUNT(UserId) FROM UserMain
     WHERE CreatedOn >= @PrevFiscalBegin
       AND CreatedOn <= DATEADD(YEAR,-1,@now)
       
    -- Current Fiscal Year --
    SELECT @NewUserCurrYear = COUNT(UserId) FROM UserMain 
     WHERE CreatedOn >= @CurrFiscalBegin 
       AND CreatedOn <= @CurrFiscalEnd 

    -- Validate query
    -- SELECT @NewUserPrevYear , @NewUserPrevYTD , @NewUserCurrYear

    -----------------------------------------------             ---------------
    -- Calculate New Users as Pct of All Members --             -- RECRUIT-3 --
    -----------------------------------------------             ---------------
    SELECT @NewUserPct = 
        CASE WHEN @CurrMembers > 0 
            THEN CAST(@NewUserCurrYear AS decimal(18,9))/CAST(@CurrMembers AS decimal(18,9))
            ELSE NULL
        END
    ----------------------------
    -- BEGIN SECTION   ENGAGE --
    ----------------------------

    -----------------------------------------
    -- Calculate Activities By Fiscal Year --
    -----------------------------------------

    -- Previous Fiscal Year --
    -- Identify Non-Financial Activities --
    INSERT INTO @PrevYrNonFinAct(Id, Seqn, RowType, RelatedSeqn)
     SELECT ID, SEQN, ACTIVITY_TYPE, ORIGINATING_TRANS_NUM
       FROM Activity a
            LEFT OUTER JOIN dbo.asi_SplitString(@FinancialActivities, ',') exc ON a.ACTIVITY_TYPE = exc.Element
      WHERE TRANSACTION_DATE >= @PrevFiscalBegin 
        AND TRANSACTION_DATE <= @PrevFiscalEnd 
        AND exc.Element IS NULL

     SELECT @NonFinActPrevYr = COUNT(Seqn) FROM @PrevYrNonFinAct

    -- Identify Financial Activities --             
    INSERT INTO @PrevYrFinAct(Id, Seqn, RowType, RelatedSeqn)
     SELECT ID, SEQN, ACTIVITY_TYPE, ORIGINATING_TRANS_NUM
       FROM Activity a
            LEFT OUTER JOIN dbo.asi_SplitString(@FinancialActivities, ',') inc ON a.ACTIVITY_TYPE = inc.Element
      WHERE TRANSACTION_DATE >= @PrevFiscalBegin 
        AND TRANSACTION_DATE <= @PrevFiscalEnd 
        AND inc.Element IS NOT NULL

     SELECT @FinActPrevYr = COUNT(Seqn) FROM @PrevYrFinAct

    -- Current Fiscal Year --
    -- Identify Non-Financial Activities --
    INSERT INTO @CurrYrNonFinAct(Id, Seqn, RowType, RelatedSeqn)
     SELECT ID, SEQN, ACTIVITY_TYPE, ORIGINATING_TRANS_NUM
       FROM Activity a
            LEFT OUTER JOIN dbo.asi_SplitString(@FinancialActivities, ',') exc ON a.ACTIVITY_TYPE = exc.Element
      WHERE TRANSACTION_DATE >= @CurrFiscalBegin 
        AND TRANSACTION_DATE <= @CurrFiscalEnd 
        AND exc.Element IS NULL

     SELECT @NonFinActCurrYr = COUNT(Seqn) FROM @CurrYrNonFinAct

    -- Identify Financial Activities --             
    INSERT INTO @CurrYrFinAct(Id, Seqn, RowType, RelatedSeqn)
     SELECT ID, SEQN, ACTIVITY_TYPE, ORIGINATING_TRANS_NUM 
       FROM Activity a
           LEFT OUTER JOIN dbo.asi_SplitString(@FinancialActivities, ',') inc ON a.ACTIVITY_TYPE = inc.Element 
      WHERE TRANSACTION_DATE >= @CurrFiscalBegin 
        AND TRANSACTION_DATE <= @CurrFiscalEnd 
        AND inc.Element IS NOT NULL

     SELECT @FinActCurrYr = COUNT(Seqn) FROM @CurrYrFinAct

    -- Identify Committee Activities --
    SELECT @CmteActCurrYr = COUNT(Seqn) FROM @CurrYrNonFinAct 
     WHERE RowType = 'COMMITTEE'
    
    SELECT @CmteActPerMbr = 
     CASE WHEN @CurrMembers > 0 
         THEN CAST(@CmteActCurrYr AS decimal(18,9))/CAST(@CurrMembers AS decimal(18,9))
         ELSE NULL
     END
    
    -- Identify Email Activities --
    SELECT @EmailsCurrYr = COUNT(Seqn) FROM @CurrYrNonFinAct 
     WHERE RowType = 'EMAIL'
    
    SELECT @EmailsPerMbr = 
     CASE WHEN @CurrMembers > 0 
         THEN CAST(@EmailsCurrYr AS decimal(18,9))/CAST(@CurrMembers AS decimal(18,9))
         ELSE NULL
     END
    
     -- TODO: Calculate and include emails from Marketing Suite

    -- Identify Letter Activities --
    SELECT @LettersCurrYr = COUNT(Seqn) FROM @CurrYrNonFinAct 
     WHERE RowType = 'LETTER'
    
    SELECT @LettersPerMbr = 
     CASE WHEN @CurrMembers > 0 
         THEN CAST(@LettersCurrYr AS decimal(18,9))/CAST(@CurrMembers AS decimal(18,9))
         ELSE NULL
     END

     -- TODO: Calculate and include letters from Marketing Suite

    -- Validate query
    -- SELECT @NonFinActPrevYr, @FinActPrevYr, @NonFinActCurrYr, @FinActCurrYr, @CmteActCurrYr, @EmailsCurrYr, @LettersCurrYr

    ---------------------------                             ---------------------
    -- Activities per Member --                             -- ENGAGE-1 THRU 6 --
    ---------------------------                             ---------------------
    SELECT @NonFinActPerMbr = 
     CASE WHEN @CurrMembers > 0 
         THEN CAST(@NonFinActCurrYr AS decimal(18,9))/CAST(@CurrMembers AS decimal(18,9))
         ELSE NULL
     END
    SELECT @FinActPerMbr = 
     CASE WHEN @CurrMembers > 0 
         THEN CAST(@FinActCurrYr AS decimal(18,9))/CAST(@CurrMembers AS decimal(18,9))
         ELSE NULL
     END
    SELECT @CmteActPerMbr = 
     CASE WHEN @CurrMembers > 0 
         THEN CAST(@CmteActCurrYr AS decimal(18,9))/CAST(@CurrMembers AS decimal(18,9))
         ELSE NULL
     END
    SELECT @WebVisitsPerMbr = 
     CASE WHEN @CurrMembers > 0 
         THEN CAST(@WebVisitsPrevYr AS decimal(18,9))/CAST(@CurrMembers AS decimal(18,9))
         ELSE NULL
     END
    SELECT @EmailsPerMbr = 
     CASE WHEN @CurrMembers > 0 
         THEN CAST(@EmailsCurrYr AS decimal(18,9))/CAST(@CurrMembers AS decimal(18,9))
         ELSE NULL
     END
    SELECT @LettersPerMbr = 
     CASE WHEN @CurrMembers > 0 
         THEN CAST(@LettersCurrYr AS decimal(18,9))/CAST(@CurrMembers AS decimal(18,9))
         ELSE NULL
     END
    
     -- Validate query
     -- SELECT @NonFinActPerMbr, @FinActPerMbr, @CmteActPerMbr, @EmailsPerMbr, @LettersPerMbr
             
    --------------------------
    -- BEGIN SECTION GROW --
    --------------------------

    -----------------------------------------                   ------------
    -- Calculate Current Year Renewal Rate --                   -- GROW-1 --
    -----------------------------------------                   ------------
    -- Calculate Renewals in the Current Year --
    SELECT @RenewMbrCurrYear = COUNT(ID)
      FROM Name
     WHERE MEMBER_STATUS = 'R'
       AND MEMBER_STATUS_DATE >= @CurrFiscalBegin
       AND MEMBER_STATUS_DATE <= @CurrFiscalEnd
        
    -- Calculate Renewal Billings in the Current Year --
    SELECT @RenewBillCurrYear = COUNT(DISTINCT(ID))
      FROM Subscriptions
     WHERE BILL_BEGIN >= @CurrFiscalBegin
       AND BILL_BEGIN <= @CurrFiscalEnd

    --
    SELECT @RenewRateCurrYr = 
        CASE WHEN @RenewBillCurrYear > 0 
            THEN CAST(@RenewMbrCurrYear AS decimal(18,9))/CAST(@RenewBillCurrYear AS decimal(18,9))
            ELSE NULL
        END
        
     -- Validate query
     -- SELECT @RenewRateCurrYr

 
    ----------------------------------------                ------------
    -- Calculate Registrations Per Member --                -- GROW-2 --
    ----------------------------------------                ------------
    -- Identify Open Registrations within the current fiscal year
    INSERT INTO @EventRegsCurrYear(Id, Seqn, RowType, RelatedSeqn, KeyValue)
        SELECT o.ST_ID, o.ORDER_NUMBER, 'OrderLine', o.ORIGINATING_TRANS_NUM,
               o.ST_ID + '/' + ol.PRODUCT_CODE
          FROM Orders o LEFT OUTER JOIN Order_Lines ol ON o.ORDER_NUMBER = ol.ORDER_NUMBER 
                        LEFT OUTER JOIN Product_Function pf ON ol.PRODUCT_CODE = pf.PRODUCT_CODE
                        LEFT OUTER JOIN Meet_Master m ON pf.PRODUCT_CODE LIKE m.MEETING + '/%'
         WHERE (pf.IS_EVENT_REGISTRATION_OPTION <> 0 OR pf.PRODUCT_CODE LIKE '%/MAIN')
           AND o.ORDER_DATE >= @CurrFiscalBegin
           AND o.ORDER_DATE <= @CurrFiscalEnd

    -- Calculate the Total Registrations for the current fiscal year
    SELECT @EventRegCurrYr = COUNT(Id) FROM @EventRegsCurrYear 

    -- Calculate the average of Event Registrations for the Current Year per Total Members
    SELECT  @AvgEventReg = 
        CASE WHEN @CurrMembers > 0 
            THEN CAST(@EventRegCurrYr AS decimal(18,9))/CAST(@CurrMembers AS decimal(18,9))
            ELSE NULL
        END

    -----------------------------------                     ------------
    -- Calculate Increase in Members --                     -- GROW-3 --
    -----------------------------------                     ------------
    -- Retrieve Previous Year Total Members
    SELECT @PrevYearMembers =
        CASE
            WHEN @PrevYearExists <> 0 THEN (SELECT TotalMembers FROM AsiGPSData WHERE PeriodBegin = @PrevFiscalBegin)
            ELSE 0
        END

    -- Calculate Current Year Increase of Total Members over Previous Year
    SELECT  @MbrIncreasePct =
        CASE
            WHEN @PrevYearExists = 0 THEN NULL
            WHEN @PrevYearMembers <> 0 THEN ((CAST(@CurrMembers AS DECIMAL(18,9)) - CAST(@PrevYearMembers AS DECIMAL(18,9)))/CAST(@PrevYearMembers AS DECIMAL(18,9)))
            ELSE NULL
        END

        -- Validate query
        -- SELECT @PrevFiscalBegin, @PrevYearExists, @PrevYearMembers, @CurrFiscalBegin, @CurrMembers, @MbrIncreasePct, @MbrIncreasePct * 100

    --------------------------------                        ------------
    -- Calculate Revenue Increase --                        -- GROW-4 --
    --------------------------------                        ------------
    -- Retrieve Previous Year Total Revenue
    SELECT @PrevYearRevenue =
        CASE
            WHEN @PrevYearExists <> 0 THEN (SELECT TotalRevenue FROM AsiGPSData WHERE PeriodBegin = @PrevFiscalBegin)
            ELSE 0
        END

    -- Calculate Current Yerar Total Revenue
    SELECT @TotalRevenue = ABS(SUM(AMOUNT))
      FROM Trans
     WHERE TRANSACTION_TYPE = 'DIST'
       AND TRANSACTION_DATE >= @CurrFiscalBegin
       AND TRANSACTION_DATE <= @CurrFiscalEnd

    -- Calculate Total Revenue per Member
    SELECT @RevenuePerMember =
        CASE WHEN @CurrMembers <> 0 
            THEN CAST(@TotalRevenue AS decimal(18,9))/CAST(@CurrMembers AS decimal(18,9))
            ELSE NULL
        END

    -- Calculate Current Year Increase of Total Revenue over Previous Year
    SELECT  @RevenueIncreasePct =
        CASE
            WHEN @PrevYearExists = 0 THEN NULL
            WHEN @PrevYearRevenue <> 0 THEN ((@TotalRevenue - @PrevYearRevenue)/@PrevYearRevenue)
            ELSE NULL
        END

        -- Validate query
        -- SELECT @PrevYearRevenue, @TotalRevenue, @RevenuePerMember, @RevenueIncreasePct


    ------------------------------------------
    -- Convert percentages to whole numbers --
    ------------------------------------------
    SET @NewMbrPct = @NewMbrPct * 100
    SET @PrevYrNewRenewPct = @PrevYrNewRenewPct * 100
    SET @NewUserPct = @NewUserPct * 100
    SET @MbrIncreasePct = @MbrIncreasePct * 100
    SET @RevenueIncreasePct = @RevenueIncreasePct * 100
    SET @AvgEventRegIncreasePct = @AvgEventRegIncreasePct * 100

    ----------------------------
    -- Calculate Index values --
    ----------------------------
    SELECT @IndexRecruit = (@NewMbrPct + @PrevYrNewRenewPct + @NewUserPct)
    SELECT @IndexEngage = (@NonFinActPerMbr + @FinActPerMbr + @CmteActPerMbr + ISNULL(@WebVisitsPerMbr,0) + @EmailsPerMbr + @LettersPerMbr) * 100
    SELECT @IndexGrow = (@RenewRateCurrYr/8 + @AvgEventReg + @MbrIncreasePct + @RevenueIncreasePct) 
    SELECT @IndexOverall = (@IndexRecruit + @IndexEngage + @IndexGrow)/3
    
        -- Validate query
        -- SELECT @RenewRateCurrYr, @AvgEventReg, @MbrIncreasePct, @RevenueIncreasePct
        -- SELECT @IndexRecruit, @IndexEngage, @IndexGrow, @IndexOverall


    ---------------------------------------------------
    -- Populate current year values in Summary Table --
    ---------------------------------------------------
    INSERT AsiGPSData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           TotalRevenue,
           Recruit1,
           Recruit2,
           Recruit3,
           Engage1,
           Engage2,
           Engage3,
           Engage4,
           Engage5,
           Engage6,
           Grow1,
           Grow2,
           Grow3,
           Grow4,
           IndexRecruit,
           IndexEngage,
           IndexGrowth,
           IndexOverallPerformance,
           RunDate,
           SerialNo,
           RowType)
    SELECT @CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @TotalRevenue,
           @NewMbrPct,
           @PrevYrNewRenewPct,
           @NewUserPct,
           @NonFinActPerMbr,
           @FinActPerMbr,
           @CmteActPerMbr,
           @WebVisitsPerMbr,
           @EmailsPerMbr,
           @LettersPerMbr,
           @RenewRateCurrYr,
           @AvgEventReg,
           @MbrIncreasePct,
           @RevenuePerMember,
           @IndexRecruit,
           @IndexEngage,
           @IndexGrow,
           @IndexOverall,
           @RunDate,
           @SerialNo,
           'Organization'
    -------------------------------------------------------
    -- Populate Current Year values in Pivot Data tables --
    -------------------------------------------------------
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @CurrYear,         
           @CurrYearText,     
           'CurrMbr',         
           0,                 
           'CurrentMembers',
           CAST(@CurrMembers AS decimal(18, 9)),
           @RunDate,
           @SerialNo,
           'Organization')
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @CurrYear,         
           @CurrYearText,     
           'Recruit',         
           1,                 
           'Recruit1',
           @NewMbrPct * 100,
           @RunDate,
           @SerialNo,
           'Organization')
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @CurrYear,         
           @CurrYearText,     
           'Recruit',         
           2,                 
           'Recruit2',                      
           @PrevYrNewRenewPct * 100,
           @RunDate,
           @SerialNo,
           'Organization')
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @CurrYear,         
           @CurrYearText,     
           'Recruit',         
           3,                 
           'Recruit3',
           @NewUserPct * 100,
           @RunDate,
           @SerialNo,
           'Organization')
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @CurrYear,         
           @CurrYearText,     
           'Engage',          
           1,                 
           'Engage1',            
           @NonFinActPerMbr,
           @RunDate,
           @SerialNo,
           'Organization')
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @CurrYear,         
           @CurrYearText,     
           'Engage',          
           2,                 
           'Engage2',
           @FinActPerMbr,
           @RunDate,
           @SerialNo,
           'Organization')
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @CurrYear,         
           @CurrYearText,     
           'Engage',          
           3,                 
           'Engage3',
           @CmteActPerMbr,
           @RunDate,
           @SerialNo,
           'Organization')
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @CurrYear,         
           @CurrYearText,     
           'Engage',          
           4,                 
           'Engage4',
           @WebVisitsPerMbr,
           @RunDate,
           @SerialNo,
           'Organization')
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @CurrYear,         
           @CurrYearText,     
           'Engage',          
           5,                 
           'Engage5',
           @EmailsPerMbr,
           @RunDate,
           @SerialNo,
           'Organization')
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @CurrYear,         
           @CurrYearText,     
           'Engage',          
           6,                 
           'Engage6',
           @LettersPerMbr,
           @RunDate,
           @SerialNo,
           'Organization')
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @CurrYear,         
           @CurrYearText,     
           'Grow',            
           1,                 
           'Grow1',
           @RenewRateCurrYr,
           @RunDate,
           @SerialNo,
           'Organization')
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @CurrYear,         
           @CurrYearText,     
           'Grow',            
           2,                 
           'Grow2',
           @AvgEventReg,
           @RunDate,
           @SerialNo,
           'Organization')
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @CurrYear,         
           @CurrYearText,     
           'Grow',            
           3,                 
           'Grow3',
           @MbrIncreasePct,
           @RunDate,
           @SerialNo,
           'Organization')
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @CurrYear,         
           @CurrYearText,     
           'Grow',            
           4,                 
           'Grow4',
           @RevenuePerMember,
           @RunDate,
           @SerialNo,
           'Organization')
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @CurrYear,         
           @CurrYearText,     
           'Index',           
           2,                 
           'IndexRecruit',
           @IndexRecruit,
           @RunDate,
           @SerialNo,
           'Organization')
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @CurrYear,         
           @CurrYearText,     
           'Index',           
           3,                 
           'IndexEngage',
           @IndexEngage,
           @RunDate,
           @SerialNo,
           'Organization')
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @CurrYear,         
           @CurrYearText,     
           'Index',           
           4,                 
           'IndexGrow',
           @IndexGrow,
           @RunDate,
           @SerialNo,
           'Organization')
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @CurrYear,         
           @CurrYearText,     
           'Index',           
           1,                 
           'IndexOverallPerformance',
           @IndexOverall,       
           @RunDate,
           @SerialNo,
           'Organization')   


END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AsiGPSUpdateValues]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[AsiGPSUpdateValues]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

--------------------------------------------------------------
-- Create AsiGPSUpdateValues table and populate with defaults
--------------------------------------------------------------
CREATE PROCEDURE [dbo].[AsiGPSUpdateValues] (
        @DataYear           nvarchar(4),    -- The Year (YYYY) for which the data is being updated
        @RowType            nvarchar(20),   -- VALID VALUES: 'OrgGoal' or 'Industry'
        @CurrMembers        int,
        @NewMbrPct          decimal(18,9),
        @PrevYrNewRenewPct  decimal(18,9),
        @NewUserPct         decimal(18,9),
        @NonFinActPerMbr    decimal(18,9),
        @FinActPerMbr       decimal(18,9),
        @CmteActPerMbr      decimal(18,9),
        @WebVisitsPerMbr    decimal(18,9),  -- NYI
        @EmailsPerMbr       decimal(18,9),
        @LettersPerMbr      decimal(18,9),
        @RenewRateCurrYr    decimal(18,9),
        @EventRegPerMbr     decimal(18,9),
        @MbrIncrease        int,
        @RevenuePerMember   decimal(18,9),
        @IndexRecruit       decimal(18,9),
        @IndexEngage        decimal(18,9),
        @IndexGrow          decimal(18,9),
        @IndexOverall       decimal(18,9)
   ) 
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @RunDate            datetime,
            @ThisYear           int,
            @FiscalBegin        int,
            @ThisFiscalBegin    datetime,
            @ThisFiscalEnd      datetime,
            @ThisDimension      nvarchar(30),
            @SerialNo           varchar(255)

---------------------------------------
-- Establish the dimension being set --
---------------------------------------
    SET @ThisDimension = 
        CASE WHEN @RowType = 'OrgGoal' THEN 'Goal'
             WHEN @RowType = 'Industry' THEN 'Industry'
             ELSE NULL -- Need to stop execution and return an error
        END;

    IF @ThisDimension IS NULL
    BEGIN
        PRINT 'ERROR: Invalid value for @RowType parameter. Valid values = OrgGoal or Industry.'
        RETURN
    END
    ELSE
    BEGIN    

    ---------------------------------------------------
    -- Establish the date that this procedure is run --
    ---------------------------------------------------
    SELECT @RunDate = dbo.asi_GetAppDatetime();
        
    -------------------------------------------------------------------------
    -- Establish the date ranges for the previous and current Fiscal Years --
    -------------------------------------------------------------------------
    SELECT @FiscalBegin = 
        CASE WHEN EXISTS(SELECT * FROM System_Params WHERE ParameterName = 'AR_Control.YearBegins') 
            THEN (SELECT ShortValue FROM System_Params WHERE ParameterName = 'AR_Control.YearBegins')
            ELSE 1
        END;

    SET @ThisYear = CAST(@DataYear AS int)
    
    SET @ThisFiscalBegin = 
        CASE WHEN @FiscalBegin > 1 THEN CAST(CAST(@ThisYear-1 AS varchar(4)) + '-' + CAST(@FiscalBegin AS VARCHAR(2)) + '-1' AS datetime)
             ELSE CAST(@DataYear + '-' + CAST(@FiscalBegin AS VARCHAR(2)) + '-1' AS datetime)
        END;
    
    SET @ThisFiscalEnd = DATEADD(DAY,-1,DATEADD(YEAR,1,@ThisFiscalBegin))

    ------------------------------------
    -- Identify License Serial Number --
    ------------------------------------
    SELECT  @SerialNo = ShortValue FROM System_Params WHERE ParameterName = 'System_Control.SerialNo'

    --------------------------------------------------
    -- Delete Summary Data row if it already exists --
    --------------------------------------------------

    DELETE AsiGPSData
      FROM AsiGPSData a
     WHERE a.PeriodBegin = @ThisFiscalBegin
       AND a.PeriodEnd = @ThisFiscalEnd
       AND a.SerialNo = @SerialNo 
       AND a.RowType = @RowType

    ------------------------------------------------
    -- Delete Pivot Data row if it already exists --
    ------------------------------------------------

    DELETE AsiGPSPivotData
     FROM AsiGPSPivotData a
     WHERE a.DataYear = @ThisYear
       AND a.SerialNo = @SerialNo 
       AND a.RowType = @RowType

    ----------------------------------------------------------
    -- Populate Summary Data with corresponding Goal values --
    ----------------------------------------------------------
    INSERT AsiGPSData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           Recruit1,
           Recruit2,
           Recruit3,
           Engage1,
           Engage2,
           Engage3,
           Engage4,
           Engage5,
           Engage6,
           Grow1,
           Grow2,
           Grow3,
           Grow4,
           IndexRecruit,
           IndexEngage,
           IndexGrowth,
           IndexOverallPerformance,
           RunDate,
           SerialNo,
           RowType)
    SELECT @ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @NewMbrPct,
           @PrevYrNewRenewPct,
           @NewUserPct,
           @NonFinActPerMbr,             
           @FinActPerMbr,             
           @CmteActPerMbr,             
           @WebVisitsPerMbr,
           @EmailsPerMbr,
           @LettersPerMbr,
           @RenewRateCurrYr,
           @EventRegPerMbr,
           @MbrIncrease,
           @RevenuePerMember,
           @IndexRecruit,
           @IndexEngage,
           @IndexGrow,
           @IndexOverall,
           @RunDate,
           @SerialNo,
           @RowType

 
    --------------------------------------------------------
    -- Populate Pivot Data with corresponding Goal values --
    --------------------------------------------------------
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @ThisYear,
           @ThisDimension,
           'CurrMbr',
           0,                 
           'CurrentMembers',
           CAST(@CurrMembers AS decimal(18, 9)),
           @RunDate,
           @SerialNo,
           @RowType)
                  
           -- Recruit Dimensions ------------------------
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @ThisYear,         
           @ThisDimension,            
           'Recruit',         
           1,                 
           'Recruit1',
           @NewMbrPct,
           @RunDate,
           @SerialNo,
           @RowType)
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES         
           (@ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @ThisYear,         
           @ThisDimension,            
           'Recruit',         
           2,                 
           'Recruit2',                      
           @PrevYrNewRenewPct,
           @RunDate,
           @SerialNo,
           @RowType)
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @ThisYear,         
           @ThisDimension,            
           'Recruit',         
           3,                 
           'Recruit3',
           @NewUserPct,
           @RunDate,
           @SerialNo,
           @RowType)
                
           -- Engage Dimensions ------------------------
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @ThisYear,         
           @ThisDimension,            
           'Engage',          
           1,                 
           'Engage1',            
           @NonFinActPerMbr,
           @RunDate,
           @SerialNo,
           @RowType)
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @ThisYear,         
           @ThisDimension,            
           'Engage',          
           2,                 
           'Engage2',
           @FinActPerMbr,
           @RunDate,
           @SerialNo,
           @RowType)        
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @ThisYear,         
           @ThisDimension,            
           'Engage',          
           3,                 
           'Engage3',
           @CmteActPerMbr,
           @RunDate,
           @SerialNo,
           @RowType)
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @ThisYear,         
           @ThisDimension,            
           'Engage',          
           4,                 
           'Engage4',
           @WebVisitsPerMbr,
           @RunDate,
           @SerialNo,
           @RowType)
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @ThisYear,         
           @ThisDimension,            
           'Engage',          
           5,                 
           'Engage5',
           @EmailsPerMbr,
           @RunDate,
           @SerialNo,
           @RowType)
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @ThisYear,         
           @ThisDimension,            
           'Engage',          
           6,                 
           'Engage6',
           @LettersPerMbr,
           @RunDate,
           @SerialNo,
           @RowType)
                  
           -- Grow Dimensions ------------------------
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @ThisYear,         
           @ThisDimension,            
           'Grow',            
           1,                 
           'Grow1',
           @RenewRateCurrYr,
           @RunDate,
           @SerialNo,
           @RowType)
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @ThisYear,         
           @ThisDimension,            
           'Grow',            
           2,                 
           'Grow2',
           @EventRegPerMbr,
           @RunDate,
           @SerialNo,
           @RowType)

    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @ThisYear,         
           @ThisDimension,            
           'Grow',            
           3,                 
           'Grow3',
           @MbrIncrease,
           @RunDate,
           @SerialNo,
           @RowType)       
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @ThisYear,         
           @ThisDimension,            
           'Grow',            
           4,                 
           'Grow4',
           @RevenuePerMember,
           @RunDate,
           @SerialNo,
           @RowType)
           
           -- Index Dimensions ------------------------
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @ThisYear,         
           @ThisDimension,            
           'Index',            
           2,                 
           'IndexRecruit',
           @IndexRecruit,
           @RunDate,
           @SerialNo,
           @RowType)
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @ThisYear,         
           @ThisDimension,            
           'Index',            
           3,                 
           'IndexEngage',
           @IndexEngage,
           @RunDate,
           @SerialNo,
           @RowType)
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @ThisYear,         
           @ThisDimension,            
           'Index',            
           4,                 
           'IndexGrow',
           @IndexGrow,
           @RunDate,
           @SerialNo,
           @RowType)
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @ThisYear,         
           @ThisDimension,            
           'Index',            
           1,                 
           'IndexOverallPerformance',
           @IndexOverall,
           @RunDate,
           @SerialNo,
           @RowType)        

    END
END;


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_AddressUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_AddressUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE  sp_asi_AddressUpdate
 as
 declare
 @addrnum int,
 @ADDRESS_1 varchar(40),
 @ADDRESS_2 varchar(40),
 @ADDRESS_3 varchar(40),
 @CITY varchar(40),
 @STATE_PROVINCE varchar(15),
 @ZIP varchar(10),
 @COUNTRY varchar(25),
 @code int,
 @full_address varchar(255),
 @formula varchar(255),
 @addrlen integer,
 @ID varchar(10),
 @Preferred_Mail integer
 set nocount on
 DECLARE Get_Addrs cursor for 
 select ID,PREFERRED_MAIL,ADDRESS_NUM,ADDRESS_1,ADDRESS_2,ADDRESS_3,CITY,STATE_PROVINCE,ZIP,COUNTRY from Name_Address
 where datalength(ADDRESS_1)>1
 open Get_Addrs
 fetch next from Get_Addrs into @ID,@Preferred_Mail,@addrnum,@ADDRESS_1,@ADDRESS_2,@ADDRESS_3,@CITY,@STATE_PROVINCE,@ZIP,@COUNTRY
 While @@FETCH_STATUS<>-1
 BEGIN
 if  @@FETCH_STATUS <> -2
 BEGIN
 select @code=NULL
 select @code=ADDRESS_FORMAT from Country_Names  where COUNTRY=@COUNTRY
 select @code=isnull(@code,0)
 if @code=0  
 begin  
 if (not exists (select * from Country_Addr_Layouts where ADDRESS_FORMAT=0)) 
 insert into Country_Addr_Layouts (ADDRESS_FORMAT, ADDRESS_LAYOUT, FORMULA) 
 values (0, 'ADDRESS_1[N]ADDRESS_2[N]ADDRESS_3[N]CITY[C][S]STATE_PROVINCE[S]ZIP[N][U]COUNTRY', 
 'ADDRESS_1[N]ADDRESS_2[N]CITY[C][S]STATE_PROVINCE[S]ZIP[N][U]COUNTRY') 
 end 
 begin
 select @formula=FORMULA from Country_Addr_Layouts where ADDRESS_FORMAT=@code
 while charindex('[N]',@formula)>0
 begin
 select @formula=stuff(@formula,charindex('[N]',@formula),3,char(13))
 end
 while charindex('[S]',@formula)>0
 begin
 select @formula=stuff(@formula,charindex('[S]',@formula),3,' ')
 end
 while charindex('[C]',@formula)>0
 begin
 select @formula=stuff(@formula,charindex('[C]',@formula),3,',')
 end
 if charindex('CITY',@formula)>0
 select @formula=stuff(@formula,charindex('CITY',@formula),4,'_CITY') 
 if charindex('ZIP',@formula)>0
 select @formula=stuff(@formula,charindex('ZIP',@formula),3,'_ZIP') 
 if charindex('COUNTRY',@formula)>0
 select @formula=stuff(@formula,charindex('COUNTRY',@formula),7,'_COUNTRY') 
 if charindex('[U]ADDRESS_1',@formula)>0 
 select @formula=stuff(@formula,charindex('[U]ADDRESS_1',@formula),12,upper(@ADDRESS_1)) 
 if charindex('[U]ADDRESS_2',@formula)>0 
 select @formula=stuff(@formula,charindex('[U]ADDRESS_2',@formula),12,upper(@ADDRESS_2)) 
 if charindex('[U]ADDRESS_3',@formula)>0 
 select @formula=stuff(@formula,charindex('[U]ADDRESS_3',@formula),12,upper(@ADDRESS_3))
 if charindex('[U]_CITY',@formula)>0 
   begin
   if charindex('[U]_CITY,',@formula)>0
     begin
     if datalength (@STATE_PROVINCE) = 0  
       select @formula=stuff(@formula,charindex('[U]_CITY,',@formula),9,'[U]_CITY') 
     end
   select @formula=stuff(@formula,charindex('[U]_CITY',@formula),8,upper(@CITY))
   end
 if charindex('[U]STATE_PROVINCE',@formula)>0 
 select @formula=stuff(@formula,charindex('[U]STATE_PROVINCE',@formula),17,upper(@STATE_PROVINCE)) 
 if charindex('[U]_ZIP',@formula)>0 
 select @formula=stuff(@formula,charindex('[U]_ZIP',@formula),7,upper(@ZIP)) 
 if charindex('[U]_COUNTRY',@formula)>0 
 select @formula=stuff(@formula,charindex('[U]_COUNTRY',@formula),11,upper(@COUNTRY)) 
 if charindex('ADDRESS_1',@formula)>0 
   select @formula=stuff(@formula,charindex('ADDRESS_1',@formula),9,@ADDRESS_1) 
 if charindex('ADDRESS_2',@formula)>0 
   select @formula=stuff(@formula,charindex('ADDRESS_2',@formula),9,@ADDRESS_2) 
 if charindex('ADDRESS_3',@formula)>0 
   select @formula=stuff(@formula,charindex('ADDRESS_3',@formula),9,@ADDRESS_3)
 if charindex('_CITY',@formula)>0 
   begin
   if charindex('_CITY,',@formula)>0
     begin
     if datalength (@STATE_PROVINCE) = 0  
       select @formula=stuff(@formula,charindex('_CITY,',@formula),6,'_CITY') 
     end
   select @formula=stuff(@formula,charindex('_CITY',@formula),5,@CITY) 
   end
 if charindex('STATE_PROVINCE',@formula)>0 
 select @formula=stuff(@formula,charindex('STATE_PROVINCE',@formula),14,@STATE_PROVINCE) 
 if charindex('_ZIP',@formula)>0 
 select @formula=stuff(@formula,charindex('_ZIP',@formula),4,@ZIP) 
 if charindex('_COUNTRY',@formula)>0 
 select @formula=stuff(@formula,charindex('_COUNTRY',@formula),8,@COUNTRY) 
 if charindex('US1',@formula)>0 
 select @formula=stuff(@formula,charindex('US1',@formula),3,'') 
 if charindex('US2',@formula)>0 
 select @formula=stuff(@formula,charindex('US2',@formula),3,'') 
 while charindex(char(13)+' ',@formula)>0      
 begin        
 select @formula=stuff(@formula,charindex(char(13)+' ',@formula),2,char(13))      
 end
 while charindex(char(13)+',',@formula)>0      
 begin        
 select @formula=stuff(@formula,charindex(char(13)+',',@formula),2,char(13))      
 end 
 while charindex(char(13)+char(13),@formula)>0      
 begin        
 select @formula=stuff(@formula,charindex(char(13)+char(13),@formula),2,char(13))      
 end    
 while charindex(char(13)+' '+char(13),@formula)>0      
 begin        
 select @formula=stuff(@formula,charindex(char(13)+' '+char(13),@formula),3,char(13))      
 end
 select @addrlen=datalength (@formula)
 while substring (@formula, @addrlen, 1)=char(13)
          select @formula=substring(@formula, 1, @addrlen-1)
 select @full_address=@formula
 if datalength(@full_address)>1
 begin
 update Name_Address set FULL_ADDRESS=@full_address,ADDRESS_FORMAT=@code where ADDRESS_NUM=@addrnum
     if @Preferred_Mail = 1
        begin
              update Name set FULL_ADDRESS = @full_address where ID = @ID
       end
 end
 end
 END
 fetch next from Get_Addrs into @ID, @Preferred_Mail,@addrnum,@ADDRESS_1,@ADDRESS_2,@ADDRESS_3,@CITY,@STATE_PROVINCE,@ZIP,@COUNTRY
 END
 close Get_Addrs
 deallocate Get_Addrs

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_AdvancedFlowdown]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_AdvancedFlowdown]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure [dbo].[sp_asi_AdvancedFlowdown]
 as
 set nocount on
 declare
 @Short varchar(8000),
 @Str varchar(255),
 @Pos int,
 @Len int,
 @Cmd varchar(8000),
 @TableName varchar(30),
 @FieldName varchar(30)
 update Name set Name.MEMBER_RECORD = Member_Types.MEMBER_RECORD
 from Name, Member_Types 
 where Name.MEMBER_TYPE = Member_Types.MEMBER_TYPE
 and Name.MEMBER_RECORD <> Member_Types.MEMBER_RECORD 
 update Name set Name.COMPANY_RECORD = Member_Types.COMPANY_RECORD 
 from Name, Member_Types 
 where Name.MEMBER_TYPE=Member_Types.MEMBER_TYPE
 and Name.COMPANY_RECORD <> Member_Types.COMPANY_RECORD 
 create table 
 #TableNames (TABLE_NAME varchar(30) not null default '')
 create table
 #TablesAndFields (TABLE_NAME varchar(30) not null default 'Name',
 FIELD_NAME varchar(30) not null default '')
 select @Short = ShortValue from System_Params where ParameterName = 'Member_Control.FlowDownFields'
 select @Len = datalength(@Short)
 if @Len=0
 BEGIN
 select @Short = LongValue from System_Params where ParameterName = 'Member_Control.FlowDownFields'
 END
 select @Pos = charindex(',',@Short)
 while @Pos > 0
 BEGIN
 select @Str = substring(@Short,1,@Pos - 1)
 select @Short = substring(@Short,@Pos + 1,datalength(@Short) - @Pos)
 select @Pos = charindex('.',@Str)
 if @Pos > 0
 BEGIN
 insert #TablesAndFields
 select substring(@Str,1,@Pos-1),substring(@Str,@Pos+1,datalength(@Str)-@Pos)
 END
 else
 BEGIN
 insert #TablesAndFields(FIELD_NAME)
 select @Str
 END
 select @Pos = charindex(',',@Short)
 END
 select @Pos = charindex('.',@Short)
 if @Pos > 0
 BEGIN
 insert #TablesAndFields
 select substring(@Short,1,@Pos - 1),substring(@Short,@Pos + 1,datalength(@Short) - @Pos)
 END
 else
 BEGIN
 insert #TablesAndFields(FIELD_NAME)
 select @Short
 END
 insert #TableNames
 select distinct TABLE_NAME
 from #TablesAndFields
 declare GetTables cursor for
 select TABLE_NAME
 from #TableNames
 open GetTables
 fetch next from GetTables into @TableName
 while @@fetch_status = 0
 BEGIN
 select @Cmd = 'update ' + @TableName + ' set ' 
 declare GetFields cursor for 
 select FIELD_NAME
 from #TablesAndFields
 where TABLE_NAME = @TableName
 open GetFields
 fetch next from GetFields into @FieldName
 while @@fetch_status = 0
 BEGIN
 select @Cmd = @Cmd + @FieldName + '=xxx.' + @FieldName + ',' 
 fetch next from GetFields into @FieldName
 END
 close GetFields
 deallocate GetFields
 select @Cmd = substring(@Cmd,1,datalength(@Cmd)-1)
 if @TableName = 'Name'
 BEGIN
 select @Cmd = @Cmd + ' from ' + @TableName + ' ' + @TableName + ',' + @TableName + ' xxx'
 select @Cmd = @Cmd + ' where Name.CO_ID = xxx.ID and Name.COMPANY_RECORD=0'
 END
 else
 BEGIN
 select @Cmd = @Cmd + ' from ' + @TableName + ' ' + @TableName + ',' + @TableName + ' xxx,Name Name,Name n2'
 select @Cmd = @Cmd + ' where Name.CO_ID = n2.ID and Name.ID = ' + @TableName + '.ID and n2.ID = xxx.ID'
 select @Cmd = @Cmd + ' and Name.COMPANY_RECORD=0'
 END
 set nocount off
 exec(@Cmd)
 set nocount on
 fetch next from GetTables into @TableName
 END
 close GetTables
 deallocate GetTables

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_ARPayment]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_ARPayment]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[sp_asi_ARPayment]
       @inv_num            int          = 0,
       @pmt_amt_tot        money        = 0,
       @trans_counter      int          = 0,
       @gLOrg              varchar(5)   = '',
       @gLAcct             varchar(50)  = '',
       @cashOrg            varchar(5)   = '',
       @cashAcct           varchar(50)  = '',
       @pseudoAcctAR       varchar(50)  = '',
       @pseudoAcctPay      varchar(50)  = '',
       @pay_type           varchar(10)  = '',
       @checknum           varchar(10)  = '',
       @cCnum              varchar(25)  = '',
       @cCexpire           varchar(10)  = '',
       @cCauthorize        varchar(10)  = '',
       @cCname             varchar(40)  = '',
       @cCnum_encrypted    varchar(150) = '',
       @cCexpire_encrypted varchar(150) = '',
       @entered_by         varchar(15)  = '',
       @payment_batch      varchar(10)  = '',
       @posted_flag        int          = 2,
       @transaction_date   datetime,
       @fiscal_period      int          = 0
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @now datetime;
    SELECT @now = dbo.asi_GetAppDatetime();
    
    IF EXISTS (SELECT * FROM [sysobjects] WHERE [name] = '#Inv_Line_Temp' AND [xtype] = 'U')
    BEGIN
        TRUNCATE TABLE [#Inv_Line_Temp];
    END
    ELSE
    BEGIN
        CREATE TABLE [#Inv_Line_Temp] (
                     [LINE_NUM]           int NOT NULL DEFAULT 0,
                     [INVOICE_NUM]        int NOT NULL DEFAULT 0,
                     [CHARGES]            money NOT NULL DEFAULT 0,
                     [CREDITS]            money NOT NULL DEFAULT 0,
                     [BALANCE]            money NOT NULL DEFAULT 0,
                     [ADJUSTMENTS]        money NOT NULL DEFAULT 0,
                     [INVLINES_BILL_THRU] datetime NULL DEFAULT NULL,
                     [BATCH_NUM]          varchar(10) NOT NULL DEFAULT '',
                     [ORG_CODE]           varchar(5) NOT NULL DEFAULT '',
                     [TRANS_NUMBER]       int NOT NULL DEFAULT 0,
                     [OWNER_ORG_CODE]     varchar(10) NOT NULL DEFAULT '',
                     [SOURCE_SYSTEM]      varchar(10) NOT NULL DEFAULT '',
                     [TRANSACTION_DATE]   datetime NULL DEFAULT NULL,
                     [BT_ID]              varchar(10) NOT NULL DEFAULT '',
                     [ST_ID]              varchar(10) NOT NULL DEFAULT '',
                     [DESCRIPTION]        varchar(255) NOT NULL DEFAULT '',
                     [PRODUCT_CODE]       varchar(31) NOT NULL DEFAULT '',
                     [EFFECTIVE_DATE]     datetime NULL DEFAULT NULL,
                     [QUANTITY]           numeric(17, 4) NOT NULL DEFAULT 0,
                     [PROD_TYPE]          varchar(5) NOT NULL DEFAULT '',
                     [SUBSC_BILL_THRU]    datetime NULL DEFAULT NULL,
                     [MEMBER_TYPE]        varchar(5) NOT NULL DEFAULT '',
                     [STATUS]             varchar(5) NOT NULL DEFAULT '',
                     [MEMBER_STATUS]      varchar(5) NOT NULL DEFAULT '',
                     [MEMBER_STATUS_DATE] datetime NULL DEFAULT NULL,
                     [PAID_THRU]          datetime NULL DEFAULT NULL,
                     [MEMBER_RECORD]      bit NOT NULL DEFAULT 0,
                     [JOIN_DATE]          datetime NULL DEFAULT NULL,
                     [CO_ID]              varchar(10) NOT NULL DEFAULT '',
                     [COMPANY_RECORD]     bit NOT NULL DEFAULT 0,
                     [ACTIVITY_SEQN]      int NOT NULL DEFAULT 0,
                     [AMT_PAID]           money NOT NULL DEFAULT 0
        );
        CREATE UNIQUE INDEX [invlinenum_idx] ON [#Inv_Line_Temp] ([LINE_NUM]);
    END;
    
    DECLARE @ret_value int;
    DECLARE @error_hold int;
    
    SET @ret_value = 1;
    SET @error_hold = 1;
    
    DECLARE @application_type int;
    SELECT @application_type = COUNT(1)
      FROM [System_Params]
     WHERE [ParameterName] = 'Dues_Control.ARPaymentApplication';
     
    IF @inv_num = 0
    BEGIN
        GOTO error_handler;
    END;
    
    IF @pmt_amt_tot = 0
    BEGIN
        GOTO error_handler;
    END;
    
    DECLARE @ref_num int;
    DECLARE @line_num int;
    DECLARE @charges money;
    DECLARE @credits money;
    DECLARE @balance money;
    DECLARE @adjustments money;
    DECLARE @invoice_balance money;
    DECLARE @inv_lines_total money;
    DECLARE @bT_ID varchar(10);
    DECLARE @sT_ID varchar(10);
    
    SELECT @ref_num = [REFERENCE_NUM]
      FROM [Invoice]
     WHERE [INVOICE_NUM] = @inv_num;
     
    SELECT @bT_ID = [BT_ID]
      FROM [Invoice]
     WHERE [INVOICE_NUM] = @inv_num;
     
    SELECT @sT_ID = [ST_ID]
      FROM [Invoice]
     WHERE [INVOICE_NUM] = @inv_num;
     
    SELECT @invoice_balance = [BALANCE]
      FROM [Invoice]
     WHERE [INVOICE_NUM] = @inv_num;
     
    DECLARE @pmt_amt money;
    DECLARE @pmt_amt_tot_no_overpay money;
    DECLARE @proportional_amt money;
    
    IF @pmt_amt_tot > @invoice_balance
    BEGIN
        SELECT @pmt_amt = @invoice_balance;
        SELECT @pmt_amt_tot_no_overpay = @invoice_balance;
    END;
    ELSE
    BEGIN
        SELECT @pmt_amt = @pmt_amt_tot;
        SELECT @pmt_amt_tot_no_overpay = @pmt_amt_tot;
    END;
    
    INSERT INTO [#Inv_Line_Temp] ([LINE_NUM],
                                  [INVOICE_NUM],
                                  [CHARGES],
                                  [CREDITS],
                                  [BALANCE],
                                  [ADJUSTMENTS],
                                  [INVLINES_BILL_THRU]
                                 )
           SELECT [LINE_NUM],
                  @inv_num,
                  [CHARGES],
                  [CREDITS],
                  [BALANCE],
                  [ADJUSTMENTS],
                  [BILL_THRU]
             FROM [Invoice_Lines]
            WHERE [REFERENCE_NUM] = @ref_num;
            
    UPDATE [#Inv_Line_Temp]
       SET [#Inv_Line_Temp].[BATCH_NUM] = [Invoice].[BATCH_NUM],
           [#Inv_Line_Temp].[ORG_CODE] = [Invoice].[ORG_CODE]
      FROM [Invoice]
     WHERE [REFERENCE_NUM] = @ref_num;
     
    UPDATE [#Inv_Line_Temp]
       SET [#Inv_Line_Temp].[TRANS_NUMBER] = [Trans].[TRANS_NUMBER],
           [#Inv_Line_Temp].[OWNER_ORG_CODE] = [Trans].[OWNER_ORG_CODE],
           [#Inv_Line_Temp].[SOURCE_SYSTEM] = [Trans].[SOURCE_SYSTEM],
           [#Inv_Line_Temp].[TRANSACTION_DATE] = [Trans].[TRANSACTION_DATE],
           [#Inv_Line_Temp].[BT_ID] = [Trans].[BT_ID],
           [#Inv_Line_Temp].[ST_ID] = [Trans].[ST_ID],
           [#Inv_Line_Temp].[DESCRIPTION] = [Trans].[DESCRIPTION],
           [#Inv_Line_Temp].[PRODUCT_CODE] = [Trans].[PRODUCT_CODE],
           [#Inv_Line_Temp].[EFFECTIVE_DATE] = [Trans].[EFFECTIVE_DATE],
           [#Inv_Line_Temp].[QUANTITY] = [Trans].[QUANTITY],
           [#Inv_Line_Temp].[PROD_TYPE] = [Trans].[PROD_TYPE]
      FROM [Trans]
     WHERE [Trans].[INVOICE_REFERENCE_NUM] = @ref_num AND [Trans].[INVOICE_LINE_NUM] = [#Inv_Line_Temp].[LINE_NUM] AND [JOURNAL_TYPE] = 'IN';
     
    UPDATE [#Inv_Line_Temp]
       SET [#Inv_Line_Temp].[SUBSC_BILL_THRU] = [Subscriptions].[BILL_THRU]
      FROM [Subscriptions]
     WHERE [Subscriptions].[INVOICE_REFERENCE_NUM] = @ref_num AND [INVOICE_LINE_NUM] = [#Inv_Line_Temp].[LINE_NUM];
     
    UPDATE [#Inv_Line_Temp]
       SET [#Inv_Line_Temp].[MEMBER_TYPE] = [Name].[MEMBER_TYPE],
           [#Inv_Line_Temp].[STATUS] = [Name].[STATUS],
           [#Inv_Line_Temp].[MEMBER_STATUS] = [Name].[MEMBER_STATUS],
           [#Inv_Line_Temp].[MEMBER_STATUS_DATE] = [Name].[MEMBER_STATUS_DATE],
           [#Inv_Line_Temp].[PAID_THRU] = [Name].[PAID_THRU],
           [#Inv_Line_Temp].[MEMBER_RECORD] = [Name].[MEMBER_RECORD],
           [#Inv_Line_Temp].[JOIN_DATE] = [Name].[JOIN_DATE],
           [#Inv_Line_Temp].[CO_ID] = [Name].[CO_ID],
           [#Inv_Line_Temp].[COMPANY_RECORD] = [Name].[COMPANY_RECORD]
      FROM [Name]
     WHERE [Name].[ID] = [#Inv_Line_Temp].[ST_ID];
     
    SELECT @inv_lines_total = SUM([CHARGES])
      FROM [#Inv_Line_Temp];
      
    DECLARE @pmt_tots_proportional money;
    SET @pmt_tots_proportional = 0;
    
    DECLARE line_cursor CURSOR FOR 
        SELECT [LINE_NUM],
               [CHARGES],
               [CREDITS],
               [BALANCE],
               [ADJUSTMENTS]
          FROM [#Inv_Line_Temp]
         WHERE [CHARGES] <> 0
         ORDER BY [LINE_NUM];
    OPEN line_cursor;
    
    FETCH NEXT FROM line_cursor INTO @line_num,
                                     @charges,
                                     @credits,
                                     @balance,
                                     @adjustments;
                                     
    WHILE @@fetch_Status = 0 AND ABS(@pmt_amt) > 0
    BEGIN
        IF @application_type = 0
        BEGIN
            IF @balance >= @pmt_amt
            BEGIN
                UPDATE [#Inv_Line_Temp]
                   SET [CREDITS] = [CREDITS] + @pmt_amt,
                       [BALANCE] = [BALANCE] - @pmt_amt,
                       [AMT_PAID] = @pmt_amt
                 WHERE CURRENT OF [line_cursor];
                SET @pmt_amt = 0;
            END;
            ELSE
            BEGIN
                IF @pmt_amt > @balance
                BEGIN
                    UPDATE [#Inv_Line_Temp]
                       SET [CREDITS] = [CREDITS] + @balance,
                           [BALANCE] = 0,
                           [AMT_PAID] = [AMT_PAID] + @balance
                     WHERE CURRENT OF [line_cursor];
                    SET @pmt_amt = @pmt_amt - @balance;
                END;
            END;
        END;
        ELSE
        BEGIN
            IF @application_type = 1
            BEGIN
                IF @charges <> 0
                BEGIN
                    IF @pmt_amt_tot < @inv_lines_total
                    BEGIN
                        SET @proportional_amt = ROUND(@pmt_amt_tot_no_overpay * @charges / @inv_lines_total, 2);
                        UPDATE [#Inv_Line_Temp]
                           SET [CREDITS] = [CREDITS] + @proportional_amt,
                               [BALANCE] = [BALANCE] - @proportional_amt,
                               [AMT_PAID] = @proportional_amt
                         WHERE CURRENT OF [line_cursor];
                        SET @pmt_tots_proportional = @pmt_tots_proportional + @proportional_amt;
                        SET @pmt_amt = @pmt_amt - @proportional_amt;
                    END;
                    ELSE
                    BEGIN
                        UPDATE [#Inv_Line_Temp]
                           SET [CREDITS] = [CREDITS] + @balance,
                               [BALANCE] = 0,
                               [AMT_PAID] = [AMT_PAID] + @balance
                         WHERE CURRENT OF [line_cursor];
                        SET @pmt_amt = @pmt_amt - @balance;
                    END;
                END;
            END;
        END;
        
        FETCH NEXT FROM line_cursor INTO @line_num,
                                         @charges,
                                         @credits,
                                         @balance,
                                         @adjustments;
    END;
    
    CLOSE line_cursor;
    DEALLOCATE line_cursor;
    
    IF @application_type = 1 AND ABS(@pmt_amt_tot) < @inv_lines_total
    BEGIN
        DECLARE @pmt_amt_diff money;
        SET @pmt_amt_diff = @pmt_amt_tot - @pmt_tots_proportional;
        IF @pmt_amt_diff <> 0
        BEGIN
            UPDATE [#Inv_Line_Temp]
               SET [CREDITS] = [CREDITS] + @pmt_amt_diff,
                   [BALANCE] = [BALANCE] - @pmt_amt_diff
             WHERE [BALANCE] = (SELECT MAX([BALANCE])
                                  FROM [#Inv_Line_Temp]
                               );
        END;
    END;
    
    DECLARE @activity_count int;
    SELECT @activity_count = COUNT(1)
      FROM [#Inv_Line_Temp]
     WHERE [AMT_PAID] <> 0;
     
    DECLARE @activity_counter int;
    IF NOT EXISTS (SELECT [COUNTER_NAME]
                     FROM [Counter]
                    WHERE [COUNTER_NAME] = 'Activity'
                  )
    BEGIN
        INSERT INTO [Counter] ([COUNTER_NAME], [LAST_VALUE])
        VALUES ('Activity', 0);
    END;
    
    UPDATE [Counter]
       SET [LAST_VALUE] = [LAST_VALUE] + @activity_count,
           [LAST_UPDATED] = @now,
           [UPDATED_BY] = USER_NAME()
     WHERE [COUNTER_NAME] = 'Activity';
    SELECT @activity_counter = [LAST_VALUE]
      FROM [Counter]
     WHERE [COUNTER_NAME] = 'Activity';
     
    CREATE TABLE [#tmp_seqn] (
                 [LINE_NUM]       int NOT NULL DEFAULT 0,
                 [SEQN_TMP]       int NOT NULL DEFAULT 0,
                 [SEQN_TMP_IDENT] int IDENTITY(1, 1)
    );
    CREATE UNIQUE INDEX [invlinenum_idx] ON [#tmp_seqn] ([LINE_NUM]);
    
    INSERT INTO [#tmp_seqn] ([LINE_NUM])
           SELECT [#Inv_Line_Temp].[LINE_NUM]
             FROM [#Inv_Line_Temp]
            WHERE [AMT_PAID] <> 0;
            
    UPDATE [#tmp_seqn]
       SET [SEQN_TMP] = [SEQN_TMP_IDENT] + @activity_counter - @activity_count;
       
    UPDATE [#Inv_Line_Temp]
       SET [ACTIVITY_SEQN] = [#tmp_seqn].[SEQN_TMP]
      FROM [#tmp_seqn]
     WHERE [#Inv_Line_Temp].[LINE_NUM] = [#tmp_seqn].[LINE_NUM];
     
    UPDATE [Invoice]
       SET [CREDITS] = [CREDITS] + @pmt_amt_tot_no_overpay,
           [BALANCE] = [BALANCE] - @pmt_amt_tot_no_overpay
     WHERE [REFERENCE_NUM] = @ref_num;
     
    IF @@error <> 0
    BEGIN
        SET @error_hold = @@error;
        GOTO error_handler;
    END;
    
    UPDATE [Invoice_Lines]
       SET [Invoice_Lines].[CREDITS] = [Invoice_Lines].[CREDITS] + [#Inv_Line_Temp].[AMT_PAID],
           [Invoice_Lines].[BALANCE] = [Invoice_Lines].[BALANCE] - [#Inv_Line_Temp].[AMT_PAID]
      FROM [Invoice_Lines], [#Inv_Line_Temp]
     WHERE [Invoice_Lines].[REFERENCE_NUM] = @ref_num AND [Invoice_Lines].[LINE_NUM] = [#Inv_Line_Temp].[LINE_NUM];
     
    IF @@error <> 0
    BEGIN
        SET @error_hold = @@error;
        GOTO error_handler;
    END;
    
    UPDATE [Subscriptions]
       SET [PAID_THRU] = [#Inv_Line_Temp].[SUBSC_BILL_THRU],
           [Subscriptions].[BALANCE] = [Subscriptions].[BALANCE] - [#Inv_Line_Temp].[AMT_PAID],
           [PAYMENT_AMOUNT] = [PAYMENT_AMOUNT] + [#Inv_Line_Temp].[AMT_PAID],
           [BEGIN_DATE] = [#Inv_Line_Temp].[EFFECTIVE_DATE],
           [CONTINUOUS_SINCE] = [#Inv_Line_Temp].[EFFECTIVE_DATE],
           [PAYMENT_DATE] = @transaction_date,
           [LAST_PAID_THRU] = [#Inv_Line_Temp].[SUBSC_BILL_THRU],
           [COPIES_PAID] = [BILL_COPIES],
           [LTD_PAYMENTS] = [LTD_PAYMENTS] + [#Inv_Line_Temp].[AMT_PAID]
      FROM [#Inv_Line_Temp]
     WHERE [Subscriptions].[INVOICE_REFERENCE_NUM] = @ref_num AND [Subscriptions].[INVOICE_LINE_NUM] = [#Inv_Line_Temp].[LINE_NUM];
     
    IF @@error <> 0
    BEGIN
        SET @error_hold = @@error;
        GOTO error_handler;
    END;
    
    INSERT INTO [Activity] ([SEQN],
                            [ID],
                            [ACTIVITY_TYPE],
                            [PRODUCT_CODE],
                            [OTHER_CODE],
                            [TRANSACTION_DATE],
                            [DESCRIPTION],
                            [EFFECTIVE_DATE],
                            [THRU_DATE],
                            [AMOUNT],
                            [SOURCE_SYSTEM],
                            [QUANTITY],
                            [ORIGINATING_TRANS_NUM],
                            [ORG_CODE],
                            [OTHER_ID],
                            [CO_ID],
                            [MEMBER_TYPE]
                           )
           SELECT [ACTIVITY_SEQN],
                  [BT_ID],
                  'DUES',
                  [PRODUCT_CODE],
                  (SELECT [PROD_TYPE]
                     FROM [Product]
                    WHERE [Product].[PRODUCT_CODE] = [#Inv_Line_Temp].[PRODUCT_CODE]
                  ),
                  [TRANSACTION_DATE],
                  [DESCRIPTION],
                  [EFFECTIVE_DATE],
                  [SUBSC_BILL_THRU],
                  [AMT_PAID],
                  'AR',
                  [QUANTITY],
                  [TRANS_NUMBER],
                  [OWNER_ORG_CODE],
                  [ST_ID],
                  [CO_ID],
                  [MEMBER_TYPE]
             FROM [#Inv_Line_Temp]
            WHERE [ACTIVITY_SEQN] <> 0;
            
    IF @@error <> 0
    BEGIN
        SET @error_hold = @@error;
        GOTO error_handler;
    END;
    
    UPDATE [Batch]
       SET [TRANS_COUNT] = [TRANS_COUNT] + 1,
           [TRANS_CASH] = [TRANS_CASH] + @pmt_amt_tot
     WHERE [BATCH_NUM] = @payment_batch;
     
    IF @@error <> 0
    BEGIN
        SET @error_hold = @@error;
        GOTO error_handler;
    END;
    
    UPDATE [Name]
       SET [PAID_THRU] = [#Inv_Line_Temp].[SUBSC_BILL_THRU]
      FROM [#Inv_Line_Temp]
     WHERE [Name].[ID] = [#Inv_Line_Temp].[ST_ID];
     
    IF @@error <> 0
    BEGIN
        SET @error_hold = @@error;
        GOTO error_handler;
    END;
    
    DECLARE @trans_line_ctr int;
    SELECT @trans_line_ctr = 1;
    
    IF @pmt_amt_tot > @invoice_balance
    BEGIN
        DECLARE @invoice_ref_num int;
        IF NOT EXISTS (SELECT [COUNTER_NAME]
                         FROM [Counter]
                        WHERE [COUNTER_NAME] = 'Invoice_Ref'
                      )
        BEGIN
            INSERT INTO [Counter] ([COUNTER_NAME], [LAST_VALUE])
            VALUES ('Invoice_Ref', 0);
        END;
        UPDATE [Counter]
           SET [LAST_VALUE] = [LAST_VALUE] + 1,
               [LAST_UPDATED] = @now,
               [UPDATED_BY] = USER_NAME()
         WHERE [COUNTER_NAME] = 'Invoice_Ref';
         
        SELECT @invoice_ref_num = [LAST_VALUE]
          FROM [Counter]
         WHERE [COUNTER_NAME] = 'Invoice_Ref';
         
        DECLARE @overpay_amt money;
        SELECT @overpay_amt = @pmt_amt_tot - @invoice_balance;
        DECLARE @prepay_desc varchar(100);
        SELECT @prepay_desc = 'Dues Overpayment: ' + CONVERT( varchar(2), DATEPART([mm], @now)) + '/' + CONVERT(varchar(2), DATEPART([dd], @now)) + '/' + CONVERT(varchar(4), DATEPART([yyyy], @now)) + ' -- ' + CONVERT(varchar(20), @invoice_ref_num);
        DECLARE @aR_acct varchar(100);
        SELECT @aR_acct = [AR_ACCOUNT]
          FROM [Invoice]
         WHERE [INVOICE_NUM] = @inv_num;
         
        INSERT INTO [Invoice] ([BT_ID],
                               [ST_ID],
                               [REFERENCE_NUM],
                               [INVOICE_NUM],
                               [INVOICE_DATE],
                               [EFFECTIVE_DATE],
                               [ORG_CODE],
                               [SOURCE_SYSTEM],
                               [DESCRIPTION],
                               [CUSTOMER_REFERENCE],
                               [TERMS_CODE],
                               [AR_ACCOUNT],
                               [SOURCE_CODE],
                               [BATCH_NUM],
                               [INVOICE_TYPE],
                               [CREDITS],
                               [BALANCE]
                              )
        VALUES (@bT_ID,
                @sT_ID,
                @invoice_ref_num,
                0,
                @transaction_date,
                @transaction_date,
                @cashOrg,
                'AR',
                @prepay_desc,
                '',
                '',
                @aR_acct,
                '',
                @payment_batch,
                '',
                @overpay_amt,
                0.00 - @overpay_amt
               );
               
        INSERT INTO [Trans] ([TRANS_NUMBER],
                             [LINE_NUMBER],
                             [SUB_LINE_NUMBER],
                             [BATCH_NUM],
                             [OWNER_ORG_CODE],
                             [SOURCE_SYSTEM],
                             [JOURNAL_TYPE],
                             [TRANSACTION_TYPE],
                             [TRANSACTION_DATE],
                             [BT_ID],
                             [ST_ID],
                             [INVOICE_REFERENCE_NUM],
                             [DESCRIPTION],
                             [CUSTOMER_NAME],
                             [CUSTOMER_REFERENCE],
                             [REFERENCE_1],
                             [SOURCE_CODE],
                             [PRODUCT_CODE],
                             [EFFECTIVE_DATE],
                             [PAID_THRU],
                             [MONTHS_PAID],
                             [FISCAL_PERIOD],
                             [DEFERRAL_MONTHS],
                             [AMOUNT],
                             [ADJUSTMENT_AMOUNT],
                             [PSEUDO_ACCOUNT],
                             [GL_ACCT_ORG_CODE],
                             [GL_ACCOUNT],
                             [DEFERRED_GL_ACCOUNT],
                             [INVOICE_CHARGES],
                             [INVOICE_CREDITS],
                             [QUANTITY],
                             [UNIT_PRICE],
                             [PAYMENT_TYPE],
                             [CHECK_NUMBER],
                             [CC_NUMBER],
                             [CC_EXPIRE],
                             [CC_AUTHORIZE],
                             [CC_NAME],
                             [TERMS_CODE],
                             [ACTIVITY_SEQN],
                             [POSTED],
                             [PROD_TYPE],
                             [ACTIVITY_TYPE],
                             [ACTION_CODES],
                             [TICKLER_DATE],
                             [DATE_ENTERED],
                             [ENTERED_BY],
                             [INSTALL_BILL_DATE],
                             [TAXABLE_VALUE],
                             [SOLICITOR_ID],
                             [MERGE_CODE],
                             [SALUTATION_CODE],
                             [SENDER_CODE],
                             [IS_MATCH_GIFT],
                             [MATCH_GIFT_TRANS_NUM],
                             [INVOICE_LINE_NUM],
                             [MATCH_ACTIVITY_SEQN],
                             [MEM_TRIB_ID],
                             [RECEIPT_ID],
                             [DO_NOT_RECEIPT],
                             [ENCRYPT_CC_NUMBER],
                             [ENCRYPT_CC_EXPIRE]
                            )
               SELECT @trans_counter,
                      @trans_line_ctr,
                      1,
                      @payment_batch,
                      @cashOrg,
                      'AR',
                      'PAY',
                      'AR',
                      @transaction_date,
                      @bT_ID,
                      @sT_ID,
                      @invoice_ref_num,
                      @prepay_desc,
                      '',
                      '',
                      'Inv# R0',
                      '',
                      '',
                      NULL,
                      NULL,
                      0,
                      @fiscal_period,
                      0,
                      -@overpay_amt,
                      0,
                      @pseudoAcctAR,
                      @gLOrg,
                      @gLAcct,
                      '',
                      0,
                      @overpay_amt,
                      0.0000,
                      0.00,
                      '',
                      @checknum,
                      @cCnum,
                      @cCexpire,
                      @cCauthorize,
                      @cCname,
                      '',
                      0,
                      @posted_flag,
                      '',
                      '',
                      '',
                      NULL,
                      @now,
                      @entered_by,
                      NULL,
                      0.00,
                      '',
                      '',
                      '',
                      '',
                      0,
                      0,
                      1,
                      0,
                      '',
                      0,
                      0,
                      @cCnum_encrypted,
                      @cCexpire_encrypted;
                      
        IF @@error <> 0
        BEGIN
            SET @error_hold = @@error;
            GOTO error_handler;
        END;
        
        SELECT @trans_line_ctr = @trans_line_ctr + 1;
    END;
    
    INSERT INTO [Trans] ([TRANS_NUMBER],
                         [LINE_NUMBER],
                         [SUB_LINE_NUMBER],
                         [BATCH_NUM],
                         [OWNER_ORG_CODE],
                         [SOURCE_SYSTEM],
                         [JOURNAL_TYPE],
                         [TRANSACTION_TYPE],
                         [TRANSACTION_DATE],
                         [BT_ID],
                         [ST_ID],
                         [INVOICE_REFERENCE_NUM],
                         [DESCRIPTION],
                         [CUSTOMER_NAME],
                         [CUSTOMER_REFERENCE],
                         [REFERENCE_1],
                         [SOURCE_CODE],
                         [PRODUCT_CODE],
                         [EFFECTIVE_DATE],
                         [PAID_THRU],
                         [MONTHS_PAID],
                         [FISCAL_PERIOD],
                         [DEFERRAL_MONTHS],
                         [AMOUNT],
                         [ADJUSTMENT_AMOUNT],
                         [PSEUDO_ACCOUNT],
                         [GL_ACCT_ORG_CODE],
                         [GL_ACCOUNT],
                         [DEFERRED_GL_ACCOUNT],
                         [INVOICE_CHARGES],
                         [INVOICE_CREDITS],
                         [QUANTITY],
                         [UNIT_PRICE],
                         [PAYMENT_TYPE],
                         [CHECK_NUMBER],
                         [CC_NUMBER],
                         [CC_EXPIRE],
                         [CC_AUTHORIZE],
                         [CC_NAME],
                         [TERMS_CODE],
                         [ACTIVITY_SEQN],
                         [POSTED],
                         [PROD_TYPE],
                         [ACTIVITY_TYPE],
                         [ACTION_CODES],
                         [TICKLER_DATE],
                         [DATE_ENTERED],
                         [ENTERED_BY],
                         [INSTALL_BILL_DATE],
                         [TAXABLE_VALUE],
                         [SOLICITOR_ID],
                         [MERGE_CODE],
                         [SALUTATION_CODE],
                         [SENDER_CODE],
                         [IS_MATCH_GIFT],
                         [MATCH_GIFT_TRANS_NUM],
                         [INVOICE_LINE_NUM],
                         [MATCH_ACTIVITY_SEQN],
                         [MEM_TRIB_ID],
                         [RECEIPT_ID],
                         [DO_NOT_RECEIPT],
                         [ENCRYPT_CC_NUMBER],
                         [ENCRYPT_CC_EXPIRE]
                        )
           SELECT @trans_counter,
                  @trans_line_ctr,
                  [#Inv_Line_Temp].[LINE_NUM],
                  @payment_batch,
                  [#Inv_Line_Temp].[OWNER_ORG_CODE],
                  'AR',
                  'PAY',
                  'AR',
                  @transaction_date,
                  [#Inv_Line_Temp].[BT_ID],
                  [#Inv_Line_Temp].[ST_ID],
                  @ref_num,
                  '',
                  '',
                  '',
                  'Inv# ' + CONVERT( varchar(20), @ref_num),
                  '',
                  '',
                  NULL,
                  [#Inv_Line_Temp].[INVLINES_BILL_THRU],
                  0,
                  @fiscal_period,
                  0,
                  - ([#Inv_Line_Temp].[AMT_PAID]),
                  0,
                  @pseudoAcctAR,
                  @gLOrg,
                  @gLAcct,
                  '',
                  0,
                  [#Inv_Line_Temp].[AMT_PAID],
                  0.0000,
                  0.00,
                  '',
                  @checknum,
                  @cCnum,
                  @cCexpire,
                  @cCauthorize,
                  @cCname,
                  '',
                  [#Inv_Line_Temp].[ACTIVITY_SEQN],
                  @posted_flag,
                  '',
                  '',
                  '',
                  NULL,
                  @now,
                  @entered_by,
                  NULL,
                  0.00,
                  '',
                  '',
                  '',
                  '',
                  0,
                  0,
                  [#Inv_Line_Temp].[LINE_NUM],
                  0,
                  '',
                  0,
                  0,
                  @cCnum_encrypted,
                  @cCexpire_encrypted
             FROM [#Inv_Line_Temp]
            WHERE [#Inv_Line_Temp].[AMT_PAID] <> 0;
            
    IF @@error <> 0
    BEGIN
        SET @error_hold = @@error;
        GOTO error_handler;
    END;
    
    SELECT @trans_line_ctr = @trans_line_ctr + 1;
    INSERT INTO [Trans] ([TRANS_NUMBER],
                         [LINE_NUMBER],
                         [SUB_LINE_NUMBER],
                         [BATCH_NUM],
                         [OWNER_ORG_CODE],
                         [SOURCE_SYSTEM],
                         [JOURNAL_TYPE],
                         [TRANSACTION_TYPE],
                         [TRANSACTION_DATE],
                         [BT_ID],
                         [ST_ID],
                         [INVOICE_REFERENCE_NUM],
                         [DESCRIPTION],
                         [CUSTOMER_NAME],
                         [CUSTOMER_REFERENCE],
                         [REFERENCE_1],
                         [SOURCE_CODE],
                         [PRODUCT_CODE],
                         [EFFECTIVE_DATE],
                         [PAID_THRU],
                         [MONTHS_PAID],
                         [FISCAL_PERIOD],
                         [DEFERRAL_MONTHS],
                         [AMOUNT],
                         [ADJUSTMENT_AMOUNT],
                         [PSEUDO_ACCOUNT],
                         [GL_ACCT_ORG_CODE],
                         [GL_ACCOUNT],
                         [DEFERRED_GL_ACCOUNT],
                         [INVOICE_CHARGES],
                         [INVOICE_CREDITS],
                         [QUANTITY],
                         [UNIT_PRICE],
                         [PAYMENT_TYPE],
                         [CHECK_NUMBER],
                         [CC_NUMBER],
                         [CC_EXPIRE],
                         [CC_AUTHORIZE],
                         [CC_NAME],
                         [TERMS_CODE],
                         [ACTIVITY_SEQN],
                         [POSTED],
                         [PROD_TYPE],
                         [ACTIVITY_TYPE],
                         [ACTION_CODES],
                         [TICKLER_DATE],
                         [DATE_ENTERED],
                         [ENTERED_BY],
                         [INSTALL_BILL_DATE],
                         [TAXABLE_VALUE],
                         [SOLICITOR_ID],
                         [MERGE_CODE],
                         [SALUTATION_CODE],
                         [SENDER_CODE],
                         [IS_MATCH_GIFT],
                         [MATCH_GIFT_TRANS_NUM],
                         [INVOICE_LINE_NUM],
                         [MATCH_ACTIVITY_SEQN],
                         [MEM_TRIB_ID],
                         [RECEIPT_ID],
                         [DO_NOT_RECEIPT],
                         [ENCRYPT_CC_NUMBER],
                         [ENCRYPT_CC_EXPIRE]
                        )
           SELECT @trans_counter,
                  @trans_line_ctr,
                  1,
                  @payment_batch,
                  @cashOrg,
                  'AR',
                  'PAY',
                  'PAY',
                  @transaction_date,
                  @bT_ID,
                  @sT_ID,
                  0,
                  '',
                  '',
                  '',
                  '',
                  '',
                  '',
                  NULL,
                  NULL,
                  0,
                  @fiscal_period,
                  0,
                  @pmt_amt_tot,
                  0,
                  @pseudoAcctPay,
                  @cashOrg,
                  @cashAcct,
                  '',
                  0,
                  0,
                  0.0000,
                  0.00,
                  '',
                  @checknum,
                  @cCnum,
                  @cCexpire,
                  @cCauthorize,
                  @cCname,
                  '',
                  0,
                  @posted_flag,
                  '',
                  '',
                  '',
                  NULL,
                  @now,
                  @entered_by,
                  NULL,
                  0.00,
                  '',
                  '',
                  '',
                  '',
                  0,
                  0,
                  0,
                  0,
                  '',
                  0,
                  0,
                  @cCnum_encrypted,
                  @cCexpire_encrypted;
                  
    IF @@error <> 0
    BEGIN
        SET @error_hold = @@error;
        GOTO error_handler;
    END;
    
    SET @ret_value = 0;
    GOTO endit;
    
    error_handler:
    SET @ret_value = @error_hold;
    
    endit:
    SELECT @ret_value;
    
    SET NOCOUNT OFF;
    RETURN;
END;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_iboGetCounter]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_iboGetCounter]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


CREATE PROCEDURE [dbo].[sp_iboGetCounter]
    @counterName varchar(30) = '',
    @incrementBy int = 1,
    @firstUnique int OUTPUT
-- version 10/7/03
-- sp_iboGetCounter  For a given CounterName, returns the next value. (Guaranteed unique).
-- If you supply the optional second param "incrementBy", then you receive the additional guarantee that
-- you can use that many consecutive numbers, all with a uniqueness guarantee.
-- Sample use:  ----------------------------------------------------------------
-- exec sp_iboGetCounter  'MyCounterName', 3
-- returns     101  Now you know that 101, 102, 103 are all usable unique numbers
-- Revisions: ------------------------------------------------------------------- x/x/xx
-- Initial version 1/8/97   mw added optional second param IncrementBy
-- Revision 4/24/01   scd added Transaction and locking, output parm rather than recordset
-- Revision 10/7/2003 Change to update first, only insert if fails to remove contention and reduce deadlocks
-- Revision 03/2017 to optimize DB accesses and locks to improve performance and reduce contention a bit more
AS
BEGIN
    DECLARE @id          varchar(10);
    DECLARE @newId       varchar(10);
    DECLARE @lastValue   int;
    DECLARE @checksum    int;
    DECLARE @hasChecksum bit;
    DECLARE @strChecksum varchar(1);
    DECLARE @updatedBy   varchar(255);
    DECLARE @digit       int;
    DECLARE @weight      int;
    DECLARE @subpos      int;
    DECLARE @sum         int;
    DECLARE @weights     varchar(9);
    DECLARE @pos         int;
    DECLARE @now         datetime;
    DECLARE @trancount   int;
    
    SELECT @now = GETDATE();
    SELECT @updatedBy = CAST(USER_NAME() AS varchar(255));
    SET @trancount = 0;
    
    IF @counterName IN ('Name', 'Prospect') 
    BEGIN
        IF (SELECT [ShortValue] FROM [System_Params] WITH (NOLOCK) WHERE [ParameterName] = 'Member_Control.UseChecksumForId' ) = 'YES'
        BEGIN -- @counterName IN ('Name', 'Prospect') AND 'Member_Control.UseChecksumForId' = 'YES'
            IF @@TRANCOUNT > 0 SET @trancount = 1;
            IF @trancount = 0 BEGIN TRANSACTION;
            SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
            SELECT @weights = '2345672345';
            SELECT @lastValue = [LAST_VALUE],
                   @hasChecksum = [HAS_CHECKSUM]
              FROM [dbo].[Counter] WITH (ROWLOCK)
             WHERE [COUNTER_NAME] = @counterName;
            IF (@hasChecksum = 1)
            BEGIN
                SELECT @id = CONVERT( varchar(10), @lastValue);
                SELECT @id = SUBSTRING(@id, 1, DATALENGTH(@id) - 1);
                SELECT @lastValue = CONVERT( int, @id) + 1;
                SELECT @id = CONVERT( varchar(10), @lastValue);
            END;
            ELSE
            BEGIN
                SELECT @lastValue = @lastValue + 1;
                SELECT @id = CONVERT( varchar(10), @lastValue);
            END;
            SELECT @subpos = DATALENGTH(@id) + 1;
            SELECT @pos = 0;
            WHILE @pos < DATALENGTH(@id)
            BEGIN
                SELECT @pos = @pos + 1;
                SELECT @weight = CONVERT( int, (SUBSTRING(@weights, @pos, 1)) );
                SELECT @digit = CONVERT( int, (SUBSTRING(@id, @subpos-@pos, 1)) );
                SELECT @sum = ISNULL(@sum, 0) + (@weight * @digit);
            END;
            SELECT @checksum = @sum % 11;
            IF @checksum = 0
            BEGIN
                SELECT @checksum = 1;
            END;
            SELECT @checksum = (11 - @checksum) % 10;
            SELECT @strChecksum = CONVERT(varchar(1), @checksum);
            SELECT @newId = @id + @strChecksum;
            
            UPDATE [dbo].[Counter] WITH (ROWLOCK)
               SET [LAST_VALUE] = CONVERT( int, @newId),
                   [LAST_UPDATED] = @now,
                   [UPDATED_BY] = @updatedBy,
                   [HAS_CHECKSUM] = 1,
                   @firstUnique = CONVERT( int, @newId)
             WHERE [COUNTER_NAME] = @counterName;
            IF @@ROWCOUNT = 0
            BEGIN
                INSERT INTO [dbo].[Counter] ([COUNTER_NAME], [LAST_VALUE])
                       SELECT @counterName, 0
                        WHERE NOT EXISTS (SELECT 1
                                            FROM [dbo].[Counter] WITH (ROWLOCK)
                                           WHERE [COUNTER_NAME] = @counterName
                                          );
                UPDATE [dbo].[Counter] WITH (ROWLOCK)
                   SET [LAST_VALUE] = CONVERT( int, @newId),
                       [LAST_UPDATED] = @now,
                       [UPDATED_BY] = @updatedBy,
                       [HAS_CHECKSUM] = 1,
                       @firstUnique = CONVERT( int, @newId)
                 WHERE [COUNTER_NAME] = @counterName;
            END;
            IF @trancount = 0 COMMIT TRANSACTION;
            SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
        END;
        ELSE
        BEGIN -- @counterName IN ('Name', 'Prospect') AND 'Member_Control.UseChecksumForId' <> 'YES'
            UPDATE [dbo].[Counter] WITH (ROWLOCK)
               SET [LAST_VALUE] = [LAST_VALUE] + @incrementBy,
                   [LAST_UPDATED] = @now,
                   [UPDATED_BY] = @updatedBy,
                   @firstUnique = [LAST_VALUE] + 1
             WHERE [COUNTER_NAME] = @counterName;
            IF @@rowCount = 0
            BEGIN
                INSERT INTO [dbo].[Counter] ([COUNTER_NAME], [LAST_VALUE])
                       SELECT @counterName, 0
                        WHERE NOT EXISTS (SELECT 1
                                            FROM [dbo].[Counter] WITH (ROWLOCK)
                                           WHERE [COUNTER_NAME] = @counterName
                       );
                UPDATE [dbo].[Counter] WITH (ROWLOCK)
                   SET [LAST_VALUE] = [LAST_VALUE] + @incrementBy,
                       [LAST_UPDATED] = @now,
                       [UPDATED_BY] = @updatedBy,
                       @firstUnique = [LAST_VALUE] + 1
                 WHERE [COUNTER_NAME] = @counterName;
            END;
        END;
    END;
    ELSE
    BEGIN -- @counterName NOT IN ('Name', 'Prospect') 
        UPDATE [dbo].[Counter] WITH (ROWLOCK)
           SET [LAST_VALUE] = [LAST_VALUE] + @incrementBy,
               [LAST_UPDATED] = @now,
               [UPDATED_BY] = @updatedBy,
               @firstUnique = [LAST_VALUE] + 1
         WHERE [COUNTER_NAME] = @counterName;
        IF @@rowCount = 0
        BEGIN
            INSERT INTO [dbo].[Counter] ([COUNTER_NAME], [LAST_VALUE])
                   SELECT @counterName, 0
                    WHERE NOT EXISTS (SELECT 1
                                        FROM [dbo].[Counter] WITH (ROWLOCK)
                                       WHERE [COUNTER_NAME] = @counterName
                   );
            UPDATE [dbo].[Counter] WITH (ROWLOCK)
               SET [LAST_VALUE] = [LAST_VALUE] + @incrementBy,
                   [LAST_UPDATED] = @now,
                   [UPDATED_BY] = @updatedBy,
                   @firstUnique = [LAST_VALUE] + 1
             WHERE [COUNTER_NAME] = @counterName;
        END;
    END;
END;



GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_Cert_Completion]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_Cert_Completion]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[sp_asi_Cert_Completion]
       @progID                       varchar(31),
       @notifyBoard                  bit          = 0,
       @notifyStudent                bit          = 0,
       @actUF1                       varchar(255) = '',
       @actUF2                       varchar(255) = '',
       @actUF3                       varchar(255) = '',
       @actUF4                       float        = 0,
       @actUF5                       float        = 0,
       @actUF6                       datetime     = NULL,
       @actUF7                       datetime     = NULL,
       @allowGracePeriods            bit          = 0,
       @updateGoodThruForGracePeriod bit          = 0,
       @currentLocalDate             varchar(50)  = ''
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @now datetime;
    SELECT @now = dbo.asi_GetAppDatetime();
    
    DECLARE @rowsAffected                integer,
            @seqn                        int,
            @studentID                   varchar(10),
            @registrationItem            varchar(31),
            @status                      varchar(1),
            @enrolledDate                datetime,
            @deadline                    datetime,
            @completionDate              datetime,
            @boardNotified               bit,
            @studentNotified             bit,
            @goodThruDate                datetime,
            @requirementType             int,
            @inGracePeriod               bit,
            @activitySeqn                int,
            @gracePeriodMonths           int,
            @gracePeriodForInit          bit,
            @gracePeriodForMaint         bit,
            @designation1                varchar(20),
            @designation2                varchar(20),
            @designation3                varchar(20),
            @jointProgram                varchar(31),
            @rotateDateRule              int,
            @rotateBeginDate             datetime,
            @rotateCompletionMonths      int,
            @fullName                    varchar(60),
            @company                     varchar(80),
            @city                        varchar(40),
            @stateProvince               varchar(15),
            @country                     varchar(25),
            @programID                   varchar(31),
            @title                       varchar(50),
            @autoEnrollForMaint          bit,
            @programType                 int,
            @currentProgramID            varchar(31),
            @jointProgramProof           bit,
            @currentProgramProof         bit,
            @seqn1                       int,
            @seqn2                       int,
            @superCategory               bit,
            @subcategoryNames            varchar(8000),
            @cplProgramID                varchar(31),
            @cplComponentCode            varchar(31),
            @cplComponentCategory        varchar(31),
            @cplLineNumber               int,
            @cplLineType                 varchar(10),
            @cplUnitsRequiredForCredit   numeric(15, 2),
            @cplRequirementType          int,
            @productCertParent           bit,
            @certRegUnitsEarned          numeric(15, 2),
            @certRegSeqn                 int,
            @certRegRegType              varchar(1),
            @certRegProgID               varchar(31),
            @totalUnits                  numeric(15, 2),
            @unitsFromCPL                numeric(15, 2),
            @unitsFromComponents         numeric(15, 2),
            @unitsFromSubComponents      numeric(15, 2),
            @unitsFromSubCategories      numeric(15, 2),
            @compProdCode                varchar(31),
            @subcategoryNamesItem        varchar(31),
            @subCompProdCode             varchar(31),
            @subCompLineNumber           int,
            @subCompChildProdCode        varchar(31),
            @subCompRequired             bit,
            @abort                       bit,
            @result                      int,
            @newProgSeqn                 int,
            @newActSeqn                  int,
            @coID                        varchar(10),
            @memberType                  varchar(5),
            @totCharges                  money,
            @cRNotes                     varchar(8000),
            @actString                   varchar(255),
            @treatDeadline               bit,
            @totalUnitsRequiredForCredit numeric(15, 2);
            
    CREATE TABLE [#ProgramLinesList] (
                 [PROGRAM_ID]                varchar(31),
                 [COMPONENT_CODE]            varchar(31),
                 [COMPONENT_CATEGORY]        varchar(31),
                 [LINE_NUMBER]               int,
                 [LINE_TYPE]                 varchar(10),
                 [UNITS_REQUIRED_FOR_CREDIT] numeric(15, 2),
                 [REQUIREMENT_TYPE]          int
    );
    
    CREATE TABLE [#ComponentList] (
                 [PRODUCT_CODE] varchar(31)
    );
    
    CREATE TABLE [#SubcomponentList] (
                 [PRODUCT_CODE]          varchar(31),
                 [LINE_NUMBER]           int,
                 [CHILD_PRODUCT_CODE]    varchar(31),
                 [REQUIRED]              bit,
                 [SubcomponentCompleted] bit
    );
    
    CREATE TABLE [#TTPList] (
                 [TTPComponentRegSeqn] int
    );
    
    CREATE TABLE [#CompletedList] (
                 [STUDENT_ID]             varchar(10),
                 [COMPLETION_DATE]        datetime,
                 [PROGRAM]                varchar(31),
                 [FULLNAME]               varchar(60),
                 [COMPANY]                varchar(80),
                 [CITY]                   varchar(40),
                 [STATE_PROVINCE]         varchar(15),
                 [COUNTRY]                varchar(25),
                 [SEQN]                   int,
                 [ACTIVITY_SEQN]          int,
                 [InGracePeriod]          bit,
                 [AutoEnrollForMaint]     bit,
                 [ProgramType]            int,
                 [RotateDateRule]         int,
                 [RotateBeginDate]        datetime,
                 [RotateCompletionMonths] int,
                 [Designation1]           varchar(20),
                 [Designation2]           varchar(20),
                 [Designation3]           varchar(20),
                 [GracePeriodForInit]     bit,
                 [GracePeriodForMaint]    bit,
                 [Deadline]               datetime,
                 [GoodThruDate]           datetime,
                 [CoID]                   varchar(10),
                 [MemberType]             varchar(5),
                 [TotCharges]             money,
                 [CRNotes]                varchar(8000),
                 [RequirementType]        int,
                 [Title]                  varchar(50)
    );
    
    TRUNCATE TABLE [#CompletedList];
    
    IF @progID = 'ALL'
    BEGIN
        DECLARE get_rows CURSOR FOR
            SELECT [cr].[SEQN],
                   [cr].[STUDENT_ID],
                   [cr].[REGISTRATION_ITEM],
                   [cr].[STATUS],
                   [cr].[ENROLLED_DATE],
                   [cr].[TOTAL_CHARGES],
                   [cr].[NOTES],
                   [cr].[DEADLINE],
                   [cr].[COMPLETION_DATE],
                   [cr].[BOARD_NOTIFIED],
                   [cr].[GOOD_THRU_DATE],
                   [cr].[REQUIREMENT_TYPE],
                   [cr].[IN_GRACE_PERIOD],
                   [cr].[ACTIVITY_SEQN],
                   [cp].[GRACE_PERIOD_MONTHS],
                   [cp].[GRACE_PERIOD_FOR_INIT],
                   [cp].[GRACE_PERIOD_FOR_MAINT],
                   [cp].[DESIGNATION_1],
                   [cp].[DESIGNATION_2],
                   [cp].[DESIGNATION_3],
                   [cp].[JOINT_PROGRAM],
                   [cp].[AUTO_ENROLL_FOR_MAINT],
                   [cp].[ROTATE_DATE_RULE],
                   [cp].[ROTATE_BEGIN_DATE],
                   [cp].[ROTATE_COMPLETION_MONTHS],
                   [n].[FULL_NAME],
                   [n].[COMPANY],
                   [n].[CITY],
                   [n].[STATE_PROVINCE],
                   [n].[COUNTRY],
                   [n].[CO_ID],
                   [n].[MEMBER_TYPE],
                   [cp].[ID],
                   [cp].[TITLE],
                   [cp].[PROGRAM_TYPE]
              FROM [Cert_Register] AS [cr],
                   [Cert_Program] AS [cp],
                   [Name] AS [n]
             WHERE [cr].[SEQN] IN (SELECT [cr2].[SEQN]
                                     FROM [Cert_Register] AS [cr2],
                                          [Cert_Program] AS [cp2]
                                    WHERE [cr2].[REGISTRATION_ITEM] = [cp2].[ID]
                                  ) AND [cr].[STUDENT_ID] = [n].[ID] AND [cr].[REGISTRATION_ITEM] = [cp].[ID] AND [cr].[STATUS] = 'E' AND [cr].[ENROLLED_DATE] IS NOT NULL AND [cr].[CANCELED_DATE] IS NULL
             ORDER BY [cp].[ID];
    END
    ELSE
    BEGIN
        DECLARE get_rows CURSOR
        FOR SELECT [cr].[SEQN],
                   [cr].[STUDENT_ID],
                   [cr].[REGISTRATION_ITEM],
                   [cr].[STATUS],
                   [cr].[ENROLLED_DATE],
                   [cr].[TOTAL_CHARGES],
                   [cr].[NOTES],
                   [cr].[DEADLINE],
                   [cr].[COMPLETION_DATE],
                   [cr].[BOARD_NOTIFIED],
                   [cr].[GOOD_THRU_DATE],
                   [cr].[REQUIREMENT_TYPE],
                   [cr].[IN_GRACE_PERIOD],
                   [cr].[ACTIVITY_SEQN],
                   [cp].[GRACE_PERIOD_MONTHS],
                   [cp].[GRACE_PERIOD_FOR_INIT],
                   [cp].[GRACE_PERIOD_FOR_MAINT],
                   [cp].[DESIGNATION_1],
                   [cp].[DESIGNATION_2],
                   [cp].[DESIGNATION_3],
                   [cp].[JOINT_PROGRAM],
                   [cp].[AUTO_ENROLL_FOR_MAINT],
                   [cp].[ROTATE_DATE_RULE],
                   [cp].[ROTATE_BEGIN_DATE],
                   [cp].[ROTATE_COMPLETION_MONTHS],
                   [n].[FULL_NAME],
                   [n].[COMPANY],
                   [n].[CITY],
                   [n].[STATE_PROVINCE],
                   [n].[COUNTRY],
                   [n].[CO_ID],
                   [n].[MEMBER_TYPE],
                   [cp].[ID],
                   [cp].[TITLE],
                   [cp].[PROGRAM_TYPE]
              FROM [Cert_Register] AS [cr],
                   [Cert_Program] AS [cp],
                   [Name] AS [n]
             WHERE [cr].[SEQN] IN (SELECT [cr2].[SEQN]
                                     FROM [Cert_Register] AS [cr2],
                                          [Cert_Program] AS [cp2]
                                    WHERE [cr2].[REGISTRATION_ITEM] = [cp2].[ID] AND [cp2].[ID] = @progID
                                  ) AND [cr].[STUDENT_ID] = [n].[ID] AND [cr].[REGISTRATION_ITEM] = [cp].[ID] AND [cr].[STATUS] = 'E' AND [cp].[ID] = @progID AND [cr].[ENROLLED_DATE] IS NOT NULL AND [cr].[CANCELED_DATE] IS NULL;
    END;
    
    OPEN get_rows;
    FETCH NEXT FROM get_rows INTO @seqn,
                                  @studentID,
                                  @registrationItem,
                                  @status,
                                  @enrolledDate,
                                  @totCharges,
                                  @cRNotes,
                                  @deadline,
                                  @completionDate,
                                  @boardNotified,
                                  @goodThruDate,
                                  @requirementType,
                                  @inGracePeriod,
                                  @activitySeqn,
                                  @gracePeriodMonths,
                                  @gracePeriodForInit,
                                  @gracePeriodForMaint,
                                  @designation1,
                                  @designation2,
                                  @designation3,
                                  @jointProgram,
                                  @autoEnrollForMaint,
                                  @rotateDateRule,
                                  @rotateBeginDate,
                                  @rotateCompletionMonths,
                                  @fullName,
                                  @company,
                                  @city,
                                  @stateProvince,
                                  @country,
                                  @coID,
                                  @memberType,
                                  @programID,
                                  @title,
                                  @programType;
                                  
    WHILE (@@FETCH_STATUS <> -1)
    BEGIN
        IF @@FETCH_STATUS <> -2
        BEGIN
            TRUNCATE TABLE [#ProgramLinesList];
            TRUNCATE TABLE [#SubcomponentList];
            TRUNCATE TABLE [#ComponentList];
            TRUNCATE TABLE [#TTPList];
            SELECT @totalUnits = 0;
            SELECT @abort = 0;
            SELECT @totalUnitsRequiredForCredit = 0;
            IF DATALENGTH(ISNULL(@jointProgram, '')) > 0
            BEGIN
                SELECT @seqn1 = 0;
                SELECT @seqn2 = 0;
                SELECT @seqn1 = [SEQN]
                  FROM [Cert_Register]
                 WHERE [STUDENT_ID] = @studentID AND [REG_TYPE] = 'P' AND [REGISTRATION_ITEM] = @jointProgram AND [STATUS] = 'P' AND [GOOD_THRU_DATE] >= @now;
                IF ISNULL(@seqn1, 0) = 0
                BEGIN
                    SELECT @seqn1 = [SEQN]
                      FROM [Cert_Register]
                     WHERE [STUDENT_ID] = @studentID AND [REG_TYPE] = 'P' AND [REGISTRATION_ITEM] = @jointProgram AND [STATUS] = 'P';
                    SELECT @seqn2 = [SEQN]
                      FROM [Cert_Register]
                     WHERE [STUDENT_ID] = @studentID AND [REG_TYPE] = 'P' AND [REGISTRATION_ITEM] = @jointProgram AND [STATUS] = 'E' AND [GOOD_THRU_DATE] >= @now;
                END;
                IF ISNULL(@seqn1, 0) > 0 AND ISNULL(@seqn2, 0) > 0
                BEGIN
                    SELECT @seqn1 = [SEQN]
                      FROM [Cert_Register]
                     WHERE [STUDENT_ID] = @studentID AND [REG_TYPE] = 'P' AND [REGISTRATION_ITEM] = @registrationItem AND [STATUS] = 'P' AND [GOOD_THRU_DATE] >= @now;
                    IF ISNULL(@seqn1, 0) = 0
                    BEGIN
                        SELECT @seqn1 = [SEQN]
                          FROM [Cert_Register]
                         WHERE [STUDENT_ID] = @studentID AND [REG_TYPE] = 'P' AND [REGISTRATION_ITEM] = @registrationItem AND [STATUS] = 'P';
                        SELECT @seqn2 = [SEQN]
                          FROM [Cert_Register]
                         WHERE [STUDENT_ID] = @studentID AND [REG_TYPE] = 'P' AND [REGISTRATION_ITEM] = @registrationItem AND [STATUS] = 'E' AND [GOOD_THRU_DATE] >= @now;
                    END;
                    IF ISNULL(@seqn1, 0) > 0 AND ISNULL(@seqn2, 0) > 0
                    BEGIN
                        SELECT @requirementType = 3;
                    END;
                END;
            END;
            INSERT INTO [#ProgramLinesList]
                   SELECT [PROGRAM_ID],
                          [COMPONENT_CODE],
                          [COMPONENT_CATEGORY],
                          [LINE_NUMBER],
                          [LINE_TYPE],
                          [UNITS_REQUIRED_FOR_CREDIT],
                          [REQUIREMENT_TYPE]
                     FROM [Cert_Prog_Lines]
                    WHERE [PROGRAM_ID] = @programID AND [REQUIREMENT_TYPE] = @requirementType;
            DECLARE get_requirements CURSOR
            FOR SELECT *
                  FROM [#ProgramLinesList];
            OPEN get_requirements;
            FETCH NEXT FROM get_requirements INTO @cplProgramID,
                                                  @cplComponentCode,
                                                  @cplComponentCategory,
                                                  @cplLineNumber,
                                                  @cplLineType,
                                                  @cplUnitsRequiredForCredit,
                                                  @cplRequirementType;
            WHILE (@@FETCH_STATUS <> -1) AND @abort = 0
            BEGIN
                IF @@FETCH_STATUS <> -2
                BEGIN
                    IF @cplUnitsRequiredForCredit > 0
                    BEGIN
                        SELECT @totalUnitsRequiredForCredit = @totalUnitsRequiredForCredit + @cplUnitsRequiredForCredit
                    END;
                    IF ISNULL(@cplLineType, '') = 'COMPONENT'
                    BEGIN
                        SELECT @unitsFromCPL = 0;
                        SELECT @productCertParent = 0;
                        SELECT @certRegUnitsEarned = 0;
                        SELECT @certRegSeqn = 0;
                        SELECT @certRegRegType = '';
                        SELECT @certRegProgID = '';
                        SELECT @productCertParent = [pc].[PARENT],
                               @certRegUnitsEarned = [cr].[UNITS_EARNED],
                               @certRegSeqn = [cr].[SEQN],
                               @certRegRegType = [cr].[REG_TYPE],
                               @certRegProgID = [cr].[PROGRAM_ID] 
                        --    from Cert_Register cr,Product_Cert pc where pc.PRODUCT_CODE*=cr.REGISTRATION_ITEM
                          FROM [Product_Cert] AS [pc]
                               LEFT OUTER JOIN [Cert_Register] AS [cr] ON [pc].[PRODUCT_CODE] = [cr].[REGISTRATION_ITEM]
                         WHERE [pc].[PRODUCT_CODE] = @cplComponentCode AND [cr].[STUDENT_ID] = @studentID AND ( ([cr].[REG_TYPE] = 'C' OR [cr].[REG_TYPE] = 'B') AND ([cr].[PROGRAM_ID] = '' OR [cr].[PROGRAM_ID] = @programID) AND ([cr].[PROGRAM_REG_SEQN] = 0 OR [cr].[PROGRAM_REG_SEQN] = @seqn) ) AND [cr].[STATUS] = 'P';
                        IF ISNULL(@certRegSeqn, 0) > 0
                        BEGIN
                            IF ISNULL(@certRegUnitsEarned, 0) > 0
                            BEGIN
                                SELECT @unitsFromCPL = @unitsFromCPL + @certRegUnitsEarned;
                                SELECT @certRegUnitsEarned = 0;
                            END;
                            IF ISNULL(@certRegRegType, '') = 'B'
                            BEGIN
                                INSERT INTO [#TTPList]
                                       SELECT @certRegSeqn;
                            END;
                            IF ISNULL(@unitsFromCPL, 0) > 0
                            BEGIN
                                SELECT @totalUnits = @totalUnits + @unitsFromCPL;
                                SELECT @unitsFromCPL = 0;
                            END;
                        END;
                        ELSE
                        BEGIN
                            SELECT @abort = 1;
                        END;
                    END;
                    IF ISNULL(@cplLineType, '') = 'CATEGORY'
                    BEGIN
                        SELECT @superCategory = 0;
                        SELECT @subcategoryNames = '';
                        SELECT @superCategory = [SUPER_CATEGORY],
                               @subcategoryNames = [SUBCATEGORY_NAMES]
                          FROM [Cert_Comp_Cat]
                         WHERE [CATEGORY] = @cplComponentCategory;
                        IF ISNULL(@superCategory, 0) = 1
                        BEGIN
                            SELECT @unitsFromSubCategories = 0;
                            IF DATALENGTH(ISNULL(@subcategoryNames, '')) > 0
                            BEGIN
                                IF CHARINDEX(',', @subcategoryNames) = 0
                                BEGIN
                                    SELECT @subcategoryNamesItem = @subcategoryNames;
                                    TRUNCATE TABLE [#ComponentList];
                                    INSERT INTO [#ComponentList]
                                           SELECT [p].[PRODUCT_CODE]
                                             FROM [Cert_Register] AS [cr],
                                                  [Product_Cert] AS [pc],
                                                  [Product] AS [p]
                                            WHERE [p].[PRODUCT_CODE] = [pc].[PRODUCT_CODE] AND [pc].[PRODUCT_CODE] = [cr].[REGISTRATION_ITEM] AND [p].[CATEGORY] = @subcategoryNamesItem AND [p].[PROD_TYPE] = 'CERTIFY' AND [pc].[SUBCOMPONENT] = 0 AND [cr].[STUDENT_ID] = @studentID AND ( ([cr].[REG_TYPE] = 'C' OR [cr].[REG_TYPE] = 'B') AND ([cr].[PROGRAM_ID] = '' OR [cr].[PROGRAM_ID] = @programID) AND ([cr].[PROGRAM_REG_SEQN] = 0 OR [cr].[PROGRAM_REG_SEQN] = @seqn) )
                                            GROUP BY [p].[PRODUCT_CODE];
                                    DECLARE get_subcategories CURSOR
                                    FOR SELECT [PRODUCT_CODE]
                                          FROM [#ComponentList];
                                    OPEN get_subcategories;
                                    FETCH NEXT FROM get_subcategories INTO @compProdCode;
                                    WHILE @@fetch_Status = 0
                                    BEGIN
                                        SELECT @productCertParent = 0;
                                        SELECT @certRegUnitsEarned = 0;
                                        SELECT @certRegSeqn = 0;
                                        SELECT @certRegRegType = '';
                                        SELECT @certRegProgID = '';
                                        SELECT @productCertParent = [pc].[PARENT],
                                               @certRegUnitsEarned = [cr].[UNITS_EARNED],
                                               @certRegSeqn = [cr].[SEQN],
                                               @certRegRegType = [cr].[REG_TYPE],
                                               @certRegProgID = [cr].[PROGRAM_ID] 
                                        -- from Cert_Register cr,Product_Cert pc
                                          FROM [Product_Cert] AS [pc]
                                               LEFT OUTER JOIN [Cert_Register] AS [cr] ON [pc].[PRODUCT_CODE] = [cr].[REGISTRATION_ITEM]
                                         WHERE [pc].[PRODUCT_CODE] = @compProdCode AND [cr].[STUDENT_ID] = @studentID AND ( ([cr].[REG_TYPE] = 'C' OR [cr].[REG_TYPE] = 'B') AND ([cr].[PROGRAM_ID] = '' OR [cr].[PROGRAM_ID] = @programID) AND ([cr].[PROGRAM_REG_SEQN] = 0 OR [cr].[PROGRAM_REG_SEQN] = @seqn) ) AND [cr].[STATUS] = 'P';
                                        IF ISNULL(@certRegSeqn, 0) > 0
                                        BEGIN
                                            IF ISNULL(@certRegUnitsEarned, 0) > 0
                                            BEGIN
                                                SELECT @unitsFromSubCategories = @unitsFromSubCategories + @certRegUnitsEarned;
                                                SELECT @certRegUnitsEarned = 0;
                                            END;
                                        END;
                                        IF ISNULL(@certRegSeqn, 0) > 0 AND ISNULL(@certRegRegType, '') = 'B'
                                        BEGIN
                                            INSERT INTO [#TTPList]
                                                   SELECT @certRegSeqn;
                                        END;
                                        FETCH NEXT FROM get_subcategories INTO @compProdCode;
                                    END;
                                    CLOSE get_subcategories;
                                    DEALLOCATE get_subcategories;
                                END;
                                IF CHARINDEX(',', @subcategoryNames) > 0
                                BEGIN
                                    WHILE CHARINDEX(',', @subcategoryNames) > 0
                                    BEGIN
                                        SELECT @subcategoryNamesItem = SUBSTRING(@subcategoryNames, 1, CHARINDEX(',', @subcategoryNames)-1);
                                        SELECT @subcategoryNames = SUBSTRING(@subcategoryNames, CHARINDEX(',', @subcategoryNames) + 1, DATALENGTH(@subcategoryNames));
                                        TRUNCATE TABLE [#ComponentList];
                                        INSERT INTO [#ComponentList]
                                               SELECT [p].[PRODUCT_CODE]
                                                 FROM [Cert_Register] AS [cr],
                                                      [Product_Cert] AS [pc],
                                                      [Product] AS [p]
                                                WHERE [p].[PRODUCT_CODE] = [pc].[PRODUCT_CODE] AND [pc].[PRODUCT_CODE] = [cr].[REGISTRATION_ITEM] AND [p].[CATEGORY] = @subcategoryNamesItem AND [p].[PROD_TYPE] = 'CERTIFY' AND [pc].[SUBCOMPONENT] = 0 AND [cr].[STUDENT_ID] = @studentID AND ( ([cr].[REG_TYPE] = 'C' OR [cr].[REG_TYPE] = 'B') AND ([cr].[PROGRAM_ID] = '' OR [cr].[PROGRAM_ID] = @programID) AND ([cr].[PROGRAM_REG_SEQN] = 0 OR [cr].[PROGRAM_REG_SEQN] = @seqn) )
                                                GROUP BY [p].[PRODUCT_CODE];
                                        DECLARE get_subcategories CURSOR
                                        FOR SELECT [PRODUCT_CODE]
                                              FROM [#ComponentList];
                                        OPEN get_subcategories;
                                        FETCH NEXT FROM get_subcategories INTO @compProdCode;
                                        WHILE @@fetch_Status = 0
                                        BEGIN
                                            SELECT @productCertParent = 0;
                                            SELECT @certRegUnitsEarned = 0;
                                            SELECT @certRegSeqn = 0;
                                            SELECT @certRegRegType = '';
                                            SELECT @certRegProgID = '';
                                            SELECT @productCertParent = [pc].[PARENT],
                                                   @certRegUnitsEarned = [cr].[UNITS_EARNED],
                                                   @certRegSeqn = [cr].[SEQN],
                                                   @certRegRegType = [cr].[REG_TYPE],
                                                   @certRegProgID = [cr].[PROGRAM_ID] 
                                            --from Cert_Register cr,Product_Cert pc
                                              FROM [Product_Cert] AS [pc]
                                                   LEFT OUTER JOIN [Cert_Register] AS [cr] ON [pc].[PRODUCT_CODE] = [cr].[REGISTRATION_ITEM]
                                             WHERE [pc].[PRODUCT_CODE] = @compProdCode AND [cr].[STUDENT_ID] = @studentID AND ( ([cr].[REG_TYPE] = 'C' OR [cr].[REG_TYPE] = 'B') AND ([cr].[PROGRAM_ID] = '' OR [cr].[PROGRAM_ID] = @programID) AND ([cr].[PROGRAM_REG_SEQN] = 0 OR [cr].[PROGRAM_REG_SEQN] = @seqn) ) AND [cr].[STATUS] = 'P';
                                            IF ISNULL(@certRegSeqn, 0) > 0
                                            BEGIN
                                                IF ISNULL(@certRegUnitsEarned, 0) > 0
                                                BEGIN
                                                    SELECT @unitsFromSubCategories = @unitsFromSubCategories + @certRegUnitsEarned;
                                                    SELECT @certRegUnitsEarned = 0;
                                                END;
                                            END;
                                            IF ISNULL(@certRegSeqn, 0) > 0 AND ISNULL(@certRegRegType, '') = 'B'
                                            BEGIN
                                                INSERT INTO [#TTPList]
                                                       SELECT @certRegSeqn;
                                            END;
                                            FETCH NEXT FROM get_subcategories INTO @compProdCode;
                                        END;
                                        CLOSE get_subcategories;
                                        DEALLOCATE get_subcategories;
                                    END;
                                    SELECT @subcategoryNamesItem = @subcategoryNames;
                                    TRUNCATE TABLE [#ComponentList];
                                    INSERT INTO [#ComponentList]
                                           SELECT [p].[PRODUCT_CODE]
                                             FROM [Cert_Register] AS [cr],
                                                  [Product_Cert] AS [pc],
                                                  [Product] AS [p]
                                            WHERE [p].[PRODUCT_CODE] = [pc].[PRODUCT_CODE] AND [pc].[PRODUCT_CODE] = [cr].[REGISTRATION_ITEM] AND [p].[CATEGORY] = @subcategoryNamesItem AND [p].[PROD_TYPE] = 'CERTIFY' AND [pc].[SUBCOMPONENT] = 0 AND [cr].[STUDENT_ID] = @studentID AND ( ([cr].[REG_TYPE] = 'C' OR [cr].[REG_TYPE] = 'B') AND ([cr].[PROGRAM_ID] = '' OR [cr].[PROGRAM_ID] = @programID) AND ([cr].[PROGRAM_REG_SEQN] = 0 OR [cr].[PROGRAM_REG_SEQN] = @seqn) )
                                            GROUP BY [p].[PRODUCT_CODE];
                                    DECLARE get_subcategories CURSOR
                                    FOR SELECT [PRODUCT_CODE]
                                          FROM [#ComponentList];
                                    OPEN get_subcategories;
                                    FETCH NEXT FROM get_subcategories INTO @compProdCode;
                                    WHILE @@fetch_Status = 0
                                    BEGIN
                                        SELECT @productCertParent = 0;
                                        SELECT @certRegUnitsEarned = 0;
                                        SELECT @certRegSeqn = 0;
                                        SELECT @certRegRegType = '';
                                        SELECT @certRegProgID = '';
                                        SELECT @productCertParent = [pc].[PARENT],
                                               @certRegUnitsEarned = [cr].[UNITS_EARNED],
                                               @certRegSeqn = [cr].[SEQN],
                                               @certRegRegType = [cr].[REG_TYPE],
                                               @certRegProgID = [cr].[PROGRAM_ID] 
                                        --from Cert_Register cr,Product_Cert pc
                                          FROM [Product_Cert] AS [pc]
                                               LEFT OUTER JOIN [Cert_Register] AS [cr] ON [pc].[PRODUCT_CODE] = [cr].[REGISTRATION_ITEM]
                                         WHERE [pc].[PRODUCT_CODE] = @compProdCode AND [cr].[STUDENT_ID] = @studentID AND ( ([cr].[REG_TYPE] = 'C' OR [cr].[REG_TYPE] = 'B') AND ([cr].[PROGRAM_ID] = '' OR [cr].[PROGRAM_ID] = @programID) AND ([cr].[PROGRAM_REG_SEQN] = 0 OR [cr].[PROGRAM_REG_SEQN] = @seqn) ) AND [cr].[STATUS] = 'P';
                                        IF ISNULL(@certRegSeqn, 0) > 0
                                        BEGIN
                                            IF ISNULL(@certRegUnitsEarned, 0) > 0
                                            BEGIN
                                                SELECT @unitsFromSubCategories = @unitsFromSubCategories + @certRegUnitsEarned;
                                                SELECT @certRegUnitsEarned = 0;
                                            END;
                                        END;
                                        IF ISNULL(@certRegSeqn, 0) > 0 AND ISNULL(@certRegRegType, '') = 'B'
                                        BEGIN
                                            INSERT INTO [#TTPList]
                                                   SELECT @certRegSeqn;
                                        END;
                                        FETCH NEXT FROM get_subcategories INTO @compProdCode;
                                    END;
                                    CLOSE get_subcategories;
                                    DEALLOCATE get_subcategories;
                                END;
                            END;
                            IF ISNULL(@unitsFromSubCategories, 0) < ISNULL(@cplUnitsRequiredForCredit, 0)
                            BEGIN
                                SELECT @abort = 1;
                            END;
                            IF ISNULL(@unitsFromSubCategories, 0) > 0
                            BEGIN
                                SELECT @totalUnits = @totalUnits + @unitsFromSubCategories;
                                SELECT @unitsFromSubCategories = 0;
                            END;
                        END;
                        ELSE
                        BEGIN
                            TRUNCATE TABLE [#ComponentList];
                            SELECT @unitsFromComponents = 0;
                            SELECT @unitsFromSubComponents = 0;
                            INSERT INTO [#ComponentList]
                                   SELECT [p].[PRODUCT_CODE]
                                     FROM [Cert_Register] AS [cr],
                                          [Product_Cert] AS [pc],
                                          [Product] AS [p]
                                    WHERE [p].[PRODUCT_CODE] = [pc].[PRODUCT_CODE] AND [pc].[PRODUCT_CODE] = [cr].[REGISTRATION_ITEM] AND [p].[CATEGORY] = @cplComponentCategory AND [p].[PROD_TYPE] = 'CERTIFY' AND [pc].[SUBCOMPONENT] = 0 AND [cr].[STUDENT_ID] = @studentID AND ( ([cr].[REG_TYPE] = 'C' OR [cr].[REG_TYPE] = 'B') AND ([cr].[PROGRAM_ID] = '' OR [cr].[PROGRAM_ID] = @programID) AND ([cr].[PROGRAM_REG_SEQN] = 0 OR [cr].[PROGRAM_REG_SEQN] = @seqn) )
                                    GROUP BY [p].[PRODUCT_CODE];
                            DECLARE get_components CURSOR FOR
                                SELECT [PRODUCT_CODE]
                                  FROM [#ComponentList];
                            OPEN get_components;
                            
                            FETCH NEXT FROM get_components INTO @compProdCode;
                            IF @@FETCH_STATUS <> 0
                            BEGIN
                                SELECT @abort = 1;
                            END;
                            
                            WHILE @@FETCH_STATUS = 0
                            BEGIN
                                SELECT @productCertParent = 0;
                                SELECT @certRegUnitsEarned = 0;
                                SELECT @certRegSeqn = 0;
                                SELECT @certRegRegType = '';
                                SELECT @certRegProgID = '';
                                SELECT @productCertParent = [pc].[PARENT],
                                       @certRegUnitsEarned = [cr].[UNITS_EARNED],
                                       @certRegSeqn = [cr].[SEQN],
                                       @certRegRegType = [cr].[REG_TYPE],
                                       @certRegProgID = [cr].[PROGRAM_ID] 
                                --from Cert_Register cr,Product_Cert pc
                                  FROM [Product_Cert] AS [pc]
                                       LEFT OUTER JOIN [Cert_Register] AS [cr] ON [pc].[PRODUCT_CODE] = [cr].[REGISTRATION_ITEM]
                                 WHERE [pc].[PRODUCT_CODE] = @compProdCode AND [cr].[STUDENT_ID] = @studentID AND ( ([cr].[REG_TYPE] = 'C' OR [cr].[REG_TYPE] = 'B') AND ([cr].[PROGRAM_ID] = '' OR [cr].[PROGRAM_ID] = @programID) AND ([cr].[PROGRAM_REG_SEQN] = 0 OR [cr].[PROGRAM_REG_SEQN] = @seqn) ) AND [cr].[STATUS] = 'P';
                                IF ISNULL(@certRegSeqn, 0) > 0
                                BEGIN
                                    IF ISNULL(@certRegUnitsEarned, 0) > 0
                                    BEGIN
                                        SELECT @unitsFromComponents = @unitsFromComponents + @certRegUnitsEarned;
                                        SELECT @certRegUnitsEarned = 0;
                                    END;
                                    IF ISNULL(@productCertParent, 0) <> 0
                                    BEGIN
                                        TRUNCATE TABLE [#SubcomponentList];
                                        INSERT INTO [#SubcomponentList]
                                               SELECT [PRODUCT_CODE],
                                                      [LINE_NUMBER],
                                                      [CHILD_PRODUCT_CODE],
                                                      [REQUIRED],
                                                      0
                                                 FROM [Product_Sub]
                                                WHERE [Product_Sub].[PRODUCT_CODE] = @compProdCode;
                                        DECLARE get_subcomponents CURSOR
                                        FOR SELECT @subCompChildProdCode
                                              FROM [#SubcomponentList];
                                        OPEN get_subcomponents;
                                        FETCH NEXT FROM get_subcomponents INTO @subCompChildProdCode;
                                        WHILE @@FETCH_STATUS = 0
                                        BEGIN
                                            SELECT @certRegUnitsEarned = 0;
                                            SELECT @certRegUnitsEarned = [cr].[UNITS_EARNED]
                                              FROM [Cert_Register] AS [cr]
                                             WHERE [cr].[REGISTRATION_ITEM] = @subCompChildProdCode AND [cr].[STUDENT_ID] = @studentID AND ( ([cr].[REG_TYPE] = 'C' OR [cr].[REG_TYPE] = 'B') AND ([cr].[PROGRAM_ID] = '' OR [cr].[PROGRAM_ID] = @programID) AND ([cr].[PROGRAM_REG_SEQN] = 0 OR [cr].[PROGRAM_REG_SEQN] = @seqn) ) AND [cr].[STATUS] = 'P';
                                            IF ISNULL(@certRegUnitsEarned, 0) > 0
                                            BEGIN
                                                UPDATE [#SubcomponentList]
                                                   SET [SubcomponentCompleted] = 1
                                                 WHERE CURRENT OF [get_subcomponents];
                                                SELECT @unitsFromSubComponents = @unitsFromSubComponents + @certRegUnitsEarned;
                                                SELECT @certRegUnitsEarned = 0;
                                            END;
                                            FETCH NEXT FROM get_subcomponents INTO @subCompChildProdCode;
                                        END;
                                        CLOSE get_subcomponents;
                                        DEALLOCATE get_subcomponents;
                                        SELECT @unitsFromComponents = @unitsFromComponents + @unitsFromSubComponents;
                                    END;
                                    IF ISNULL(@certRegRegType, '') = 'B'
                                    BEGIN
                                        INSERT INTO [#TTPList]
                                               SELECT @certRegSeqn;
                                    END;
                                END;
                                FETCH NEXT FROM get_components INTO @compProdCode;
                            END;
                            CLOSE get_components;
                            DEALLOCATE get_components;
                            IF ISNULL(@unitsFromComponents, 0) > 0 AND (ISNULL(@unitsFromComponents, 0) >= ISNULL(@cplUnitsRequiredForCredit, 0))
                            BEGIN
                                SELECT @totalUnits = @totalUnits + @unitsFromComponents;
                                SELECT @unitsFromComponents = 0;
                                SELECT @unitsFromSubComponents = 0;
                            END;
                            ELSE
                            BEGIN
                                SELECT @abort = 1;
                            END;
                        END;
                    END;
                END;
                FETCH NEXT FROM get_requirements INTO @cplProgramID,
                                                      @cplComponentCode,
                                                      @cplComponentCategory,
                                                      @cplLineNumber,
                                                      @cplLineType,
                                                      @cplUnitsRequiredForCredit,
                                                      @cplRequirementType;
            END;
            CLOSE get_requirements;
            DEALLOCATE get_requirements;
            IF ISNULL(@inGracePeriod, 0) <> 0 AND @abort = 0
            BEGIN
                SELECT @requirementType = 2;
                TRUNCATE TABLE [#ProgramLinesList];
                INSERT INTO [#ProgramLinesList]
                       SELECT [PROGRAM_ID],
                              [COMPONENT_CODE],
                              [COMPONENT_CATEGORY],
                              [LINE_NUMBER],
                              [LINE_TYPE],
                              [UNITS_REQUIRED_FOR_CREDIT],
                              [REQUIREMENT_TYPE]
                         FROM [Cert_Prog_Lines]
                        WHERE [PROGRAM_ID] = @programID AND [REQUIREMENT_TYPE] = @requirementType;
                DECLARE get_requirements CURSOR
                FOR SELECT *
                      FROM [#ProgramLinesList];
                OPEN get_requirements;
                FETCH NEXT FROM get_requirements INTO @cplProgramID,
                                                      @cplComponentCode,
                                                      @cplComponentCategory,
                                                      @cplLineNumber,
                                                      @cplLineType,
                                                      @cplUnitsRequiredForCredit,
                                                      @cplRequirementType;
                WHILE (@@FETCH_STATUS <> -1)
                BEGIN
                    IF @@FETCH_STATUS <> -2
                    BEGIN
                        IF ISNULL(@cplLineType, '') = 'COMPONENT'
                        BEGIN
                            SELECT @unitsFromCPL = 0;
                            SELECT @productCertParent = 0;
                            SELECT @certRegUnitsEarned = 0;
                            SELECT @certRegSeqn = 0;
                            SELECT @certRegRegType = '';
                            SELECT @certRegProgID = '';
                            SELECT @productCertParent = [pc].[PARENT],
                                   @certRegUnitsEarned = [cr].[UNITS_EARNED],
                                   @certRegSeqn = [cr].[SEQN],
                                   @certRegRegType = [cr].[REG_TYPE],
                                   @certRegProgID = [cr].[PROGRAM_ID]
                              FROM [Product_Cert] AS [pc]
                                   LEFT OUTER JOIN [Cert_Register] AS [cr] ON [pc].[PRODUCT_CODE] = [cr].[REGISTRATION_ITEM]
                             WHERE [pc].[PRODUCT_CODE] = @cplComponentCode AND [cr].[STUDENT_ID] = @studentID AND ( ([cr].[REG_TYPE] = 'C' OR [cr].[REG_TYPE] = 'B') AND ([cr].[PROGRAM_ID] = '' OR [cr].[PROGRAM_ID] = @programID) AND ([cr].[PROGRAM_REG_SEQN] = 0 OR [cr].[PROGRAM_REG_SEQN] = @seqn) ) AND [cr].[STATUS] = 'P';
                            IF ISNULL(@certRegSeqn, 0) > 0
                            BEGIN
                                IF ISNULL(@certRegUnitsEarned, 0) > 0
                                BEGIN
                                    SELECT @unitsFromCPL = @unitsFromCPL + @certRegUnitsEarned;
                                    SELECT @certRegUnitsEarned = 0;
                                END;
                                IF ISNULL(@certRegRegType, '') = 'B'
                                BEGIN
                                    INSERT INTO [#TTPList]
                                           SELECT @certRegSeqn;
                                END;
                                IF ISNULL(@unitsFromCPL, 0) > 0
                                BEGIN
                                    SELECT @totalUnits = @totalUnits + @unitsFromCPL;
                                    SELECT @unitsFromCPL = 0;
                                END;
                            END;
                            ELSE
                            BEGIN
                                SELECT @abort = 1;
                            END;
                        END;
                        IF ISNULL(@cplLineType, '') = 'CATEGORY'
                        BEGIN
                            SELECT @superCategory = 0;
                            SELECT @subcategoryNames = '';
                            SELECT @superCategory = [SUPER_CATEGORY],
                                   @subcategoryNames = [SUBCATEGORY_NAMES]
                              FROM [Cert_Comp_Cat]
                             WHERE [CATEGORY] = @cplComponentCategory;
                            IF ISNULL(@superCategory, 0) = 1
                            BEGIN
                                SELECT @unitsFromSubCategories = 0;
                                IF DATALENGTH(ISNULL(@subcategoryNames, '')) > 0
                                BEGIN
                                    IF CHARINDEX(',', @subcategoryNames) = 0
                                    BEGIN
                                        SELECT @subcategoryNamesItem = @subcategoryNames;
                                        TRUNCATE TABLE [#ComponentList];
                                        INSERT INTO [#ComponentList]
                                               SELECT [p].[PRODUCT_CODE]
                                                 FROM [Cert_Register] AS [cr],
                                                      [Product_Cert] AS [pc],
                                                      [Product] AS [p]
                                                WHERE [p].[PRODUCT_CODE] = [pc].[PRODUCT_CODE] AND [pc].[PRODUCT_CODE] = [cr].[REGISTRATION_ITEM] AND [p].[CATEGORY] = @subcategoryNamesItem AND [p].[PROD_TYPE] = 'CERTIFY' AND [pc].[SUBCOMPONENT] = 0 AND [cr].[STUDENT_ID] = @studentID AND ( ([cr].[REG_TYPE] = 'C' OR [cr].[REG_TYPE] = 'B') AND ([cr].[PROGRAM_ID] = '' OR [cr].[PROGRAM_ID] = @programID) AND ([cr].[PROGRAM_REG_SEQN] = 0 OR [cr].[PROGRAM_REG_SEQN] = @seqn) )
                                                GROUP BY [p].[PRODUCT_CODE];
                                        DECLARE get_subcategories CURSOR
                                        FOR SELECT [PRODUCT_CODE]
                                              FROM [#ComponentList];
                                        OPEN get_subcategories;
                                        FETCH NEXT FROM get_subcategories INTO @compProdCode;
                                        WHILE @@FETCH_STATUS = 0
                                        BEGIN
                                            SELECT @productCertParent = 0;
                                            SELECT @certRegUnitsEarned = 0;
                                            SELECT @certRegSeqn = 0;
                                            SELECT @certRegRegType = '';
                                            SELECT @certRegProgID = '';
                                            SELECT @productCertParent = [pc].[PARENT],
                                                   @certRegUnitsEarned = [cr].[UNITS_EARNED],
                                                   @certRegSeqn = [cr].[SEQN],
                                                   @certRegRegType = [cr].[REG_TYPE],
                                                   @certRegProgID = [cr].[PROGRAM_ID]
                                              FROM [Product_Cert] AS [pc]
                                                   LEFT OUTER JOIN [Cert_Register] AS [cr] ON [pc].[PRODUCT_CODE] = [cr].[REGISTRATION_ITEM]
                                             WHERE [pc].[PRODUCT_CODE] = @compProdCode AND [cr].[STUDENT_ID] = @studentID AND ( ([cr].[REG_TYPE] = 'C' OR [cr].[REG_TYPE] = 'B') AND ([cr].[PROGRAM_ID] = '' OR [cr].[PROGRAM_ID] = @programID) AND ([cr].[PROGRAM_REG_SEQN] = 0 OR [cr].[PROGRAM_REG_SEQN] = @seqn) ) AND [cr].[STATUS] = 'P';
                                            IF ISNULL(@certRegSeqn, 0) > 0
                                            BEGIN
                                                IF ISNULL(@certRegUnitsEarned, 0) > 0
                                                BEGIN
                                                    SELECT @unitsFromSubCategories = @unitsFromSubCategories + @certRegUnitsEarned;
                                                    SELECT @certRegUnitsEarned = 0;
                                                END;
                                            END;
                                            IF ISNULL(@certRegSeqn, 0) > 0 AND ISNULL(@certRegRegType, '') = 'B'
                                            BEGIN
                                                INSERT INTO [#TTPList]
                                                       SELECT @certRegSeqn;
                                            END;
                                            FETCH NEXT FROM get_subcategories INTO @compProdCode;
                                        END;
                                        CLOSE get_subcategories;
                                        DEALLOCATE get_subcategories;
                                    END;
                                    IF CHARINDEX(',', @subcategoryNames) > 0
                                    BEGIN
                                        WHILE CHARINDEX(',', @subcategoryNames) > 0
                                        BEGIN
                                            SELECT @subcategoryNamesItem = SUBSTRING(@subcategoryNames, 1, CHARINDEX(',', @subcategoryNames)-1);
                                            SELECT @subcategoryNames = SUBSTRING(@subcategoryNames, CHARINDEX(',', @subcategoryNames) + 1, DATALENGTH(@subcategoryNames));
                                            TRUNCATE TABLE [#ComponentList];
                                            INSERT INTO [#ComponentList]
                                                   SELECT [p].[PRODUCT_CODE]
                                                     FROM [Cert_Register] AS [cr],
                                                          [Product_Cert] AS [pc],
                                                          [Product] AS [p]
                                                    WHERE [p].[PRODUCT_CODE] = [pc].[PRODUCT_CODE] AND [pc].[PRODUCT_CODE] = [cr].[REGISTRATION_ITEM] AND [p].[CATEGORY] = @subcategoryNamesItem AND [p].[PROD_TYPE] = 'CERTIFY' AND [pc].[SUBCOMPONENT] = 0 AND [cr].[STUDENT_ID] = @studentID AND ( ([cr].[REG_TYPE] = 'C' OR [cr].[REG_TYPE] = 'B') AND ([cr].[PROGRAM_ID] = '' OR [cr].[PROGRAM_ID] = @programID) AND ([cr].[PROGRAM_REG_SEQN] = 0 OR [cr].[PROGRAM_REG_SEQN] = @seqn) )
                                                    GROUP BY [p].[PRODUCT_CODE];
                                            DECLARE get_subcategories CURSOR
                                            FOR SELECT [PRODUCT_CODE]
                                                  FROM [#ComponentList];
                                            OPEN get_subcategories;
                                            FETCH NEXT FROM get_subcategories INTO @compProdCode;
                                            WHILE @@fetch_Status = 0
                                            BEGIN
                                                SELECT @productCertParent = 0;
                                                SELECT @certRegUnitsEarned = 0;
                                                SELECT @certRegSeqn = 0;
                                                SELECT @certRegRegType = '';
                                                SELECT @certRegProgID = '';
                                                SELECT @productCertParent = [pc].[PARENT],
                                                       @certRegUnitsEarned = [cr].[UNITS_EARNED],
                                                       @certRegSeqn = [cr].[SEQN],
                                                       @certRegRegType = [cr].[REG_TYPE],
                                                       @certRegProgID = [cr].[PROGRAM_ID]
                                                  FROM [Product_Cert] AS [pc]
                                                       LEFT OUTER JOIN [Cert_Register] AS [cr] ON [pc].[PRODUCT_CODE] = [cr].[REGISTRATION_ITEM]
                                                 WHERE [pc].[PRODUCT_CODE] = @compProdCode AND [cr].[STUDENT_ID] = @studentID AND ( ([cr].[REG_TYPE] = 'C' OR [cr].[REG_TYPE] = 'B') AND ([cr].[PROGRAM_ID] = '' OR [cr].[PROGRAM_ID] = @programID) AND ([cr].[PROGRAM_REG_SEQN] = 0 OR [cr].[PROGRAM_REG_SEQN] = @seqn) ) AND [cr].[STATUS] = 'P';
                                                IF ISNULL(@certRegSeqn, 0) > 0
                                                BEGIN
                                                    IF ISNULL(@certRegUnitsEarned, 0) > 0
                                                    BEGIN
                                                        SELECT @unitsFromSubCategories = @unitsFromSubCategories + @certRegUnitsEarned;
                                                        SELECT @certRegUnitsEarned = 0;
                                                    END;
                                                END;
                                                IF ISNULL(@certRegSeqn, 0) > 0 AND ISNULL(@certRegRegType, '') = 'B'
                                                BEGIN
                                                    INSERT INTO [#TTPList]
                                                           SELECT @certRegSeqn;
                                                END;
                                                FETCH NEXT FROM get_subcategories INTO @compProdCode;
                                            END;
                                            CLOSE get_subcategories;
                                            DEALLOCATE get_subcategories;
                                        END;
                                        SELECT @subcategoryNamesItem = @subcategoryNames;
                                        TRUNCATE TABLE [#ComponentList];
                                        INSERT INTO [#ComponentList]
                                               SELECT [p].[PRODUCT_CODE]
                                                 FROM [Cert_Register] AS [cr],
                                                      [Product_Cert] AS [pc],
                                                      [Product] AS [p]
                                                WHERE [p].[PRODUCT_CODE] = [pc].[PRODUCT_CODE] AND [pc].[PRODUCT_CODE] = [cr].[REGISTRATION_ITEM] AND [p].[CATEGORY] = @subcategoryNamesItem AND [p].[PROD_TYPE] = 'CERTIFY' AND [pc].[SUBCOMPONENT] = 0 AND [cr].[STUDENT_ID] = @studentID AND ( ([cr].[REG_TYPE] = 'C' OR [cr].[REG_TYPE] = 'B') AND ([cr].[PROGRAM_ID] = '' OR [cr].[PROGRAM_ID] = @programID) AND ([cr].[PROGRAM_REG_SEQN] = 0 OR [cr].[PROGRAM_REG_SEQN] = @seqn) )
                                                GROUP BY [p].[PRODUCT_CODE];
                                        DECLARE get_subcategories CURSOR
                                        FOR SELECT [PRODUCT_CODE]
                                              FROM [#ComponentList];
                                        OPEN get_subcategories;
                                        FETCH NEXT FROM get_subcategories INTO @compProdCode;
                                        WHILE @@FETCH_STATUS = 0
                                        BEGIN
                                            SELECT @productCertParent = 0;
                                            SELECT @certRegUnitsEarned = 0;
                                            SELECT @certRegSeqn = 0;
                                            SELECT @certRegRegType = '';
                                            SELECT @certRegProgID = '';
                                            SELECT @productCertParent = [pc].[PARENT],
                                                   @certRegUnitsEarned = [cr].[UNITS_EARNED],
                                                   @certRegSeqn = [cr].[SEQN],
                                                   @certRegRegType = [cr].[REG_TYPE],
                                                   @certRegProgID = [cr].[PROGRAM_ID]
                                              FROM [Product_Cert] AS [pc]
                                                   LEFT OUTER JOIN [Cert_Register] AS [cr] ON [pc].[PRODUCT_CODE] = [cr].[REGISTRATION_ITEM]
                                             WHERE [pc].[PRODUCT_CODE] = @compProdCode AND [cr].[STUDENT_ID] = @studentID AND ( ([cr].[REG_TYPE] = 'C' OR [cr].[REG_TYPE] = 'B') AND ([cr].[PROGRAM_ID] = '' OR [cr].[PROGRAM_ID] = @programID) AND ([cr].[PROGRAM_REG_SEQN] = 0 OR [cr].[PROGRAM_REG_SEQN] = @seqn) ) AND [cr].[STATUS] = 'P';
                                            IF ISNULL(@certRegSeqn, 0) > 0
                                            BEGIN
                                                IF ISNULL(@certRegUnitsEarned, 0) > 0
                                                BEGIN
                                                    SELECT @unitsFromSubCategories = @unitsFromSubCategories + @certRegUnitsEarned;
                                                    SELECT @certRegUnitsEarned = 0;
                                                END;
                                            END;
                                            IF ISNULL(@certRegSeqn, 0) > 0 AND ISNULL(@certRegRegType, '') = 'B'
                                            BEGIN
                                                INSERT INTO [#TTPList]
                                                       SELECT @certRegSeqn;
                                            END;
                                            FETCH NEXT FROM get_subcategories INTO @compProdCode;
                                        END;
                                        CLOSE get_subcategories;
                                        DEALLOCATE get_subcategories;
                                    END;
                                END;
                                IF ISNULL(@unitsFromSubCategories, 0) > 0
                                BEGIN
                                    SELECT @totalUnits = @totalUnits + @unitsFromSubCategories;
                                    SELECT @unitsFromSubCategories = 0;
                                END;
                                ELSE
                                BEGIN
                                    IF @unitsFromSubCategories < @cplUnitsRequiredForCredit
                                    BEGIN
                                        SELECT @abort = 1;
                                    END;
                                END;
                            END;
                            ELSE
                            BEGIN
                                TRUNCATE TABLE [#ComponentList];
                                SELECT @unitsFromComponents = 0;
                                SELECT @unitsFromSubComponents = 0;
                                INSERT INTO [#ComponentList]
                                       SELECT [p].[PRODUCT_CODE]
                                         FROM [Cert_Register] AS [cr],
                                              [Product_Cert] AS [pc],
                                              [Product] AS [p]
                                        WHERE [p].[PRODUCT_CODE] = [pc].[PRODUCT_CODE] AND [pc].[PRODUCT_CODE] = [cr].[REGISTRATION_ITEM] AND [p].[CATEGORY] = @cplComponentCategory AND [p].[PROD_TYPE] = 'CERTIFY' AND [pc].[SUBCOMPONENT] = 0 AND [cr].[STUDENT_ID] = @studentID AND ( ([cr].[REG_TYPE] = 'C' OR [cr].[REG_TYPE] = 'B') AND ([cr].[PROGRAM_ID] = '' OR [cr].[PROGRAM_ID] = @programID) AND ([cr].[PROGRAM_REG_SEQN] = 0 OR [cr].[PROGRAM_REG_SEQN] = @seqn) )
                                        GROUP BY [p].[PRODUCT_CODE];
                                DECLARE get_components CURSOR
                                FOR SELECT [PRODUCT_CODE]
                                      FROM [#ComponentList];
                                OPEN get_components;
                                FETCH NEXT FROM get_components INTO @compProdCode;
                                IF @@FETCH_STATUS <> 0
                                BEGIN
                                    SELECT @abort = 1;
                                END;
                                WHILE @@FETCH_STATUS = 0
                                BEGIN
                                    SELECT @productCertParent = 0;
                                    SELECT @certRegUnitsEarned = 0;
                                    SELECT @certRegSeqn = 0;
                                    SELECT @certRegRegType = '';
                                    SELECT @certRegProgID = '';
                                    SELECT @productCertParent = [pc].[PARENT],
                                           @certRegUnitsEarned = [cr].[UNITS_EARNED],
                                           @certRegSeqn = [cr].[SEQN],
                                           @certRegRegType = [cr].[REG_TYPE],
                                           @certRegProgID = [cr].[PROGRAM_ID]
                                      FROM [Product_Cert] AS [pc]
                                           LEFT OUTER JOIN [Cert_Register] AS [cr] ON [pc].[PRODUCT_CODE] = [cr].[REGISTRATION_ITEM]
                                     WHERE [pc].[PRODUCT_CODE] = @compProdCode AND [cr].[STUDENT_ID] = @studentID AND ( ([cr].[REG_TYPE] = 'C' OR [cr].[REG_TYPE] = 'B') AND ([cr].[PROGRAM_ID] = '' OR [cr].[PROGRAM_ID] = @programID) AND ([cr].[PROGRAM_REG_SEQN] = 0 OR [cr].[PROGRAM_REG_SEQN] = @seqn) ) AND [cr].[STATUS] = 'P';
                                    IF ISNULL(@certRegSeqn, 0) > 0
                                    BEGIN
                                        IF ISNULL(@certRegUnitsEarned, 0) > 0
                                        BEGIN
                                            SELECT @unitsFromComponents = @unitsFromComponents + @certRegUnitsEarned;
                                            SELECT @certRegUnitsEarned = 0;
                                        END;
                                        IF ISNULL(@productCertParent, 0) <> 0
                                        BEGIN
                                            TRUNCATE TABLE [#SubcomponentList];
                                            INSERT INTO [#SubcomponentList]
                                                   SELECT [PRODUCT_CODE],
                                                          [LINE_NUMBER],
                                                          [CHILD_PRODUCT_CODE],
                                                          [REQUIRED],
                                                          0
                                                     FROM [Product_Sub]
                                                    WHERE [Product_Sub].[PRODUCT_CODE] = @compProdCode;
                                            DECLARE get_subcomponents CURSOR
                                            FOR SELECT @subCompChildProdCode
                                                  FROM [#SubcomponentList];
                                            OPEN get_subcomponents;
                                            FETCH NEXT FROM get_subcomponents INTO @subCompChildProdCode;
                                            WHILE @@FETCH_STATUS = 0
                                            BEGIN
                                                SELECT @certRegUnitsEarned = 0;
                                                SELECT @certRegUnitsEarned = [cr].[UNITS_EARNED]
                                                  FROM [Cert_Register] AS [cr]
                                                 WHERE [cr].[REGISTRATION_ITEM] = @subCompChildProdCode AND [cr].[STUDENT_ID] = @studentID AND ( ([cr].[REG_TYPE] = 'C' OR [cr].[REG_TYPE] = 'B') AND ([cr].[PROGRAM_ID] = '' OR [cr].[PROGRAM_ID] = @programID) AND ([cr].[PROGRAM_REG_SEQN] = 0 OR [cr].[PROGRAM_REG_SEQN] = @seqn) ) AND [cr].[STATUS] = 'P';
                                                IF ISNULL(@certRegUnitsEarned, 0) > 0
                                                BEGIN
                                                    UPDATE [#SubcomponentList]
                                                       SET [SubcomponentCompleted] = 1
                                                     WHERE CURRENT OF [get_subcomponents];
                                                    SELECT @unitsFromSubComponents = @unitsFromSubComponents + @certRegUnitsEarned;
                                                    SELECT @certRegUnitsEarned = 0;
                                                END;
                                                FETCH NEXT FROM get_subcomponents INTO @subCompChildProdCode;
                                            END;
                                            CLOSE get_subcomponents;
                                            DEALLOCATE get_subcomponents;
                                            SELECT @unitsFromComponents = @unitsFromComponents + @unitsFromSubComponents;
                                        END;
                                        IF ISNULL(@certRegRegType, '') = 'B'
                                        BEGIN
                                            INSERT INTO [#TTPList]
                                                   SELECT @certRegSeqn;
                                        END;
                                    END;
                                    FETCH NEXT FROM get_components INTO @compProdCode;
                                END;
                                CLOSE get_components;
                                DEALLOCATE get_components;
                                IF ISNULL(@unitsFromComponents, 0) > 0 AND (ISNULL(@unitsFromComponents, 0) >= ISNULL(@cplUnitsRequiredForCredit, 0))
                                BEGIN
                                    SELECT @totalUnits = @totalUnits + @unitsFromComponents;
                                    SELECT @unitsFromComponents = 0;
                                    SELECT @unitsFromSubComponents = 0;
                                END;
                                ELSE
                                BEGIN
                                    SELECT @abort = 1;
                                END;
                            END;
                        END;
                    END;
                    FETCH NEXT FROM get_requirements INTO @cplProgramID,
                                                          @cplComponentCode,
                                                          @cplComponentCategory,
                                                          @cplLineNumber,
                                                          @cplLineType,
                                                          @cplUnitsRequiredForCredit,
                                                          @cplRequirementType;
                END;
                CLOSE get_requirements;
                DEALLOCATE get_requirements;
            END;
            IF @abort = 1
            BEGIN
                SELECT @totalUnits = 0;
                SELECT @abort = 0;
            END;
            IF (@totalUnits > 0 AND @totalUnitsRequiredForCredit > 0 AND @totalUnits >= @totalUnitsRequiredForCredit) OR (@totalUnits = 0 AND @totalUnitsRequiredForCredit = 0) AND @certRegSeqn > 0
            -- jf - 19 oct 07 -- check @CertRegSeqn>0
            BEGIN
                SELECT @completionDate = @now;
                INSERT INTO [#CompletedList]
                       SELECT @studentID,
                              @completionDate,
                              @programID,
                              @fullName,
                              @company,
                              @city,
                              @stateProvince,
                              @country,
                              @seqn,
                              @activitySeqn,
                              @inGracePeriod,
                              @autoEnrollForMaint,
                              @programType,
                              @rotateDateRule,
                              @rotateBeginDate,
                              @rotateCompletionMonths,
                              @designation1,
                              @designation2,
                              @designation3,
                              @gracePeriodForInit,
                              @gracePeriodForMaint,
                              @deadline,
                              @goodThruDate,
                              @coID,
                              @memberType,
                              @totCharges,
                              @cRNotes,
                              @requirementType,
                              @title;
                UPDATE [Cert_Register]
                   SET [PROGRAM_ID] = @programID,
                       [PROGRAM_REG_SEQN] = @seqn
                  FROM [Cert_Register], [#TTPList]
                 WHERE [SEQN] = [TTPComponentRegSeqn];
                IF ISNULL(@notifyBoard, 0) = 0 AND ISNULL(@notifyStudent, 0) = 0
                BEGIN
                    UPDATE [Cert_Register]
                       SET [COMPLETION_DATE] = @now,
                           [STATUS] = 'P'
                     WHERE [SEQN] = @seqn;
                END;
                IF ISNULL(@notifyBoard, 0) = 0 AND ISNULL(@notifyStudent, 0) <> 0
                BEGIN
                    UPDATE [Cert_Register]
                       SET [COMPLETION_DATE] = @now,
                           [STATUS] = 'P',
                           [STUDENT_NOTIFIED_DATE] = @now,
                           [STUDENT_NOTIFIED] = 1,
                           [REQUIREMENT_TYPE] = @requirementType
                     WHERE [SEQN] = @seqn;
                END;
                IF ISNULL(@notifyBoard, 0) <> 0 AND ISNULL(@notifyStudent, 0) = 0
                BEGIN
                    UPDATE [Cert_Register]
                       SET [COMPLETION_DATE] = @now,
                           [STATUS] = 'P',
                           [BOARD_NOTIFIED_DATE] = @now,
                           [BOARD_NOTIFIED] = 1,
                           [REQUIREMENT_TYPE] = @requirementType
                     WHERE [SEQN] = @seqn;
                END;
                IF ISNULL(@notifyBoard, 0) <> 0 AND ISNULL(@notifyStudent, 0) <> 0
                BEGIN
                    UPDATE [Cert_Register]
                       SET [COMPLETION_DATE] = @now,
                           [STATUS] = 'P',
                           [BOARD_NOTIFIED_DATE] = @now,
                           [STUDENT_NOTIFIED_DATE] = @now,
                           [STUDENT_NOTIFIED] = 1,
                           [BOARD_NOTIFIED] = 1,
                           [REQUIREMENT_TYPE] = @requirementType
                     WHERE [SEQN] = @seqn;
                END;
                SELECT @actString = '';
                IF ISNULL(@notifyBoard, 0) <> 0
                BEGIN
                    SELECT @actString = 'Board notified: ' + @currentLocalDate;
                END;
                IF ISNULL(@notifyStudent, 0) <> 0
                BEGIN
                    IF DATALENGTH(@actString) > 0
                    BEGIN
                        SELECT @actString = @actString + ' Student notified: ' + @currentLocalDate;
                    END;
                    ELSE
                    BEGIN
                        SELECT @actString = 'Student notified: ' + @currentLocalDate;
                    END;
                END;
                UPDATE [Activity]
                   SET [AMOUNT] = @totCharges,
                       [EFFECTIVE_DATE] = @now,
                       [ACTION_CODES] = 'Passed',
                       [UNITS] = @totalUnits,
                       [NOTE_2] = @actString
                 WHERE [SEQN] = @activitySeqn;
                SELECT @totalUnits = 0;
            END;
            ELSE
            BEGIN
                SELECT @treatDeadline = 1;
            END;
            IF ISNULL(@treatDeadline, 0) = 1
            BEGIN
                SELECT @treatDeadline = 0;
                IF DATEDIFF(day, @deadline, @now) > 0
                BEGIN
                    IF (@allowGracePeriods > 0 AND ( (@requirementType = 0 AND @gracePeriodForInit = 1) OR (@requirementType = 1 AND @gracePeriodForMaint = 1) ) ) AND ISNULL(@inGracePeriod, 0) = 0
                    BEGIN
                        IF @updateGoodThruForGracePeriod > 0
                        BEGIN
                            UPDATE [Cert_Register]
                               SET [IN_GRACE_PERIOD] = 1,
                                   [GOOD_THRU_DATE] = DATEADD(month, @gracePeriodMonths, @goodThruDate) - 1,
                                   [DEADLINE] = DATEADD(month, @gracePeriodMonths, @deadline) - 1
                             WHERE [SEQN] = @seqn;
                        END;
                        ELSE
                        BEGIN
                            UPDATE [Cert_Register]
                               SET [IN_GRACE_PERIOD] = 1,
                                   [DEADLINE] = DATEADD(month, @gracePeriodMonths, @deadline) - 1
                             WHERE [SEQN] = @seqn;
                        END;
                    END;
                END;
            END;
        END;
        FETCH NEXT FROM get_rows INTO @seqn,
                                      @studentID,
                                      @registrationItem,
                                      @status,
                                      @enrolledDate,
                                      @totCharges,
                                      @cRNotes,
                                      @deadline,
                                      @completionDate,
                                      @boardNotified,
                                      @goodThruDate,
                                      @requirementType,
                                      @inGracePeriod,
                                      @activitySeqn,
                                      @gracePeriodMonths,
                                      @gracePeriodForInit,
                                      @gracePeriodForMaint,
                                      @designation1,
                                      @designation2,
                                      @designation3,
                                      @jointProgram,
                                      @autoEnrollForMaint,
                                      @rotateDateRule,
                                      @rotateBeginDate,
                                      @rotateCompletionMonths,
                                      @fullName,
                                      @company,
                                      @city,
                                      @stateProvince,
                                      @country,
                                      @coID,
                                      @memberType,
                                      @programID,
                                      @title,
                                      @programType;
    END;
    CLOSE get_rows;
    DEALLOCATE get_rows;
    DECLARE treat_results CURSOR
    FOR SELECT *
          FROM [#CompletedList]
         ORDER BY [PROGRAM];
    OPEN treat_results;
    FETCH NEXT FROM treat_results INTO @studentID,
                                       @completionDate,
                                       @programID,
                                       @fullName,
                                       @company,
                                       @city,
                                       @stateProvince,
                                       @country,
                                       @seqn,
                                       @activitySeqn,
                                       @inGracePeriod,
                                       @autoEnrollForMaint,
                                       @programType,
                                       @rotateDateRule,
                                       @rotateBeginDate,
                                       @rotateCompletionMonths,
                                       @designation1,
                                       @designation2,
                                       @designation3,
                                       @gracePeriodForInit,
                                       @gracePeriodForMaint,
                                       @deadline,
                                       @goodThruDate,
                                       @coID,
                                       @memberType,
                                       @totCharges,
                                       @cRNotes,
                                       @requirementType,
                                       @title;
    WHILE @@fetch_Status = 0
    BEGIN
        IF ISNULL(@autoEnrollForMaint, 0) <> 0 AND ISNULL(@programType, 0) <> 0
        BEGIN
            EXEC @result = [sp_iboGetCounter]
                 'Activity',
                 1,
                 @newActSeqn OUTPUT;
            EXEC @result = [sp_iboGetCounter]
                 'Cert_Register',
                 1,
                 @newProgSeqn OUTPUT;
            IF @goodThruDate IS NOT NULL
            BEGIN
                SELECT @enrolledDate = @goodThruDate + 1;
            END;
            IF @requirementType = 0
            BEGIN
                IF @rotateDateRule = 0
                BEGIN
                    SELECT @deadline = @rotateBeginDate;
                END;
                IF @rotateDateRule = 1
                BEGIN
                    SELECT @deadline = DATEADD(month, @rotateCompletionMonths, @enrolledDate) - 1;
                END;
                IF @rotateDateRule > 1
                BEGIN
                    SELECT @deadline = NULL;
                END;
            END;
            IF @requirementType <> 0
            BEGIN
                IF @rotateDateRule = 0
                BEGIN
                    SELECT @deadline = DATEADD(month, @rotateCompletionMonths, @rotateBeginDate) - 1;
                    WHILE @deadline <= @enrolledDate AND @rotateCompletionMonths > 0
                    BEGIN
                        SELECT @deadline = DATEADD(month, @rotateCompletionMonths, @deadline);
                    END;
                END;
                IF @rotateDateRule = 1
                BEGIN
                    SELECT @deadline = DATEADD(month, @rotateCompletionMonths, @enrolledDate) - 1;
                END;
                IF @rotateDateRule > 1
                BEGIN
                    SELECT @deadline = NULL;
                END;
            END;
            IF @deadline IS NOT NULL
            BEGIN
                SELECT @goodThruDate = @deadline;
            END;
            BEGIN TRANSACTION;
            INSERT INTO [Cert_Register] ([SEQN],
                                         [ENROLLED_DATE],
                                         [STATUS],
                                         [REG_TYPE],
                                         [STUDENT_ID],
                                         [BT_ID],
                                         [REGISTRATION_ITEM],
                                         [REQUIREMENT_TYPE],
                                         [DESCRIPTION],
                                         [DEADLINE],
                                         [GOOD_THRU_DATE],
                                         [ACTIVITY_SEQN]
                                        )
            VALUES (@newProgSeqn,
                    @enrolledDate,
                    'E',
                    'P',
                    @studentID,
                    @studentID,
                    @registrationItem,
                    1,
                    @title + ' - Maintenance',
                    @deadline,
                    @goodThruDate,
                    @newActSeqn
                   );
            INSERT INTO [Activity] ([SEQN],
                                    [ID],
                                    [NOTE],
                                    [ACTIVITY_TYPE],
                                    [SOURCE_SYSTEM],
                                    [PRODUCT_CODE],
                                    [TRANSACTION_DATE],
                                    [DESCRIPTION],
                                    [AMOUNT],
                                    [MEMBER_TYPE],
                                    [UF_1],
                                    [UF_2],
                                    [UF_3],
                                    [UF_4],
                                    [UF_5],
                                    [UF_6],
                                    [UF_7],
                                    [CO_ID],
                                    [EFFECTIVE_DATE],
                                    [THRU_DATE],
                                    [ACTION_CODES],
                                    [CATEGORY]
                                   )
            VALUES (@newActSeqn,
                    @studentID,
                    @cRNotes,
                    'CERTIFICAT',
                    'CERTIFICAT',
                    @programID,
                    @enrolledDate,
                    @title + ' - Maintenance',
                    @totCharges,
                    @memberType,
                    @actUF1,
                    @actUF2,
                    @actUF3,
                    @actUF4,
                    @actUF5,
                    @actUF6,
                    @actUF7,
                    @coID,
                    NULL,
                    @goodThruDate,
                    'Enrolled',
                    'Maint'
                   );
            COMMIT TRANSACTION;
        END;
        FETCH NEXT FROM treat_results INTO @studentID,
                                           @completionDate,
                                           @programID,
                                           @fullName,
                                           @company,
                                           @city,
                                           @stateProvince,
                                           @country,
                                           @seqn,
                                           @activitySeqn,
                                           @inGracePeriod,
                                           @autoEnrollForMaint,
                                           @programType,
                                           @rotateDateRule,
                                           @rotateBeginDate,
                                           @rotateCompletionMonths,
                                           @designation1,
                                           @designation2,
                                           @designation3,
                                           @gracePeriodForInit,
                                           @gracePeriodForMaint,
                                           @deadline,
                                           @goodThruDate,
                                           @coID,
                                           @memberType,
                                           @totCharges,
                                           @cRNotes,
                                           @requirementType,
                                           @title;
    END;
    CLOSE treat_results;
    DEALLOCATE treat_results;
    SELECT [STUDENT_ID],
           [COMPLETION_DATE],
           [PROGRAM],
           [FULLNAME],
           [COMPANY],
           [CITY],
           [STATE_PROVINCE],
           [COUNTRY],
           [Designation1],
           [Designation2],
           [Designation3]
      FROM [#CompletedList]
     ORDER BY [PROGRAM];
END;


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_ClearOldQueryResults]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_ClearOldQueryResults]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[sp_asi_ClearOldQueryResults]
       @lastTime datetime = NULL
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @deleteTime datetime;
    SELECT @deleteTime = CASE WHEN @lastTime IS NULL
                              THEN DATEADD([d], -2, dbo.asi_GetAppDatetime())
                              ELSE @lastTime
                         END;
    WHILE (@@ROWCOUNT > 0)
    BEGIN
        DELETE [QueryResultItem]
          FROM (SELECT TOP 500 [QueryResultItem].[QueryResultKey]
                  FROM [QueryResultItem]
                       LEFT OUTER JOIN [QueryResultMain] ON [QueryResultItem].[QueryResultKey] = [QueryResultMain].[QueryResultKey]
                 WHERE [QueryResultMain].[CreatedOn] < @deleteTime
               ) [q1]
         WHERE [QueryResultItem].[QueryResultKey] = [q1].[QueryResultKey];
    END;
    SELECT @deleteTime = @deleteTime;   --Reset rowcount counter
    WHILE (@@ROWCOUNT > 0)
    BEGIN
        DELETE [QueryResultMain]
          FROM (SELECT TOP 500 [QueryResultMain].[QueryResultKey]
                  FROM [QueryResultMain]
                 WHERE [QueryResultMain].[CreatedOn] < @deleteTime
               ) [q1]
         WHERE [QueryResultMain].[QueryResultKey] = [q1].[QueryResultKey];
    END;
    SELECT @deleteTime = @deleteTime; --Reset rowcount counter
    WHILE (@@ROWCOUNT > 0)
    BEGIN
        DELETE [QueryResultItem]
          FROM (SELECT TOP 500 [QueryResultItem].[QueryResultKey]
                  FROM [QueryResultItem]
                       LEFT OUTER JOIN [QueryResultMain] ON [QueryResultItem].[QueryResultKey] = [QueryResultMain].[QueryResultKey]
                 WHERE [QueryResultMain].[QueryResultKey] IS NULL
               ) [q1]
         WHERE [QueryResultItem].[QueryResultKey] = [q1].[QueryResultKey];
    END;
END;


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_ClientUpgrade]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_ClientUpgrade]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE sp_asi_ClientUpgrade AS 
DECLARE 	@machinename varchar(255),
		@MACaddress varchar(20),
		@installerpath varchar(255),
		@clientomnispath varchar(255),
		@clientimispath varchar(255),
		@usermessage varchar(2048),
		@cmd varchar(2048),
		@tmpnum int
--Set defaults for optional paths
SET @clientomnispath = ''
SET @clientimispath =''
SET @installerpath = ''
		
--Check to see if the InstallerPath exists
set @tmpnum = (select count(*)
     		FROM System_Params
    		WHERE ParameterName = 'System_Control.InstallerPath')
if @tmpnum = 0
	goto endit
--Since Omnis suppresses machine name, resolve its address from its MAC address
--Will not retrieve address of local host!!
SET @MACaddress = (SELECT lower(net_address)
			FROM master.dbo.sysprocesses
			WHERE spid = @@spid)
--Stuff in the hypens for a real address as arp uses
SET @MACaddress = STUFF(@MACaddress, 11, 0, '-')
SET @MACaddress = STUFF(@MACaddress, 9, 0, '-')
SET @MACaddress = STUFF(@MACaddress, 7, 0, '-')
SET @MACaddress = STUFF(@MACaddress, 5, 0, '-')
SET @MACaddress = STUFF(@MACaddress, 3, 0, '-')
	
--Get the ipaddress of the machine
drop table #Macaddresses	
create table #Macaddresses (CMD_OUTPUT varchar(300) null)
insert into #Macaddresses exec master.dbo.xp_cmdshell 'arp -A'
	
--Get the ip address of the client
SET @machinename = (SELECT ltrim(rtrim(substring(CMD_OUTPUT,1,20))) 
			FROM #Macaddresses 
			WHERE CMD_OUTPUT like '%' + @MACaddress + '%')
--Get push install params from database
--iMIS installer path
SET @installerpath = (SELECT ShortValue
			FROM System_Params
			WHERE ParameterName = 'System_Control.InstallerPath')
		
--Client paths
SET @clientomnispath = (SELECT rtrim(ShortValue)
			FROM System_Params
			WHERE ParameterName = 'System_Control.ClientOmnisPath')
SET @clientimispath = (SELECT rtrim(ShortValue)
			FROM System_Params
			WHERE ParameterName = 'System_Control.ClientiMISPath')
--Message for client
SET @usermessage = (SELECT rtrim(ShortValue)
			FROM System_Params
			WHERE ParameterName = 'System_Control.UserUpgradeMsg')
if datalength (@usermessage) = 0 or @usermessage IS NULL -- default message
	set @usermessage = 'Your system is beginning iMIS upgrade procedures.  Exit iMIS and any running applications.  When prompted, follow the instructions to upgrade your current installation.' 
--If the Installer path is blank, DO NOT push
IF rtrim(@installerpath) = '' or datalength (@installerpath) = 0
	GOTO endit
IF @clientomnispath IS NULL
	SET @clientomnispath = ' '
IF @clientimispath IS NULL
	SET @clientimispath = ' '
--Check which optional parameters are actually set
IF  isnull(@clientomnispath,'') <> '' 
	SET @clientomnispath = ' /o ' + @clientomnispath
IF  isnull(@clientimispath,'') <> '' 
	SET @clientimispath = ' /i ' + @clientimispath
		
--Check the installer path ends with a \
IF right(@installerpath,1) <> '\'
	SET @installerpath = @installerpath + '\'
		
/*xCmd v1.0 for NT4/2000 - executes commands remotely
Freeware! 2001 Zoltan Csizmadia, zoltan_csizmadia@yahoo.com
		
Usage: xCmd.exe \\computer [options] command/exe arguments
		
Options:
   /D:directory           Set working directory
                          Default: Remote "%SystemRoot%\System32"
   /IDLE                  Idle priority class
   /NORMAL                Normal priority class
   /HIGH                  High priority class
   /REALTIME              Realtime priority class
   /C                     Copy the specified program to the remote mac
                          "%SystemRoot%\System32" directory
                          Commands's exe file must be absolute to loca
   /USER:user             User for remote connection
   /PWD:{password|*}      Password for remote connection
   /NOWAIT                Don't wait for remote process to terminate
Examples:
   xCmd.exe \\remote cmd       // Starts a "telnet" client
   xCmd.exe \\remote /nowait runme.exe
   xCmd.exe \\remote /user:administrator dir c:\
   xCmd.exe \\remote /user:somebody /pwd:* /d:d:\ test1.exe
   xCmd.exe \\remote /c /user:somebody /pwd:* /d:d:\ test2.exe
		
Notes:
- Input is passed to remote machine when you press the ENTER.
- Ctrl-C terminates the remote process
- Command and file path arguments have to be absolute to remote machin
  If you are using /c option, command exe file path must be absolute t
  local machine, but the arguments must be absolute to remote machine*/
	
--Display upgrade message to user
SET @cmd = 'net send ' + rtrim(@machinename) + '  "' + rtrim(@usermessage) + '"'
EXEC master.dbo.xp_cmdshell @cmd
--Launch installer
SET @cmd = 'xCmd \\' + rtrim(@machinename) + ' /C /NOWAIT '  + rtrim(@installerpath) + 'Setup.exe /z"/u' + rtrim(@clientomnispath) + rtrim(@clientimispath) + '"'
EXEC master.dbo.xp_cmdshell @cmd
endit:
RETURN

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_CreateLogins]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_CreateLogins]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE  [dbo].[sp_asi_CreateLogins]
AS
    -- script to fix up a restored iMIS db for iMIS15
    --    Henry Huey 13 Sept 2006
    --    Paul Bradshaw 15 Feb 2010
    SET NOCOUNT ON

    ------------------------------------
    -- create the IMIS role if necessary
    ------------------------------------
    IF NOT EXISTS (SELECT 1 FROM sys.database_principals WHERE [name] = 'IMIS' AND [type_desc] = 'DATABASE_ROLE' )
    BEGIN
	    CREATE ROLE [IMIS] AUTHORIZATION [dbo]
    END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_db_name]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_db_name]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE sp_asi_db_name (@input_version varchar(20) = '4.0.0.0') 
		AS 
 		declare @system_version varchar(20)
 		select (convert (varchar(64), db_name ()))
 
 		if @input_version <> '4.0.0.0'   -- iMIS passed in the version parameter (10.1 or higher client)
			begin
				select @system_version = ShortValue from System_Params 
    				where ParameterName = 'System_Control.Version' 
   				
				if @input_version >= @system_version
					goto endit -- versions match (db and client) so proceed without upgrade
    			end
 
 		-- fell through to this point; 
  		-- either there's no input parameter, so iMIS didn't pass one in, and upgrade is needed;
  		-- or there's a version mismatch between the db and the client, so an upgrade is needed
  		exec sp_asi_ClientUpgrade
 
  		endit: 
  		return

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_DeleteCmty]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_DeleteCmty]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE sp_asi_DeleteCmty 
 @cmty_seq int
 as
 delete from Cmty_Read_Tracking where COMMUNITY_SEQ = @cmty_seq
 delete from Cmty_News where COMMUNITY_SEQ = @cmty_seq
 delete from Cmty_Administrators where COMMUNITY_SEQ = @cmty_seq
 delete from Cmty_Subscription where COMMUNITY_SEQ = @cmty_seq
 delete from Cmty_Invitees where COMMUNITY_SEQ = @cmty_seq
 delete from Cmty_Discussion_Posts where COMMUNITY_SEQ = @cmty_seq
 delete from Cmty_Discussion_Forums where COMMUNITY_SEQ = @cmty_seq
 delete from Cmty_Shared_Files where COMMUNITY_SEQ = @cmty_seq
 delete from Cmty_Shared_Folders where COMMUNITY_SEQ = @cmty_seq
 delete from Cmty_Email_Notification where COMMUNITY_SEQ = @cmty_seq
 delete from Community where COMMUNITY_SEQ = @cmty_seq
 return

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_DeleteForum]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_DeleteForum]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE sp_asi_DeleteForum
 @forum_seq int
 as
 delete from Cmty_Read_Tracking where  FORUM_SEQ = @forum_seq
 delete from Cmty_Discussion_Posts where  FORUM_SEQ = @forum_seq
 delete from Cmty_Discussion_Forums where FORUM_SEQ = @forum_seq
 return

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_GetCounter2]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_GetCounter2]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


CREATE PROCEDURE [dbo].[sp_asi_GetCounter2] @CounterName varchar(30), @CounterValue int out 
AS 
BEGIN
    -- Ensure the counter exists
    INSERT INTO [dbo].[Counter] ([COUNTER_NAME], [LAST_VALUE]) 
        SELECT @CounterName, 0
         WHERE NOT EXISTS (SELECT 1 FROM [dbo].[Counter] WITH (ROWLOCK) WHERE [COUNTER_NAME] = @CounterName)

    -- Increment the counter value by 1 and return it atomically
    UPDATE [dbo].[Counter] WITH (ROWLOCK)
       SET [LAST_VALUE] = [LAST_VALUE] + 1,
           @CounterValue = [LAST_VALUE] + 1,
           [LAST_UPDATED] = GETDATE(),
           [UPDATED_BY] = USER_NAME()
     WHERE [COUNTER_NAME] = @CounterName
END



GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_Discussions]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_Discussions]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[sp_asi_Discussions]
 (@POST_SEQ_1 int,
  @TOPIC_SEQ_2 int,
  @FORUM_SEQ_3 int,
  @COMMUNITY_SEQ_4 int,
  @POST_TITLE_5 varchar(80),
  @TREE_LOCATION_6 varchar(255),
  @ID_7 varchar(10),
  @ANONYMOUS_FLAG_8 bit,
  @DATE_STORED_9 datetime)
 AS 
 DECLARE @find varchar(255)
 DECLARE @length  int
 DECLARE @thread_num  int
 DECLARE @date_last_post  datetime
 DECLARE @post_count int
 if @TOPIC_SEQ_2 = 0 
   BEGIN
     exec sp_asi_GetCounter2 'Cmty_Discussion_Topics', @TOPIC_SEQ_2 output
     SELECT @TREE_LOCATION_6 = NULL
     SELECT @date_last_post = @DATE_STORED_9
     SELECT @post_count = 1
   END
 else
     BEGIN
       IF @TREE_LOCATION_6 IS NULL
         SELECT @TREE_LOCATION_6 = '000'
       ELSE IF @TREE_LOCATION_6 = ''
         SELECT @TREE_LOCATION_6 = '000'
       SELECT @length = LEN(@TREE_LOCATION_6)-3
       SELECT @find = SUBSTRING(@TREE_LOCATION_6,1,@length) + 'zzz'
       SELECT @TREE_LOCATION_6 = MAX(TREE_LOCATION) FROM Cmty_Discussion_Posts WHERE TOPIC_SEQ = @TOPIC_SEQ_2 AND TREE_LOCATION < @find
       SELECT @thread_num = CAST(SUBSTRING(@TREE_LOCATION_6,@length+1,3) AS int)
       SELECT @TREE_LOCATION_6 = SUBSTRING(@TREE_LOCATION_6,1,@length)
       if @thread_num < 999 
          SELECT @thread_num = @thread_num + 1
       if @thread_num < 10 
         SELECT @TREE_LOCATION_6 = RTRIM(@TREE_LOCATION_6 + '00' + CAST(@thread_num AS char))
       else
 BEGIN
    if @thread_num < 100 
         SELECT @TREE_LOCATION_6 = RTRIM(@TREE_LOCATION_6 + '0' + CAST(@thread_num AS char))
         else
         SELECT @TREE_LOCATION_6 = RTRIM(@TREE_LOCATION_6 + CAST(@thread_num AS char))
 END
       if @TREE_LOCATION_6 IS NULL 
         SELECT @TREE_LOCATION_6 = '001'
       SELECT @date_last_post = NULL
       SELECT @post_count = NULL
     END
 INSERT INTO Cmty_Discussion_Posts 
  ( POST_SEQ,
   TOPIC_SEQ,
   FORUM_SEQ,
   COMMUNITY_SEQ,
   POST_TITLE,
   TREE_LOCATION,
   ID,
   ANONYMOUS_FLAG,
   DATE_STORED,
   STATUS,
  DATE_LAST_POST,
  POST_COUNT) 
 VALUES 
 ( @POST_SEQ_1,
  @TOPIC_SEQ_2,
  @FORUM_SEQ_3,
  @COMMUNITY_SEQ_4,
  @POST_TITLE_5,
  @TREE_LOCATION_6,
  @ID_7,
  @ANONYMOUS_FLAG_8,
  @DATE_STORED_9,
  'ACT',
  @date_last_post,
  @post_count)
 if @post_count IS NULL 
 UPDATE Cmty_Discussion_Posts SET DATE_LAST_POST = @DATE_STORED_9, POST_COUNT = POST_COUNT + 1
 WHERE TOPIC_SEQ = @TOPIC_SEQ_2 AND TREE_LOCATION IS NULL

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_FetchImage]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_FetchImage]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
Create Procedure sp_asi_FetchImage  @fieldname varchar(255),      @where varchar(255),      @pos int,      @size int AS declare @ptrval varchar(16),  @sqlstring varchar(255),  @tablename varchar(255) SELECT @tablename = SUBSTRING(@fieldname,1,CHARINDEX('.',@fieldname)-1) SELECT @sqlstring =  'declare @ptrval binary(16)' +     ' SELECT @ptrval=TEXTPTR(' + @fieldname + ')' +     ' FROM ' + @tablename + ' ' + @where +    ' if @ptrval <> NULL READTEXT ' + @fieldname + ' @ptrval ' +    CONVERT(varchar,@pos) + ' ' + CONVERT(varchar,@size) +    ' else SELECT NULL' EXECUTE (@sqlstring)

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_UpdateNameIndex]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_UpdateNameIndex]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE sp_asi_UpdateNameIndex 
 	@id varchar(10),			-- Name.ID
 	@fieldName varchar(61),			-- <Table>.<FIELD>
 	@fieldValue varchar(8000) = NULL,
 	@indexName varchar(31) = NULL
 AS
 	if @indexName is null
 	begin
 		select @indexName = (CASE WHEN ParameterName = 'Member_Control.Index1Fld' THEN '1'
 					  WHEN ParameterName = 'Member_Control.Index2Fld' THEN '2'
 					  WHEN ParameterName = 'Member_Control.Index3Fld' THEN '3'
 					  WHEN ParameterName = 'Member_Control.Index4Fld' THEN '4'
 				     END)
 		from System_Params where ParameterName like 'Member_Control.Index%Fld' and ShortValue = @fieldName
 	end
 	if @indexName is not null
 	begin
 		-- is this a delete
 		if @fieldValue is null
 		begin
 			delete from Name_Indexes where ID = @id and INDEX_NAME = @indexName
 		end
 		else
 		begin
 			-- Insert or update
 			-- Field is an index; check to see if it's a UD multiselect field
 			declare @udms int
 			set @udms = 0
 			select @udms = 1 where exists (select * from UD_Field where TABLE_NAME + '.' + FIELD_NAME = @fieldName and MULTI_SELECT = 1)
 			if @udms = 0
 			begin
 				-- is not a UD MS field; simple insert/update
 				update Name_Indexes
 				set INDEX_VALUE = UPPER(LEFT(@fieldValue, 30))
 				where ID = @id
 				and INDEX_NAME = @indexName
 				if @@ROWCOUNT = 0
 					insert into Name_Indexes (ID, INDEX_NAME, INDEX_VALUE, QUANTITY) values (@id, @indexName, UPPER(LEFT(@fieldValue, 30)), 0)
 			end
 			else
 			begin
 				-- Is a multiselect field
 				-- Delete existing index values
 				delete from Name_Indexes where ID = @id and INDEX_NAME = @indexName
 				-- Split on commas and insert new index values
 				declare @idx int
 				declare @value varchar(30)
 				set @idx = CHARINDEX(',', @fieldValue, 0)
 				while @idx > 0
 				begin
 					set @value = UPPER(LEFT(SUBSTRING(@fieldValue, 1, @idx - 1), 30))
 					insert into Name_Indexes (ID, INDEX_NAME, INDEX_VALUE, QUANTITY) values (@id, @indexName, @value, 0)
 					set @fieldValue = SUBSTRING(@fieldValue, @idx + 1, LEN(@fieldValue) - @idx)
 					set @idx = CHARINDEX(',', @fieldValue, 0)
 				end
 				insert into Name_Indexes (ID, INDEX_NAME, INDEX_VALUE, QUANTITY) values (@id, @indexName, UPPER(LEFT(@fieldValue, 30)), 0)
 			end
 		end
 	end

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_FlowdownNameIndex]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_FlowdownNameIndex]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE sp_asi_FlowdownNameIndex 
 	@co_id varchar(10),
 	@fieldName varchar(61),
 	@fieldValue varchar(8000) = NULL,
 	@indexName varchar(31) = NULL
 AS
 if @indexName is null
 begin
   select @indexName = (case when ParameterName = 'Member_Control.Index1Fld' then '1'
     when ParameterName = 'Member_Control.Index2Fld' then '2'
     when ParameterName = 'Member_Control.Index3Fld' then '3'
     when ParameterName = 'Member_Control.Index4Fld' then '4'
     end) from System_Params where ParameterName like 'Member_Control.Index-3Fld' and ShortValue = @fieldName
 end
 if @indexName is not null
   begin
     declare @isAddress int
     select @isAddress = (case
       when LEFT(@fieldName,12) = 'Name_Address' then 1
       when @fieldName = 'Name.CITY' then 1
       when @fieldName = 'Name.STATE_PROVINCE' then 1
       when @fieldName = 'Name.ZIP' then 1
       when @fieldName = 'Name.COUNTRY' then 1
       when @fieldName = 'Name.MAIL_CODE' then 1
       when @fieldName = 'Name.CRRT' then 1
       when @fieldName = 'Name.BAR_CODE' then 1
       when @fieldName = 'Name.COUNTY' then 1
       when @fieldName = 'Name.FULL_ADDRESS' then 1
       when @fieldName = 'Name.WORK_PHONE' then 1
       when @fieldName = 'Name.FAX' then 1
       when @fieldName = 'Name.TOLL_FREE' then 1
       else 0
     end)
     declare @childID varchar(10)
     if @isAddress = 1
     begin
       declare Get_Address_Children cursor for select Name.ID from Name, Name_Address where CO_ID = @co_id AND COMPANY_RECORD = 0 AND Name.ID = Name_Address.ID AND Name.ADDRESS_NUM_1 = Name.MAIL_ADDRESS_NUM and Name.MAIL_ADDRESS_NUM = Name_Address.ADDRESS_NUM
       open Get_Address_Children
       fetch next from Get_Address_Children into @childID
       while @@FETCH_STATUS = 0
       begin
         exec sp_asi_UpdateNameIndex @childID, @fieldName, @fieldValue, @indexName
         fetch next from Get_Address_Children into @childID
       end
       close Get_Address_Children
       deallocate Get_Address_Children
     end
     else
     begin
       declare Get_Children cursor for select ID from Name where CO_ID = @co_id AND COMPANY_RECORD = 0
       open Get_Children
       fetch next from Get_Children into @childID
       while @@FETCH_STATUS = 0
       begin
         exec sp_asi_UpdateNameIndex @childID, @fieldName, @fieldValue, @indexName
         fetch next from Get_Children into @childID
       end
       close Get_Children
       deallocate Get_Children
     end
   end

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_FolderPath]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_FolderPath]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE sp_asi_FolderPath 
             @currentfolder int
 AS
 DECLARE         @currentparent int,
                         @folderpath varchar(2048)
 SET @currentparent = (SELECT FOLDER_PARENT FROM Cmty_Shared_Folders WHERE FOLDER_SEQ=@currentfolder)
 SET @folderpath = LTRIM(STR(@currentfolder))
 WHILE @currentparent > 0
 BEGIN
             SET @folderpath = STUFF(@folderpath, 1, 0, LTRIM(STR(@currentparent) + '\'))
             SET @currentfolder = @currentparent
             SET @currentparent = (SELECT FOLDER_PARENT FROM Cmty_Shared_Folders WHERE FOLDER_SEQ=@currentfolder)
 END
 select @folderpath as FOLDERPATH
 RETURN

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_FRDonations]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_FRDonations]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[sp_asi_FRDonations]
       @id                   varchar(10),
       @includeOutrightGifts bit          = 0,
       @includePledges       bit          = 0,
       @includeSoftCredit    bit          = 0,
       @includeMatching      bit          = 0,
       @includeInKind        bit          = 0,
       @includeWrittenOff    bit          = 0,
       @includeFundRaising   bit          = 0,
       @includeEvents        bit          = 0,
       @includeDues          bit          = 0,
       @fundFilter           varchar(255) = '',
       @campaignFilter       varchar(255) = '',
       @distributionFilter   varchar(255) = '',
       @fromDate             datetime     = '',
       @throughDate          datetime     = '',
       @fromAmount           money        = 0.00,
       @throughAmount        money        = 0.00,
       @selectType           varchar(40)  = '',
       @doSplits             bit          = 0,
       @topLast              int          = 0,
       @topWhat              varchar(10)  = '',
       @topYears             int          = 0,
       @includeMidTerm       bit          = 0,
       @onlyPaidPortion      bit          = 0
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @transNum          int,
            @fund              varchar(20),
            @prevTransNum      int,
            @prevFund          varchar(20),
            @source            varchar(20),
            @product           varchar(31),
            @prevProduct       varchar(31),
            @productMajor      varchar(15),
            @eventCode         varchar(10),
            @invoiceRefNum     int,
            @sql               varchar(1000),
            @year              varchar(4),
            @prevYear          varchar(4),
            @amount            money,
            @prevAmount        money,
            @roundAmount       money,
            @yTD               money,
            @lifetime          money,
            @largest           money,
            @dateLargest       datetime,
            @donorSince        datetime,
            @currentYear       varchar(10),
            @campaign          varchar(10),
            @prevCampaign      varchar(10),
            @include           int,
            @midTermAmount     money,
            @pledgeLifetime    money,
            @pledgeLargest     money,
            @datePledgeLargest datetime,
            @dateGiftLast      datetime,
            @datePledgeLast    datetime,
            @pledgePaid        money,
            @pledgeBalance     money,
            @giftType          varchar(20), -- jf - dt17506
            @historyRowCount   int;
    CREATE TABLE [#FRDonationTemp] (
                 [ID]                  varchar(10),
                 [OriginalTransNumber] int,
                 [TransactionNumber]   int,
                 [InvoiceRefNum]       int,
                 [SourceSystem]        varchar(20),
                 [TransactionDate]     datetime,
                 [Amount]              money,
                 [AdjustmentAmount]    money,
                 [PaymentAmount]       money,
                 [Product]             varchar(31),
                 [Appeal]              varchar(40),
                 [Campaign]            varchar(10),
                 [Fund]                varchar(10),
                 [GiftType]            varchar(20),
                 [MatchOrSoftCredit]   varchar(20),
                 [PaymentType]         varchar(15),
                 [AdjustmentFlag]      varchar(3),
                 [ProductMajor]        varchar(15),
                 [MemTribId]           varchar(10),
                 [MemTribNameText]     varchar(100),
                 [ListAs]              varchar(255),
                 [SolicitorId]         varchar(10),
                 [FiscalPeriod]        int,
                 INCLUDE               int
    );
    CREATE TABLE [#FRDonation] (
                 [ID]                  varchar(10),
                 [OriginalTransNumber] int,
                 [TransactionNumber]   int,
                 [InvoiceRefNum]       int,
                 [SourceSystem]        varchar(20),
                 [TransactionDate]     datetime,
                 [Amount]              money,
                 [AdjustmentAmount]    money,
                 [PaymentAmount]       money,
                 [Product]             varchar(31),
                 [Appeal]              varchar(40),
                 [Campaign]            varchar(10),
                 [Fund]                varchar(10),
                 [GiftType]            varchar(20),
                 [MatchOrSoftCredit]   varchar(20),
                 [PaymentType]         varchar(15),
                 [AdjustmentFlag]      varchar(3),
                 [ProductMajor]        varchar(15),
                 [MemTribId]           varchar(10),
                 [MemTribNameText]     varchar(100),
                 [ListAs]              varchar(255),
                 [SolicitorId]         varchar(10),
                 [FiscalPeriod]        int,
                 INCLUDE               int
    );
    CREATE TABLE [#Trends] (
                 [TransactionNumber] int,
                 [TheYear]           varchar(4),
                 [Amount]            money,
                 [Calc]              int
    );
    CREATE TABLE [#FRPayment] (
                 [ID]                  varchar(10),
                 [OriginalTransNumber] int,
                 [TransactionNumber]   int,
                 [DateReceived]        datetime,
                 [InvoiceRefNum]       int,
                 [PaymentAmount]       money,
                 [GiftType]            varchar(20),
                 [FiscalPeriod]        int
    );
    CREATE TABLE [#FRDonationHistory] (
                 [TransactionNumber] int,
                 [InvoiceRefNum]     int,
                 [SourceSystem]      varchar(20),
                 [TransactionDate]   datetime,
                 [Amount]            money,
                 [PaymentAmount]     money,
                 [Product]           varchar(31),
                 [Campaign]          varchar(10),
                 [Fund]              varchar(10),
                 [GiftType]          varchar(20),
                 [MatchOrSoftCredit] varchar(20),
                 [AdjustmentFlag]    varchar(3),
                 INCLUDE             int
    );
    TRUNCATE TABLE [#FRDonationTemp];
    TRUNCATE TABLE [#FRDonation];
    TRUNCATE TABLE [#Trends];
    TRUNCATE TABLE [#FRPayment];
    TRUNCATE TABLE [#FRDonationHistory];
    IF @includeEvents = 1
    BEGIN
        INSERT INTO [#FRDonation] ([ID],
                                   [OriginalTransNumber],
                                   [TransactionNumber],
                                   [InvoiceRefNum],
                                   [SourceSystem],
                                   [TransactionDate],
                                   [Amount],
                                   [AdjustmentAmount],
                                   [PaymentAmount],
                                   [Product],
                                   [Appeal],
                                   [Campaign],
                                   [Fund],
                                   [GiftType],
                                   [MatchOrSoftCredit],
                                   [PaymentType],
                                   [AdjustmentFlag],
                                   [ProductMajor],
                                   [MemTribId],
                                   [MemTribNameText],
                                   [ListAs],
                                   [SolicitorId],
                                   [FiscalPeriod],
                                   INCLUDE
                                  )
               SELECT MAX([Trans].[ST_ID]) AS [ID],
                      MIN([Trans].[TRANS_NUMBER]) AS [OriginalTransNum],
                      MIN([Trans].[TRANS_NUMBER]) AS [TransactionNumber],
                      MAX([Trans].[INVOICE_REFERENCE_NUM]) AS [InvoiceRefNum],
                      'Event' AS [SourceSystem],
                      MAX([Trans].[TRANSACTION_DATE]) AS [TransactionDate],
                      (SUM([Trans].[AMOUNT]) * -1) AS [Amount],
                      0 AS [AdjustmentAmount],
                      0 AS [PaymentAmount],
                      MAX([Trans].[PRODUCT_CODE]) AS [Product],
                      MAX([Trans].[SOURCE_CODE]) AS [Appeal],
                      MAX([Trans].[CAMPAIGN_CODE]) AS [Campaign],
                      MAX([Trans].[GL_ACCT_ORG_CODE]) AS [Fund],
                      'Gift' AS [GiftType],
                      '' AS [MatchOrSoftCredit],
                      '' AS [PaymentType],
                      '' AS [AdjustmentFlag],
                      MAX([p].[PRODUCT_MAJOR]) AS [ProductMajor],
                      '' AS [MemTribId],
                      '' AS [MemTribNameText],
                      '' AS [ListAs],
                      '' AS [SolicitorId],
                      MAX([Trans].[FISCAL_PERIOD]) AS [FiscalPeriod],
                      0 AS INCLUDE
                 FROM [Trans]
                      INNER JOIN [Product] AS [p] ON [p].[PRODUCT_CODE] = [Trans].[PRODUCT_CODE]
                WHERE [Trans].[SOURCE_SYSTEM] = 'MEETING' AND [Trans].[JOURNAL_TYPE] = 'IN' AND [Trans].[TRANSACTION_TYPE] = 'DIST' AND [Trans].[IS_FR_ITEM] = 1 AND [Trans].[POSTED] >= 2 AND [Trans].[ST_ID] = @id
                GROUP BY [Trans].[ST_ID],
                         [Trans].[INVOICE_REFERENCE_NUM],
                         [Trans].[GL_ACCT_ORG_CODE],
                         [Trans].[PRODUCT_CODE];
    END;
    DELETE [#FRDonation]
     WHERE [Amount] = 0.00;
    IF @includeDues = 1
    BEGIN
        INSERT INTO [#FRDonation] ([ID],
                                   [OriginalTransNumber],
                                   [TransactionNumber],
                                   [InvoiceRefNum],
                                   [SourceSystem],
                                   [TransactionDate],
                                   [Amount],
                                   [AdjustmentAmount],
                                   [PaymentAmount],
                                   [Product],
                                   [Appeal],
                                   [Campaign],
                                   [Fund],
                                   [GiftType],
                                   [MatchOrSoftCredit],
                                   [PaymentType],
                                   [AdjustmentFlag],
                                   [ProductMajor],
                                   [MemTribId],
                                   [MemTribNameText],
                                   [ListAs],
                                   [SolicitorId],
                                   [FiscalPeriod],
                                   INCLUDE
                                  )
               SELECT MAX([Trans].[ST_ID]) AS [ID],
                      MIN([Trans].[TRANS_NUMBER]) AS [OriginalTransNum],
                      MIN([Trans].[TRANS_NUMBER]) AS [TransactionNumber],
                      MAX([Trans].[INVOICE_REFERENCE_NUM]) AS [InvoiceRefNum],
                      'Dues' AS [SourceSystem],
                      MAX([Trans].[TRANSACTION_DATE]) AS [TransactionDate],
                      (SUM([Trans].[AMOUNT]) * -1) AS [Amount],
                      0 AS [AdjustmentAmount],
                      0 AS [PaymentAmount],
                      MAX([Trans].[PRODUCT_CODE]) AS [Product],
                      MAX([Trans].[SOURCE_CODE]) AS [Appeal],
                      MAX([Trans].[CAMPAIGN_CODE]) AS [Campaign],
                      MAX([Trans].[GL_ACCT_ORG_CODE]) AS [Fund],
                      'Pledge' AS [GiftType],
                      '' AS [MatchOrSoftCredit],
                      '' AS [PaymentType],
                      '' AS [AdjustmentFlag],
                      '' AS [ProductMajor],
                      '' AS [MemTribId],
                      '' AS [MemTribNameText],
                      '' AS [ListAs],
                      '' AS [SolicitorId],
                      MAX([Trans].[FISCAL_PERIOD]) AS [FiscalPeriod],
                      0 AS INCLUDE
                 FROM [Trans]
                WHERE [Trans].[SOURCE_SYSTEM] = 'DUES' AND [Trans].[JOURNAL_TYPE] = 'IN' AND [Trans].[TRANSACTION_TYPE] = 'DIST' AND [Trans].[IS_FR_ITEM] = 1 AND [Trans].[POSTED] >= 2 AND [Trans].[ST_ID] = @id
                GROUP BY [Trans].[ST_ID],
                         [Trans].[INVOICE_REFERENCE_NUM],
                         [Trans].[GL_ACCT_ORG_CODE],
                         [Trans].[PRODUCT_CODE]
               UNION ALL
               SELECT MAX([Trans].[ST_ID]) AS [ID],
                      MIN([Trans].[TRANS_NUMBER]) AS [OriginalTransNum],
                      MIN([Trans].[TRANS_NUMBER]) AS [TransactionNumber],
                      MAX([Trans].[INVOICE_REFERENCE_NUM]) AS [InvoiceRefNum],
                      'Dues' AS [SourceSystem],
                      MAX([Trans].[TRANSACTION_DATE]) AS [TransactionDate],
                      (SUM([Trans].[AMOUNT]) * -1) AS [Amount],
                      0 AS [AdjustmentAmount],
                      0 AS [PaymentAmount],
                      MAX([Trans].[PRODUCT_CODE]) AS [Product],
                      MAX([Trans].[SOURCE_CODE]) AS [Appeal],
                      MAX([Trans].[CAMPAIGN_CODE]) AS [Campaign],
                      MAX([Trans].[GL_ACCT_ORG_CODE]) AS [Fund],
                      'Gift' AS [GiftType],
                      '' AS [MatchOrSoftCredit],
                      '' AS [PaymentType],
                      '' AS [AdjustmentFlag],
                      '' AS [ProductMajor],
                      '' AS [MemTribId],
                      '' AS [MemTribNameText],
                      '' AS [ListAs],
                      '' AS [SolicitorId],
                      MAX([Trans].[FISCAL_PERIOD]) AS [FiscalPeriod],
                      0 AS INCLUDE
                 FROM [Trans]
                WHERE ([Trans].[SOURCE_SYSTEM] = 'DUES' OR [Trans].[SOURCE_SYSTEM] = 'SC') AND [Trans].[JOURNAL_TYPE] = 'PAY' AND [Trans].[TRANSACTION_TYPE] = 'DIST' AND [Trans].[IS_FR_ITEM] = 1 AND [Trans].[POSTED] >= 2 AND [Trans].[ST_ID] = @id
                GROUP BY [Trans].[ST_ID],
                         [Trans].[TRANS_NUMBER],
                         [Trans].[GL_ACCT_ORG_CODE],
                         [Trans].[PRODUCT_CODE];
    END;
    IF @includeSoftCredit = 1
    BEGIN
        -- jb dt14899 22 may 06 
        -- updated so only original soft credit is included, adjustment lines from CM/DM are not returned
        -- CM/DM adjustments are applied to the original value
        INSERT INTO [#FRDonation] ([ID],
                                   [OriginalTransNumber],
                                   [TransactionNumber],
                                   [InvoiceRefNum],
                                   [SourceSystem],
                                   [TransactionDate],
                                   [Amount],
                                   [AdjustmentAmount],
                                   [PaymentAmount],
                                   [Product],
                                   [Appeal],
                                   [Campaign],
                                   [Fund],
                                   [GiftType],
                                   [MatchOrSoftCredit],
                                   [PaymentType],
                                   [AdjustmentFlag],
                                   [ProductMajor],
                                   [MemTribId],
                                   [MemTribNameText],
                                   [ListAs],
                                   [SolicitorId],
                                   [FiscalPeriod],
                                   INCLUDE
                                  )
               SELECT MAX([Trans_SoftCredit].[SOFT_CREDIT_ID]) AS [ID],
                      MAX([Trans_SoftCredit].[TRANS_NUMBER]) AS [OriginalTransNum],
                      MAX([Trans_SoftCredit].[TRANS_NUMBER]) AS [TransactionNumber],
                      '' AS [InvoiceRefNum],
                      'Fundraising' AS [SourceSystem],
                      MAX([Activity].[TRANSACTION_DATE]) AS [TransactionDate],
                      SUM([Trans_SoftCredit].[AMOUNT] + [dbo].[fn_asi_SoftCreditCMDM_Amount] ([Trans_SoftCredit].[TRANS_NUMBER], [Trans_SoftCredit].[ORIGINATING_ACTIVITY_SEQN], [Trans_SoftCredit].[SOFT_CREDIT_ID]
                                                                                             ) ) AS [Amount],
                      0 AS [AdjustmentAmount],
                      0 AS [PaymentAmount],
                      MAX([Trans_SoftCredit].[PRODUCT_CODE]) AS [Product],
                      MAX([Activity].[SOURCE_CODE]) AS [Appeal],
                      MAX([Activity].[CAMPAIGN_CODE]) AS [Campaign],
                      MAX([Activity].[ORG_CODE]) AS [Fund],
                      (CASE WHEN MAX([Activity].[ACTIVITY_TYPE]) = 'GIFT'
                            THEN 'Gift'
                            ELSE 'Pledge'
                       END) AS [GiftType],
                      'Soft Credit' AS [MatchOrSoftCredit],
                      CASE WHEN MAX([Cash_Accounts].[ACCOUNT_TYPE]) = 0
                           THEN 'Cash' WHEN MAX([Cash_Accounts].[ACCOUNT_TYPE]) = 1
                           THEN 'Credit Card' WHEN MAX([Cash_Accounts].[ACCOUNT_TYPE]) = 2
                           THEN 'In Kind'
                           ELSE ''
                      END AS [PaymentType],
                      MAX(CASE [dbo].[fn_asi_SoftCreditCMDM_Exists] ([Trans_SoftCredit].[TRANS_NUMBER], [Trans_SoftCredit].[ORIGINATING_ACTIVITY_SEQN], [Trans_SoftCredit].[SOFT_CREDIT_ID]
                                                                    ) WHEN 1
                               THEN 'Yes'
                               ELSE ''
                          END) AS [AdjustmentFlag],
                      '' AS [ProductMajor],
                      '' AS [MemTribId],
                      '' AS [MemTribNameText],
                      '' AS [ListAs],
                      '' AS [SolicitorId],
                      MAX([Trans].[FISCAL_PERIOD]) AS [FiscalPeriod],
                      0 AS INCLUDE
                 FROM [Trans_SoftCredit]
                      INNER JOIN [Activity] ON [Activity].[SEQN] = [Trans_SoftCredit].[ORIGINATING_ACTIVITY_SEQN]
                      INNER JOIN [Trans] ON [Trans].[TRANS_NUMBER] = [Trans_SoftCredit].[TRANS_NUMBER]
                      LEFT OUTER JOIN [Cash_Accounts] ON [Trans].[CHECK_NUMBER] = [Cash_Accounts].[CASH_ACCOUNT_CODE]
                WHERE [Activity].[SOURCE_SYSTEM] = 'FR' AND [Trans].[LINE_NUMBER] = 1 AND [Trans].[SUB_LINE_NUMBER] = 1 AND [Trans].[POSTED] >= 2 AND [Trans_SoftCredit].[SOFT_CREDIT_ID] = @id AND [Trans_SoftCredit].[TRANS_NUMBER] = [Activity].[ORIGINATING_TRANS_NUM]       -- jb dt14899
                GROUP BY [Trans_SoftCredit].[SOFT_CREDIT_ID],
                         [Trans_SoftCredit].[TRANS_NUMBER],
                         [Activity].[ORG_CODE],
                         [Trans_SoftCredit].[PRODUCT_CODE];
    END;
    IF @includeFundRaising = 1
    BEGIN
        INSERT INTO [#FRDonationTemp] ([ID],
                                       [OriginalTransNumber],
                                       [TransactionNumber],
                                       [InvoiceRefNum],
                                       [SourceSystem],
                                       [TransactionDate],
                                       [Amount],
                                       [AdjustmentAmount],
                                       [PaymentAmount],
                                       [Product],
                                       [Appeal],
                                       [Campaign],
                                       [Fund],
                                       [GiftType],
                                       [MatchOrSoftCredit],
                                       [PaymentType],
                                       [AdjustmentFlag],
                                       [ProductMajor],
                                       [MemTribId],
                                       [MemTribNameText],
                                       [ListAs],
                                       [SolicitorId],
                                       [FiscalPeriod],
                                       INCLUDE
                                      )
               SELECT MAX([P].[BT_ID]) AS [ID],
                      (CASE WHEN MAX([P].[IS_MATCH_GIFT]) = 1
                            THEN MAX([P].[MATCH_GIFT_TRANS_NUM])
                            ELSE MAX([P].[TRANS_NUMBER])
                       END) AS [OriginalTransNumber],
                      MAX([P].[TRANS_NUMBER]) AS [TransactionNumber],
                      MAX([P].[INVOICE_REFERENCE_NUM]) AS [InvoiceRefNum],
                      'Fundraising' AS [SourceSystem],
                      MAX([P].[TRANSACTION_DATE]) AS [TransactionDate],
                      (SUM([P].[AMOUNT]) * -1) AS [Amount],
                      0 AS [AdjustmentAmount],
                      0 AS [PaymentAmount],
                      MAX([P].[PRODUCT_CODE]) AS [Product],
                      MAX([P].[SOURCE_CODE]) AS [Appeal],
                      MAX([P].[CAMPAIGN_CODE]) AS [Campaign],
                      MAX([P].[OWNER_ORG_CODE]) AS [Fund],
                      (CASE WHEN MAX([P].[INSTALL_BILL_DATE]) IS NULL
                            THEN 'Gift'
                            ELSE 'Pledge'
                       END) AS [GiftType],
                      (CASE WHEN MAX([P].[IS_MATCH_GIFT]) = 1
                            THEN 'Matching'
                            ELSE ''
                       END) AS [MatchOrSoftCredit],
                      CASE WHEN MAX([Cash_Accounts].[ACCOUNT_TYPE]) = 0
                           THEN 'Cash' WHEN MAX([Cash_Accounts].[ACCOUNT_TYPE]) = 1
                           THEN 'Credit Card' WHEN MAX([Cash_Accounts].[ACCOUNT_TYPE]) = 2
                           THEN 'In Kind'
                           ELSE ''
                      END AS [PaymentType],
                      '' AS [AdjustmentFlag],
                      '' AS [ProductMajor],
                      MAX([P].[MEM_TRIB_ID]) AS [MemTribId],
                      MAX([P].[MEM_TRIB_NAME_TEXT]) AS [MemTribNameText],
                      MAX([P].[ACTION_CODES]) AS [ListAs],
                      MAX([P].[SOLICITOR_ID]) AS [SolicitorId],
                      MAX([P].[FISCAL_PERIOD]) AS [FiscalPeriod],
                      0 AS INCLUDE
                 FROM [Trans] AS [P]
                      INNER JOIN [Invoice] AS [I] ON [I].[REFERENCE_NUM] = [P].[INVOICE_REFERENCE_NUM]
                      LEFT OUTER JOIN [Cash_Accounts] ON [P].[CHECK_NUMBER] = [Cash_Accounts].[CASH_ACCOUNT_CODE]
                WHERE [P].[JOURNAL_TYPE] = 'IN' AND [P].[TRANSACTION_TYPE] = 'DIST' AND [P].[SOURCE_SYSTEM] = 'FR' AND [P].[POSTED] >= 2 AND [P].[BT_ID] = @id
                GROUP BY [P].[BT_ID],
                         [P].[TRANS_NUMBER],
                         [P].[OWNER_ORG_CODE],
                         [P].[PRODUCT_CODE]
               UNION ALL
               SELECT MAX([C].[BT_ID]) AS [ID],
                      '' AS [OriginalTransNumber],
                      MAX([Invoice].[ORIGINATING_TRANS_NUM]) AS [TransactionNumber],
                      --'' as InvoiceRefNum, -- jf - 30 aug 06
                      max([C].[INVOICE_REFERENCE_NUM]) AS [InvoiceRefNum],
                      'Fundraising' AS [SourceSystem],
                      '' AS [TransactionDate],
                      (SUM([C].[AMOUNT]) * -1) AS [Amount],
                      (SUM([C].[AMOUNT]) * -1) AS [AdjustmentAmount],
                      0 AS [PaymentAmount],
                      MAX([C].[PRODUCT_CODE]) AS [Product],
                      '' AS [Appeal],
                      '' AS [Campaign],
                      MAX([C].[OWNER_ORG_CODE]) AS [Fund],
                      '' AS [GiftType],
                      '' AS [MatchOrSoftCredit],
                      '' AS [PaymentType],
                      'Yes' AS [AdjustmentFlag],
                      '' AS [ProductMajor],
                      '' AS [MemTribId],
                      '' AS [MemTribNameText],
                      '' AS [ListAs],
                      '' AS [SolicitorId],
                      0 AS [FiscalPeriod],
                      0 AS INCLUDE
                 FROM [Trans] AS [C]
                      INNER JOIN [Invoice] ON [Invoice].[REFERENCE_NUM] = [C].[INVOICE_REFERENCE_NUM]
                WHERE [Invoice].[SOURCE_SYSTEM] = 'FR' AND ( ([C].[JOURNAL_TYPE] = 'CM' AND [C].[TRANSACTION_TYPE] = 'DIST') OR ([C].[JOURNAL_TYPE] = 'DM' AND [C].[TRANSACTION_TYPE] = 'DIST') ) AND [C].[POSTED] >= 2 AND [C].[BT_ID] = @id
                GROUP BY [C].[BT_ID],
                         [C].[TRANS_NUMBER],
                         [C].[OWNER_ORG_CODE],
                         [C].[PRODUCT_CODE];
    END;
    IF @includeDues = 1
    BEGIN
        INSERT INTO [#FRDonationTemp] ([ID],
                                       [OriginalTransNumber],
                                       [TransactionNumber],
                                       [InvoiceRefNum],
                                       [SourceSystem],
                                       [TransactionDate],
                                       [Amount],
                                       [AdjustmentAmount],
                                       [PaymentAmount],
                                       [Product],
                                       [Appeal],
                                       [Campaign],
                                       [Fund],
                                       [GiftType],
                                       [MatchOrSoftCredit],
                                       [PaymentType],
                                       [AdjustmentFlag],
                                       [ProductMajor],
                                       [MemTribId],
                                       [MemTribNameText],
                                       [ListAs],
                                       [SolicitorId],
                                       [FiscalPeriod],
                                       INCLUDE
                                      )
               SELECT MAX([T].[BT_ID]) AS [ID],
                      '' AS [OriginalTransNumber],
                      MAX([Invoice].[ORIGINATING_TRANS_NUM]) AS [TransactionNumber],
                      MAX([T].[INVOICE_REFERENCE_NUM]) AS [InvoiceRefNum],
                      'Dues' AS [SourceSystem],
                      MAX([T].[TRANSACTION_DATE]) AS [TransactionDate], -- jf - 4 dec 09 -- PBI 1316
                      (SUM([T].[AMOUNT]) * -1) AS [Amount],
                      (SUM([T].[AMOUNT]) * -1) AS [AdjustmentAmount],
                      0 AS [PaymentAmount],
                      MAX([T].[PRODUCT_CODE]) AS [Product],
                      '' AS [Appeal],
                      '' AS [Campaign],
                      MAX([T].[OWNER_ORG_CODE]) AS [Fund],
                      'Pledge' AS [GiftType],
                      '' AS [MatchOrSoftCredit],
                      '' AS [PaymentType],
                      'Yes' AS [AdjustmentFlag],
                      '' AS [ProductMajor],
                      '' AS [MemTribId],
                      '' AS [MemTribNameText],
                      '' AS [ListAs],
                      '' AS [SolicitorId],
                      0 AS [FiscalPeriod],
                      0 AS INCLUDE
                 FROM [Trans] AS [T]
                      INNER JOIN [Invoice] ON [Invoice].[REFERENCE_NUM] = [T].[INVOICE_REFERENCE_NUM]
                WHERE [Invoice].[SOURCE_SYSTEM] = 'DUES' AND ( ([T].[JOURNAL_TYPE] = 'CM' AND [T].[TRANSACTION_TYPE] = 'DIST') OR ([T].[JOURNAL_TYPE] = 'DM' AND [T].[TRANSACTION_TYPE] = 'DIST') ) AND [T].[IS_FR_ITEM] = 1 AND [T].[POSTED] >= 2 AND [T].[BT_ID] = @id AND [T].[BT_ID] = [T].[ST_ID]
                GROUP BY [T].[BT_ID],
                         [T].[TRANS_NUMBER],
                         [T].[OWNER_ORG_CODE],
                         [T].[PRODUCT_CODE]
               UNION ALL
               SELECT MAX([T].[ST_ID]) AS [ID],
                      '' AS [OriginalTransNumber],
                      MAX([Invoice].[ORIGINATING_TRANS_NUM]) AS [TransactionNumber],
                      MAX([T].[INVOICE_REFERENCE_NUM]) AS [InvoiceRefNum],
                      'Dues' AS [SourceSystem],
                      '' AS [TransactionDate],
                      (SUM([T].[AMOUNT]) * -1) AS [Amount],
                      (SUM([T].[AMOUNT]) * -1) AS [AdjustmentAmount],
                      0 AS [PaymentAmount],
                      MAX([T].[PRODUCT_CODE]) AS [Product],
                      '' AS [Appeal],
                      '' AS [Campaign],
                      MAX([T].[OWNER_ORG_CODE]) AS [Fund],
                      'Pledge' AS [GiftType],
                      '' AS [MatchOrSoftCredit],
                      '' AS [PaymentType],
                      'Yes' AS [AdjustmentFlag],
                      '' AS [ProductMajor],
                      '' AS [MemTribId],
                      '' AS [MemTribNameText],
                      '' AS [ListAs],
                      '' AS [SolicitorId],
                      0 AS [FiscalPeriod],
                      0 AS INCLUDE
                 FROM [Trans] AS [T]
                      INNER JOIN [Invoice] ON [Invoice].[REFERENCE_NUM] = [T].[INVOICE_REFERENCE_NUM]
                WHERE [Invoice].[SOURCE_SYSTEM] = 'DUES' AND ( ([T].[JOURNAL_TYPE] = 'CM' AND [T].[TRANSACTION_TYPE] = 'DIST') OR ([T].[JOURNAL_TYPE] = 'DM' AND [T].[TRANSACTION_TYPE] = 'DIST') ) AND [T].[IS_FR_ITEM] = 1 AND [T].[POSTED] >= 2 AND [T].[ST_ID] = @id AND [T].[BT_ID] <> [T].[ST_ID]
                GROUP BY [T].[BT_ID],
                         [T].[TRANS_NUMBER],
                         [T].[OWNER_ORG_CODE],
                         [T].[PRODUCT_CODE];
    END;
    IF @selectType IN ('Donor History', 'SummaryData', 'Summary2', 'GiftPortfolio')
    BEGIN
        INSERT INTO [#FRPayment] ([ID],
                                  [OriginalTransNumber],
                                  [TransactionNumber],
                                  [DateReceived],
                                  [InvoiceRefNum],
                                  [PaymentAmount],
                                  [GiftType],
                                  [FiscalPeriod]
                                 )
               SELECT [C].[ST_ID] AS [ID],
                      MAX([P].[TRANS_NUMBER]) AS [OriginalTransNumber],
                      MAX([C].[TRANS_NUMBER]) AS [TransactionNumber],
                      MAX([P].[EFFECTIVE_DATE]) AS [DateReceived],
                      MAX([C].[INVOICE_REFERENCE_NUM]) AS [InvoiceRefNum],
                      SUM([C].[AMOUNT]) AS [PaymentAmount],
                      (CASE WHEN MAX([Activity].[ACTIVITY_TYPE]) = 'GIFT'
                            THEN 'Gift'
                            ELSE 'Pledge Payment'
                       END) AS [GiftType],
                      MAX([C].[FISCAL_PERIOD]) AS [FiscalPeriod]
                 FROM [Trans] AS [C]
                      INNER JOIN [Invoice] ON [Invoice].[REFERENCE_NUM] = [C].[INVOICE_REFERENCE_NUM]
                      INNER JOIN [Trans] AS [P] ON [P].[TRANS_NUMBER] = [Invoice].[ORIGINATING_TRANS_NUM]
                      INNER JOIN [Activity] ON [Activity].[SEQN] = [P].[ACTIVITY_SEQN]
                WHERE [P].[LINE_NUMBER] = 1 AND [P].[SUB_LINE_NUMBER] = 1 AND [P].[JOURNAL_TYPE] = 'IN' AND [P].[TRANSACTION_TYPE] = 'DIST' AND [Invoice].[SOURCE_SYSTEM] = 'FR' AND [C].[JOURNAL_TYPE] = 'IN' AND [C].[TRANSACTION_TYPE] = 'PAY' AND [C].[ST_ID] = @id
                GROUP BY [C].[ST_ID],
                         [C].[TRANS_NUMBER],
                         [C].[INVOICE_REFERENCE_NUM]
               UNION ALL
               SELECT [C].[ST_ID] AS [ID],
                      MAX([P].[TRANS_NUMBER]) AS [OriginalTransNumber],
                      MAX([P].[TRANS_NUMBER]) AS [TransactionNumber],
                      MAX([C].[TRANSACTION_DATE]) AS [DateReceived],
                      MAX([C].[INVOICE_REFERENCE_NUM]) AS [InvoiceRefNum],
                      (SUM([C].[AMOUNT]) * -1) AS [PaymentAmount],
                      (CASE WHEN MAX([Activity].[ACTIVITY_TYPE]) = 'GIFT'
                            THEN 'Gift'
                            ELSE 'Pledge Payment'
                       END) AS [GiftType],
                      MAX([C].[FISCAL_PERIOD]) AS [FiscalPeriod]
                 FROM [Trans] AS [C]
                      INNER JOIN [Invoice] ON [Invoice].[REFERENCE_NUM] = [C].[INVOICE_REFERENCE_NUM]
                      INNER JOIN [Trans] AS [P] ON [P].[TRANS_NUMBER] = [Invoice].[ORIGINATING_TRANS_NUM]
                      INNER JOIN [Activity] ON [Activity].[SEQN] = [P].[ACTIVITY_SEQN]
                WHERE [P].[LINE_NUMBER] = 1 AND [P].[SUB_LINE_NUMBER] = 1 AND [P].[JOURNAL_TYPE] = 'IN' AND [P].[TRANSACTION_TYPE] = 'DIST' AND [Invoice].[SOURCE_SYSTEM] = 'FR' AND [C].[JOURNAL_TYPE] = 'PAY' AND [C].[TRANSACTION_TYPE] = 'AR' AND [C].[ST_ID] = @id
                GROUP BY [C].[ST_ID],
                         [P].[TRANS_NUMBER]
               UNION ALL
               -- jf - 21 jun 06 dt16264
               SELECT [P].[ST_ID] AS [ID],
                      MAX([P].[TRANS_NUMBER]) AS [OriginalTransNumber],
                      MAX([C].[TRANS_NUMBER]) AS [TransactionNumber],
                      MAX([P].[EFFECTIVE_DATE]) AS [DateReceived],
                      MAX([P].[INVOICE_REFERENCE_NUM]) AS [InvoiceRefNum],
                      SUM([C].[INVOICE_CREDITS]) AS [PaymentAmount],
                      (CASE WHEN MAX([Activity].[ACTIVITY_TYPE]) = 'GIFT'
                            THEN 'Gift'
                            ELSE 'Pledge Payment'
                       END) AS [GiftType],
                      MAX([C].[FISCAL_PERIOD]) AS [FiscalPeriod]
                 FROM [Trans] AS [C]
                      INNER JOIN [Invoice] ON [Invoice].[REFERENCE_NUM] = [C].[INVOICE_REFERENCE_NUM]
                      INNER JOIN [Trans] AS [P] ON [P].[TRANS_NUMBER] = [Invoice].[ORIGINATING_TRANS_NUM]
                      INNER JOIN [Activity] ON [Activity].[SEQN] = [P].[ACTIVITY_SEQN]
                WHERE [P].[LINE_NUMBER] = 1 AND [P].[SUB_LINE_NUMBER] = 1 AND [P].[JOURNAL_TYPE] = 'IN' AND [P].[TRANSACTION_TYPE] = 'DIST' AND [Invoice].[SOURCE_SYSTEM] = 'FR' AND ( ([C].[JOURNAL_TYPE] = 'PAY' AND [C].[TRANSACTION_TYPE] = 'PAY') OR ([C].[JOURNAL_TYPE] = 'IN' AND [C].[TRANSACTION_TYPE] = 'TR') ) AND [P].[ST_ID] = @id
                GROUP BY [P].[ST_ID],
                         [P].[TRANS_NUMBER],
                         [P].[INVOICE_REFERENCE_NUM];
        IF @includeDues = 1
        BEGIN
            INSERT INTO [#FRPayment] ([ID],
                                      [OriginalTransNumber],
                                      [TransactionNumber],
                                      [DateReceived],
                                      [InvoiceRefNum],
                                      [PaymentAmount],
                                      [GiftType],
                                      [FiscalPeriod]
                                     )
                   SELECT [C].[BT_ID] AS [ID],
                          MAX([P].[TRANS_NUMBER]) AS [OriginalTransNumber],
                          MAX([C].[TRANS_NUMBER]) AS [TransactionNumber],
                          MAX([C].[TRANSACTION_DATE]) AS [DateReceived],
                          MAX([C].[INVOICE_REFERENCE_NUM]) AS [InvoiceRefNum],
                          SUM([Activity].[AMOUNT]) AS [PaymentAmount],
                          'Gift' AS [GiftType],
                          MAX([C].[FISCAL_PERIOD]) AS [FiscalPeriod]
                     FROM [Trans] AS [C]
                          INNER JOIN [Trans] AS [P] ON [P].[TRANS_NUMBER] = [C].[TRANS_NUMBER]
                          INNER JOIN [Activity] ON [Activity].[ORIGINATING_TRANS_NUM] = [P].[TRANS_NUMBER]
                    WHERE [Activity].[ACTIVITY_TYPE] = 'GIFT' AND [P].[LINE_NUMBER] = 1 AND [P].[SUB_LINE_NUMBER] = 1 AND [P].[JOURNAL_TYPE] = 'PAY' AND [P].[TRANSACTION_TYPE] = 'DIST' AND [P].[IS_FR_ITEM] = 1 AND [C].[JOURNAL_TYPE] = 'PAY' AND [C].[TRANSACTION_TYPE] = 'PAY' AND [C].[BT_ID] = @id
                    GROUP BY [C].[BT_ID],
                             [C].[TRANS_NUMBER],
                             [C].[INVOICE_REFERENCE_NUM]
                   UNION ALL
                   SELECT [T].[ST_ID] AS [ID],
                          MAX([I].[ORIGINATING_TRANS_NUM]) AS [OriginalTransNumber],
                          MAX([T].[TRANS_NUMBER]) AS [TransactionNumber],
                          MAX([T].[TRANSACTION_DATE]) AS [DateReceived],
                          MAX([T].[INVOICE_REFERENCE_NUM]) AS [InvoiceRefNum],
                          SUM([T].[AMOUNT]) * -1 AS [PaymentAmount],
                          'Pledge Payment' AS [GiftType],
                          MAX([T].[FISCAL_PERIOD]) AS [FiscalPeriod]
                     FROM [Trans] AS [T]
                          INNER JOIN [Invoice] AS [I] ON [I].[REFERENCE_NUM] = [T].[INVOICE_REFERENCE_NUM]
                          INNER JOIN [Invoice_Lines] AS [IL] ON [IL].[REFERENCE_NUM] = [T].[INVOICE_REFERENCE_NUM]
                    WHERE [T].[IS_FR_ITEM] = 1 AND ( ([T].[JOURNAL_TYPE] = 'IN' AND [T].[TRANSACTION_TYPE] = 'PAY') OR ([T].[JOURNAL_TYPE] = 'PAY' AND [T].[TRANSACTION_TYPE] = 'AR') ) AND [T].[ST_ID] = @id AND [I].[BT_ID] = [IL].[ST_ID] AND [T].[INVOICE_LINE_NUM] = [IL].[LINE_NUM] AND [I].[SOURCE_SYSTEM] = 'DUES' -- jf - 1 dec 09 -- PBI 1316
                    GROUP BY [T].[ST_ID],
                             [I].[ORIGINATING_TRANS_NUM]
                   UNION ALL
                   SELECT [T].[ST_ID] AS [ID],
                          MAX([I].[ORIGINATING_TRANS_NUM]) AS [OriginalTransNumber],
                          MAX([T].[TRANS_NUMBER]) AS [TransactionNumber],
                          MAX([T].[TRANSACTION_DATE]) AS [DateReceived],
                          MAX([T].[INVOICE_REFERENCE_NUM]) AS [InvoiceRefNum],
                          SUM([T].[AMOUNT]) * -1 AS [PaymentAmount],
                          'Pledge Payment' AS [GiftType],
                          MAX([T].[FISCAL_PERIOD]) AS [FiscalPeriod]
                     FROM [Trans] AS [T]
                          INNER JOIN [Invoice] AS [I] ON [I].[REFERENCE_NUM] = [T].[INVOICE_REFERENCE_NUM]
                          INNER JOIN [Invoice_Lines] AS [IL] ON [IL].[REFERENCE_NUM] = [T].[INVOICE_REFERENCE_NUM]
                    WHERE [T].[IS_FR_ITEM] = 1 AND ( ([T].[JOURNAL_TYPE] = 'IN' AND [T].[TRANSACTION_TYPE] = 'PAY') OR ([T].[JOURNAL_TYPE] = 'PAY' AND [T].[TRANSACTION_TYPE] = 'AR') ) AND [IL].[ST_ID] = @id AND [T].[INVOICE_LINE_NUM] = [IL].[LINE_NUM] AND [I].[SOURCE_SYSTEM] = 'DUES' -- jf - 1 dec 09 -- PBI 1316
                    GROUP BY [T].[ST_ID],
                             [I].[ORIGINATING_TRANS_NUM]
                   UNION
                   SELECT [A].[ID],
                          [A].[ORIGINATING_TRANS_NUM] AS [OriginalTransNumber],
                          MAX([A].[ORIGINATING_TRANS_NUM]) AS [TransactionNumber],
                          MAX([A].[TRANSACTION_DATE]) AS [DateReceived],
                          MAX([T].[INVOICE_REFERENCE_NUM]) AS [InvoiceRefNum],
                          SUM([A].[AMOUNT]) AS [PaymentAmount],
                          'Gift' AS [GiftType],
                          MAX([T].[FISCAL_PERIOD]) AS [FiscalPeriod]
                     FROM [Activity] AS [A]
                          INNER JOIN [Trans] AS [T] ON [T].[ACTIVITY_SEQN] = [A].[SEQN]
                    WHERE [A].[ACTIVITY_TYPE] IN ('GIFT', 'DUES') AND [T].[IS_FR_ITEM] = 1 AND [T].[JOURNAL_TYPE] = 'PAY' AND [T].[TRANSACTION_TYPE] = 'DIST' AND [A].[ID] = @id AND [T].[BT_ID] = @id AND ([A].[SOURCE_SYSTEM] = 'DUES' OR [A].[SOURCE_SYSTEM] = 'SC')
                    GROUP BY [A].[ID],
                             [A].[ORIGINATING_TRANS_NUM]
                   UNION
                   SELECT [A].[ID],
                          [A].[ORIGINATING_TRANS_NUM] AS [OriginalTransNumber],
                          MAX([A].[ORIGINATING_TRANS_NUM]) AS [TransactionNumber],
                          MAX([A].[TRANSACTION_DATE]) AS [DateReceived],
                          MAX([T].[INVOICE_REFERENCE_NUM]) AS [InvoiceRefNum],
                          SUM([A].[AMOUNT]) AS [PaymentAmount],
                          'Gift' AS [GiftType],
                          MAX([T].[FISCAL_PERIOD]) AS [FiscalPeriod]
                     FROM [Activity] AS [A]
                          INNER JOIN [Trans] AS [T] ON [T].[ACTIVITY_SEQN] = [A].[SEQN]
                    WHERE [A].[ACTIVITY_TYPE] IN ('GIFT', 'DUES') AND [T].[IS_FR_ITEM] = 1 AND [T].[JOURNAL_TYPE] = 'PAY' AND [T].[TRANSACTION_TYPE] = 'DIST' AND [A].[ID] = @id AND [T].[ST_ID] = @id AND [T].[ST_ID] <> [T].[BT_ID] AND ([A].[SOURCE_SYSTEM] = 'DUES' OR [A].[SOURCE_SYSTEM] = 'SC')
                    GROUP BY [A].[ID],
                             [A].[ORIGINATING_TRANS_NUM];
        END;
    END;
    INSERT INTO [#FRDonation] ([ID],
                               [OriginalTransNumber],
                               [TransactionNumber],
                               [InvoiceRefNum],
                               [SourceSystem],
                               [TransactionDate],
                               [Amount],
                               [AdjustmentAmount],
                               [PaymentAmount],
                               [Product],
                               [Appeal],
                               [Campaign],
                               [Fund],
                               [GiftType],
                               [MatchOrSoftCredit],
                               [PaymentType],
                               [AdjustmentFlag],
                               [ProductMajor],
                               [MemTribId],
                               [MemTribNameText],
                               [ListAs],
                               [SolicitorId],
                               [FiscalPeriod],
                               INCLUDE
                              )
           SELECT MAX([ID]) AS [ID],
                  MAX([OriginalTransNumber]) AS [OriginalTransNumber],
                  MAX([TransactionNumber]) AS [TransactionNumber],
                  MAX([InvoiceRefNum]) AS [InvoiceRefNum],
                  MAX([SourceSystem]) AS [SourceSystem],
                  MAX([TransactionDate]) AS [TransactionDate],
                  SUM([Amount]) AS [Amount],
                  SUM([AdjustmentAmount]) AS [AdjustmentAmount],
                  SUM([PaymentAmount]) AS [PaymentAmount],
                  MAX([Product]) AS [Product],
                  MAX([Appeal]) AS [Appeal],
                  MAX([Campaign]) AS [Campaign],
                  MAX([Fund]) AS [Fund],
                  MAX([GiftType]) AS [GiftType],
                  MAX([MatchOrSoftCredit]) AS [MatchOrSoftCredit],
                  MAX([PaymentType]) AS [PaymentType],
                  MAX([AdjustmentFlag]) AS [AdjustmentFlag],
                  MAX([ProductMajor]) AS [ProductMajor],
                  MAX([MemTribId]) AS [MemTribId],
                  MAX([MemTribNameText]) AS [MemTribNameText],
                  MAX([ListAs]) AS [ListAs],
                  MAX([SolicitorId]) AS [SolicitorId],
                  MAX([FiscalPeriod]) AS [FiscalPeriod],
                  MAX(INCLUDE) AS INCLUDE
             FROM [#FRDonationTemp]
            GROUP BY [ID],
                     [TransactionNumber],
                     [Fund],
                     [Product];
    IF @includeInKind = 0
    BEGIN
        DELETE [#FRDonation]
         WHERE [PaymentType] = 'In Kind';
    END;
    IF @includeMatching = 0
    BEGIN
        DELETE [#FRDonation]
         WHERE [MatchOrSoftCredit] = 'Matching';
    END;
    IF @selectType = 'SummaryData'
    BEGIN
        SELECT @currentYear = CONVERT( char(4), DATEPART(year, dbo.asi_GetAppDatetime())) + '0101';
        SELECT SUM([Amount]) AS [Amount],
               MAX([TransactionDate]) AS [TransactionDate] INTO [#MyTemp]
          FROM [#FRDonation]
         GROUP BY [TransactionNumber],
                  [InvoiceRefNum];
        SELECT @largest = MAX([Amount]),
               @dateLargest = MAX([TransactionDate])
          FROM [#MyTemp]
         GROUP BY [Amount];
        IF @onlyPaidPortion = 0
        BEGIN
            SELECT @lifetime = SUM([Amount])
              FROM [#FRDonation];
        END;
        ELSE
        BEGIN
            SELECT @lifetime = ISNULL(SUM([Amount]), 0)
              FROM [#FRDonation]
             WHERE [GiftType] = 'Gift' AND [MatchOrSoftCredit] NOT IN ('Matching', 'Soft Credit');
            SELECT @lifetime = @lifetime + ISNULL(SUM([PaymentAmount]), 0)
              FROM [#FRPayment]
             WHERE [GiftType] = 'Pledge Payment';
        END;
        SELECT @donorSince = MIN([TransactionDate])
          FROM [#FRDonation];
        IF @onlyPaidPortion = 0
        BEGIN
            SELECT @yTD = SUM([Amount])
              FROM [#FRDonation]
             WHERE [TransactionDate] >= @currentYear;
        END;
        ELSE
        BEGIN
            SELECT @yTD = ISNULL(SUM([Amount]), 0)
              FROM [#FRDonation]
             WHERE [TransactionDate] >= @currentYear AND [GiftType] = 'Gift' AND [MatchOrSoftCredit] NOT IN ('Matching', 'Soft Credit');
            SELECT @yTD = @yTD + ISNULL(SUM([PaymentAmount]), 0)
              FROM [#FRPayment]
             WHERE [GiftType] = 'Pledge Payment' AND [DateReceived] >= @currentYear;
        END;
        SELECT ISNULL(@lifetime, 0),
               ISNULL(@donorSince, ''),
               ISNULL(@largest, 0),
               ISNULL(@dateLargest, ''),
               ISNULL(@yTD, 0);
    END;
    IF @selectType = 'GiftPortfolio'
    BEGIN
        SELECT SUM([Amount]) AS [Amount],
               MAX([TransactionDate]) AS [TransactionDate],
               MAX([GiftType]) AS [GiftType] INTO [#MyTemp2]
          FROM [#FRDonation]
         GROUP BY [TransactionNumber],
                  [InvoiceRefNum];
        SELECT @largest = MAX([Amount])
          FROM [#MyTemp2]
         WHERE [GiftType] = 'Gift'
         GROUP BY [Amount];
        SELECT @pledgeLargest = MAX([Amount])
          FROM [#MyTemp2]
         WHERE [GiftType] = 'Pledge'
         GROUP BY [Amount];
        SELECT @lifetime = SUM([Amount])
          FROM [#FRDonation]
         WHERE [GiftType] = 'Gift';
        IF @onlyPaidPortion = 0
        BEGIN
            SELECT @pledgeLifetime = ISNULL(SUM([Amount]), 0)
              FROM [#FRDonation]
             WHERE [GiftType] = 'Pledge';
        END;
        ELSE
        BEGIN
            SELECT @pledgeLifetime = ISNULL(SUM([PaymentAmount]), 0)
              FROM [#FRPayment]
             WHERE [GiftType] = 'Pledge Payment';
        END;
        SELECT @datePledgeLast = MAX([TransactionDate])
          FROM [#FRDonation]
         WHERE [GiftType] = 'Pledge';
        SELECT @dateGiftLast = MAX([TransactionDate])
          FROM [#FRDonation]
         WHERE [GiftType] = 'Gift';
        SELECT @pledgeBalance = ISNULL(SUM([i].[BALANCE]), 0)
          FROM [Invoice] AS [i]
         WHERE [i].[BT_ID] = @id AND [i].[SOURCE_SYSTEM] = 'FR' AND [i].[ORIGINATING_TRANS_NUM] > 0 AND [i].[INSTALL_BILL_DATE] IS NOT NULL;
        SELECT @pledgeBalance = @pledgeBalance + ISNULL(SUM([BALANCE]), 0)
          FROM [Invoice_Lines]
         WHERE [ST_ID] = @id AND [IS_FR_ITEM] = 1;
        SELECT ISNULL(@lifetime, 0),
               ISNULL(@pledgeLifetime, 0),
               ISNULL(@largest, 0),
               ISNULL(@pledgeLargest, 0),
               ISNULL(@datePledgeLast, ''),
               ISNULL(@dateGiftLast, ''),
               ISNULL(@pledgeBalance, 0);
    END;
    IF @includeOutrightGifts = 0
    BEGIN
        DELETE [#FRDonation]
         WHERE [GiftType] = 'Gift' AND [MatchOrSoftCredit] NOT IN ('Matching', 'Soft Credit');
    END;
    IF @includePledges = 0
    BEGIN
        DELETE [#FRDonation]
         WHERE [GiftType] IN ('Pledge', 'Pledge Payment') AND [MatchOrSoftCredit] NOT IN ('Matching', 'Soft Credit');
    END;
    UPDATE [#FRDonation]
       SET [GiftType] = [GiftType] + '*'
     WHERE [MatchOrSoftCredit] <> '';
    IF @includeInKind = 1	-- jf - dt17507
    BEGIN
        UPDATE [#FRDonation]
           SET [GiftType] = [GiftType] + CHAR(134)
         WHERE [PaymentType] = 'In Kind';
    END;
    SELECT @include = 0;
    IF @fundFilter <> ''
    BEGIN
        UPDATE [#FRDonation]
           SET INCLUDE = 1
         WHERE CHARINDEX([Fund], @fundFilter) > 0;
        SELECT @include = 1;
    END;
    IF @campaignFilter <> ''
    BEGIN
        IF @fundFilter <> ''
        BEGIN
            UPDATE [#FRDonation]
               SET INCLUDE = 2
             WHERE CHARINDEX([Campaign], @campaignFilter) > 0 AND INCLUDE = 1;
            SELECT @include = 2;
        END;
        ELSE
        BEGIN
            UPDATE [#FRDonation]
               SET INCLUDE = 1
             WHERE CHARINDEX([Campaign], @campaignFilter) > 0;
            SELECT @include = 1;
        END;
    END;
    IF @distributionFilter <> ''
    BEGIN
        IF @fundFilter <> '' AND @campaignFilter <> ''
        BEGIN
            UPDATE [#FRDonation]
               SET INCLUDE = 3
             WHERE CHARINDEX(';' + [Product] + ';', @distributionFilter) > 0 AND INCLUDE = 2;
            SELECT @include = 3;
        END;
        IF @fundFilter <> '' AND @campaignFilter = ''
        BEGIN
            UPDATE [#FRDonation]
               SET INCLUDE = 2
             WHERE CHARINDEX(';' + [Product] + ';', @distributionFilter) > 0 AND INCLUDE = 1;
            SELECT @include = 2;
        END;
        IF @fundFilter = '' AND @campaignFilter <> ''
        BEGIN
            UPDATE [#FRDonation]
               SET INCLUDE = 2
             WHERE CHARINDEX(';' + [Product] + ';', @distributionFilter) > 0 AND INCLUDE = 1;
            SELECT @include = 2;
        END;
        IF @fundFilter = '' AND @campaignFilter = ''
        BEGIN
            UPDATE [#FRDonation]
               SET INCLUDE = 1
             WHERE CHARINDEX(';' + [Product] + ';', @distributionFilter) > 0 AND INCLUDE = 0;
            SELECT @include = 1;
        END;
    END;
    IF @doSplits = 1 --jf - 4 jul 07 - dt563 added Campaign for FR Dues.
    BEGIN
        DECLARE TheCursor CURSOR
        FOR SELECT [TransactionNumber],
                   [Fund],
                   [SourceSystem],
                   [Product],
                   [Campaign]
              FROM [#FRDonation]
             WHERE [SourceSystem] <> 'Event' AND [GiftType] <> ''
             ORDER BY [TransactionNumber]; -- jf - dt17506
        OPEN TheCursor;
        FETCH NEXT FROM TheCursor INTO @transNum,
                                       @fund,
                                       @source,
                                       @product,
                                       @campaign;
        WHILE @@fetch_Status = 0
        BEGIN
            IF @transNum = @prevTransNum AND @fund = @prevFund AND @product <> @prevProduct -- jf - 4 dec 09 -- PBI 1316
            BEGIN
                UPDATE [#FRDonation]
                   SET [Product] = '-Split-'
                 WHERE [TransactionNumber] = @transNum;
            END;
            IF @prevFund <> ''
            BEGIN
                IF @transNum = @prevTransNum AND @fund <> @prevFund
                BEGIN
                    UPDATE [#FRDonation]
                       SET [Fund] = '-Split-',
                           [Product] = '-Split-'
                     WHERE [TransactionNumber] = @transNum;
                END;
            END;
            IF @prevCampaign <> ''
            BEGIN
                IF @transNum = @prevTransNum AND @campaign <> @prevCampaign AND @campaign <> ''
                BEGIN
                    UPDATE [#FRDonation]
                       SET [Campaign] = '-Split-'
                     WHERE [TransactionNumber] = @transNum;
                END;
            END;
            BEGIN
                SELECT @prevTransNum = @transNum;
                SELECT @prevFund = @fund;
                SELECT @prevCampaign = @campaign;
                SELECT @prevProduct = @product;
            END;
            FETCH NEXT FROM TheCursor INTO @transNum,
                                           @fund,
                                           @source,
                                           @product,
                                           @campaign;
        END;
        CLOSE TheCursor;
        DEALLOCATE TheCursor;
    END;
    SELECT @prevFund = '';
    IF CHARINDEX(',', @fundFilter) = 0
    BEGIN
        DECLARE TheCursor CURSOR
        FOR SELECT [InvoiceRefNum],
                   [Fund],
                   [ProductMajor],
                   [Product],
                   [Campaign]
              FROM [#FRDonation]
             WHERE [SourceSystem] = 'Event'
             ORDER BY [InvoiceRefNum];
        OPEN TheCursor;
        FETCH NEXT FROM TheCursor INTO @invoiceRefNum,
                                       @fund,
                                       @productMajor,
                                       @product,
                                       @campaign;
        WHILE @@fetch_Status = 0
        BEGIN
            IF @productMajor = @eventCode AND @fund = @prevFund
            BEGIN
                UPDATE [#FRDonation]
                   SET [Product] = '-Split-',
                       [TransactionNumber] = [InvoiceRefNum]
                 WHERE [InvoiceRefNum] = @invoiceRefNum;
            END;
            IF @prevFund <> ''
            BEGIN
                IF @productMajor = @eventCode AND @fund <> @prevFund AND @fund <> ''
                BEGIN
                    UPDATE [#FRDonation]
                       SET [Fund] = '-Split-',
                           [Product] = '-Split-',
                           [TransactionNumber] = [InvoiceRefNum]
                     WHERE [InvoiceRefNum] = @invoiceRefNum;
                END;
            END;
            IF @prevCampaign <> ''
            BEGIN
                IF @productMajor = @eventCode AND @campaign <> @prevCampaign AND @campaign <> ''
                BEGIN
                    UPDATE [#FRDonation]
                       SET [Campaign] = '-Split-',
                           [TransactionNumber] = [InvoiceRefNum]
                     WHERE [InvoiceRefNum] = @invoiceRefNum;
                END;
            END;
            BEGIN
                SELECT @eventCode = @productMajor;
                SELECT @prevFund = @fund;
                SELECT @prevCampaign = @campaign;
            END;
            FETCH NEXT FROM TheCursor INTO @invoiceRefNum,
                                           @fund,
                                           @productMajor,
                                           @product,
                                           @campaign;
        END;
        CLOSE TheCursor;
        DEALLOCATE TheCursor;
    END;

    -- jf - 23 oct 06 dt18031
    --delete #FRDonation where OriginalTransNumber=0 and GiftType='' and AdjustmentFlag='Yes'
    -- jf - 10 feb 10 -- Change to above dt18031 fix. SMR 204631 - PBI 6630 - only delete adjustment if original transaction not found
    DELETE [#FRDonation]
      FROM [#FRDonation] [f]
     WHERE [f].[OriginalTransNumber] = 0 AND [f].[AdjustmentFlag] = 'Yes' AND NOT EXISTS (SELECT 1
                                                                                            FROM [Trans] AS [t]
                                                                                           WHERE [t].[JOURNAL_TYPE] = 'IN' AND [t].[TRANSACTION_TYPE] = 'DIST' AND ([t].[ACTIVITY_TYPE] = 'PLEDGE' OR [t].[ACTIVITY_TYPE] = 'GIFT') AND [t].[INVOICE_REFERENCE_NUM] = [f].[InvoiceRefNum]
                                                                                         );
    IF @selectType = 'Summary1'
    BEGIN
        SELECT @sql = 'select TOP ' + CONVERT( varchar(3), @topLast) + ' max(TransactionDate) Date,
sum(Amount) Amount,max(GiftType) Type,max(SourceSystem) Source
from #FRDonation group by TransactionNumber,InvoiceRefNum';
        IF @topWhat <> 'Donations'
        BEGIN
            SELECT @sql = @sql + ' having max(GiftType)=' + '''' + CONVERT( varchar(10), @topWhat) + '''';
        END;
        SELECT @sql = @sql + ' order by max(TransactionDate) Desc,TransactionNumber';
        EXEC (@sql);
    END;
    IF @selectType = 'Summary2'
    BEGIN
        IF @onlyPaidPortion = 0
        BEGIN
            INSERT INTO [#Trends]
                   SELECT [TransactionNumber],
                          MAX(SUBSTRING(CONVERT( char(6), [FiscalPeriod]), 1, 4)),
                          SUM([Amount]),
                          0
                     FROM [#FRDonation]
                    GROUP BY [TransactionNumber],
                             [InvoiceRefNum]; --,Product -- jf 30 aug 06
        END;
        ELSE
        BEGIN
            INSERT INTO [#Trends]
                   SELECT [TransactionNumber],
                          MAX(SUBSTRING(CONVERT( char(6), [FiscalPeriod]), 1, 4)),
                          SUM([Amount]),
                          0
                     FROM [#FRDonation]
                    WHERE [GiftType] IN ('Gift', 'Gift*', 'Pledge*')
                    GROUP BY [TransactionNumber],
                             [InvoiceRefNum]; --,Product -- jf 31 aug 06
            INSERT INTO [#Trends]
                   SELECT [TransactionNumber],
                          MAX(SUBSTRING(CONVERT( char(6), [FiscalPeriod]), 1, 4)),
                          SUM([PaymentAmount]),
                          0
                     FROM [#FRPayment]
                    WHERE [GiftType] = 'Pledge Payment'
                    GROUP BY [TransactionNumber];
        END;
        DECLARE TheCursor CURSOR
        FOR SELECT MAX([TheYear]),
                   SUM([Amount])
              FROM [#Trends]
             GROUP BY [TheYear]
             ORDER BY MAX([TheYear]) ASC;
        OPEN TheCursor;
        FETCH NEXT FROM TheCursor INTO @year,
                                       @amount;
        WHILE @@FETCH_STATUS = 0
        BEGIN
            IF @prevYear <> ''
            BEGIN
                --select @RoundAmount=((@Amount-@PrevAmount)/@PrevAmount)*100
                SELECT @roundAmount = ( (@amount - @prevAmount) / CASE WHEN @prevAmount = 0
                                                                       THEN 1
                                                                       ELSE @prevAmount
                                                                  END) * 100; -- 9/5/2012 cv replaced code above due to divide by zero error pbi 30575
                UPDATE [#Trends]
                   SET [Calc] = ROUND(@roundAmount, 0)
                 WHERE [TheYear] = @year;
            END;
            SELECT @prevYear = @year;
            SELECT @prevAmount = @amount;
            FETCH NEXT FROM TheCursor INTO @year,
                                           @amount;
        END;
        CLOSE TheCursor;
        DEALLOCATE TheCursor;
        SELECT @sql = 'select TOP ' + CONVERT( varchar(2), @topYears) + ' max(TheYear) Year,
sum(Amount) Amount,sum(Amount)/count(TransactionNumber) as Average,convert(varchar(25),max(Calc))+''%'' Calc from #Trends
group by TheYear order by max(TheYear) Desc';
        EXEC (@sql);
    END;
    IF @selectType = 'Donor History'
    BEGIN
        SELECT @sql = 'insert into #FRDonationHistory (TransactionNumber,InvoiceRefNum,TransactionDate,GiftType,MatchOrSoftCredit,
SourceSystem,Campaign,Fund,Product,Amount,PaymentAmount,AdjustmentFlag,Include) 
select TransactionNumber,InvoiceRefNum,max(TransactionDate) TransactionDate,max(GiftType) GiftType,
max(MatchOrSoftCredit) MatchOrSoftCredit,max(SourceSystem) SourceSystem,max(Campaign) Campaign,max(Fund) Fund,max(Product) Product,
sum(Amount) Amount,sum(PaymentAmount) PaymentAmount,max(AdjustmentFlag) AdjustmentFlag,max(Include) Include
from #FRDonation group by TransactionNumber,InvoiceRefNum,Product';
        EXEC (@sql);
        SELECT MAX([ID]) AS [ID],
               [OriginalTransNumber],
               MAX([TransactionNumber]) AS [TransactionNumber],
               MAX([DateReceived]) AS [DateReceived],
               MAX([InvoiceRefNum]) AS [InvoiceRefNum],
               SUM([PaymentAmount]) AS [PaymentAmount],
               MAX([GiftType]) AS [GiftType],
               MAX([FiscalPeriod]) AS [FiscalPeriod] INTO [#TempPayments]
          FROM [#FRPayment]
         GROUP BY [OriginalTransNumber];
        DELETE [#FRPayment];
        INSERT INTO [#FRPayment]
               SELECT *
                 FROM [#TempPayments];
        UPDATE [#FRDonationHistory]
           SET [#FRDonationHistory].[PaymentAmount] = [#FRPayment].[PaymentAmount]
          FROM [#FRDonationHistory]
               JOIN [#FRPayment] ON [#FRPayment].[OriginalTransNumber] = [#FRDonationHistory].[TransactionNumber]
         WHERE [#FRPayment].[OriginalTransNumber] = [#FRDonationHistory].[TransactionNumber] AND [#FRDonationHistory].[GiftType] <> '';
        UPDATE [#FRDonationHistory]
           SET [Product] = ''
         WHERE [GiftType] = ''; -- jf - dt17506
        IF @fromDate <> ''
        BEGIN
            DELETE [#FRDonationHistory]
             WHERE [TransactionDate] < @fromDate;
        END;
        IF @throughDate <> ''
        BEGIN
            DELETE [#FRDonationHistory]
             WHERE [TransactionDate] > @throughDate;
        END;
        SELECT @midTermAmount = 0.00;
        IF @includeMidTerm = 1
        BEGIN
            SELECT @midTermAmount = ISNULL(SUM([PaymentAmount]), 0)
              FROM [#FRPayment]
             WHERE [GiftType] = 'Pledge Payment' AND [TransactionNumber] NOT IN (SELECT [TransactionNumber]
                                                                                   FROM [#FRDonationHistory]
                                                                                );
        END;
        SELECT @historyRowCount = 0;
        SELECT @historyRowCount = COUNT(*)
          FROM [#FRDonationHistory];
        IF @historyRowCount > 0 -- jf - 23 jan 07 -- dt18065
        -- this ensures we get the midterm amount if there are no history rows..
        BEGIN
            SELECT @sql = 'select TransactionNumber,max(InvoiceRefNum),max(TransactionDate) Date,max(GiftType) Type,SourceSystem Source,
max(Campaign) Campaign,max(Fund) Fund,max(Product) Distribution_Product_Function,
sum(Amount) Total_Donation,sum(PaymentAmount) Amount_Paid,max(AdjustmentFlag) Adj,
case
when max(SourceSystem)=''Event'' then 0 
when max(MatchOrSoftCredit)=''Soft Credit'' then 0
else sum(Amount)-sum(PaymentAmount) end as Balance,' + CONVERT( varchar(10), @midTermAmount) + ' as MidTermAmount 
from #FRDonationHistory';
            IF @include > 0
            BEGIN
                SELECT @sql = @sql + ' where Include=' + CONVERT( varchar(1), @include) + ' group by TransactionNumber,SourceSystem';
            END;
            ELSE
            BEGIN
                SELECT @sql = @sql + ' group by TransactionNumber,SourceSystem';
            END;
            IF @fromAmount > 0 AND @throughAmount > 0
            BEGIN
                SELECT @sql = @sql + ' having sum(Amount)>=' + CONVERT( varchar(10), @fromAmount) + ' and sum(Amount)<=' + CONVERT(varchar(10), @throughAmount);
            END;
            IF @fromAmount > 0 AND @throughAmount = 0
            BEGIN
                SELECT @sql = @sql + ' having sum(Amount)>=' + CONVERT( varchar(10), @fromAmount);
            END;
            IF @fromAmount = 0 AND @throughAmount > 0
            BEGIN
                SELECT @sql = @sql + ' having isnull(sum(Amount),0)<=' + CONVERT( varchar(10), @throughAmount);
            END;
            IF @includeWrittenOff = 0
            BEGIN
                SELECT @sql = @sql + CASE WHEN @fromAmount > 0 OR @throughAmount > 0
                                          THEN ' and sum(Amount)>0.00'
                                          ELSE ' having sum(Amount)>0.00'
                                      END;
            END;
        END -- if row count
            ;
        ELSE
        BEGIN
            SELECT @sql = 'select 0 TransactionNumber,0 InvoiceRefNum,'''' Date,'''' Type,'''' Source,
'''' Campaign,'''' Fund,'''' Distribution_Product_Function,0.00 Total_Donation,0.00 Amount_Paid,0 Adj,0 Balance,
' + CONVERT( varchar(10), @midTermAmount) + ' MidTermAmount';
        END;
        EXEC (@sql);
    END;
END;



GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_FullAddress]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_FullAddress]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure sp_asi_FullAddress  
  @ADDRESS_1 varchar(40)=null, 
  @ADDRESS_2 varchar(40)=null,
  @ADDRESS_3 varchar(40)=null, 
  @CITY varchar(40)=null, 
  @STATE_PROVINCE varchar(15)=null, 
  @ZIP varchar(10)=null, 
  @COUNTRY varchar(25)=null
  as 
  declare 
  @formula varchar(255), 
  @code int,
  @addrlen int
  BEGIN 
  if datalength(@ADDRESS_1) = 0 and datalength(@ADDRESS_2) = 0 and datalength(@ADDRESS_3) = 0 and datalength(@CITY) = 0 
 and datalength(@STATE_PROVINCE) = 0 and datalength(@ZIP) = 0 and datalength(@COUNTRY) = 0
      begin
        select @formula=''
        select FULL_ADDRESS=@formula
        return
      end
  select @code = NULL
  select @code=ADDRESS_FORMAT from Country_Names where upper(COUNTRY)=upper(@COUNTRY) 
  select @code=isnull(@code,0)
  if @code=0  
    begin  if (not exists (select * from Country_Addr_Layouts where ADDRESS_FORMAT=0)) 
    insert into Country_Addr_Layouts (ADDRESS_FORMAT, ADDRESS_LAYOUT, FORMULA) 
  values (0, 'ADDRESS_1[N]ADDRESS_2[N]ADDRESS_3[N]CITY[C][S]STATE_PROVINCE[S]ZIP[N][U]COUNTRY', 
  'ADDRESS_1[N]ADDRESS_2[N]CITY[C][S]STATE_PROVINCE[S]ZIP[N][U]COUNTRY') 
    end 
  begin   
  select @formula=FORMULA from Country_Addr_Layouts where ADDRESS_FORMAT=@code 
  while charindex('[N]',@formula)>0 
    begin 
    select @formula=stuff(@formula,charindex('[N]',@formula),3,char(13)) 
    end 
  while charindex('[S]',@formula)>0 
    begin 
    select @formula=stuff(@formula,charindex('[S]',@formula),3,' ') 
    end 
  while charindex('[C]',@formula)>0 
    begin 
    select @formula=stuff(@formula,charindex('[C]',@formula),3,',') 
    end 
  if charindex('CITY',@formula)>0
    select @formula=stuff(@formula,charindex('CITY',@formula),4,'_CITY') 
  if charindex('ZIP',@formula)>0
    select @formula=stuff(@formula,charindex('ZIP',@formula),3,'_ZIP') 
  if charindex('COUNTRY',@formula)>0
    select @formula=stuff(@formula,charindex('COUNTRY',@formula),7,'_COUNTRY') 
  if charindex('[U]ADDRESS_1',@formula)>0 
    select @formula=stuff(@formula,charindex('[U]ADDRESS_1',@formula),12,upper(@ADDRESS_1)) 
  if charindex('[U]ADDRESS_2',@formula)>0 
    select @formula=stuff(@formula,charindex('[U]ADDRESS_2',@formula),12,upper(@ADDRESS_2))
  if charindex('[U]ADDRESS_3',@formula)>0 
    select @formula=stuff(@formula,charindex('[U]ADDRESS_3',@formula),12,upper(@ADDRESS_3)) 
  if charindex('[U]_CITY',@formula)>0 
    begin
    if charindex('[U]_CITY,',@formula)>0
      begin
      if datalength (@STATE_PROVINCE) = 0  
        select @formula=stuff(@formula,charindex('[U]_CITY,',@formula),9,'[U]_CITY') 
      end
    select @formula=stuff(@formula,charindex('[U]_CITY',@formula),8,upper(@CITY) )
    end
  if charindex('[U]STATE_PROVINCE',@formula)>0 
    select @formula=stuff(@formula,charindex('[U]STATE_PROVINCE',@formula),17,upper(@STATE_PROVINCE)) 
  if charindex('[U]_ZIP',@formula)>0 
    select @formula=stuff(@formula,charindex('[U]_ZIP',@formula),7,upper(@ZIP)) 
  if charindex('[U]_COUNTRY',@formula)>0 
    select @formula=stuff(@formula,charindex('[U]_COUNTRY',@formula),11,upper(@COUNTRY)) 
  if charindex('ADDRESS_1',@formula)>0 
    select @formula=stuff(@formula,charindex('ADDRESS_1',@formula),9,@ADDRESS_1) 
  if charindex('ADDRESS_2',@formula)>0 
    select @formula=stuff(@formula,charindex('ADDRESS_2',@formula),9,@ADDRESS_2) 
 if charindex('ADDRESS_3',@formula)>0 
    select @formula=stuff(@formula,charindex('ADDRESS_3',@formula),9,@ADDRESS_3) 
  if charindex('_CITY',@formula)>0 
    begin
    if charindex('_CITY,',@formula)>0
      begin
      if datalength (@STATE_PROVINCE) = 0  
        select @formula=stuff(@formula,charindex('_CITY,',@formula),6,'_CITY') 
      end
    select @formula=stuff(@formula,charindex('_CITY',@formula),5,@CITY) 
    end
  if charindex('STATE_PROVINCE',@formula)>0 
    select @formula=stuff(@formula,charindex('STATE_PROVINCE',@formula),14,@STATE_PROVINCE) 
  if charindex('_ZIP',@formula)>0 
    select @formula=stuff(@formula,charindex('_ZIP',@formula),4,@ZIP) 
  if charindex('_COUNTRY',@formula)>0 
    select @formula=stuff(@formula,charindex('_COUNTRY',@formula),8,@COUNTRY) 
  if charindex('US1',@formula)>0 
    select @formula=stuff(@formula,charindex('US1',@formula),3,'') 
  if charindex('US2',@formula)>0 
    select @formula=stuff(@formula,charindex('US2',@formula),3,'') 
  while charindex(char(13)+' ',@formula)>0      
    begin        
    select @formula=stuff(@formula,charindex(char(13)+' ',@formula),2,char(13))      
    end
  while charindex(char(13)+',',@formula)>0      
    begin        
    select @formula=stuff(@formula,charindex(char(13)+',',@formula),2,char(13))      
    end 
  while charindex(char(13)+char(13),@formula)>0      
    begin        
    select @formula=stuff(@formula,charindex(char(13)+char(13),@formula),2,char(13))      
    end    
  while charindex(char(13)+' '+char(13),@formula)>0      
    begin        
    select @formula=stuff(@formula,charindex(char(13)+' '+char(13),@formula),3,char(13))      
    end
  select @addrlen=datalength (@formula)
  while substring (@formula, @addrlen, 1)=char(13)
         select @formula=substring(@formula, 1, @addrlen-1)
  select @formula  FULL_ADDRESS 
  return 
  end 
  END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_GetCompanySort]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_GetCompanySort]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  StoredProcedure dbo.sp_asi_GetCompanySort  ******/

CREATE PROCEDURE dbo.sp_asi_GetCompanySort
	@CompanyName varchar(80),
	@CompanySort varchar(30) OUTPUT
AS
BEGIN
	SET NOCOUNT ON

	SET @CompanySort = dbo.fn_asi_GetCompanySort(@CompanyName)
	SELECT @CompanySort as CompanySort
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_GetCounter]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_GetCounter]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


CREATE PROCEDURE [dbo].[sp_asi_GetCounter]  
--   sp_asi_GetCounter
--   For a given CounterName, returns the next value. (Guaranteed unique).
--   If you supply the optional second param "incrementBy", then you receive
--   the additional guarantee that you can use that many consecutive numbers,
--   all with a uniqueness guarantee.
--   Sample use:  -----------------------------------------------------------
--                exec sp_asi_GetCounter  'MyCounterName', 3
--   Returns:
--                101
--   Now you know that 101, 102, 103 are all usable unique numbers
-- 
       @counterName   varchar(30) = '',
       @incrementBy   int         = 1,
       @checksumOnOff int         = 0 -- 1 = ON, 2 = OFF
AS
BEGIN
    DECLARE @now datetime;
    SELECT @now = GETDATE();
    
    -- Ensure the counter exists
    INSERT INTO [dbo].[Counter] ([COUNTER_NAME], [LAST_VALUE])
           SELECT @counterName, 0
            WHERE NOT EXISTS (SELECT 1
                                FROM [dbo].[Counter] WITH (ROWLOCK)
                               WHERE [COUNTER_NAME] = @counterName
           );
           
    DECLARE @id varchar(10);
    DECLARE @lastValue int;
    DECLARE @counterValue int;
    IF @checksumOnOff = 1
    BEGIN
        UPDATE [dbo].[Counter] WITH (ROWLOCK)
           SET [LAST_VALUE] = ([LAST_VALUE] + 10) - ([LAST_VALUE] % 10),
               [LAST_UPDATED] = @now,
               [UPDATED_BY] = USER_NAME(),
               [HAS_CHECKSUM] = 1
         WHERE [COUNTER_NAME] = 'Name';
         
        UPDATE [dbo].[Counter] WITH (ROWLOCK)
           SET [LAST_VALUE] = ([LAST_VALUE] + 10) - ([LAST_VALUE] % 10),
               [LAST_UPDATED] = @now,
               [UPDATED_BY] = USER_NAME(),
               [HAS_CHECKSUM] = 1
         WHERE [COUNTER_NAME] = 'Prospect';
        RETURN;
    END;
    IF @checksumOnOff = 2
    BEGIN
        SELECT @lastValue = ([LAST_VALUE] + 10) - ([LAST_VALUE] % 10)
          FROM [dbo].[Counter] WITH (ROWLOCK)
         WHERE [COUNTER_NAME] = 'Name';
         
        UPDATE [dbo].[Counter] WITH (ROWLOCK)
           SET [LAST_VALUE] = @lastValue,
               [LAST_UPDATED] = @now,
               [UPDATED_BY] = USER_NAME(),
               [HAS_CHECKSUM] = 0
         WHERE [COUNTER_NAME] = 'Name';
         
        SELECT @lastValue = ([LAST_VALUE] + 10) - ([LAST_VALUE] % 10)
          FROM [dbo].[Counter] WITH (ROWLOCK)
         WHERE [COUNTER_NAME] = 'Prospect';
         
        UPDATE [dbo].[Counter] WITH (ROWLOCK)
           SET [LAST_VALUE] = @lastValue,
               [LAST_UPDATED] = @now,
               [UPDATED_BY] = USER_NAME(),
               [HAS_CHECKSUM] = 0
         WHERE [COUNTER_NAME] = 'Prospect';
        RETURN;
    END;
    
    -- @checksumOnOff parameter not specified, or specified as zero
    IF @counterName IN ('Name', 'Prospect') AND (SELECT [ShortValue]
                                                   FROM [dbo].[System_Params]
                                                  WHERE [ParameterName] = 'Member_Control.UseChecksumForId'
                                                 ) = 'YES'
    BEGIN
        -- Otherwise just get new "base" value for LastValue
        UPDATE [dbo].[Counter] WITH (ROWLOCK)
           SET [LAST_VALUE] = CASE WHEN [HAS_CHECKSUM] = 0
                                   THEN [dbo].[asi_ComputeValueWithMod11Checksum] ([LAST_VALUE] + @incrementBy
                                                                                  ) WHEN [HAS_CHECKSUM] = 1
                                   THEN [dbo].[asi_ComputeValueWithMod11Checksum] ([LAST_VALUE] / 10 + @incrementBy
                                                                                  )
                              END,
               @counterValue = [LAST_VALUE] + @incrementBy,
               [LAST_UPDATED] = @now,
               [UPDATED_BY] = USER_NAME(),
               [HAS_CHECKSUM] = 1
         WHERE [COUNTER_NAME] = @counterName;
        SELECT (@counterValue - @incrementBy + 1) AS [LAST_VALUE];
    END;
    ELSE
    BEGIN
        -- No checksum
        UPDATE [dbo].[Counter] WITH (ROWLOCK)
           SET [LAST_VALUE] = [LAST_VALUE] + @incrementBy,
               @counterValue = [LAST_VALUE] + @incrementBy,
               [LAST_UPDATED] = @now,
               [UPDATED_BY] = USER_NAME()
         WHERE [COUNTER_NAME] = @counterName;
        SELECT (@counterValue - @incrementBy + 1) AS [LAST_VALUE];
    END;
END;


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_GetFullName]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_GetFullName]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  StoredProcedure dbo.sp_asi_GetFullName  ******/

-- =============================================
-- This stored procedure calculates FullName based on the input parameters.
-- Input parameters are FirstName, MiddleName, LastName, Prefix, Suffix, Title, Designation,
-- Informal. Output parameter is FullName.
-- By default, FullName is calculated to 
-- @Prefix + ' ' + @FirstName + ' ' + @MiddleName + ' ' + @LastName
--        + ', ' + @Suffix + ', ' + @Designation
-- =============================================
CREATE PROCEDURE dbo.sp_asi_GetFullName
    @FirstName varchar(20) = NULL,
    @MiddleName varchar(20) = NULL,
    @LastName varchar(30) = NULL,
	@Prefix varchar(25) = NULL,
    @Suffix varchar(10) = NULL,
    @Designation varchar(20) = NULL,
    @Title varchar(80) = NULL,
    @Informal varchar(20) = NULL,
    @FullName varchar(70) OUTPUT
AS
BEGIN
	SET @FullName = dbo.fn_asi_GetFullName(@FirstName,@MiddleName,@LastName,@Prefix,@Suffix,@Designation,@Title,@Informal)
	SELECT @FullName as FullName

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_GetLastFirst]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_GetLastFirst]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  StoredProcedure dbo.sp_asi_GetLastFirst  ******/

-- =============================================
-- This stored procedure calculates LastFirst based on the input parameters.
-- Input parameters are LastName, FirstName.
-- Output parameter is LastFirst.
-- By default, LastFirst is calculated to 
-- @LastName + ', ' + @FirstName
-- if both parameters are not empty strings, otherwise
-- @LastName + ' ' + @FirstName
-- =============================================
CREATE PROCEDURE [dbo].[sp_asi_GetLastFirst]
    @LastName varchar(30) = NULL,
    @FirstName varchar(20) = NULL,
    @LastFirst varchar(30) OUTPUT
AS
BEGIN
	SET @LastFirst = dbo.fn_asi_GetLastFirst(@LastName, @FirstName)
	SELECT @LastFirst as LastFirst
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_MakeImisUser]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_MakeImisUser]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[sp_asi_MakeImisUser] @userid varchar(255), @userpassword varchar(255), @sapassword varchar(255)=NULL 
 as  
 declare @execSQL nvarchar(1000)
 declare @loginid varbinary (85)  
 select @loginid = sid from master..syslogins where loginname = @userid 
 if exists (select u.isaliased from sysusers u where u.isaliased = 1 and u.sid = @loginid and @loginid is not NULL) 
 	begin
 	exec sp_password NULL, @userpassword, @userid  
 	return 
 	end
 if @loginid is not null 
 	begin  
 	exec sp_password NULL, @userpassword, @userid  
 	end 
 else  begin  
 	exec sp_addlogin @userid, @userpassword 
 	select @loginid = sid from master..syslogins where loginname = @userid  
 	end  
 if not exists (select d.sid from sysusers d where d.sid = @loginid )  
 	begin   
 	if lower(@userid)='guest'  
 		begin   
 		if not exists (select d.sid from sysusers d where d.name = lower(@userid) and d.sid < 0)    
 			exec sp_adduser @userid, @userid   
        SELECT @execSQL = 'sp_addrolemember ''IMIS'', [' + @userid + ']'
        EXEC (@execSQL)
 		end  
 	else   
 		exec sp_adduser @userid, @userid, 'IMIS'  
 	end  
 else  begin  
 	declare @oldusername varchar(255)  
 	select @oldusername = u.name from  sysusers u where u.sid = @loginid 
 	if @oldusername <> @userid  
 		begin  
 		exec sp_dropuser @oldusername  
 		exec sp_adduser @userid, @userid, 'IMIS'  
 		end  
 	end 
 return

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_MeetingsFlowdown]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_MeetingsFlowdown]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[sp_asi_MeetingsFlowdown]
  (
  	@ID			VARCHAR(10),
  	@OLD_COMPANY		VARCHAR(80),
  	@NEW_COMPANY		VARCHAR(80),
  	@COMPANY_SORT		VARCHAR(90),
  	@OLD_CO_ID			VARCHAR(10), 
  	@NEW_CO_ID			VARCHAR(10),
  	@OLD_EMAIL			VARCHAR(100),
  	@NEW_EMAIL			VARCHAR(100),
  	@OLD_PHONE			VARCHAR(25),
  	@NEW_PHONE			VARCHAR(25),
  	@OLD_FAX			VARCHAR(25),
  	@NEW_FAX			VARCHAR(25),
  	@OLD_TOLL_FREE			VARCHAR(25),
  	@NEW_TOLL_FREE			VARCHAR(25),
  	@PREF_MAIL_CHANGED		VARCHAR(2),
  	@ADDRESS_1			VARCHAR(40),
  	@ADDRESS_2			VARCHAR(40),
  	@ADDRESS_3			VARCHAR(40),
  	@CITY				VARCHAR(40),
  	@STATE_PROVINCE		VARCHAR(15),
  	@ZIP				VARCHAR(10),
  	@COUNTRY			VARCHAR(25),
  	@BAR_CODE			VARCHAR(14),
  	@DPB				VARCHAR(8),
  	@OLD_PREF_MAIL_ADDR		VARCHAR(255),
  	@NEW_PREF_MAIL_ADDR		VARCHAR(255),
  	@OLD_FULL_NAME		VARCHAR(60),
  	@NEW_FULL_NAME		VARCHAR(60),
      @BADGE_FULL_NAME    VARCHAR(60),
  	@PREFIX				VARCHAR(10),
  	@FIRST_NAME			VARCHAR(20),
  	@MIDDLE_NAME		VARCHAR(20),
  	@LAST_NAME			VARCHAR(30),
  	@SUFFIX				VARCHAR(10),
  	@DESIGNATION		VARCHAR(20),
  	@LAST_FIRST			VARCHAR(30),
  	@OLD_TITLE			VARCHAR(80),
  	@NEW_TITLE			VARCHAR(80),
  	@OLD_INFORMAL		VARCHAR(20),
  	@NEW_INFORMAL		VARCHAR(20),
  	@MAINADDR_IS_PREFMAIL		VARCHAR(2),
  	@MAIN_ADDR_CHANGED		VARCHAR(2),
  	@MAIN_ADDRESS_1		VARCHAR(40),
  	@MAIN_ADDRESS_2		VARCHAR(40),
  	@MAIN_ADDRESS_3		VARCHAR(40),
  	@MAIN_CITY			VARCHAR(40),
  	@MAIN_STATE_PROVINCE		VARCHAR(15),
  	@MAIN_ZIP			VARCHAR(10),
  	@MAIN_COUNTRY			VARCHAR(25),
  	@MAIN_BAR_CODE		VARCHAR(14),
  	@MAIN_DPB			VARCHAR(8),
  	@OLD_MAIN_ADDR		VARCHAR(255),
  	@NEW_MAIN_ADDR		VARCHAR(255),
  	@OLD_PREF_MAIL_ADDR_1	VARCHAR(255),
  	@OLD_PREF_MAIL_ADDR_2	VARCHAR(40),
  	@OLD_PREF_MAIL_ADDR_3	VARCHAR(40),
  	@OLD_PREF_MAIL_CITY		VARCHAR(40),
  	@OLD_PREF_MAIL_STATE		VARCHAR(15),
  	@OLD_PREF_MAIL_ZIP		VARCHAR(10),
  	@OLD_PREF_MAIL_COUNTRY	VARCHAR(25),
  	@OLD_MAIN_ADDR_1		VARCHAR(255),
  	@OLD_MAIN_ADDR_2		VARCHAR(40),
  	@OLD_MAIN_ADDR_3		VARCHAR(40),
  	@OLD_MAIN_CITY		VARCHAR(40),
  	@OLD_MAIN_STATE		VARCHAR(15),
  	@OLD_MAIN_ZIP			VARCHAR(10),
  	@OLD_MAIN_COUNTRY		VARCHAR(25)
  )
  AS
 declare 
 @CompanyPurposes varchar(255), 
 @TitlePurposes varchar(255),
 @PrefPurpose varchar(255),
 @UseCompany bit,
 @UseTitle bit
 select @CompanyPurposes =ShortValue from System_Params where ParameterName = 'Member_Control.PrintCompanyWithAddressString'
 select @TitlePurposes =ShortValue from System_Params where ParameterName = 'Member_Control.PrintTitleWithAddressString'
 select @UseCompany=0
 select @UseTitle=0
  SELECT Orders.*, Name.COMPANY_RECORD, Name.ADDRESS_NUM_1, Name.MAIL_ADDRESS_NUM, 'N' as NAME_UPDATED, 
  	'N' as TITLE_UPDATED, 'N' as INFORMAL_UPDATED, 'N' as COMPANY_UPDATED, 'N' as ADDRESS_UPDATED, 
  	'N' as BLOCK_ADDRESS_UPDATE, 'N' as BLOCK_PREF_MAIL_UPDATE
  	INTO #tmp_meet_flowdown
  	FROM Orders INNER JOIN Name
  	ON Name.ID = Orders.ST_ID
  	WHERE
  	Orders.SOURCE_SYSTEM in ('MEETING','EXPO','EXHIBITION') AND
  	(Orders.ST_ID = @ID OR 
  	Orders.CO_ID = @ID)
   IF (select ShortValue from System_Params where ParameterName = 'Member_Control.DisableAutoFlowDown') = 'YES'
   BEGIN	
  	IF @OLD_COMPANY != @NEW_COMPANY
  	BEGIN
  	UPDATE #tmp_meet_flowdown set COMPANY_UPDATED = 'Y'
  		WHERE COMPANY = @OLD_COMPANY
  	UPDATE Orders SET Orders.COMPANY = @NEW_COMPANY,
  			Orders.COMPANY_SORT = @COMPANY_SORT
  		FROM #tmp_meet_flowdown, Orders
  		WHERE  Orders.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND
  		#tmp_meet_flowdown.COMPANY_UPDATED = 'Y'
  	UPDATE Order_Badge SET Order_Badge.COMPANY = @NEW_COMPANY
  		FROM #tmp_meet_flowdown, Order_Badge
  		WHERE Order_Badge.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND
  		#tmp_meet_flowdown.COMPANY_UPDATED = 'Y' AND
  		(Order_Badge.BADGE_TYPE = 'PRIMARY' OR Order_Badge.COMPANY = @OLD_COMPANY)
  	END
  	BEGIN
  	DELETE from #tmp_meet_flowdown where CO_ID = @ID
  	END
   END
  DELETE from #tmp_meet_flowdown where COMPANY_RECORD = 1 and CO_ID = @ID
  UPDATE #tmp_meet_flowdown SET BLOCK_ADDRESS_UPDATE = 'Y' 
  	WHERE CO_ID = @ID and ADDRESS_NUM_1 != MAIL_ADDRESS_NUM
  IF @MAINADDR_IS_PREFMAIL != 'Y'
  BEGIN
  UPDATE #tmp_meet_flowdown SET BLOCK_PREF_MAIL_UPDATE = 'Y' 
  	WHERE CO_ID = @ID
  END
  IF @OLD_CO_ID != @NEW_CO_ID
  BEGIN	
  UPDATE Orders SET Orders.CO_ID = @NEW_CO_ID
  	FROM #tmp_meet_flowdown, Orders
  	WHERE Orders.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND
  	Orders.ST_ID = @ID AND
  	Orders.CO_ID = @OLD_CO_ID
  END
  IF @OLD_EMAIL != @NEW_EMAIL
  BEGIN
  UPDATE Orders SET Orders.EMAIL = @NEW_EMAIL
  	FROM #tmp_meet_flowdown, Orders
  	WHERE Orders.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND
  	Orders.ST_ID = @ID AND
  	Orders.EMAIL = @OLD_EMAIL
  END
  IF @OLD_FULL_NAME != @NEW_FULL_NAME
  BEGIN
  IF @OLD_FULL_NAME = ' '
  	BEGIN
  	UPDATE #tmp_meet_flowdown set NAME_UPDATED = 'Y'
  		WHERE ST_ID = @ID AND	FULL_NAME = ' '
  	END
  ELSE
  	BEGIN
  	UPDATE #tmp_meet_flowdown set NAME_UPDATED = 'Y'
  		WHERE ST_ID = @ID AND	FULL_NAME LIKE '%' + @OLD_FULL_NAME + '%'
  	END
  UPDATE Orders SET         
  	Orders.FULL_NAME = @NEW_FULL_NAME,
  	Orders.PREFIX = @PREFIX,
  	Orders.FIRST_NAME = @FIRST_NAME,
  	Orders.MIDDLE_NAME = @MIDDLE_NAME,
  	Orders.LAST_NAME = @LAST_NAME,
  	Orders.SUFFIX = @SUFFIX,
  	Orders.DESIGNATION = @DESIGNATION,
  	Orders.LAST_FIRST = @LAST_FIRST
  	FROM #tmp_meet_flowdown, Orders
  	WHERE Orders.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND
  	#tmp_meet_flowdown.NAME_UPDATED = 'Y'
  UPDATE Order_Badge SET         
  	Order_Badge.FULL_NAME = @BADGE_FULL_NAME, /* jf - 12 sep 07 dt895 */
  	Order_Badge.PREFIX = @PREFIX,
  	Order_Badge.FIRST_NAME = @FIRST_NAME,
  	Order_Badge.MIDDLE_NAME = @MIDDLE_NAME,
  	Order_Badge.LAST_NAME = @LAST_NAME,
  	Order_Badge.SUFFIX = @SUFFIX,
  	Order_Badge.DESIGNATION = @DESIGNATION
  	FROM #tmp_meet_flowdown, Order_Badge
  	WHERE Order_Badge.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND
  	#tmp_meet_flowdown.NAME_UPDATED = 'Y' AND	
  	Order_Badge.BADGE_TYPE = 'PRIMARY'
  END
  IF @OLD_TITLE != @NEW_TITLE
  BEGIN
  IF @OLD_FULL_NAME = ' '
  	BEGIN
  	UPDATE #tmp_meet_flowdown set TITLE_UPDATED = 'Y'
  		WHERE ST_ID = @ID AND	FULL_NAME = ' '
  		AND TITLE = @OLD_TITLE
  	END
  ELSE
  	BEGIN
  	UPDATE #tmp_meet_flowdown set TITLE_UPDATED = 'Y'
  		WHERE ST_ID = @ID AND FULL_NAME LIKE '%' + @OLD_FULL_NAME + '%'
  		AND TITLE = @OLD_TITLE
  	END
  UPDATE Orders SET Orders.TITLE = @NEW_TITLE
  	FROM #tmp_meet_flowdown, Orders
  	WHERE Orders.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND
  	#tmp_meet_flowdown.TITLE_UPDATED = 'Y'
  UPDATE Order_Badge SET Order_Badge.TITLE = @NEW_TITLE
  	FROM #tmp_meet_flowdown, Order_Badge
  	WHERE Order_Badge.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND
  	#tmp_meet_flowdown.TITLE_UPDATED = 'Y' AND	
  	Order_Badge.BADGE_TYPE = 'PRIMARY'
  END
  IF @OLD_INFORMAL != @NEW_INFORMAL
  BEGIN
  UPDATE #tmp_meet_flowdown set INFORMAL_UPDATED = 'Y'
  	WHERE ST_ID = @ID AND INFORMAL = @OLD_INFORMAL
  UPDATE Orders SET Orders.INFORMAL = @NEW_INFORMAL
  	FROM #tmp_meet_flowdown, Orders
  	WHERE Orders.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND
  	#tmp_meet_flowdown.INFORMAL_UPDATED = 'Y'
  UPDATE Order_Badge SET Order_Badge.INFORMAL = @NEW_INFORMAL
  	FROM #tmp_meet_flowdown, Order_Badge
  	WHERE Order_Badge.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND
  	#tmp_meet_flowdown.INFORMAL_UPDATED = 'Y' AND	
  	Order_Badge.BADGE_TYPE = 'PRIMARY'
  END
  IF @OLD_PHONE != @NEW_PHONE
  BEGIN
  UPDATE Orders SET  Orders.PHONE = @NEW_PHONE
  	FROM #tmp_meet_flowdown, Orders
  	WHERE Orders.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND
  	Orders.PHONE = @OLD_PHONE
  END
  IF @OLD_FAX != @NEW_FAX
  BEGIN
  UPDATE Orders SET Orders.FAX = @NEW_FAX
  	FROM #tmp_meet_flowdown, Orders
  	WHERE Orders.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND
  	Orders.FAX = @OLD_FAX
  END
  IF @OLD_TOLL_FREE != @NEW_TOLL_FREE
  BEGIN
  UPDATE Orders SET Orders.TOLL_FREE = @NEW_TOLL_FREE
  	FROM #tmp_meet_flowdown, Orders
  	WHERE Orders.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND
  	Orders.TOLL_FREE = @OLD_TOLL_FREE
  END
  IF @OLD_COMPANY != @NEW_COMPANY
  BEGIN
  UPDATE #tmp_meet_flowdown set COMPANY_UPDATED = 'Y'
  	WHERE COMPANY = @OLD_COMPANY
  UPDATE Orders SET Orders.COMPANY = @NEW_COMPANY,
  		Orders.COMPANY_SORT = @COMPANY_SORT
  	FROM #tmp_meet_flowdown, Orders
  	WHERE  Orders.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND
  	#tmp_meet_flowdown.COMPANY_UPDATED = 'Y'
  UPDATE Order_Badge SET Order_Badge.COMPANY = @NEW_COMPANY
  	FROM #tmp_meet_flowdown, Order_Badge
  	WHERE Order_Badge.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND
  	#tmp_meet_flowdown.COMPANY_UPDATED = 'Y' AND
  	(Order_Badge.BADGE_TYPE = 'PRIMARY' OR Order_Badge.COMPANY = @OLD_COMPANY)
  END
  IF @PREF_MAIL_CHANGED = 'Y'
  BEGIN
 select @PrefPurpose=','+PURPOSE+',' from Name_Address
 join Name on Name.ID=Name_Address.ID 
 where Name.MAIL_ADDRESS_NUM=Name_Address.ADDRESS_NUM and Name.ID=@ID
 If charindex(@PrefPurpose,@CompanyPurposes)>0
 begin
  select @UseCompany=1
 end
 If charindex(@PrefPurpose,@TitlePurposes)>0
 begin
  select @UseTitle=1
 end
  UPDATE #tmp_meet_flowdown set ADDRESS_UPDATED = 'Y'
  WHERE ADDRESS_1 = @OLD_PREF_MAIL_ADDR_1  AND
  	ADDRESS_2 = @OLD_PREF_MAIL_ADDR_2  AND
  	ADDRESS_3 = @OLD_PREF_MAIL_ADDR_3  AND
  	CITY = @OLD_PREF_MAIL_CITY  AND
  	STATE_PROVINCE = @OLD_PREF_MAIL_STATE  AND
  	ZIP = @OLD_PREF_MAIL_ZIP  AND
  	COUNTRY = @OLD_PREF_MAIL_COUNTRY
  UPDATE Orders SET         
  		Orders.ADDRESS_1 = @ADDRESS_1,
  		Orders.ADDRESS_2 = @ADDRESS_2,
  		Orders.ADDRESS_3 = @ADDRESS_3,
  		Orders.CITY = @CITY,
  		Orders.STATE_PROVINCE = @STATE_PROVINCE,
  		Orders.ZIP = @ZIP,
  		Orders.COUNTRY = @COUNTRY,
  		Orders.DPB = @DPB,
  		Orders.BAR_CODE = @BAR_CODE,
  		Orders.FULL_ADDRESS = @NEW_PREF_MAIL_ADDR,
  		Orders.ST_PRINT_COMPANY = @UseCompany,
  		Orders.ST_PRINT_TITLE = @UseTitle,
  Orders.ST_ADDRESS_NUM=#tmp_meet_flowdown.MAIL_ADDRESS_NUM
  FROM #tmp_meet_flowdown, Orders
  WHERE Orders.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND	
  	#tmp_meet_flowdown.ADDRESS_UPDATED = 'Y' AND
  	#tmp_meet_flowdown.BLOCK_ADDRESS_UPDATE = 'N' AND
  	#tmp_meet_flowdown.BLOCK_PREF_MAIL_UPDATE  = 'N' 
  UPDATE Order_Badge SET         
  		Order_Badge.ADDRESS_1 = @ADDRESS_1,
  		Order_Badge.ADDRESS_2 = @ADDRESS_2,
  		Order_Badge.ADDRESS_3 = @ADDRESS_3,
  		Order_Badge.CITY = @CITY,
  		Order_Badge.STATE_PROVINCE = @STATE_PROVINCE,
  		Order_Badge.ZIP = @ZIP,
  		Order_Badge.COUNTRY = @COUNTRY,
  		Order_Badge.BAR_CODE = @BAR_CODE,
  		Order_Badge.FULL_ADDRESS = @NEW_PREF_MAIL_ADDR,
  		Order_Badge.ST_PRINT_COMPANY =  case Order_Badge.BADGE_TYPE when 'PRIMARY' then @UseCompany else Order_Badge.ST_PRINT_COMPANY end,
  		Order_Badge.ST_PRINT_TITLE = case Order_Badge.BADGE_TYPE when 'PRIMARY' then @UseTitle else Order_Badge.ST_PRINT_TITLE end 
  	FROM #tmp_meet_flowdown, Order_Badge
  	WHERE Order_Badge.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND
  	#tmp_meet_flowdown.ADDRESS_UPDATED = 'Y' AND
  	#tmp_meet_flowdown.BLOCK_ADDRESS_UPDATE = 'N' AND
  	#tmp_meet_flowdown.BLOCK_PREF_MAIL_UPDATE  = 'N' AND
  	(Order_Badge.BADGE_TYPE = 'PRIMARY' OR Order_Badge.FULL_ADDRESS LIKE @OLD_PREF_MAIL_ADDR)
  END
  IF @MAINADDR_IS_PREFMAIL != 'Y' AND @MAIN_ADDR_CHANGED = 'Y'
  BEGIN
  UPDATE #tmp_meet_flowdown set ADDRESS_UPDATED = 'Y'
  WHERE ADDRESS_1 = @OLD_MAIN_ADDR_1  AND
  	ADDRESS_2 = @OLD_MAIN_ADDR_2  AND
  	ADDRESS_3 = @OLD_MAIN_ADDR_3  AND
  	CITY = @OLD_MAIN_CITY  AND
  	STATE_PROVINCE = @OLD_MAIN_STATE  AND
  	ZIP = @OLD_MAIN_ZIP  AND
  	COUNTRY = @OLD_MAIN_COUNTRY
  UPDATE Orders SET         
  		Orders.ADDRESS_1 = @MAIN_ADDRESS_1,
  		Orders.ADDRESS_2 = @MAIN_ADDRESS_2,
  		Orders.ADDRESS_3 = @MAIN_ADDRESS_3,
  		Orders.CITY = @MAIN_CITY,
  		Orders.STATE_PROVINCE = @MAIN_STATE_PROVINCE,
  		Orders.ZIP = @MAIN_ZIP,
  		Orders.COUNTRY = @MAIN_COUNTRY,
  		Orders.DPB = @MAIN_DPB,
  		Orders.BAR_CODE = @MAIN_BAR_CODE,
  		Orders.FULL_ADDRESS = @NEW_MAIN_ADDR
  FROM #tmp_meet_flowdown, Orders
  WHERE Orders.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND
  	#tmp_meet_flowdown.CO_ID = @ID AND	
  	#tmp_meet_flowdown.ADDRESS_UPDATED = 'Y' AND
  	#tmp_meet_flowdown.BLOCK_ADDRESS_UPDATE = 'N' 
  UPDATE Order_Badge SET         
  		Order_Badge.ADDRESS_1 = @MAIN_ADDRESS_1,
  		Order_Badge.ADDRESS_2 = @MAIN_ADDRESS_2,
  		Order_Badge.ADDRESS_3 = @MAIN_ADDRESS_3,
  		Order_Badge.CITY = @MAIN_CITY,
  		Order_Badge.STATE_PROVINCE = @MAIN_STATE_PROVINCE,
  		Order_Badge.ZIP = @MAIN_ZIP,
  		Order_Badge.COUNTRY = @MAIN_COUNTRY,
  		Order_Badge.BAR_CODE = @MAIN_BAR_CODE,
  		Order_Badge.FULL_ADDRESS = @NEW_MAIN_ADDR
  	FROM #tmp_meet_flowdown, Order_Badge
  	WHERE Order_Badge.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND
  	#tmp_meet_flowdown.CO_ID = @ID AND
  	#tmp_meet_flowdown.ADDRESS_UPDATED = 'Y' AND
  	#tmp_meet_flowdown.BLOCK_ADDRESS_UPDATE = 'N' AND
  	(Order_Badge.BADGE_TYPE = 'PRIMARY' OR Order_Badge.FULL_ADDRESS LIKE @OLD_MAIN_ADDR)
  END
  drop table #tmp_meet_flowdown

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_NameAddressNameGlobalSync]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_NameAddressNameGlobalSync]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[sp_asi_NameAddressNameGlobalSync]
AS
BEGIN
    DECLARE @now datetime;
    SELECT @now = dbo.asi_GetAppDatetime();
    
    -- WORK PHONE ####################
    DECLARE @wORK_PHONE_PURPOSE varchar(255);
    SELECT @wORK_PHONE_PURPOSE = (SELECT [ShortValue]
                                    FROM [System_Params]
                                   WHERE [ParameterName] = 'Member_Control.' + (SELECT [ShortValue]
                                                                                  FROM [System_Params]
                                                                                 WHERE [ParameterName] = 'Member_Control.SyncWorkPhoneToAddress'
                                                                                ) + 'Prompt'
                                  );
    IF @wORK_PHONE_PURPOSE IS NOT NULL
    BEGIN
        -- Name to Name_Address Synchronization - Parent Records
        UPDATE [Name_Address]
           SET [PHONE] = [n].[WORK_PHONE],
               [LAST_UPDATED] = @now
          FROM [Name_Address] [na]
               INNER JOIN [Name] [n] ON [n].[ID] = [na].[ID]
         WHERE NOT [n].[WORK_PHONE] = '' AND [na].[PHONE] = '' AND [na].[PURPOSE] = @wORK_PHONE_PURPOSE;
        SELECT [n].[ID],
               [n].[WORK_PHONE] AS [VAL_BEFORE],
               [na].[PHONE] AS [VAL_AFTER] INTO [#tmp_SyncW]
          FROM [Name_Address] AS [na]
               INNER JOIN [Name] AS [n] ON [n].[ID] = [na].[ID]
         WHERE NOT [na].[PHONE] = '' AND NOT [na].[PHONE] = [n].[WORK_PHONE] AND [na].[PURPOSE] = @wORK_PHONE_PURPOSE;
        IF (SELECT COUNT(1) FROM [#tmp_SyncW]) > 0
        BEGIN
            CREATE UNIQUE INDEX [ndx_SyncW_ID] ON [#tmp_SyncW] ([ID]);
            -- Name_Address to Name Synchronization - Parent Records
            UPDATE [Name]
               SET [WORK_PHONE] = [ts].[VAL_AFTER],
                   [LAST_UPDATED] = @now
              FROM [#tmp_SyncW] [ts]
             WHERE [Name].[ID] = [ts].[ID];
            -- Change Log Inserts - Parent Records
            INSERT INTO [Name_Log] ([DATE_TIME],
                                    [LOG_TYPE],
                                    [SUB_TYPE],
                                    USER_ID,
                                    [ID],
                                    [LOG_TEXT]
                                   )
                   SELECT @now,
                          'CHANGE',
                          'CHANGE',
                          'SYNC',
                          [ts].[ID],
                          'Name.WORK_PHONE: '+[ts].[VAL_BEFORE]+' -> '+[ts].[VAL_AFTER]
                     FROM [#tmp_SyncW] AS [ts];
            -- Meetings Flowdown - Parent Records
            UPDATE [Orders]
               SET [PHONE] = [ts].[VAL_AFTER]
              FROM [#tmp_SyncW] [ts]
             WHERE [Orders].[ST_ID] = [ts].[ID] AND [Orders].[SOURCE_SYSTEM] = 'MEETING' AND [Orders].[PHONE] = [ts].[VAL_BEFORE];
            IF (
                SELECT COUNT(1)
                  FROM [System_Params]
                 WHERE [ParameterName] = 'Member_Control.DisableAutoFlowDown' AND [ShortValue] = 'YES'
            ) = 0
            BEGIN
                -- Name Parent to Child Flowdown Records
                SELECT [n].[ID],
                       [ts].[VAL_BEFORE],
                       [ts].[VAL_AFTER] INTO [#tmp_SyncChildrenW]
                  FROM [#tmp_SyncW] AS [ts]
                       INNER JOIN [Name] AS [n] ON [n].[CO_ID] = [ts].[ID]
                 WHERE [n].[COMPANY_RECORD] = 0 AND [n].[WORK_PHONE] = [ts].[VAL_BEFORE];
                IF (
                    SELECT COUNT(1)
                      FROM [#tmp_SyncChildrenW]
                ) > 0
                BEGIN
                    -- Name_Address to Name Synchronization - Child Records
                    UPDATE [Name]
                       SET [WORK_PHONE] = [tsc].[VAL_AFTER],
                           [LAST_UPDATED] = @now
                      FROM [#tmp_SyncChildrenW] [tsc]
                     WHERE [Name].[ID] = [tsc].[ID];
                    -- Change Log Inserts - Child Records
                    INSERT INTO [Name_Log] ([DATE_TIME],
                                            [LOG_TYPE],
                                            [SUB_TYPE],
                                            USER_ID,
                                            [ID],
                                            [LOG_TEXT]
                                           )
                           SELECT @now,
                                  'CHANGE',
                                  'CHANGE',
                                  'SYNC',
                                  [tsc].[ID],
                                  'Name.WORK_PHONE: '+[tsc].[VAL_BEFORE]+' -> '+[tsc].[VAL_AFTER]
                             FROM [#tmp_SyncChildrenW] AS [tsc];
                    -- Name to Name_Address Synchronization - Child Records
                    UPDATE [Name_Address]
                       SET [PHONE] = [n].[WORK_PHONE],
                           [LAST_UPDATED] = @now
                      FROM [Name_Address] [na]
                           INNER JOIN [Name] [n] ON [n].[ID] = [na].[ID]
                     WHERE NOT [n].[WORK_PHONE] = '' AND [na].[PURPOSE] = @wORK_PHONE_PURPOSE;
                END;
                DROP TABLE [#tmp_SyncChildrenW];
                -- Meetings Flowdown - Child Records
                UPDATE [Orders]
                   SET [PHONE] = [ts].[VAL_AFTER]
                  FROM [#tmp_SyncW] [ts]
                 WHERE [Orders].[CO_ID] = [ts].[ID] AND [Orders].[SOURCE_SYSTEM] = 'MEETING' AND [Orders].[PHONE] = [ts].[VAL_BEFORE];
            END;
        END;
        DROP TABLE [#tmp_SyncW];
    END;
    -- FAX ####################
    DECLARE @fAX_PURPOSE varchar(255);
    SELECT @fAX_PURPOSE = (SELECT [ShortValue]
                             FROM [System_Params]
                            WHERE [ParameterName] = 'Member_Control.' + (SELECT [ShortValue]
                                                                           FROM [System_Params]
                                                                          WHERE [ParameterName] = 'Member_Control.SyncFaxToAddress'
                           ) + 'Prompt'
    );
    IF @fAX_PURPOSE IS NOT NULL
    BEGIN
        -- Name to Name_Address Synchronization - Parent Records
        UPDATE [Name_Address]
           SET [FAX] = [n].[FAX],
               [LAST_UPDATED] = @now
          FROM [Name_Address] [na]
               INNER JOIN [Name] [n] ON [n].[ID] = [na].[ID]
         WHERE NOT [n].[FAX] = '' AND [na].[FAX] = '' AND [na].[PURPOSE] = @fAX_PURPOSE;
        SELECT [n].[ID],
               [n].[FAX] AS [VAL_BEFORE],
               [na].[FAX] AS [VAL_AFTER] INTO [#tmp_SyncF]
          FROM [Name_Address] AS [na]
               INNER JOIN [Name] AS [n] ON [n].[ID] = [na].[ID]
         WHERE NOT [na].[FAX] = '' AND NOT [na].[FAX] = [n].[FAX] AND [na].[PURPOSE] = @fAX_PURPOSE;
        IF (SELECT COUNT(1) FROM [#tmp_SyncF]) > 0
        BEGIN
            CREATE UNIQUE INDEX [ndx_SyncF_ID] ON [#tmp_SyncF] ([ID]);
            -- Name_Address to Name Synchronization - Parent Records
            UPDATE [Name]
               SET [FAX] = [ts].[VAL_AFTER],
                   [LAST_UPDATED] = @now
              FROM [#tmp_SyncF] [ts]
             WHERE [Name].[ID] = [ts].[ID];
            -- Change Log Inserts - Parent Records
            INSERT INTO [Name_Log] ([DATE_TIME],
                                    [LOG_TYPE],
                                    [SUB_TYPE],
                                    USER_ID,
                                    [ID],
                                    [LOG_TEXT]
                                   )
                   SELECT @now,
                          'CHANGE',
                          'CHANGE',
                          'SYNC',
                          [ts].[ID],
                          'Name.FAX: '+[ts].[VAL_BEFORE]+' -> '+[ts].[VAL_AFTER]
                     FROM [#tmp_SyncF] AS [ts];
            -- Meetings Flowdown - Parent Records
            UPDATE [Orders]
               SET [FAX] = [ts].[VAL_AFTER]
              FROM [#tmp_SyncF] [ts]
             WHERE [Orders].[ST_ID] = [ts].[ID] AND [Orders].[SOURCE_SYSTEM] = 'MEETING' AND [Orders].[FAX] = [ts].[VAL_BEFORE];
            IF (SELECT COUNT(1) FROM [System_Params] WHERE [ParameterName] = 'Member_Control.DisableAutoFlowDown' AND [ShortValue] = 'YES') = 0
            BEGIN
                -- Name Parent to Child Flowdown Records
                SELECT [n].[ID],
                       [ts].[VAL_BEFORE],
                       [ts].[VAL_AFTER] INTO [#tmp_SyncChildrenF]
                  FROM [#tmp_SyncF] AS [ts]
                       INNER JOIN [Name] AS [n] ON [n].[CO_ID] = [ts].[ID]
                 WHERE [n].[COMPANY_RECORD] = 0 AND [n].[FAX] = [ts].[VAL_BEFORE];
                IF (SELECT COUNT(1) FROM [#tmp_SyncChildrenF]) > 0
                BEGIN
                    -- Name_Address to Name Synchronization - Child Records
                    UPDATE [Name]
                       SET [FAX] = [tsc].[VAL_AFTER],
                           [LAST_UPDATED] = @now
                      FROM [#tmp_SyncChildrenF] [tsc]
                     WHERE [Name].[ID] = [tsc].[ID];
                    -- Change Log Inserts - Child Records
                    INSERT INTO [Name_Log] ([DATE_TIME],
                                            [LOG_TYPE],
                                            [SUB_TYPE],
                                            USER_ID,
                                            [ID],
                                            [LOG_TEXT]
                                           )
                           SELECT @now,
                                  'CHANGE',
                                  'CHANGE',
                                  'SYNC',
                                  [tsc].[ID],
                                  'Name.FAX: '+[tsc].[VAL_BEFORE]+' -> '+[tsc].[VAL_AFTER]
                             FROM [#tmp_SyncChildrenF] AS [tsc];
                    -- Name to Name_Address Synchronization - Child Records
                    UPDATE [Name_Address]
                       SET [FAX] = [n].[FAX],
                           [LAST_UPDATED] = @now
                      FROM [Name_Address] [na]
                           JOIN [Name] [n] ON [n].[ID] = [na].[ID]
                     WHERE NOT [n].[FAX] = '' AND [na].[PURPOSE] = @fAX_PURPOSE;
                END;
                DROP TABLE [#tmp_SyncChildrenF];
                -- Meetings Flowdown - Child Records
                UPDATE [Orders]
                   SET [FAX] = [ts].[VAL_AFTER]
                  FROM [#tmp_SyncF] [ts]
                 WHERE [Orders].[CO_ID] = [ts].[ID] AND [Orders].[SOURCE_SYSTEM] = 'MEETING' AND [Orders].[FAX] = [ts].[VAL_BEFORE];
            END;
        END;
        DROP TABLE [#tmp_SyncF];
    END;
    -- EMAIL ####################
    DECLARE @eMAIL_PURPOSE varchar(255);
    SELECT @eMAIL_PURPOSE = (SELECT [ShortValue]
                               FROM [System_Params]
                              WHERE [ParameterName] = 'Member_Control.'+ (SELECT [ShortValue]
                                                                            FROM [System_Params]
                                                                           WHERE [ParameterName] = 'Member_Control.SyncEmailToAddress'
                                                                         ) + 'Prompt'
                            );
    IF @eMAIL_PURPOSE IS NOT NULL
    BEGIN
        -- Name to Name_Address Synchronization - Parent Records
        UPDATE [Name_Address]
           SET [EMAIL] = [n].[EMAIL],
               [LAST_UPDATED] = @now
          FROM [Name_Address] [na]
               INNER JOIN [Name] [n] ON [n].[ID] = [na].[ID]
         WHERE NOT [n].[EMAIL] = '' AND [na].[EMAIL] = '' AND [na].[PURPOSE] = @eMAIL_PURPOSE;
        SELECT [n].[ID],
               [n].[EMAIL] AS [VAL_BEFORE],
               [na].[EMAIL] AS [VAL_AFTER] INTO [#tmp_SyncE]
          FROM [Name_Address] AS [na]
               INNER JOIN [Name] AS [n] ON [n].[ID] = [na].[ID]
         WHERE NOT [na].[EMAIL] = '' AND NOT [na].[EMAIL] = [n].[EMAIL] AND [na].[PURPOSE] = @eMAIL_PURPOSE;
        IF (SELECT COUNT(1) FROM [#tmp_SyncE]) > 0
        BEGIN
            CREATE UNIQUE INDEX [ndx_SyncE_ID] ON [#tmp_SyncE] ([ID]);
            -- Name_Address to Name Synchronization - Parent Records
            UPDATE [Name]
               SET [EMAIL] = [ts].[VAL_AFTER],
                   [LAST_UPDATED] = @now
              FROM [#tmp_SyncE] [ts]
             WHERE [Name].[ID] = [ts].[ID];
            -- Change Log Inserts - Parent Records
            INSERT INTO [Name_Log] ([DATE_TIME],
                                    [LOG_TYPE],
                                    [SUB_TYPE],
                                    USER_ID,
                                    [ID],
                                    [LOG_TEXT]
                                   )
                   SELECT @now,
                          'CHANGE',
                          'CHANGE',
                          'SYNC',
                          [ts].[ID],
                          'Name.EMAIL: '+[ts].[VAL_BEFORE]+' -> '+[ts].[VAL_AFTER]
                     FROM [#tmp_SyncE] AS [ts];
            -- Meetings Flowdown - Parent Records
            UPDATE [Orders]
               SET
                   [EMAIL] = [ts].[VAL_AFTER]
              FROM [#tmp_SyncE] [ts]
             WHERE [Orders].[ST_ID] = [ts].[ID] AND [Orders].[SOURCE_SYSTEM] = 'MEETING' AND [Orders].[EMAIL] = [ts].[VAL_BEFORE];
            -- Email no longer honored as part of user-defined flowdown
            --         IF (
            --             SELECT COUNT(*) FROM System_Params
            --             WHERE ParameterName = 'Member_Control.FlowDownFields'
            --             AND (ShortValue LIKE '%Name.EMAIL%' OR LongValue LIKE '%Name.EMAIL%')
            --         ) = 1
            --         BEGIN
            --             SELECT
            --                 n.ID,
            --                 ts.VAL_BEFORE,
            --                 ts.VAL_AFTER
            --             INTO #tmp_SyncChildrenE
            --             FROM #tmp_SyncE ts
            --             JOIN Name n ON n.CO_ID = ts.ID
            --             WHERE n.COMPANY_RECORD = 0
            --             AND n.EMAIL = ts.VAL_BEFORE
            --             IF (SELECT COUNT(*) FROM #tmp_SyncChildrenE) > 0
            --             BEGIN
            --                 UPDATE Name SET
            --                     EMAIL = tsc.VAL_AFTER,
            --                     LAST_UPDATED = @now
            --                 FROM #tmp_SyncChildrenE tsc
            --                 WHERE Name.ID = tsc.ID
            --                 INSERT INTO Name_Log (DATE_TIME, LOG_TYPE, SUB_TYPE, USER_ID, ID, LOG_TEXT)
            --                 SELECT
            --                     @now, 'CHANGE', 'CHANGE', 'SYNC',
            --                     tsc.ID,
            --                     'Name.EMAIL: ' + tsc.VAL_BEFORE + ' -> ' + tsc.VAL_AFTER
            --                 FROM #tmp_SyncChildrenE tsc
            --                 UPDATE Name_Address SET
            --                     EMAIL = n.EMAIL,
            --                     LAST_UPDATED = @now
            --                 FROM Name_Address na
            --                 JOIN Name n ON n.ID = na.ID
            --                 WHERE NOT n.EMAIL = ''
            --                 AND na.PURPOSE = @EMAIL_PURPOSE
            --             END
            --             DROP TABLE #tmp_SyncChildrenE
            --             UPDATE Orders SET
            --                 EMAIL = ts.VAL_AFTER
            --             FROM #tmp_SyncE ts
            --             WHERE Orders.CO_ID = ts.ID
            --             AND Orders.SOURCE_SYSTEM = 'MEETING'
            --             AND Orders.EMAIL = ts.VAL_BEFORE
            --         END
        END;
        DROP TABLE [#tmp_SyncE];
    END;
    -- HOME PHONE ####################
    DECLARE @hOME_PHONE_PURPOSE varchar(255);
    SELECT @hOME_PHONE_PURPOSE = (SELECT [ShortValue]
                                    FROM [System_Params]
                                   WHERE [ParameterName] = 'Member_Control.' + (SELECT [ShortValue]
                                                                                  FROM [System_Params]
                                                                                 WHERE [ParameterName] = 'Member_Control.SyncHomePhoneToAddress'
                                  ) + 'Prompt'
    );
    IF @hOME_PHONE_PURPOSE IS NOT NULL
    BEGIN
        -- Name to Name_Address Synchronization - Parent Records
        UPDATE [Name_Address]
           SET [PHONE] = [n].[HOME_PHONE],
               [LAST_UPDATED] = @now
          FROM [Name_Address] [na]
               INNER JOIN [Name] [n] ON [n].[ID] = [na].[ID]
         WHERE NOT [n].[HOME_PHONE] = '' AND [na].[PHONE] = '' AND [na].[PURPOSE] = @hOME_PHONE_PURPOSE;
        SELECT [n].[ID],
               [n].[HOME_PHONE] AS [VAL_BEFORE],
               [na].[PHONE] AS [VAL_AFTER] INTO [#tmp_SyncH]
          FROM [Name_Address] AS [na]
               INNER JOIN [Name] AS [n] ON [n].[ID] = [na].[ID]
         WHERE NOT [na].[PHONE] = '' AND NOT [na].[PHONE] = [n].[HOME_PHONE] AND [na].[PURPOSE] = @hOME_PHONE_PURPOSE;
        IF (SELECT COUNT(1) FROM [#tmp_SyncH]) > 0
        BEGIN
            CREATE UNIQUE INDEX [ndx_SyncH_ID] ON [#tmp_SyncH] ([ID]);
            UPDATE [Name]
               SET [HOME_PHONE] = [ts].[VAL_AFTER],
                   [LAST_UPDATED] = @now
              FROM [#tmp_SyncH] [ts]
             WHERE [Name].[ID] = [ts].[ID];
            -- Change Log Inserts - Parent Records
            INSERT INTO [Name_Log] ([DATE_TIME],
                                    [LOG_TYPE],
                                    [SUB_TYPE],
                                    USER_ID,
                                    [ID],
                                    [LOG_TEXT]
                                   )
                   SELECT @now,
                          'CHANGE',
                          'CHANGE',
                          'SYNC',
                          [ts].[ID],
                          'Name.HOME_PHONE: '+[ts].[VAL_BEFORE]+' -> '+[ts].[VAL_AFTER]
                     FROM [#tmp_SyncH] AS [ts];
            -- Meetings Flowdown - Parent Records
            -- N/A (Home phone not part of orders/meetings)
            -- Home phone no longer honored as part of user-defined flowdown
            --         IF (
            --             SELECT COUNT(*) FROM System_Params
            --             WHERE ParameterName = 'Member_Control.FlowDownFields'
            --             AND (ShortValue LIKE '%Name.HOME_PHONE%' OR LongValue LIKE '%Name.HOME_PHONE%')
            --         ) = 1
            --         BEGIN
            --             SELECT
            --                 n.ID,
            --                 ts.VAL_BEFORE,
            --                 ts.VAL_AFTER
            --             INTO #tmp_SyncChildrenH
            --             FROM #tmp_SyncH ts
            --             JOIN Name n ON n.CO_ID = ts.ID
            --             WHERE n.COMPANY_RECORD = 0
            --             AND n.HOME_PHONE = ts.VAL_BEFORE
            --             IF (SELECT COUNT(*) FROM #tmp_SyncChildrenH) > 0
            --             BEGIN
            --                 UPDATE Name SET
            --                     HOME_PHONE = tsc.VAL_AFTER,
            --                     LAST_UPDATED = @now
            --                 FROM #tmp_SyncChildrenH tsc
            --                 WHERE Name.ID = tsc.ID
            --                 INSERT INTO Name_Log (DATE_TIME, LOG_TYPE, SUB_TYPE, USER_ID, ID, LOG_TEXT)
            --                 SELECT
            --                     @now, 'CHANGE', 'CHANGE', 'SYNC',
            --                     tsc.ID,
            --                     'Name.HOME_PHONE: ' + tsc.VAL_BEFORE + ' -> ' + tsc.VAL_AFTER
            --                 FROM #tmp_SyncChildrenH tsc
            --                 UPDATE Name_Address SET
            --                     PHONE = n.HOME_PHONE,
            --                     LAST_UPDATED = @now
            --                 FROM Name_Address na
            --                 JOIN Name n ON n.ID = na.ID
            --                 WHERE NOT n.HOME_PHONE = ''
            --                 AND na.PURPOSE = @HOME_PHONE_PURPOSE
            --             END
            --             DROP TABLE #tmp_SyncChildrenH
            --         END
        END;
        DROP TABLE [#tmp_SyncH];
    END;
END;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_NameProspectUnion]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_NameProspectUnion]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure sp_asi_NameProspectUnion 
 @ID varchar(15)='',
 @LastFirst varchar(30)='',
 @CompanySort varchar(30)='',
 @MaxCount integer=0 
 as
 set nocount on
 if @ID<>''
 -- Search by ID
 BEGIN
 select ID,PREFIX,LAST_FIRST,FIRST_NAME,MIDDLE_NAME,LAST_NAME,SUFFIX,FULL_NAME,TITLE,COMPANY,COMPANY_SORT,CITY,
 STATE_PROVINCE,ZIP,COUNTRY,HOME_PHONE,WORK_PHONE,FAX,EMAIL,ORG_CODE,MEMBER_TYPE,CATEGORY,STATUS,MAJOR_KEY,
 CO_ID,BT_ID,DUP_MATCH_KEY,FULL_ADDRESS,DESIGNATION,INFORMAL,TOLL_FREE,MAIL_CODE,CRRT,BAR_CODE,COUNTY,
 MAIL_ADDRESS_NUM,BILL_ADDRESS_NUM,GENDER,BIRTH_DATE,US_CONGRESS,STATE_SENATE,STATE_HOUSE,SIC_CODE,CHAPTER,
 FUNCTIONAL_TITLE,CONTACT_RANK,MEMBER_RECORD,COMPANY_RECORD,JOIN_DATE,SOURCE_CODE,PAID_THRU,MEMBER_STATUS,
 MEMBER_STATUS_DATE,PREVIOUS_MT,MT_CHANGE_DATE,CO_MEMBER_TYPE,EXCLUDE_MAIL,EXCLUDE_DIRECTORY,DATE_ADDED,
 LAST_UPDATED,UPDATED_BY,INTENT_TO_EDIT,ADDRESS_NUM_1,ADDRESS_NUM_2,ADDRESS_NUM_3,WEBSITE,'' ImisID,0 IsProspect
 from Name where ID = @ID
 UNION ALL
 select ProspectID ID,Prefix PREFIX,LastFirst LAST_FIRST,FirstName FIRST_NAME,
 MiddleName MIDDLE_NAME,LastName LAST_NAME,Suffix SUFFIX,FullName FULL_NAME,Title TITLE,
 Organization COMPANY,CompanySort COMPANY_SORT,City CITY,StateProvince STATE_PROVINCE,
 PostalCode IP,Country COUNTRY,HomePhone HOME_PHONE,WorkPhone WORK_PHONE,Fax FAX,Email EMAIL,
 '' ORG_CODE,ListCode MEMBER_TYPE,
 '' CATEGORY,'' STATUS,'' MAJOR_KEY,'' CO_ID,'' BT_ID,'' DUP_MATCH_KEY,'' FULL_ADDRESS,
 '' DESIGNATION,'' NFORMAL,'' TOLL_FREE,'' MAIL_CODE,'' CRRT,'' BAR_CODE,'' COUNTY,
 0 MAIL_ADDRESS_NUM,0 BILL_ADDRESS_NUM,'' GENDER,NULL BIRTH_DATE,'' US_CONGRESS,'' STATE_SENATE,
 '' STATE_HOUSE,'' SIC_CODE,'' CHAPTER,'' FUNCTIONAL_TITLE,0 CONTACT_RANK,0 MEMBER_RECORD,
 0 COMPANY_RECORD,NULL JOIN_DATE,'' SOURCE_CODE,NULL PAID_THRU,'' MEMBER_STATUS,NULL MEMBER_STATUS_DATE,
 '' PREVIOUS_MT,NULL MT_CHANGE_DATE,'' CO_MEMBER_TYPE,0 EXCLUDE_MAIL,0 EXCLUDE_DIRECTORY,
 NULL DATE_ADDED,NULL LAST_UPDATED,'' UPDATED_BY,'' INTENT_TO_EDIT,0 ADDRESS_NUM_1,
 0 ADDRESS_NUM_2,0 ADDRESS_NUM_3,'' WEBSITE,ImisID,1 IsProspect from Prospect
 where ProspectID = @ID
 END
 ELSE IF @LastFirst<>''
 -- Search by LastFirst
 BEGIN
 set rowcount @MaxCount
 select ID,PREFIX,LAST_FIRST,FIRST_NAME,MIDDLE_NAME,LAST_NAME,SUFFIX,FULL_NAME,TITLE,COMPANY,COMPANY_SORT,CITY,
 STATE_PROVINCE,ZIP,COUNTRY,HOME_PHONE,WORK_PHONE,FAX,EMAIL,ORG_CODE,MEMBER_TYPE,CATEGORY,STATUS,MAJOR_KEY,
 CO_ID,BT_ID,DUP_MATCH_KEY,FULL_ADDRESS,DESIGNATION,INFORMAL,TOLL_FREE,MAIL_CODE,CRRT,BAR_CODE,COUNTY,
 MAIL_ADDRESS_NUM,BILL_ADDRESS_NUM,GENDER,BIRTH_DATE,US_CONGRESS,STATE_SENATE,STATE_HOUSE,SIC_CODE,CHAPTER,
 FUNCTIONAL_TITLE,CONTACT_RANK,MEMBER_RECORD,COMPANY_RECORD,JOIN_DATE,SOURCE_CODE,PAID_THRU,MEMBER_STATUS,
 MEMBER_STATUS_DATE,PREVIOUS_MT,MT_CHANGE_DATE,CO_MEMBER_TYPE,EXCLUDE_MAIL,EXCLUDE_DIRECTORY,DATE_ADDED,
 LAST_UPDATED,UPDATED_BY,INTENT_TO_EDIT,ADDRESS_NUM_1,ADDRESS_NUM_2,ADDRESS_NUM_3,WEBSITE,'' ImisID,0 IsProspect
 from Name where LAST_FIRST like @LastFirst+'%'
 UNION ALL
 select ProspectID ID,Prefix PREFIX,LastFirst LAST_FIRST,FirstName FIRST_NAME,
 MiddleName MIDDLE_NAME,LastName LAST_NAME,Suffix SUFFIX,FullName FULL_NAME,Title TITLE,
 Organization COMPANY,CompanySort COMPANY_SORT,City CITY,StateProvince STATE_PROVINCE,
 PostalCode IP,Country COUNTRY,HomePhone HOME_PHONE,WorkPhone WORK_PHONE,Fax FAX,Email EMAIL,
 '' ORG_CODE,ListCode MEMBER_TYPE,
 '' CATEGORY,'' STATUS,'' MAJOR_KEY,'' CO_ID,'' BT_ID,'' DUP_MATCH_KEY,'' FULL_ADDRESS,
 '' DESIGNATION,'' NFORMAL,'' TOLL_FREE,'' MAIL_CODE,'' CRRT,'' BAR_CODE,'' COUNTY,
 0 MAIL_ADDRESS_NUM,0 BILL_ADDRESS_NUM,'' GENDER,NULL BIRTH_DATE,'' US_CONGRESS,'' STATE_SENATE,
 '' STATE_HOUSE,'' SIC_CODE,'' CHAPTER,'' FUNCTIONAL_TITLE,0 CONTACT_RANK,0 MEMBER_RECORD,
 0 COMPANY_RECORD,NULL JOIN_DATE,'' SOURCE_CODE,NULL PAID_THRU,'' MEMBER_STATUS,NULL MEMBER_STATUS_DATE,
 '' PREVIOUS_MT,NULL MT_CHANGE_DATE,'' CO_MEMBER_TYPE,0 EXCLUDE_MAIL,0 EXCLUDE_DIRECTORY,
 NULL DATE_ADDED,NULL LAST_UPDATED,'' UPDATED_BY,'' INTENT_TO_EDIT,0 ADDRESS_NUM_1,
 0 ADDRESS_NUM_2,0 ADDRESS_NUM_3,'' WEBSITE,ImisID,1 IsProspect from Prospect
 where LastFirst like @LastFirst+'%' and ImisID=''
 END
 ELSE
 -- Search by CompanySort
 BEGIN
 set rowcount @MaxCount
 select ID,PREFIX,LAST_FIRST,FIRST_NAME,MIDDLE_NAME,LAST_NAME,SUFFIX,FULL_NAME,TITLE,COMPANY,COMPANY_SORT,CITY,
 STATE_PROVINCE,ZIP,COUNTRY,HOME_PHONE,WORK_PHONE,FAX,EMAIL,ORG_CODE,MEMBER_TYPE,CATEGORY,STATUS,MAJOR_KEY,
 CO_ID,BT_ID,DUP_MATCH_KEY,FULL_ADDRESS,DESIGNATION,INFORMAL,TOLL_FREE,MAIL_CODE,CRRT,BAR_CODE,COUNTY,
 MAIL_ADDRESS_NUM,BILL_ADDRESS_NUM,GENDER,BIRTH_DATE,US_CONGRESS,STATE_SENATE,STATE_HOUSE,SIC_CODE,CHAPTER,
 FUNCTIONAL_TITLE,CONTACT_RANK,MEMBER_RECORD,COMPANY_RECORD,JOIN_DATE,SOURCE_CODE,PAID_THRU,MEMBER_STATUS,
 MEMBER_STATUS_DATE,PREVIOUS_MT,MT_CHANGE_DATE,CO_MEMBER_TYPE,EXCLUDE_MAIL,EXCLUDE_DIRECTORY,DATE_ADDED,
 LAST_UPDATED,UPDATED_BY,INTENT_TO_EDIT,ADDRESS_NUM_1,ADDRESS_NUM_2,ADDRESS_NUM_3,WEBSITE,'' ImisID,0 IsProspect
 from Name where COMPANY_SORT like @CompanySort+'%'
 UNION ALL
 select ProspectID ID,Prefix PREFIX,LastFirst LAST_FIRST,FirstName FIRST_NAME,
 MiddleName MIDDLE_NAME,LastName LAST_NAME,Suffix SUFFIX,FullName FULL_NAME,Title TITLE,
 Organization COMPANY,CompanySort COMPANY_SORT,City CITY,StateProvince STATE_PROVINCE,
 PostalCode IP,Country COUNTRY,HomePhone HOME_PHONE,WorkPhone WORK_PHONE,Fax FAX,Email EMAIL,
 '' ORG_CODE,ListCode MEMBER_TYPE,
 '' CATEGORY,'' STATUS,'' MAJOR_KEY,'' CO_ID,'' BT_ID,'' DUP_MATCH_KEY,'' FULL_ADDRESS,
 '' DESIGNATION,'' NFORMAL,'' TOLL_FREE,'' MAIL_CODE,'' CRRT,'' BAR_CODE,'' COUNTY,
 0 MAIL_ADDRESS_NUM,0 BILL_ADDRESS_NUM,'' GENDER,NULL BIRTH_DATE,'' US_CONGRESS,'' STATE_SENATE,
 '' STATE_HOUSE,'' SIC_CODE,'' CHAPTER,'' FUNCTIONAL_TITLE,0 CONTACT_RANK,0 MEMBER_RECORD,
 0 COMPANY_RECORD,NULL JOIN_DATE,'' SOURCE_CODE,NULL PAID_THRU,'' MEMBER_STATUS,NULL MEMBER_STATUS_DATE,
 '' PREVIOUS_MT,NULL MT_CHANGE_DATE,'' CO_MEMBER_TYPE,0 EXCLUDE_MAIL,0 EXCLUDE_DIRECTORY,
 NULL DATE_ADDED,NULL LAST_UPDATED,'' UPDATED_BY,'' INTENT_TO_EDIT,0 ADDRESS_NUM_1,
 0 ADDRESS_NUM_2,0 ADDRESS_NUM_3,'' WEBSITE,ImisID,1 IsProspect from Prospect
 where CompanySort like @CompanySort+'%' and ImisID=''
 END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_NameToNameAddressSync]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_NameToNameAddressSync]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE sp_asi_NameToNameAddressSync (
  @ID VARCHAR(10)
  )
  AS
  UPDATE Name_Address SET 
  PHONE = (
  SELECT HOME_PHONE FROM Name WHERE ID = @ID
  )
  WHERE ID = @ID
  AND PURPOSE = (
  SELECT ShortValue FROM System_Params 
  WHERE ParameterName = 
  'Member_Control.' + (
  SELECT ShortValue FROM System_Params 
  WHERE ParameterName = 'Member_Control.SyncHomePhoneToAddress'
  ) + 'Prompt'
  )
  UPDATE Name_Address SET
  PHONE = (
  SELECT WORK_PHONE FROM Name WHERE ID = @ID
  )
  WHERE ID = @ID
  AND PURPOSE = (
  SELECT ShortValue FROM System_Params 
  WHERE ParameterName = 
  'Member_Control.' + (
  SELECT ShortValue FROM System_Params 
  WHERE ParameterName = 'Member_Control.SyncWorkPhoneToAddress'
  ) + 'Prompt'
  )
  UPDATE Name_Address SET
  FAX = (
  SELECT FAX FROM Name WHERE ID = @ID
  )
  WHERE ID = @ID
  AND PURPOSE = (
  SELECT ShortValue FROM System_Params 
  WHERE ParameterName = 
  'Member_Control.' + (
  SELECT ShortValue FROM System_Params 
  WHERE ParameterName = 'Member_Control.SyncFaxToAddress'
  ) + 'Prompt'
  )
  UPDATE Name_Address SET
  EMAIL = (
  SELECT EMAIL FROM Name WHERE ID = @ID
  )
  WHERE ID = @ID
  AND PURPOSE = (
  SELECT ShortValue FROM System_Params 
  WHERE ParameterName = 
  'Member_Control.' + (
  SELECT ShortValue FROM System_Params 
  WHERE ParameterName = 'Member_Control.SyncEmailToAddress'
  ) + 'Prompt'
  )

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_sp_columns]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_sp_columns]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
--	Procedure for SQL2K (8.0) server, revised for iMIS
-- 	extensively revised (and simplified) for SQL Server 2005
CREATE PROCEDURE sp_asi_sp_columns (@table_name	 varchar(96))
as
select
'' TABLE_QUALIFIER,
'' TABLE_OWNER,
'' TABLE_NAME,
convert (varchar(96), c.name) COLUMN_NAME,
0 DATA_TYPE,
convert (varchar(96), t.name) 'TYPE_NAME',
convert(int, 
	case when t.name = 'float' then 15
	when t.name = 'real' then 7 		
	else OdbcPrec(c.xtype,c.length,c.xprec)
end) 'PRECISION', 
convert(int, case
	when t.name IN ('money', 'numeric','decimal') 
		then OdbcPrec(c.xtype,c.length,c.xprec)+2
	when t.name IN ('datetime') 
		then 16
	when t.name IN ('text', 'image') 
		then OdbcPrec(c.xtype,c.length,c.xprec)
	else c.length
	end) 'LENGTH',  
SCALE = convert(smallint, OdbcScale(c.xtype,c.xscale)),
0 RADIX,
isnullable NULLABLE,
NULL REMARKS,
colorder ORDINAL_POSITION
from syscolumns c
inner join systypes t on c.usertype = t.usertype
where id = (select id from sysobjects where name = @table_name)
and c.name <> 'TIME_STAMP'
order by ORDINAL_POSITION

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_sp_columns_ts]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_sp_columns_ts]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
--	Procedure for SQL2K (8.0) server, revised for iMIS
-- 	extensively revised (and simplified) for SQL Server 2005
CREATE PROCEDURE sp_asi_sp_columns_ts (@table_name varchar(96))
as
select
'' TABLE_QUALIFIER,
'' TABLE_OWNER,
'' TABLE_NAME,
convert (varchar(96), c.name) COLUMN_NAME,
0 DATA_TYPE,
convert (varchar(96), 
	case when ColumnProperty (c.id, c.name, 'IsIdentity') = 1
		then 'int identity'
	else t.name
	end) 
'TYPE_NAME',
convert(int, 
	case when t.name = 'float' then 15
	when t.name = 'real' then 7 		
	else OdbcPrec(c.xtype,c.length,c.xprec)
end) 'PRECISION', 
convert(int, case
	when t.name IN ('money', 'numeric','decimal') 
		then OdbcPrec(c.xtype,c.length,c.xprec)+2
	when t.name IN ('datetime') 
		then 16
	when t.name IN ('text', 'image') 
		then OdbcPrec(c.xtype,c.length,c.xprec)
	else c.length
	end) 'LENGTH',  
SCALE = convert(smallint, OdbcScale(c.xtype,c.xscale)),
0 RADIX,
isnullable NULLABLE,
NULL REMARKS,
colorder ORDINAL_POSITION
from syscolumns c
inner join systypes t on c.usertype = t.usertype
where id = (select id from sysobjects where name = @table_name)
order by ORDINAL_POSITION

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_sp_pkeys]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_sp_pkeys]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE sp_asi_sp_pkeys(
					@table_name		varchar(96),
					@table_owner 	varchar(96) = null,
					@table_qualifier varchar(96) = null )
		as
			DECLARE @table_id			int
			DECLARE @full_table_name	varchar(255) /* 2*128 + 1 */
			if @table_qualifier is not null
			begin
				if db_name() <> @table_qualifier
				begin	/* If qualifier doesn't match current database */
					raiserror (15250, -1,-1)
					return
				end
			end
			if @table_owner is null
			begin	/* If unqualified table name */
				SELECT @full_table_name = @table_name
			end
			else
			begin	/* Qualified table name */
				if @table_owner = ''
				begin	/* If empty owner name */
					SELECT @full_table_name = @table_owner
				end
				else
				begin
					SELECT @full_table_name = @table_owner + '.' + @table_name
				end
			end
			/*	Get Object ID */
			SELECT @table_id = object_id(@full_table_name)
			select
				TABLE_QUALIFIER = convert(varchar(96),db_name()),
				TABLE_OWNER = convert(varchar(96),user_name(o.uid)),
				TABLE_NAME = convert(varchar(96),o.name),
				COLUMN_NAME = convert(varchar(96),c.name),
				KEY_SEQ = convert(smallint,c1.colid),
				PK_NAME = convert(varchar(96),i.name)
			from
				sysindexes i, syscolumns c, sysobjects o, syscolumns c1
			where
				o.id = @table_id
				and o.id = c.id
				and o.id = i.id
				and (i.status & 0x800) = 0x800
				and c.name = index_col (@full_table_name, i.indid, c1.colid)
				and c1.colid <= i.keycnt	/* create rows from 1 to keycnt */
				and c1.id = @table_id
			order by 1, 2, 3, 5

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_suser_name]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_suser_name]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE sp_asi_suser_name AS 
		select (convert (varchar(64), suser_sname ()))

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_TreatProspectImport]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_TreatProspectImport]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure sp_asi_TreatProspectImport @Prefix varchar(5),@ListCode varchar(20),@CurrentLocalDate varchar (50)=''
   as
   set nocount on
   declare 
   @ProspectKey uniqueidentifier,
   @ProspectID varchar(15),
   @NewProspectID int,
   @Result int
   declare Get_Prospect cursor for 
   select ProspectKey from Prospect where ImportDate is null
   open Get_Prospect
   fetch next from Get_Prospect into @ProspectKey
   WHILE @@FETCH_STATUS = 0
    BEGIN
     exec @Result=sp_iboGetCounter 'Prospect',1,@NewProspectID output
     update Prospect set ListCode=@ListCode,ProspectID=@Prefix+convert(varchar(10),@NewProspectID),
     ImportDate=@CurrentLocalDate,
     LastFirst=
     CASE 
     WHEN rtrim(isnull(LastName,''))<>'' and rtrim(isnull(FirstName,''))<>''
     THEN substring(upper(LastName)+', '+upper(FirstName),1,30)
     WHEN rtrim(isnull(LastName,''))='' and rtrim(isnull(FirstName,''))='' and rtrim(isnull(Organization,''))=''
     THEN 'NODATA'
     ELSE ''
     END,
     CompanySort=
     CASE
     WHEN rtrim(isnull(Organization,''))<>'' and substring(upper(isnull(Organization,'')),1,4)='THE '
     THEN substring(upper(Organization),5,30)
     WHEN rtrim(isnull(Organization,''))<>'' and substring(upper(isnull(Organization,'')),1,4)<>'THE '
     THEN  substring(upper(Organization),1,30)
     ELSE ''
     END
     where ProspectKey=@ProspectKey
     fetch next from Get_Prospect into @ProspectKey
    END
   close Get_Prospect
   deallocate Get_Prospect
   delete Prospect where LastFirst='NODATA'

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_UnformatPhoneNumber]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_UnformatPhoneNumber]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure sp_asi_UnformatPhoneNumber
     @table VARCHAR(100),
     @column VARCHAR(100)
 AS
 DECLARE @sql VARCHAR(2000)
 DECLARE @phone VARCHAR(100)
 SET @sql = 'DECLARE csrPhone CURSOR GLOBAL FOR ' +
     'SELECT ' + @column + ' ' + 
      'FROM ' + @table + ' ' +
      'WHERE ' + @column + ' LIKE ''%[^0-9]%'' ' +
      'FOR UPDATE '
 EXEC(@sql)
 OPEN csrPhone
 FETCH NEXT FROM csrPhone INTO @phone
 SET NOCOUNT ON
 WHILE @@FETCH_STATUS = 0
 BEGIN
      WHILE PATINDEX('%[^0-9]%', @phone) > 0
           SET @phone = STUFF(@phone, PATINDEX('%[^0-9]%', @phone), 1, '')
      SET @sql = 'UPDATE ' + @table + ' ' +
           'SET ' + @column + ' = ''' + @phone + ''' ' +
           'WHERE CURRENT OF GLOBAL csrPhone '
      EXEC(@sql)
      FETCH NEXT FROM csrPhone INTO @phone
 END
 SET NOCOUNT OFF
 CLOSE csrPhone
 DEALLOCATE csrPhone

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_UnformatPhoneNumbers]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_UnformatPhoneNumbers]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure sp_asi_UnformatPhoneNumbers
 as
 	-- Name 
 	exec sp_asi_UnformatPhoneNumber 'Name','HOME_PHONE'
 	exec sp_asi_UnformatPhoneNumber 'Name','WORK_PHONE'
 	exec sp_asi_UnformatPhoneNumber 'Name','FAX'
 	exec sp_asi_UnformatPhoneNumber 'Name','TOLL_FREE'
 	-- Name_Address
 	exec sp_asi_UnformatPhoneNumber 'Name_Address','PHONE'
 	exec sp_asi_UnformatPhoneNumber 'Name_Address','FAX'
 	-- Meet_Hotel
 	exec sp_asi_UnformatPhoneNumber 'Meet_Hotel','PHONE'
 	exec sp_asi_UnformatPhoneNumber 'Meet_Hotel','FAX'
 	exec sp_asi_UnformatPhoneNumber 'Meet_Hotel','TOLL_FREE'
 	-- Orders
 	exec sp_asi_UnformatPhoneNumber 'Orders','PHONE'
 	exec sp_asi_UnformatPhoneNumber 'Orders','FAX'
 	exec sp_asi_UnformatPhoneNumber 'Orders','TOLL_FREE'
 	-- Product_Instance
 	exec sp_asi_UnformatPhoneNumber 'Product_Instance','PHONE'
 	exec sp_asi_UnformatPhoneNumber 'Product_Instance','FAX'
 	exec sp_asi_UnformatPhoneNumber 'Product_Instance','TOLL_FREE'
 	-- Ref_Client
 	exec sp_asi_UnformatPhoneNumber 'Ref_Client','PHONE'
 	exec sp_asi_UnformatPhoneNumber 'Ref_Client','FAX'
 	-- Ref_Provider
 	exec sp_asi_UnformatPhoneNumber 'Ref_Provider','PHONE'
 	-- Rpt_WorkingTbl
 	exec sp_asi_UnformatPhoneNumber 'Rpt_WorkingTbl','WORK_PHONE'
 	exec sp_asi_UnformatPhoneNumber 'Rpt_WorkingTbl','HOME_PHONE'
 	-- Exhb_Srvc_Comp
 	exec sp_asi_UnformatPhoneNumber 'Exhb_Srvc_Comp','CONTACT_PHONE'
 	-- Contacts
 	exec sp_asi_UnformatPhoneNumber 'Contacts','PHONE'
 	exec sp_asi_UnformatPhoneNumber 'Contacts','FAX'

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_UpdateCompanySort]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_UpdateCompanySort]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[sp_asi_UpdateCompanySort]
AS 
    BEGIN

        SET NOCOUNT ON

        SET ROWCOUNT 1000
        DECLARE @isDone BIT
        SET @isDone = 0
        WHILE ( @isDone = 0 ) 
            BEGIN
                BEGIN TRANSACTION
                UPDATE  Name
                SET     COMPANY_SORT = dbo.fn_asi_GetCompanySort(COMPANY)
                WHERE   ( COMPANY_SORT <> dbo.fn_asi_GetCompanySort(COMPANY) )
                        AND ( LEN(COMPANY_SORT) = 0 )
                IF @@ROWCOUNT = 0 
                    SET @isDone = 1
                COMMIT TRANSACTION
            END
        SET ROWCOUNT 0
    END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_UpdateCompanyTitleUse]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_UpdateCompanyTitleUse]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure sp_asi_UpdateCompanyTitleUse
 as
 set nocount on
 declare
 @CompanyPurposes varchar(255), 
 @TitlePurposes varchar(255),
 @PrefPurpose varchar(255),
 @UseCompany bit,
 @UseTitle bit,
 @OrderNumber float,
 @Id varchar(10)
 select @CompanyPurposes =ShortValue from System_Params where ParameterName = 'Member_Control.PrintCompanyWithAddressString'
 select @TitlePurposes =ShortValue from System_Params where ParameterName = 'Member_Control.PrintTitleWithAddressString'
 select @UseCompany=0
 select @UseTitle=0
 declare Get_Orders cursor for 
 select ORDER_NUMBER,ST_ID
 from Orders where STAGE not in ('CLOSED','CANCELED','COMPLETED')
 open Get_Orders
 fetch next from Get_Orders into @OrderNumber,@Id
 WHILE @@FETCH_STATUS = 0
 BEGIN
 select @PrefPurpose=','+PURPOSE+',' from Name_Address
 join Name on Name.ID=Name_Address.ID 
 where Name.MAIL_ADDRESS_NUM=Name_Address.ADDRESS_NUM and Name.ID=@Id
 If charindex(@PrefPurpose,@CompanyPurposes)>0
 begin
  select @UseCompany=1
 end
 If charindex(@PrefPurpose,@TitlePurposes)>0
 begin
  select @UseTitle=1
 end
 update Orders set ST_PRINT_COMPANY=@UseCompany,ST_PRINT_TITLE=@UseTitle
 where ORDER_NUMBER=@OrderNumber
 update Order_Badge set ST_PRINT_COMPANY=@UseCompany,ST_PRINT_TITLE=@UseTitle
 where ORDER_NUMBER=@OrderNumber and BADGE_TYPE='PRIMARY'
 select @UseCompany=0
 select @UseTitle=0
 fetch next from Get_Orders into @OrderNumber,@Id
 END
 close Get_Orders
 deallocate Get_Orders

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_UpdateDupMatchKey]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_UpdateDupMatchKey]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  StoredProcedure dbo.sp_asi_UpdateDupMatchKey  ******/
 -- =============================================
 -- This stored procedure calculates the Name.DUP_MATCH_KEY value - update the formula as required
 -- =============================================
 create procedure dbo.sp_asi_UpdateDupMatchKey
 as
 begin
 	-- controls update messages being sent to display
 	set nocount on
 	update Name
 		set DUP_MATCH_KEY=dbo.fn_asi_GetDupMatchKey(ID)
 		where DUP_MATCH_KEY<>dbo.fn_asi_GetDupMatchKey(ID)
 end
 GRANT EXECUTE on fn_asi_convert_foreign_chars to IMIS

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_UpdateEventFR]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_UpdateEventFR]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure sp_asi_UpdateEventFR
 as
 set nocount on
 declare
 @MeetCode varchar(10),
 @Appeal varchar(40), 
 @Campaign varchar(10),
 @Fund varchar(5),
 @OrderNumber float,
 @FairMarketValue money,
 @ProductCode varchar(31),
 @ProdTitle varchar(60),
 @RefNum int,
 @Status varchar(1),
 @ActivityType varchar(10),
 @Seqn int,
 @Id varchar(10),
 @TransDate datetime,
 @TransNumber int,
 @Result int,
 @NewSeqn int,
 @Amount money,
 @SourceCode varchar(40)
 declare Get_FREvents cursor for 
 select 
 max(m.MEET_APPEAL) MEET_APPEAL,
 max(m.MEET_CAMPAIGN) MEET_CAMPAIGN,
 max(m.ORG_CODE) ORG_CODE,
 max(m.STATUS) STATUS,
 max(p.TAXABLE_VALUE) TAXABLE_VALUE,
 p.PRODUCT_CODE,
 max(p.TITLE) TITLE,
 max(om.ORDER_NUMBER) ORDER_NUMBER,
 max(o.INVOICE_REFERENCE_NUM) INVOICE_REFERENCE_NUM,
 max(ol.EXTENDED_AMOUNT) EXTENDED_AMOUNT,
 max(t.ACTIVITY_TYPE) ACTIVITY_TYPE,
 max(t.ACTIVITY_SEQN) ACTIVITY_SEQN,
 t.ST_ID,
 max(t.TRANSACTION_DATE) TRANSACTION_DATE,
 max(t.TRANS_NUMBER) TRANS_NUMBER,
 max(t.SOURCE_CODE) SOURCE_CODE 
 from Meet_Master m
 join Order_Meet om on m.MEETING=om.MEETING
 join Orders o on om.ORDER_NUMBER=o.ORDER_NUMBER
 join Order_Lines ol on ol.ORDER_NUMBER=o.ORDER_NUMBER
 join Product p on p.PRODUCT_MAJOR=m.MEETING
 join Trans t on t.INVOICE_REFERENCE_NUM=o.INVOICE_REFERENCE_NUM
 where m.IS_FR_MEET=1 and t.TRANSACTION_TYPE='DIST' and t.JOURNAL_TYPE='IN'
 and t.SOURCE_SYSTEM='MEETING' and ol.PRODUCT_CODE=p.PRODUCT_CODE and ol.EXTENDED_AMOUNT>0
 group by p.PRODUCT_CODE,t.ST_ID
 open Get_FREvents 
 fetch next from Get_FREvents into @Appeal,@Campaign,@Fund,@Status,@FairMarketValue,@ProductCode,@ProdTitle,
 @OrderNumber,@RefNum,@Amount,@ActivityType,@Seqn,@Id,@TransDate,@TransNumber,@SourceCode
 WHILE @@FETCH_STATUS = 0
 BEGIN
 if NOT EXISTS(select * from Activity where ID=@Id and PRODUCT_CODE=@ProductCode and ACTIVITY_TYPE='GIFT')
 BEGIN
 If @Status<>'C'
 begin
 update Order_Lines set MEET_APPEAL=@Appeal,MEET_CAMPAIGN=@Campaign,ORG_CODE=@Fund,
 FAIR_MARKET_VALUE=@FairMarketValue,IS_FR_ITEM=1
 where PRODUCT_CODE=@ProductCode
 end
 update Product set APPEAL_CODE=@Appeal,CAMPAIGN_CODE=@Campaign,ORG_CODE=@Fund,
 IS_FR_ITEM=1 where PRODUCT_CODE=@ProductCode
 update Product_Function set IS_FR_ITEM=1 where PRODUCT_CODE=@ProductCode
 if isnull(@Appeal,'')='' and isnull(@SourceCode,'')<>''
 begin
 select @Appeal=@SourceCode
 end
 update Trans set SOURCE_CODE=@Appeal,CAMPAIGN_CODE=@Campaign,
 IS_FR_ITEM=1, ACTIVITY_TYPE=CASE ACTIVITY_TYPE WHEN 'PLEDGE' THEN 'GIFT' ELSE ACTIVITY_TYPE END 
 where INVOICE_REFERENCE_NUM=@RefNum and TRANSACTION_TYPE='DIST'
 exec @Result=sp_iboGetCounter 'Activity',1,@NewSeqn output
 insert into Activity(SEQN,ID,ACTIVITY_TYPE,PRODUCT_CODE,OTHER_CODE,TRANSACTION_DATE,DESCRIPTION, 
 EFFECTIVE_DATE,AMOUNT,SOURCE_CODE,SOURCE_SYSTEM,CO_ID,MEMBER_TYPE,ORIGINATING_TRANS_NUM,
 ORG_CODE,CAMPAIGN_CODE,OTHER_ID,TAXABLE_VALUE)
 select @NewSeqn,@Id,'GIFT',@ProductCode,'GIFT',@TransDate,@ProdTitle,
 NULL,@Amount,@Appeal,'MEETING', 
 (CASE n.COMPANY_RECORD WHEN 1 then n.ID WHEN 0 then n.CO_ID END), 
 n.MEMBER_TYPE,@TransNumber,@Fund,@Campaign,@Id,@FairMarketValue 
 from Name n where n.ID =@Id
 END
 fetch next from Get_FREvents into @Appeal,@Campaign,@Fund,@Status,@FairMarketValue,@ProductCode,@ProdTitle,
 @OrderNumber,@RefNum,@Amount,@ActivityType,@Seqn,@Id,@TransDate,@TransNumber,@SourceCode
 END
 close Get_FREvents 
 deallocate Get_FREvents
 update Trans set Trans.SOURCE_CODE=a.SOURCE_CODE,Trans.CAMPAIGN_CODE=a.CAMPAIGN_CODE,Trans.IS_FR_ITEM=1
 from Trans
 join Activity a on a.ORIGINATING_TRANS_NUM=Trans.TRANS_NUMBER
 join Invoice i on i.ORIGINATING_TRANS_NUM=a.ORIGINATING_TRANS_NUM
 where Trans.TRANSACTION_TYPE='DIST' and Trans.JOURNAL_TYPE='IN' and Trans.SOURCE_SYSTEM='MEETING'
 and Trans.IS_FR_ITEM=0 and Trans.INVOICE_REFERENCE_NUM=i.REFERENCE_NUM
 and a.ACTIVITY_TYPE in ('GIFT','PLEDGE')
 update Trans set INSTALL_BILL_DATE=NULL where SOURCE_SYSTEM='MEETING'
 update Invoice set INSTALL_BILL_DATE=NULL where SOURCE_SYSTEM='MEETING'
 update Activity set ACTIVITY_TYPE='GIFT' where ACTIVITY_TYPE='PLEDGE'
 and SOURCE_SYSTEM='MEETING'

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_UpdateFullName]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_UpdateFullName]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[sp_asi_UpdateFullName]
AS 
    BEGIN

        DECLARE @prefixes varchar(1000)
        SELECT @prefixes = ShortValue from System_Params where ParameterName = 'Member_Control.IncludePrefixString'

    -- controls update messages being sent to display
        SET NOCOUNT ON 

        SET ROWCOUNT 1000
        DECLARE @isDone BIT
        SET @isDone = 0
        WHILE ( @isDone = 0 ) 
            BEGIN
                BEGIN TRANSACTION
                UPDATE  Name
                SET     FULL_NAME = ISNULL(LTRIM(
                                       ISNULL( CASE WHEN CHARINDEX(',' + PREFIX + ',' ,',' + ISNULL(@prefixes,'') + ',') > 0 
                                             THEN ISNULL(SUBSTRING(SUBSTRING(@prefixes, 
                                                                             CHARINDEX(',' + PREFIX + ',' ,',' + @prefixes + ','), 
                                                                             DATALENGTH(PREFIX)),
                                                                   1,
                                                                   DATALENGTH(SUBSTRING(@prefixes,
                                                                                        CHARINDEX(','+PREFIX+',' , ',' + (@prefixes)+','),
                                                                                        DATALENGTH(PREFIX)))
                                                                   * ABS(SIGN(SIGN(DATALENGTH(SUBSTRING(@prefixes,
                                                                                              CHARINDEX(','+PREFIX+',' , ',' + @prefixes+','),
                                                                                              DATALENGTH(PREFIX)))-1) + 
                                                                                              SIGN(ASCII(SUBSTRING(@prefixes,
                                                                                                                   CHARINDEX(','+PREFIX+',' , ',' + @prefixes+','),
                                                                                                                   DATALENGTH(PREFIX)))-32)))) +
                                                         SUBSTRING(' ', 1, ABS(SIGN(SIGN(DATALENGTH(SUBSTRING(@prefixes, CHARINDEX(','+PREFIX+',' , ',' + @prefixes + ','),
                                                 DATALENGTH(PREFIX)))-1) + SIGN(ASCII(SUBSTRING(@prefixes, CHARINDEX(',' + PREFIX + ',' , ',' + @prefixes + ','), DATALENGTH(PREFIX)))-32)))),'') 
                                             END ,'')
                                        +
                                         SUBSTRING(FIRST_NAME, 1 ,DATALENGTH(FIRST_NAME) * ABS(SIGN(SIGN(DATALENGTH(FIRST_NAME)-1) + COALESCE(SIGN(ASCII(FIRST_NAME)-32), 0))))
                                        + SUBSTRING(' ', 1, ABS(SIGN(SIGN(DATALENGTH(FIRST_NAME)-1) + COALESCE(SIGN(ASCII(FIRST_NAME)-32), 0)))) 
                                        + SUBSTRING(MIDDLE_NAME, 1, DATALENGTH(MIDDLE_NAME) * ABS(SIGN(SIGN(DATALENGTH(MIDDLE_NAME)-1) + COALESCE(SIGN(ASCII(MIDDLE_NAME)-32), 0)))) 
                                        + SUBSTRING(' ', 1, ABS(SIGN(SIGN(DATALENGTH(MIDDLE_NAME)-1) + COALESCE(SIGN(ASCII(MIDDLE_NAME)-32), 0)))) 
                                        + SUBSTRING(LAST_NAME, 1, DATALENGTH(LAST_NAME) * ABS(SIGN(SIGN(DATALENGTH(LAST_NAME)-1) + COALESCE(SIGN(ASCII(LAST_NAME)-32), 0)))) 
                                        + SUBSTRING(', ', 1, 2 * ABS(SIGN(SIGN(DATALENGTH(LTRIM(RTRIM(SUFFIX))))))) 
                                        + SUBSTRING(SUFFIX, 1, DATALENGTH(SUFFIX) * ABS(SIGN(SIGN(DATALENGTH(LTRIM(RTRIM(SUFFIX))))))) 
                                        + SUBSTRING(', ', 1 ,2 * ABS(SIGN(SIGN(DATALENGTH(LTRIM(RTRIM(DESIGNATION))))))) 
                                        + SUBSTRING(DESIGNATION, 1, DATALENGTH(DESIGNATION) * ABS(SIGN(SIGN(DATALENGTH(DESIGNATION)-1) + COALESCE(SIGN(ASCII(DESIGNATION)-32), 0))))
                                        ),'')
                WHERE   FULL_NAME <> ISNULL(LTRIM(
                                       ISNULL( CASE WHEN CHARINDEX(',' + PREFIX + ',' ,',' + ISNULL(@prefixes,'') + ',') > 0 
                                             THEN ISNULL(SUBSTRING(SUBSTRING(@prefixes, 
                                                                             CHARINDEX(',' + PREFIX + ',' ,',' + @prefixes + ','), 
                                                                             DATALENGTH(PREFIX)),
                                                                   1,
                                                                   DATALENGTH(SUBSTRING(@prefixes,
                                                                                        CHARINDEX(','+PREFIX+',' , ',' + (@prefixes)+','),
                                                                                        DATALENGTH(PREFIX)))
                                                                   * ABS(SIGN(SIGN(DATALENGTH(SUBSTRING(@prefixes,
                                                                                              CHARINDEX(','+PREFIX+',' , ',' + @prefixes+','),
                                                                                              DATALENGTH(PREFIX)))-1) + 
                                                                                              SIGN(ASCII(SUBSTRING(@prefixes,
                                                                                                                   CHARINDEX(','+PREFIX+',' , ',' + @prefixes+','),
                                                                                                                   DATALENGTH(PREFIX)))-32)))) +
                                                         SUBSTRING(' ', 1, ABS(SIGN(SIGN(DATALENGTH(SUBSTRING(@prefixes, CHARINDEX(','+PREFIX+',' , ',' + @prefixes + ','),
                                                 DATALENGTH(PREFIX)))-1) + SIGN(ASCII(SUBSTRING(@prefixes, CHARINDEX(',' + PREFIX + ',' , ',' + @prefixes + ','), DATALENGTH(PREFIX)))-32)))),'') 
                                             END ,'')
                                        +
                                         SUBSTRING(FIRST_NAME, 1 ,DATALENGTH(FIRST_NAME) * ABS(SIGN(SIGN(DATALENGTH(FIRST_NAME)-1) + COALESCE(SIGN(ASCII(FIRST_NAME)-32), 0))))
                                        + SUBSTRING(' ', 1, ABS(SIGN(SIGN(DATALENGTH(FIRST_NAME)-1) + COALESCE(SIGN(ASCII(FIRST_NAME)-32), 0)))) 
                                        + SUBSTRING(MIDDLE_NAME, 1, DATALENGTH(MIDDLE_NAME) * ABS(SIGN(SIGN(DATALENGTH(MIDDLE_NAME)-1) + COALESCE(SIGN(ASCII(MIDDLE_NAME)-32), 0)))) 
                                        + SUBSTRING(' ', 1, ABS(SIGN(SIGN(DATALENGTH(MIDDLE_NAME)-1) + COALESCE(SIGN(ASCII(MIDDLE_NAME)-32), 0)))) 
                                        + SUBSTRING(LAST_NAME, 1, DATALENGTH(LAST_NAME) * ABS(SIGN(SIGN(DATALENGTH(LAST_NAME)-1) + COALESCE(SIGN(ASCII(LAST_NAME)-32), 0)))) 
                                        + SUBSTRING(', ', 1, 2 * ABS(SIGN(SIGN(DATALENGTH(LTRIM(RTRIM(SUFFIX))))))) 
                                        + SUBSTRING(SUFFIX, 1, DATALENGTH(SUFFIX) * ABS(SIGN(SIGN(DATALENGTH(LTRIM(RTRIM(SUFFIX))))))) 
                                        + SUBSTRING(', ', 1 ,2 * ABS(SIGN(SIGN(DATALENGTH(LTRIM(RTRIM(DESIGNATION))))))) 
                                        + SUBSTRING(DESIGNATION, 1, DATALENGTH(DESIGNATION) * ABS(SIGN(SIGN(DATALENGTH(DESIGNATION)-1) + COALESCE(SIGN(ASCII(DESIGNATION)-32), 0))))
                                        ),'')

                IF @@ROWCOUNT = 0 
                    SET @isDone = 1
                COMMIT TRANSACTION
            END
        SET ROWCOUNT 0
    END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_UpdateLastFirst]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_UpdateLastFirst]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[sp_asi_UpdateLastFirst]
AS 
    BEGIN

        SET NOCOUNT ON

        SET ROWCOUNT 1000
        DECLARE @isDone BIT
        SET @isDone = 0
        WHILE ( @isDone = 0 ) 
            BEGIN
                BEGIN TRANSACTION
                UPDATE  Name
                SET     LAST_FIRST = dbo.fn_asi_GetLastFirst(LAST_NAME,
                                                             FIRST_NAME)
                WHERE   LAST_FIRST <> dbo.fn_asi_GetLastFirst(LAST_NAME,
                                                              FIRST_NAME)
                IF @@ROWCOUNT = 0 
                    SET @isDone = 1
                COMMIT TRANSACTION
            END
        SET ROWCOUNT 0
    END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_UpdateTransSoftCredit]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_UpdateTransSoftCredit]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure sp_asi_UpdateTransSoftCredit
 as
 set nocount on
 declare
 @TransNumber int,
 @BtId varchar(10),
 @StId varchar(10),
 @Amount money,
 @TotalAmount money,
 @DistAmount money,
 @ActivitySeqn int,
 @Percent float,
 @TotalPercent float,
 @count int,
 @ProductCode varchar(31),
 @InvRefNum int,
 @JournalType varchar(5)
 create table #SplitGiftRows (
 TransNumber int,
 StId varchar(10),
 Amount money,
 ActivitySeqn int,
 ProductCode varchar(31)
 )
 select @Percent=100
 declare Get_Trans cursor for 
 select TRANS_NUMBER,max(BT_ID),max(ST_ID),-max(AMOUNT),-sum(AMOUNT),max(ACTIVITY_SEQN),max(PRODUCT_CODE),
 max(INVOICE_REFERENCE_NUM),max(JOURNAL_TYPE)
 from Trans where TRANSACTION_TYPE='DIST' and SOURCE_SYSTEM='FR' and BT_ID<>ST_ID
 group by TRANS_NUMBER
 open Get_Trans
 fetch next from Get_Trans into @TransNumber,@BtId,@StId,@Amount,@TotalAmount,@ActivitySeqn,@ProductCode,@InvRefNum,@JournalType
 WHILE @@FETCH_STATUS = 0
 BEGIN
 if @TotalAmount=@Amount
 BEGIN
 if @JournalType in ('CM','DM')
 BEGIN
 select @ActivitySeqn=max(ACTIVITY_SEQN) from Trans
 join Invoice on REFERENCE_NUM=@InvRefNum
 where TRANS_NUMBER=ORIGINATING_TRANS_NUM
 and TRANSACTION_TYPE='DIST' and PRODUCT_CODE=@ProductCode
 group by ACTIVITY_SEQN
 END
 begin transaction
 insert into Trans_SoftCredit(TRANS_NUMBER,SOFT_CREDIT_ID,PERCENTAGE,AMOUNT,ORIGINATING_ACTIVITY_SEQN,PRODUCT_CODE)
 values(@TransNumber,@StId,@Percent,@Amount,@ActivitySeqn,@ProductCode)
 update Trans set ST_ID=@BtId where TRANS_NUMBER=@TransNumber
 commit transaction
 END
 ELSE
 BEGIN
 truncate table #SplitGiftRows
 insert into #SplitGiftRows(TransNumber,StId,Amount,ActivitySeqn,ProductCode)
 select max(ORIGINATING_TRANS_NUM),max(OTHER_ID),sum(AMOUNT),max(SEQN),max(PRODUCT_CODE) from Activity
 where ORIGINATING_TRANS_NUM=@TransNumber
 group by ORIGINATING_TRANS_NUM,PRODUCT_CODE
 declare Get_Dist cursor for 
 select TransNumber,StId,Amount,ActivitySeqn,ProductCode from #SplitGiftRows
 open Get_Dist
 fetch next from Get_Dist into @TransNumber,@StId,@DistAmount,@ActivitySeqn,@ProductCode
 WHILE @@FETCH_STATUS = 0
 BEGIN
 if @DistAmount<>0
 BEGIN
 select @ActivitySeqn=max(ACTIVITY_SEQN) from Trans
 join Invoice on REFERENCE_NUM=@InvRefNum
 where TRANS_NUMBER=ORIGINATING_TRANS_NUM
 and TRANSACTION_TYPE='DIST' and PRODUCT_CODE=@ProductCode
 group by ACTIVITY_SEQN
 END
 insert into Trans_SoftCredit(TRANS_NUMBER,SOFT_CREDIT_ID,PERCENTAGE,AMOUNT,ORIGINATING_ACTIVITY_SEQN,PRODUCT_CODE)
 values(@TransNumber,@StId,@Percent,@DistAmount,@ActivitySeqn,@ProductCode)
 fetch next from Get_Dist into @TransNumber,@StId,@DistAmount,@ActivitySeqn,@ProductCode
 END
 close Get_Dist
 deallocate Get_Dist
 update Trans set ST_ID=@BtId where TRANS_NUMBER=@TransNumber
 END
 fetch next from Get_Trans into @TransNumber,@BtId,@StId,@Amount,@TotalAmount,@ActivitySeqn,@ProductCode,@InvRefNum,@JournalType
 END
 close Get_Trans
 deallocate Get_Trans

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_user_name]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_user_name]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE sp_asi_user_name AS 
		select (convert (varchar(64), user_name ()))

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SqlQueryNotificationStoredProcedure-7534e94f-df01-4d37-bb94-37583783cc8b]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[SqlQueryNotificationStoredProcedure-7534e94f-df01-4d37-bb94-37583783cc8b]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [SqlQueryNotificationStoredProcedure-7534e94f-df01-4d37-bb94-37583783cc8b] AS BEGIN BEGIN TRANSACTION; RECEIVE TOP(0) conversation_handle FROM [SqlQueryNotificationService-7534e94f-df01-4d37-bb94-37583783cc8b]; IF (SELECT COUNT(*) FROM [SqlQueryNotificationService-7534e94f-df01-4d37-bb94-37583783cc8b] WHERE message_type_name = 'http://schemas.microsoft.com/SQL/ServiceBroker/DialogTimer') > 0 BEGIN if ((SELECT COUNT(*) FROM sys.services WHERE name = 'SqlQueryNotificationService-7534e94f-df01-4d37-bb94-37583783cc8b') > 0)   DROP SERVICE [SqlQueryNotificationService-7534e94f-df01-4d37-bb94-37583783cc8b]; if (OBJECT_ID('SqlQueryNotificationService-7534e94f-df01-4d37-bb94-37583783cc8b', 'SQ') IS NOT NULL)   DROP QUEUE [SqlQueryNotificationService-7534e94f-df01-4d37-bb94-37583783cc8b]; DROP PROCEDURE [SqlQueryNotificationStoredProcedure-7534e94f-df01-4d37-bb94-37583783cc8b]; END COMMIT TRANSACTION; END
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[temp_GetBusinessItem]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[temp_GetBusinessItem]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[temp_GetBusinessItem] 
	@tablename varchar(256), 
	@namespace varchar(256) = null, 
	@baseclass varchar(256) = 'BusinessItem' AS
BEGIN
SET NOCOUNT ON

IF @namespace IS NOT NULL
BEGIN
SELECT
'
using System;
using Asi;
using Asi.Business;
using System.Data;
using Asi.Business.Common;

namespace Asi.Business.' + @namespace + '
{
	public class ' + @tablename + ' : ' + @baseclass + '
	{
		#region Constructors
		/// <summary>
		/// Initializes a new instance of <see cref="' + @tablename + '"/> from a <see cref="DataRowBuilder"/>.
		/// </summary>
		/// <param name="builder">A <see cref="DataRowBuilder"/> object. </param>
		public ' + @tablename + '(DataRowBuilder builder):base(builder){}
		#endregion Constructors

		#region Properties'
END

SELECT
'
		/// <summary>
		/// 
		/// </summary>
		/// <value></value>
		public ' +
CASE c.name
   WHEN 'bigint' THEN 'int'
   WHEN 'binary' THEN 'bool'
   WHEN 'bit' THEN 'bool'
   WHEN 'char' THEN 'string'
   WHEN 'datetime' THEN 'DateTime'
   WHEN 'decimal' THEN 'decimal'
   WHEN 'float' THEN 'decimal'
   WHEN 'image' THEN 'byte[]'
   WHEN 'int' THEN 'int'
   WHEN 'money' THEN 'decimal'
   WHEN 'nchar' THEN 'string'
   WHEN 'ntext' THEN 'string'
   WHEN 'numeric' THEN 'decimal'
   WHEN 'nvarchar' THEN 'string'
   WHEN 'real' THEN 'decimal'
   WHEN 'smalldatetime' THEN 'DateTime'
   WHEN 'smallint' THEN 'int'
   WHEN 'smallmoney' THEN 'decimal'
   WHEN 'text' THEN 'string'
   WHEN 'timestamp' THEN 'DateTime'
   WHEN 'tinyint' THEN 'int'
   WHEN 'uniqueidentifier' THEN 'Guid'
   WHEN 'varbinary' THEN 'byte[]'
   WHEN 'varchar' THEN 'string'
   ELSE c.name
END
+ ' ' + b.name + '
		{
			get
			{
				return Get' + 
CASE c.name
   WHEN 'bigint' THEN 'Int'
   WHEN 'binary' THEN 'Bool'
   WHEN 'bit' THEN 'Bool'
   WHEN 'char' THEN 'String'
   WHEN 'datetime' THEN 'DateTime'
   WHEN 'decimal' THEN 'Decimal'
   WHEN 'float' THEN 'Decimal'
   WHEN 'image' THEN 'byte[]'
   WHEN 'int' THEN 'Int'
   WHEN 'money' THEN 'Decimal'
   WHEN 'nchar' THEN 'String'
   WHEN 'ntext' THEN 'String'
   WHEN 'numeric' THEN 'Decimal'
   WHEN 'nvarchar' THEN 'String'
   WHEN 'real' THEN 'Decimal'
   WHEN 'smalldatetime' THEN 'DateTime'
   WHEN 'smallint' THEN 'Int'
   WHEN 'smallmoney' THEN 'Decimal'
   WHEN 'text' THEN 'String'
   WHEN 'timestamp' THEN 'DateTime'
   WHEN 'tinyint' THEN 'Int'
   WHEN 'uniqueidentifier' THEN 'Guid'
   WHEN 'varbinary' THEN 'byte[]'
   WHEN 'varchar' THEN 'String'
   ELSE c.name
END
+ '("' + b.name + '");
			}
			set
			{
				this["' + b.name + '"] = value;
			}
		}
'
  FROM sysobjects a, syscolumns b, systypes c
 WHERE a.xtype = 'U'
   AND a.name = @tablename
   AND a.id = b.id
   AND b.xtype = c.xtype
   AND b.xusertype = c.xusertype
   AND b.name NOT IN ('UpdatedByUserKey', 'CreatedByUserKey')
 ORDER BY b.name

SELECT
'
		public User ' + LEFT(b.name,13) + '
		{
			get
			{
				return UserController.User(' + b.name + ', this.BusinessContainer);
			}
		}
'
  FROM sysobjects a, syscolumns b
 WHERE a.xtype = 'U'
   AND a.name = @tablename
   AND a.id = b.id
   AND b.name IN ('UpdatedByUserKey', 'CreatedByUserKey')
 ORDER BY b.name

IF @namespace IS NOT NULL
BEGIN
	DECLARE @KeyCol varchar(256), @KeyType varchar(256), @pname varchar(256), @params varchar(1000), @assign varchar(1000)

	DECLARE GetKeys CURSOR FOR
	SELECT d.name, 
		CASE f.name
		   WHEN 'bigint' THEN 'int'
		   WHEN 'binary' THEN 'bool'
		   WHEN 'bit' THEN 'bool'
		   WHEN 'char' THEN 'string'
		   WHEN 'datetime' THEN 'DateTime'
		   WHEN 'decimal' THEN 'decimal'
		   WHEN 'float' THEN 'decimal'
		   WHEN 'image' THEN 'byte[]'
		   WHEN 'int' THEN 'int'
		   WHEN 'money' THEN 'decimal'
		   WHEN 'nchar' THEN 'string'
		   WHEN 'ntext' THEN 'string'
		   WHEN 'numeric' THEN 'decimal'
		   WHEN 'nvarchar' THEN 'string'
		   WHEN 'real' THEN 'decimal'
		   WHEN 'smalldatetime' THEN 'DateTime'
		   WHEN 'smallint' THEN 'int'
		   WHEN 'smallmoney' THEN 'decimal'
		   WHEN 'text' THEN 'string'
		   WHEN 'timestamp' THEN 'DateTime'
		   WHEN 'tinyint' THEN 'int'
		   WHEN 'uniqueidentifier' THEN 'Guid'
		   WHEN 'varbinary' THEN 'byte[]'
		   WHEN 'varchar' THEN 'string'
		   ELSE f.name
		END
	  FROM sysobjects a, sysindexes b, sysobjects c, syscolumns d, sysindexkeys e, systypes f
	 WHERE a.id = b.id
	   AND a.id = c.parent_obj
	   AND c.name = b.name
	   AND b.indid = e.indid
	   AND d.colid = e.colid
	   AND a.id = d.id
	   AND a.id = e.id
	   AND a.name = @tablename
	   AND c.xtype='PK'
	   AND d.xtype = f.xtype
	   AND d.xusertype = f.xusertype
	
	OPEN GetKeys
	
	FETCH NEXT FROM GetKeys INTO @KeyCol, @KeyType
	SET @params = ''
	SET @assign = ''
	
	WHILE @@FETCH_STATUS = 0
	BEGIN
		set @pname = LOWER(SUBSTRING(@KeyCol,1,1)) + SUBSTRING(@KeyCol,2,LEN(@KeyCol))
		SET @params = @params + @KeyType + ' ' + @pname + ', '
		SET @assign = @assign + '			this["' + @KeyCol + '"] = ' + @pname + ';
'
		
		FETCH NEXT FROM GetKeys INTO @KeyCol, @KeyType
	END
	
	CLOSE GetKeys
	
	DEALLOCATE GetKeys

SELECT
'
		#endregion Properties

		#region Methods
		protected internal void InitializeNew(' + SUBSTRING(@params,1,LEN(@params) - 1) + ')
		{
			base.InitializeNew();
' + @assign + '		}
		#endregion Methods
		
		#region StaticProperties
		#endregion StaticProperties

		#region Static Members
		#endregion Static Members
	}
}
'
END

SET NOCOUNT ON

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[temp_GetProperties]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[temp_GetProperties]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[temp_GetProperties] 
	@tablename varchar(256), 
	@namespace varchar(256) = null, 
	@inherits varchar(256) = null AS
BEGIN
SET NOCOUNT ON

IF @namespace IS NOT NULL
BEGIN
SELECT
'
using System;
using Asi;
using Asi.Business;
using System.Data;
using Asi.Business.Common;

namespace Asi.Business.' + @namespace + '
{
	public class ' + @tablename + ' : ' + @inherits + '
	{
		#region Constructors
		/// <summary>
		/// Initializes a new instance of <see cref="' + @tablename + '"/> from a <see cref="DataRowBuilder"/>.
		/// </summary>
		/// <param name="builder">A <see cref="DataRowBuilder"/> object. </param>
		public ' + @tablename + '(DataRowBuilder builder):base(builder){}
		#endregion Constructors

		#region Properties'
END

SELECT
'
		/// <summary>
		/// 
		/// </summary>
		/// <value></value>
		public ' +
CASE c.name
   WHEN 'bigint' THEN 'int'
   WHEN 'binary' THEN 'bool'
   WHEN 'bit' THEN 'bool'
   WHEN 'char' THEN 'string'
   WHEN 'datetime' THEN 'DateTime'
   WHEN 'decimal' THEN 'decimal'
   WHEN 'float' THEN 'decimal'
   WHEN 'image' THEN 'byte[]'
   WHEN 'int' THEN 'int'
   WHEN 'money' THEN 'decimal'
   WHEN 'nchar' THEN 'string'
   WHEN 'ntext' THEN 'string'
   WHEN 'numeric' THEN 'decimal'
   WHEN 'nvarchar' THEN 'string'
   WHEN 'real' THEN 'decimal'
   WHEN 'smalldatetime' THEN 'DateTime'
   WHEN 'smallint' THEN 'int'
   WHEN 'smallmoney' THEN 'decimal'
   WHEN 'text' THEN 'string'
   WHEN 'timestamp' THEN 'DateTime'
   WHEN 'tinyint' THEN 'int'
   WHEN 'uniqueidentifier' THEN 'Guid'
   WHEN 'varbinary' THEN 'byte[]'
   WHEN 'varchar' THEN 'string'
   ELSE c.name
END
+ ' ' + b.name + '
		{
			get
			{
				return Get' + 
CASE c.name
   WHEN 'bigint' THEN 'Int'
   WHEN 'binary' THEN 'Bool'
   WHEN 'bit' THEN 'Bool'
   WHEN 'char' THEN 'String'
   WHEN 'datetime' THEN 'DateTime'
   WHEN 'decimal' THEN 'Decimal'
   WHEN 'float' THEN 'Decimal'
   WHEN 'image' THEN 'byte[]'
   WHEN 'int' THEN 'Int'
   WHEN 'money' THEN 'Decimal'
   WHEN 'nchar' THEN 'String'
   WHEN 'ntext' THEN 'String'
   WHEN 'numeric' THEN 'Decimal'
   WHEN 'nvarchar' THEN 'String'
   WHEN 'real' THEN 'Decimal'
   WHEN 'smalldatetime' THEN 'DateTime'
   WHEN 'smallint' THEN 'Int'
   WHEN 'smallmoney' THEN 'Decimal'
   WHEN 'text' THEN 'String'
   WHEN 'timestamp' THEN 'DateTime'
   WHEN 'tinyint' THEN 'Int'
   WHEN 'uniqueidentifier' THEN 'Guid'
   WHEN 'varbinary' THEN 'byte[]'
   WHEN 'varchar' THEN 'String'
   ELSE c.name
END
+ '("' + b.name + '");
			}
			set
			{
				this["' + b.name + '"] = value;
			}
		}
'
  FROM sysobjects a, syscolumns b, systypes c
 WHERE a.xtype = 'U'
   AND a.name = @tablename
   AND a.id = b.id
   AND b.xtype = c.xtype
   AND b.xusertype = c.xusertype
   AND b.name NOT IN ('UpdatedByUserKey', 'CreatedByUserKey')
 ORDER BY b.name

SELECT
'
		public User ' + LEFT(b.name,13) + '
		{
			get
			{
				return UserController.User(' + b.name + ', this.BusinessContainer);
			}
		}
'
  FROM sysobjects a, syscolumns b
 WHERE a.xtype = 'U'
   AND a.name = @tablename
   AND a.id = b.id
   AND b.name IN ('UpdatedByUserKey', 'CreatedByUserKey')
 ORDER BY b.name

IF @namespace IS NOT NULL
BEGIN
	DECLARE @KeyCol varchar(256), @KeyType varchar(256), @pname varchar(256), @params varchar(1000), @assign varchar(1000)

	DECLARE GetKeys CURSOR FOR
	SELECT d.name, 
		CASE f.name
		   WHEN 'bigint' THEN 'int'
		   WHEN 'binary' THEN 'bool'
		   WHEN 'bit' THEN 'bool'
		   WHEN 'char' THEN 'string'
		   WHEN 'datetime' THEN 'DateTime'
		   WHEN 'decimal' THEN 'decimal'
		   WHEN 'float' THEN 'decimal'
		   WHEN 'image' THEN 'byte[]'
		   WHEN 'int' THEN 'int'
		   WHEN 'money' THEN 'decimal'
		   WHEN 'nchar' THEN 'string'
		   WHEN 'ntext' THEN 'string'
		   WHEN 'numeric' THEN 'decimal'
		   WHEN 'nvarchar' THEN 'string'
		   WHEN 'real' THEN 'decimal'
		   WHEN 'smalldatetime' THEN 'DateTime'
		   WHEN 'smallint' THEN 'int'
		   WHEN 'smallmoney' THEN 'decimal'
		   WHEN 'text' THEN 'string'
		   WHEN 'timestamp' THEN 'DateTime'
		   WHEN 'tinyint' THEN 'int'
		   WHEN 'uniqueidentifier' THEN 'Guid'
		   WHEN 'varbinary' THEN 'byte[]'
		   WHEN 'varchar' THEN 'string'
		   ELSE f.name
		END
	  FROM sysobjects a, sysindexes b, sysobjects c, syscolumns d, sysindexkeys e, systypes f
	 WHERE a.id = b.id
	   AND a.id = c.parent_obj
	   AND c.name = b.name
	   AND b.indid = e.indid
	   AND d.colid = e.colid
	   AND a.id = d.id
	   AND a.id = e.id
	   AND a.name = 'GroupMemberDetail'
	   AND c.xtype='PK'
	   AND d.xtype = f.xtype
	   AND d.xusertype = f.xusertype
	
	OPEN GetKeys
	
	FETCH NEXT FROM GetKeys INTO @KeyCol, @KeyType
	SET @params = ''
	SET @assign = ''
	
	WHILE @@FETCH_STATUS = 0
	BEGIN
		set @pname = LOWER(SUBSTRING(@KeyCol,1,1)) + SUBSTRING(@KeyCol,2,LEN(@KeyCol))
		SET @params = @params + @KeyType + ' ' + @pname + ', '
		SET @assign = @assign + '			this["' + @KeyCol + '"] = ' + @pname + ';
'
		
		FETCH NEXT FROM GetKeys INTO @KeyCol, @KeyType
	END
	
	CLOSE GetKeys
	
	DEALLOCATE GetKeys

SELECT
'
		#endregion Properties

		#region Methods
		protected internal void InitializeNew(' + SUBSTRING(@params,1,LEN(@params) - 1) + ')
		{
			base.InitializeNew();
' + @assign + '		}
		#endregion Methods
		
		#region StaticProperties
		#endregion StaticProperties

		#region Static Members
		#endregion Static Members
	}
}
'
END

SET NOCOUNT ON

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[TempDeleteSystemConfigVar]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[TempDeleteSystemConfigVar]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE TempDeleteSystemConfigVar 
		@ParameterName nvarchar(255)
AS
BEGIN
	DECLARE 
		@PropertyDefinitionKey uniqueidentifier

	SELECT @PropertyDefinitionKey = PropertyDefinitionKey
	  FROM SystemConfigParameterRef
	 WHERE ParameterName = @ParameterName

	DELETE FROM SystemConfig WHERE ParameterName = @ParameterName

	DELETE FROM SystemConfigPageParameterRef WHERE ParameterName = @ParameterName

	DELETE FROM SystemConfigParameterRef WHERE ParameterName = @ParameterName

	DELETE FROM PropertyDefinition WHERE PropertyDefinitionKey = @PropertyDefinitionKey
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[TempUpdateSysConfig]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[TempUpdateSysConfig]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[TempUpdateSysConfig] @ParameterName nvarchar(255), @ParameterDescription nvarchar(500), @SortOrder int, @FieldLength int = 0 AS
BEGIN
	UPDATE SystemConfigParameterRef SET Description = @ParameterDescription WHERE ParameterName = @ParameterName
	UPDATE SystemConfigPageParameterRef SET SortOrder = @SortOrder WHERE ParameterName = @ParameterName

	IF @FieldLength > 0
		UPDATE a
		   SET HIControlWidth = @FieldLength
		  FROM PropertyDefinition a inner join SystemConfigParameterRef b on a.PropertyDefinitionKey = b.PropertyDefinitionKey
		 WHERE b.ParameterName = @ParameterName
END

GO

