
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMChangeStatus]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMChangeStatus]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure changes the status of a content record
-- 
-- Modifications
-- 07/14/2003   E.Tatsui
-- =============================================

CREATE   PROCEDURE amsp_CMChangeStatus
  @InContentID numeric,
  @InNewWorkflowStatusCode char(1),
  @InContactID numeric
AS

BEGIN

  DECLARE
    @CurrentWorkflowStatus char(1),
    @CurrentContactID numeric

  SELECT @CurrentWorkflowStatus = WorkflowStatusCode,
         @CurrentContactID = ContactID
    FROM Content WITH (NOLOCK)
   WHERE ContentID = @InContentID
  -- Update only if it's changing.
  IF @CurrentWorkflowStatus != @InNewWorkflowStatusCode 
     OR IsNull(@CurrentContactID,0) != @InContactID BEGIN
  
    UPDATE Content
       SET WorkflowStatusCode = @InNewWorkflowStatusCode,
           ContactID = @InContactID
     WHERE ContentID = @InContentID
  
    INSERT INTO Content_Workflow_Log (ContentID,
                                      WorkflowStatusCode,
                                      ContactID,
                                      ChangeDateTime)
    VALUES (@InContentID,
            @InNewWorkflowStatusCode,
            @InContactID,
            CURRENT_TIMESTAMP)
  END
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_GetTableColumnList]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_GetTableColumnList]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- This procedure takes a table name and returns a string containing a comma delimited
-- list of column names from the table.  If the optional parameter InIncludeKeys is set
-- to Y, it will include the key columns in the list, by default, it will not. Also, by
-- specifying columns names to skip, the user can remove columns that would otherwise
-- have appeared in the list
--
-- Parameters:
--   IN - InTableName - the name fo the table for which the column list is desired
--   OUT - OutColumnList - the list of columns, comma delimited
--   IN - InIncludeKeys - Optional, Y (yes) or N (no) to include key columns in the list
--   IN - SkipColumnName1-5 - Optional, allows the user to specify up to 5 columns to 
--        leave out of the list.
--
-- Copyright 2005 Advanced Solutions Intl., All Rights Reserved

CREATE  PROCEDURE amsp_GetTableColumnList 
    @InTableName sysname,
    @OutColumnList nvarchar(4000) OUTPUT,
    @InIncludeKeys char(1) = 'N',
    @SkipColumnName1 sysname = '',
    @SkipColumnName2 sysname = '',
    @SkipColumnName3 sysname = '',
    @SkipColumnName4 sysname = '',
    @SkipColumnName5 sysname = '' AS
  DECLARE GetColumns CURSOR LOCAL READ_ONLY FOR
  SELECT b.name, (
         SELECT 1
           FROM sysindexes c, sysindexkeys d
          WHERE b.id = c.id 
            AND c.id = d.id
            AND c.status & 2048 = 2048
            AND c.indid = d.indid
            AND b.colid = d.colid) AS PK
    FROM sysobjects a, syscolumns b 
   WHERE a.id = b.id
     AND a.name = @InTableName
   ORDER BY b.colorder
  BEGIN
    DECLARE
    @ColumnName sysname,
    @ColumnStatus int
    
    SET @OutColumnList = ''
    OPEN GetColumns
     
    FETCH NEXT FROM GetColumns
     INTO @ColumnName, @ColumnStatus
    
    WHILE @@FETCH_STATUS = 0
    	BEGIN
        IF (@ColumnStatus IS NULL OR @ColumnStatus <> 1 OR 
           (@ColumnStatus = 1 AND @InIncludeKeys = 'Y')) AND
           @ColumnName NOT IN (@SkipColumnName1, @SkipColumnName2, @SkipColumnName3, @SkipColumnName4, @SkipColumnName5) 
          SET @OutColumnList = @OutColumnList + @ColumnName + ','
  
        FETCH NEXT FROM GetColumns
         INTO @ColumnName, @ColumnStatus
      END
      
    CLOSE GetColumns
    DEALLOCATE GetColumns
    
    SET @OutColumnList = Left(@OutColumnList,Len(@OutColumnList) - 1)
  END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMCopyContentRow]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMCopyContentRow]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This sp creates a new content record based on the content record passed in
-- 
-- Modifications
-- 09/08/2003    E.Tatsui    Created
-- =============================================

CREATE        PROCEDURE [dbo].[amsp_CMCopyContentRow]
  @InContentID numeric,
  @InContactID numeric,
  @OutContentID numeric OUTPUT
AS
BEGIN
  DECLARE
    @ColumnList nvarchar(4000),
    @InsertQuery nvarchar(4000)
  
  CREATE TABLE #SkipColumn (SkipColumnName varchar(255))
  
  -- Copy the content row 
  EXECUTE amsp_GetTableColumnList 'Content', @ColumnList OUTPUT, 'N', 'WorkflowStatusCode', 'PreviousContentID', 'PublishDateTime', 'ContactID'
  SET @InsertQuery = 'INSERT INTO Content (' + @ColumnList + ',WorkflowStatusCode, PreviousContentID, ContactID) SELECT ' + @ColumnList + ',''W'',' + CAST(@InContentID AS varchar) + ',' + CAST(@InContactID AS varchar)+  ' FROM Content WHERE ContentID = ' + CAST(@InContentID AS varchar)
  EXECUTE sp_executesql @InsertQuery
  SET @OutContentID = @@Identity
  
  -- Copy any Content_HTML rows
  EXECUTE amsp_GetTableColumnList 'Content_HTML', @ColumnList OUTPUT
  SET @InsertQuery = 'INSERT INTO Content_HTML (' + @ColumnList + ',ContentID) SELECT ' + @ColumnList + ',' + CAST(@OutContentID AS varchar) + ' FROM Content_HTML WHERE ContentID = ' + CAST(@InContentID AS varchar)
  EXECUTE sp_executesql @InsertQuery

  -- Copy any Content_Link rows
  EXECUTE amsp_GetTableColumnList 'Content_Link', @ColumnList OUTPUT, 'N', 'ContentID', 'PreviousContentLinkID'
  SET @InsertQuery = 'INSERT INTO Content_Link (' + @ColumnList + ',ContentID, PreviousContentLinkID) SELECT ' + @ColumnList + ',' + CAST(@OutContentID AS varchar) + ',CAST(ContentLinkID AS varchar)' + ' FROM Content_Link WHERE ContentID = ' + CAST(@InContentID AS varchar)
  EXECUTE sp_executesql @InsertQuery

  -- OK, Now if any of the Content_Link rows were specifying the old Content ID, let's fix them.
  UPDATE Content_Link
     SET LinkURL = Replace(LinkURL, 'ContentID=' + Convert(varchar(10), @InContentID), 'ContentID=' + Convert(varchar(10), @OutContentID))
   WHERE ContentID = @OutContentID

  -- Copy any Content_File rows
  EXECUTE amsp_GetTableColumnList 'Content_File', @ColumnList OUTPUT, 'N', 'ContentID','PreviousContentFileID'
  SET @InsertQuery = 'INSERT INTO Content_File (' + @ColumnList + ',ContentID,PreviousContentFileID) SELECT ' + @ColumnList + ',' + CAST(@OutContentID AS varchar) + ',CAST(ContentFileID AS varchar) FROM Content_File WHERE ContentID = ' + CAST(@InContentID AS varchar)
  EXECUTE sp_executesql @InsertQuery

  -- Copy any Tagged_Page_Interest_Category rows
  EXECUTE amsp_GetTableColumnList 'Tagged_Page_Interest_Category', @ColumnList OUTPUT, 'Y', 'ContentID'
  SET @InsertQuery = 'INSERT INTO Tagged_Page_Interest_Category (' + @ColumnList + ',ContentID) SELECT ' + @ColumnList + ',' + CAST(@OutContentID AS varchar) + ' FROM Tagged_Page_Interest_Category WHERE ContentID = ' + CAST(@InContentID AS varchar)
  EXECUTE sp_executesql @InsertQuery
  
  -- Copy any Component_Interest_Category rows
  EXECUTE amsp_GetTableColumnList 'Component_Interest_Category', @ColumnList OUTPUT,'Y','ComponentID'
  SET @InsertQuery = 'INSERT INTO Component_Interest_Category (' + @ColumnList + ',ComponentID) SELECT ' + @ColumnList + ',' + CAST(@OutContentID AS varchar) + ' FROM Component_Interest_Category WHERE ComponentCode = ''CM'' AND ComponentID = ' + CAST(@InContentID AS varchar)
  EXECUTE sp_executesql @InsertQuery

  -- Copy any Content_Security_Group rows
  EXECUTE amsp_GetTableColumnList 'Content_Security_Group', @ColumnList OUTPUT,'Y','ContentID'
  SET @InsertQuery = 'INSERT INTO Content_Security_Group (' + @ColumnList + ',ContentID) SELECT ' + @ColumnList + ',' + CAST(@OutContentID AS varchar) + ' FROM Content_Security_Group WHERE ContentID = ' + CAST(@InContentID AS varchar)
  EXECUTE sp_executesql @InsertQuery

  EXECUTE amsp_GetTableColumnList 'Content_Change_Request', @ColumnList OUTPUT,'N','ContentID'
  SET @InsertQuery = 'INSERT INTO Content_Change_Request (' + @ColumnList + ',ContentID) SELECT ' + @ColumnList + ',' + CAST(@OutContentID AS varchar) + ' FROM Content_Change_Request WHERE RequestStatusCode = ''A'' AND ContentID = ' + CAST(@InContentID AS varchar)
  EXECUTE sp_executesql @InsertQuery 

  -- Copy any Content_Publish_Server rows (Not used for this version of CM)
  --EXECUTE amsp_GetTableColumnList 'Content_Publish_Server', @ColumnList OUTPUT,'Y','ContentID'
  --SET @InsertQuery = 'INSERT INTO Content_Publish_Server (' + @ColumnList + ',ContentID) SELECT ' + @ColumnList + ',' + CAST(@OutContentID AS varchar) + ' FROM Content_Publish_Server WHERE ContentID = ' + CAST(@InContentID AS varchar)
  --EXECUTE sp_executesql @InsertQuery
  -- Create the Content_Workflow_Log entry
  INSERT INTO Content_Workflow_Log (ContentID, WorkflowStatusCode, ContactID, ChangeDateTime)
  VALUES (@OutContentID,'W',@InContactID, CURRENT_TIMESTAMP)
END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetUniqueContentName]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetUniqueContentName]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure cares a unique URLSafe name (Content.URLSafeName field)
-- for a specified Content record. 
--
-- Modifications
-- 08/22/2003   E.Tatsui
-- =============================================

CREATE          PROCEDURE amsp_CMGetUniqueContentName
  @InContentID numeric = NULL,
  @InContentName varchar(255) = NULL,
  @InNavMenuID numeric,
  @OutURLSafeName varchar(255) OUTPUT
AS
BEGIN

  IF @InContentID IS NULL AND @InContentName IS NULL BEGIN
    RAISERROR('Either ContentID or Title is required as input parameter',16,1)
    RETURN
  END

  DECLARE
    @Name varchar(255),
    @URLSafeName varchar(255),
    @RowNum integer,
    @Counter integer,
    @DefaultContentTitleLength numeric

  IF @InContentName IS NOT NULL
    SET @Name = @InContentName
  ELSE 
    SELECT @Name = Name
      FROM Content
     WHERE ContentID = @InContentID

  SELECT @DefaultContentTitleLength = CAST(Value as numeric)
    FROM System_Variable
   WHERE Name = 'CMDefaultContentTitleLength'

  -- Remove special characters that shouldn't be used in URL.
  SET @URLSafeName = REPLACE(@Name, ' ', '_')
  SET @URLSafeName = REPLACE(@URLSafeName, '.', '_')
  SET @URLSafeName = REPLACE(@URLSafeName, '?', '_')
  SET @URLSafeName = REPLACE(@URLSafeName, '\', '_')
  SET @URLSafeName = REPLACE(@URLSafeName, '/', '_')
  SET @URLSafeName = REPLACE(@URLSafeName, '*', '_')
  SET @URLSafeName = REPLACE(@URLSafeName, ':', '_')
  SET @URLSafeName = REPLACE(@URLSafeName, '|', '_')
  SET @URLSafeName = REPLACE(@URLSafeName, '<', '_')
  SET @URLSafeName = REPLACE(@URLSafeName, '&', '_')
  SET @URLSafeName = REPLACE(@URLSafeName, '''', '_')
  SET @URLSafeName = REPLACE(@URLSafeName, '#', '_')
  SET @URLSafeName = REPLACE(@URLSafeName, '>', '_')
  SET @URLSafeName = REPLACE(@URLSafeName, '>', '_')
  SET @URLSafeName = REPLACE(@URLSafeName, '>', '_')
  SET @URLSafeName = REPLACE(@URLSafeName, '@', '_')

  -- Multiple underscores looks so untidy.
  WHILE CHARINDEX('__', @URLSafeName) > 0 BEGIN
    SET @URLSafeName = REPLACE(@URLSafeName, '__','_')
  END
  
  SET @URLSafeName = Left(@URLSafeName,@DefaultContentTitleLength -1)

  -- It needs to be unique.
  SELECT @RowNum = COUNT(*)
    FROM Content
   WHERE UPPER(URLSafeName) = UPPER(@URLSafeName)
     AND NavMenuID = @InNavMenuID

  -- If we find a record with the same directory name, let's append a number at the end.    
  SET @Counter = 0
  WHILE @RowNum > 0 BEGIN
    SET @Counter = @Counter + 1
    SELECT @RowNum = COUNT(*)
      FROM Content
     WHERE UPPER(URLSafeName) = UPPER(@URLSafeName) + Cast(@Counter as varchar(255))
       AND NavMenuID = @InNavMenuID
  END    
  
  IF @Counter > 0
    SET @URLSafeName = @URLSafeName + Cast(@Counter as varchar(255))

  SET @OutURLSafeName = @URLSafeName
END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMCopyContentAsNew]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMCopyContentAsNew]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This procedure takes an original ContentID and ALTER  a copy of it with same attributes.
--
-- Modifications
-- 08/12/2003    E.Tatsui   Created
-- =============================================

CREATE           PROCEDURE [dbo].[amsp_CMCopyContentAsNew]
	@InOriginalContentID numeric,
  @InContactID numeric,
  @InTargetNavMenuID numeric = NULL,
  @OutNewContentID numeric OUTPUT
AS

BEGIN

  DECLARE
    @NavMenuID numeric,
    @OrigURLSafeName varchar(255),
    @URLSafeName varchar(255),
    @Counter smallint

  SELECT @OrigURLSafeName = URLSafeName,
         @NavMenuID = NavMenuID
    FROM Content WITH (NOLOCK)
   WHERE ContentID = @InOriginalContentID

  -- If there is a specific target to copy the content to, use the NavMenuID.
  IF @InTargetNavMenuID IS NOT NULL
    SET @NavMenuID = @InTargetNavMenuID

  EXEC amsp_CMCopyContentRow @InOriginalContentID, @InContactID, @OutNewContentID OUTPUT

  --Make a unique URLSafeName
  EXEC amsp_CMGetUniqueContentName NULL, @OrigURLSafeName, @NavMenuID, @URLSafeName OUTPUT

  -- amsp_CMCopyContentRow creates a Content record as a new version of the existing one,
  -- update fields to make this a new branch.
  UPDATE Content
     SET URLSafeName = @URLSafeName,
         OriginalContentID = NULL,
         PreviousContentID = NULL,
         ExpirationDate = NULL,
         PostFuseURL = NULL,
         PreFuseURL = NULL,
         PublishLocation = NULL,
         ReminderSentDateTime = NULL,
         PublicationDate = NULL,
         SortOrder = (SELECT IsNull(Max(SortOrder),0) + 1
                        FROM Content
                       WHERE NavMenuID = @NavMenuID)
   WHERE ContentID = @OutNewContentID
  
  DELETE FROM Content_Change_Request WHERE ContentID =  @OutNewContentID
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetUniqueSectionName]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetUniqueSectionName]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure cares a unique section name (Nav_Menu.Name field)
-- for a specified Nav_Menu record. 
--
-- Modifications
-- 08/22/2003   E.Tatsui
-- =============================================

CREATE      PROCEDURE amsp_CMGetUniqueSectionName
	@InNavMenuID numeric = NULL,
  @InTitle varchar(255) = NULL,
  @OutSectionName varchar(255) OUTPUT
AS
BEGIN

  IF @InNavMenuID IS NULL AND @InTitle IS NULL BEGIN
    RAISERROR('Either NavMenuID or Title is required as input parameter',16,1)
    RETURN
  END

  DECLARE
    @Title varchar(255),
    @Name varchar(255),
    @RowNum integer,
    @Counter integer

  IF @InTitle IS NOT NULL
    SET @Title = @InTitle
  ELSE 
    SELECT @Title = Title
      FROM Nav_Menu
     WHERE NavMenuID = @InNavMenuID

  -- Remove special characters that shouldn't be used in URL.
  SET @Name = REPLACE(@Title, ' ', '_')
  SET @Name = REPLACE(@Name, '.', '_')
  SET @Name = REPLACE(@Name, '?', '_')
  SET @Name = REPLACE(@Name, '\', '_')
  SET @Name = REPLACE(@Name, '/', '_')
  SET @Name = REPLACE(@Name, '*', '_')
  SET @Name = REPLACE(@Name, ':', '_')
  SET @Name = REPLACE(@Name, '|', '_')
  SET @Name = REPLACE(@Name, '<', '_')
  SET @Name = REPLACE(@Name, '&', '_')
  SET @Name = REPLACE(@Name, '''', '_')
  SET @Name = REPLACE(@Name, '#', '_')
  SET @Name = REPLACE(@Name, '>', '_')
  SET @Name = REPLACE(@Name, '>', '_')
  SET @Name = REPLACE(@Name, '>', '_')

  -- Multiple underscores looks so untidy.
  WHILE CHARINDEX('__', @Name) > 0 BEGIN
    SET @Name = REPLACE(@Name, '__','_')
  END
  
  SET @Name = Left(@Name,100)

  -- It needs to be unique.
  SELECT @RowNum = COUNT(*)
    FROM Nav_Menu
   WHERE UPPER(Name) = UPPER(@Name)

  -- If we find a record with the same directory name, let's append a number at the end.    
  SET @Counter = 0
  WHILE @RowNum > 0 BEGIN
    SET @Counter = @Counter + 1
    SELECT @RowNum = COUNT(*)
      FROM Nav_Menu
     WHERE UPPER(Name) = UPPER(@Name) + Cast(@Counter as varchar(255))
  END    
  
  IF @Counter > 0
    SET @Name = @Name + Cast(@Counter as varchar(255))

  SET @OutSectionName = @Name
END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMUpdateNavProperties]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMUpdateNavProperties]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure figures out some of the calculated values stored in Nav_Menu table 
-- for performance improvement.
--
-- Modifications
-- 10/10/2003   E.Tatsui
-- =============================================

CREATE           PROCEDURE amsp_CMUpdateNavProperties
	@InNavMenuID numeric
AS
BEGIN
  DECLARE
    @AncestoryList varchar(255),
    @FilePath varchar(255),
    @DescendantCount numeric,
    @SortOrder numeric(28,18),
    @CategoryDepth numeric,
    @ParentNavMenuID numeric,
    @Name varchar(255),
    @WebsiteKey uniqueidentifier,
    @CurrentAncestoryList varchar(255),
    @CurrentFilePath varchar(255),
    @CurrentDescendantCount numeric,
    @NavMenuID numeric,
    @CurrentParentNavMenuID numeric,
    @AncestorNavMenuID numeric,
    @NavContentGroupInd char(1)
 
  SELECT @SortOrder = SortOrder,
         @CategoryDepth = CategoryDepth,
         @Name = IsNull(DirectoryName,Name),
         @ParentNavMenuID = ParentNavMenuID,
         @WebsiteKey = WebsiteKey,
         @CurrentAncestoryList = IsNull(AncestoryList,''),
         @CurrentFilePath = IsNull(FilePath,''),
         @CurrentDescendantCount = DescendantCount,
         @AncestorNavMenuID = AncestorNavMenuID,
         @NavContentGroupInd = NavContentGroupInd
    FROM Nav_Menu WITH (NOLOCK)
   WHERE NavMenuID = @InNavMenuID

  SET @CurrentParentNavMenuID = @ParentNavMenuID

  -- First get descendant count.
  IF @NavContentGroupInd = 'N'
    SELECT @DescendantCount = Count(*)
      FROM Nav_Menu z
      WITH (NOLOCK)
    WHERE z.WebsiteKey = @WebsiteKey
      AND z.SortOrder > @SortOrder
      AND z.WorkflowStatusCode <> 'D'
      AND z.NavContentGroupInd = 'N'
      AND z.SortOrder <
         (SELECT IsNull(Min(x.SortOrder),999999999)
            FROM Nav_Menu x
             WITH (NOLOCK)
           WHERE x.SortOrder > @SortOrder
             AND x.CategoryDepth <= @CategoryDepth
             AND x.WebsiteKey = @WebsiteKey
             AND z.NavContentGroupInd = 'N')
  ELSE
    SELECT @DescendantCount = Count(*)
      FROM Nav_Menu z
      WITH (NOLOCK)
    WHERE z.NavContentGroupInd = 'C'
      AND z.WorkflowStatusCode <> 'D'
      AND z.SortOrder > @SortOrder
      AND z.SortOrder <
         (SELECT IsNull(Min(x.SortOrder),999999999)
            FROM Nav_Menu x
             WITH (NOLOCK)
           WHERE x.SortOrder > @SortOrder
             AND x.CategoryDepth <= @CategoryDepth
             AND x.NavContentGroupInd = 'C')

  -- Next, get file path and ancestory list.
  SET @FilePath = @Name + '/'
  SET @AncestoryList = ''
  WHILE @ParentNavMenuID IS NOT NULL BEGIN
    SET @AncestoryList = '''' + convert(varchar(10), @ParentNavMenuID) + ''',' + @AncestoryList

    SELECT @Name = IsNull(DirectoryName,Name),
           @ParentNavMenuID = ParentNavMenuID
      FROM Nav_Menu WITH (NOLOCK)
     WHERE NavMenuID = @ParentNavMenuID

    IF @@RowCount > 0
      SET @FilePath = @Name + '/' + @FilePath
    ELSE
      BREAK  
  END -- End while loop

  -- Strip out the last ","
  IF Len(@AncestoryList) > 0
    SET @AncestoryList = LEFT(@AncestoryList, Len(@AncestoryList) - 1)

  IF @CurrentAncestoryList <> @AncestoryList
     OR @CurrentFilePath <> @FilePath
     OR @CurrentDescendantCount <> @DescendantCount BEGIN
    UPDATE Nav_Menu
       SET FilePath = @FilePath,
           AncestoryList = NULLIF(@AncestoryList,''),
           DescendantCount = @DescendantCount
     WHERE NavMenuID = @InNavMenuID
  END

  IF @CurrentFilePath <> @FilePath BEGIN
    -- Replace filepath for all the children.
    UPDATE Nav_Menu
       SET FilePath = @FilePath + SUBSTRING(FilePath,LEN(@CurrentFilePath)+1, LEN(FilePath)- LEN(@CurrentFilePath))
     WHERE AncestorNavMenuID = @AncestorNavMenuID
       AND NavMenuID <> @InNavMenuID
       AND CHARINDEX(@CurrentFilePath, FilePath) = 1
  END

  -- If ancestory list or descendant count changes, the item's parents should
  -- be updated also.
  IF @CurrentParentNavMenuID IS NOT NULL
     AND (@CurrentAncestoryList <> @AncestoryList 
          OR @CurrentDescendantCount <> @DescendantCount) BEGIN
    EXEC amsp_CMUpdateNavProperties @CurrentParentNavMenuID
  END
END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMCopyNavMenu]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMCopyNavMenu]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure ALTER  another copy of a specified Nav_Menu record 
-- and all of its descendants.
-- In addition, it copies associated Tagged Pages.
--
-- Modifications
-- 08/22/2003      E.Tatsui    Created
-- =============================================

CREATE      PROCEDURE amsp_CMCopyNavMenu
	@InOriginalNavMenuID numeric,
  @InContactID numeric,
  @OutNewNavMenuID numeric OUTPUT
AS
BEGIN

  DECLARE
    @Title varchar(255),
    @SectionName varchar(255),
    @NewNavMenuID numeric,
    @ContentID numeric,
    @NavMenuID numeric,
    @Error integer,
    @BelowSortOrder numeric(28,18),
    @LowestSortOrder numeric(28,18),
    @SortIncrement numeric(28,18),
    @SortOrder numeric(28,18),
    @CategoryDepth integer,
    @AncestorNavMenuID numeric,
    @ParentNavMenuID numeric,
    @RowNum integer
  
  CREATE TABLE #NavMenu
               (NavMenuID numeric,
                SortOrder numeric(28,18),
                NewNavMenuID numeric)
  
  -- We want to figure out which Nav_Menu records need to be copied first.
  -- Loop through all the children and put them in a temp table.
  INSERT INTO #NavMenu
  SELECT NavMenuID, SortOrder, NULL
    FROM Nav_Menu WITH (NOLOCK) 
   WHERE NavMenuID = @InOriginalNavMenuID

  WHILE @@RowCount > 0 BEGIN
    INSERT INTO #NavMenu
    SELECT NavMenuID, SortOrder, NULL
      FROM Nav_Menu WITH (NOLOCK) 
     WHERE ParentNavMenuID IN (SELECT NavMenuID
                                 FROM #NavMenu)
       AND NavMenuID NOT IN (SELECT NavMenuID
                                 FROM #NavMenu)                                
  END

  -- Get all the Nav_Menu records we need to copy:
  DECLARE c_NavMenuToCopy CURSOR FOR 
  SELECT a.NavMenuID,
         b.Title,
         b.CategoryDepth,
         b.AncestorNavMenuID,
         b.ParentNavMenuID
    FROM #NavMenu a, Nav_Menu b WITH (NOLOCK)
   WHERE a.NavMenuID = b.NavMenuID
   ORDER BY b.SortOrder

  SELECT @LowestSortOrder = Max(SortOrder)
    FROM #NavMenu

  SELECT @BelowSortOrder = Min(SortOrder)
    FROM Nav_Menu WITH (NOLOCK)
   WHERE SortOrder > @LowestSortOrder
     AND NavContentGroupInd = (SELECT NavContentGroupInd FROM Nav_Menu WHERE NavMenuID = @InOriginalNavMenuID)

  SELECT @RowNum = COUNT(*)
    FROM #NavMenu

  IF @BelowSortOrder IS NULL
    SET @BelowSortOrder = @LowestSortOrder + @RowNum

  -- Figure out starting sort order and increment.
  SET @SortIncrement = (@BelowSortOrder - @LowestSortOrder) / (@RowNum + 1)
  SET @SortOrder = @LowestSortOrder

  OPEN c_NavMenuToCopy
  FETCH NEXT FROM  c_NavMenuToCopy
        INTO @NavMenuID,
             @Title,
             @CategoryDepth,
             @AncestorNavMenuID,
             @ParentNavMenuID

  WHILE @@FETCH_STATUS = 0 BEGIN

    -- For the first row, add "Copy of" to the title
    IF @NewNavMenuID IS NULL
      SET @Title = 'Copy of ' + @Title

    SET @Title = Left(@Title,255)
    
    EXEC amsp_CMGetUniqueSectionName NULL, @Title, @SectionName OUTPUT

    SET @SortOrder = @SortOrder + @SortIncrement

    -- If the parent is also copied previously, use the new ParentNavMenuID
    IF @ParentNavMenuID IS NOT NULL
      SELECT @ParentNavMenuID = NewNavMenuID
        FROM #NavMenu
       WHERE NavMenuID = @ParentNavMenuID

    -- If the ancestor is also copied previously, use the new ParentNavMenuID
    IF @AncestorNavMenuID IS NOT NULL
      SELECT @AncestorNavMenuID = NewNavMenuID
        FROM #NavMenu
       WHERE NavMenuID = @AncestorNavMenuID

    -- We'd create a record at the end as the 1st level, 
    -- and move it to appropriate position later.
    INSERT INTO Nav_Menu
                (WorkflowStatusCode,
                 HideFlag,
                 NavContentGroupInd,
                 Name,
                 Title,
                 ParentNavMenuID,
                 AncestorNavMenuID,
                 CategoryDepth, 
                 SortOrder,
                 DirectListComboInd,
                 ContentAuthorityGroupID,
                 AuthoritySetManuallyFlag,
                 OwnerContactID,
                 OwnerSetManuallyFlag,
                 ExpirationDays,
                 LastUpdatedByContactID,
                 WebsiteKey,
                 ShowInTopFlag,
                 ShowInSideFlag,
                 MicrositeFlag)
    SELECT 'W',
           HideFlag,
           NavContentGroupInd,
           @SectionName,
           @Title,
           @ParentNavMenuID,
           @AncestorNavMenuID,
           CategoryDepth,
           @SortOrder,
           DirectListComboInd,
           ContentAuthorityGroupID,
           AuthoritySetManuallyFlag,
           OwnerContactID,
           OwnerSetManuallyFlag,
           ExpirationDays,
           @InContactID,
           WebsiteKey,
           ShowInTopFlag,
           ShowInSideFlag,
           MicrositeFlag
      FROM Nav_Menu WITH (NOLOCK)
     WHERE NavMenuID = @NavMenuID

    SELECT @Error = @@Error

    IF @Error <> 0 BEGIN
      RETURN
    END
             
    SET @NewNavMenuID = @@Identity

    -- Save the new NavMenuID
    UPDATE #NavMenu
       SET NewNavMenuID = @NewNavMenuID
     WHERE NavMenuID = @NavMenuID

    -- We want to return the 1st NavMenuID.
    IF @OutNewNavMenuID IS NULL
      SET @OutNewNavMenuID = @NewNavMenuID

    -- If we didn't specify AncestorID on insertion, set it now.
    IF @AncestorNavMenuID IS NULL
      UPDATE Nav_Menu
         SET AncestorNavMenuID = @NewNavMenuID
       WHERE NavMenuID = @NewNavMenuID
    
    INSERT INTO Nav_Menu_Workflow_Log
                (NavMenuID,
                 WorkflowStatusCode,
                 ContactID,
                 ChangeDateTime)
     VALUES (@NewNavMenuID,
             'W',
             @InContactID,
             CURRENT_TIMESTAMP) 

    -- Copy BreadCrumb
    INSERT INTO Nav_Menu_Feature
                (NavMenuID,
                 BreadCrumb)
    SELECT @NewNavMenuID,
           @Title
      FROM Nav_Menu_Feature
     WHERE NavMenuID = @InOriginalNavMenuID

    -- Figure out FilePath, DescendantCount and AncestoryList
    EXEC amsp_CMUpdateNavProperties @NewNavMenuID 

    /* Comment this out until we actually need it 
    -- Copy all the tagged page associated with the original Nav_Menu record
    DECLARE c_CopyContent CURSOR FOR
     SELECT a.ContentID
       FROM  vCurrent_Content a, Content_Link b
      WHERE a.ContentID = b.ContentID
        AND a.NavMenuID = @InOriginalNavMenuID
        AND b.TaggedPageLayoutID IS NOT NULL
        AND a.WorkflowStatusCode IN ('A','P','W','E')
  
    OPEN c_CopyContent
    FETCH NEXT FROM c_CopyContent
     INTO @ContentID  
    
    WHILE @@FETCH_STATUS = 0 BEGIN
      EXEC amsp_CMCopyContentAsNew @ContentID, @InContactID, @NewNavMenuID, NULL
  
      FETCH NEXT FROM c_CopyContent
       INTO @ContentID  
    END
  
    SELECT @Error = @@Error
    IF @Error <> 0 BEGIN
      RETURN
    END
  
    CLOSE c_CopyContent
    DEALLOCATE c_CopyContent
    -- Ends copying all the tagged page.

    */

    FETCH NEXT FROM  c_NavMenuToCopy
          INTO @NavMenuID,
               @Title,
               @CategoryDepth,
               @AncestorNavMenuID,
               @ParentNavMenuID
  END -- Ends looping through Nav_Menu records to copy.

  CLOSE c_NavMenuToCopy
  DEALLOCATE c_NavMenuToCopy

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMRenumCurrentContent]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMRenumCurrentContent]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure updates SortOrder for current content records
-- that is contained in a specified nav menu or content folder.
--
-- Modifications
-- 09/11/2003    E.Tatsui     Created
-- 05/03/2004    E.Tatsui     Removed lines to reset WorkflowStatusCode to W and PublishedDateTime to NULL
--                            for Nav_Menu because it was causing a problem for amsp_CMDeleteContent.
--                            Reset logic seemed to be redundant anyway.
-- =============================================

CREATE  PROCEDURE [dbo].[amsp_CMRenumCurrentContent]
  @InNavMenuID numeric
AS
BEGIN
  DECLARE
    @Counter int,
    @ContentID numeric,
    @SortOrder numeric

  DECLARE c_Contents CURSOR FOR
   SELECT ContentID,
          SortOrder
     FROM vCurrent_Content
    WHERE NavMenuID = @InNavMenuID
    ORDER BY SortOrder

  SET @Counter = 0

  OPEN c_Contents
  FETCH NEXT FROM c_Contents
   INTO @ContentID,
        @SortOrder

  WHILE @@FETCH_STATUS = 0 BEGIN
    SET @Counter = @Counter + 1

    IF @Counter <> @SortOrder BEGIN
      UPDATE Content
         SET SortOrder = @Counter
       WHERE ContentID = @ContentID
      -- If this item is changing to 1st Content, make it a default content.
      -- Also mark the navigation item as "Working" and reset publish date, so that red flag
      -- will show up to notify the administrator to re-publish.
      IF @Counter = 1
        UPDATE Nav_Menu
           SET ContentID = @ContentID,
         WorkflowStatusCode = 'W',
         PublishedDateTime = NULL,
         ComponentCode = 'CM', 
         ComponentScriptCode = 'SC' 
         WHERE NavMenuID = @InNavMenuID
    END

    FETCH NEXT FROM c_Contents
     INTO @ContentID,
          @SortOrder
  END
  CLOSE c_Contents
  DEALLOCATE c_Contents

END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetFuseURL]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetFuseURL]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =======================================================================
-- This stored procedure gets PreFuseURL and PostFuseURL for ContentID
-- or NavMenuID
--
-- Modifications
-- 06/03/2003  E.Tatsui   Created
-- 10/15/2003  E.Tatsui   Added NavContentDisplayPath and FolderContentDisplayPath and used them.
-- =======================================================================

CREATE	PROCEDURE [dbo].[amsp_CMGetFuseURL]
  @InNavMenuID numeric = NULL,
  @InContentID numeric = NULL,
  @OutPreFuseURL varchar(255) OUTPUT,
  @OutPostFuseURL varchar(255) OUTPUT,
  @InPreviewFlag bit = 0
AS
BEGIN
  DECLARE
    @NavContentGroupInd   char(1),
    @CategoryDepth numeric,
    @ContentSecureFlag    char(1),
    @ContentMembersOnlyFlag   char(1),
    @MembersOnlyFlag char(1),
    @ShowInTemplateFlag   char(1),
    @TemplatePath   varchar(255),
    @ContentCount   integer,
    @LinkCount      integer,
    @FileCount      integer,
    @LinkURL      varchar(255),
    @NavMenuID  numeric,
    @Name     varchar(255),
    @PublishLocation    varchar(255),
    @FileSourceLocation   varchar(255),
    @DirectListComboInd   char(1),
    @HTMLContentID    numeric,
    @ContentID      numeric,
    @l_PreFuseURL   varchar(255),
    @l_PostFuseURL    varchar(255),
    @PreFuseURL     varchar(255),
    @PostFuseURL    varchar(255),
    @URLParamChar   char(1),
    @ContentDisplayPath varchar(255),
    @NavContentDisplayPath varchar(255),
    @FolderContentDisplayPath varchar(255),
    @URLSafeName varchar(255),
    @FilePath varchar(255),
    @FileName varchar(255),
    @DestDirectory varchar(255),
    @DefaultFileName varchar(255),
    @DefaultContentID numeric,
    @PreviousContentID numeric,
    @GenerateDefaultFlag char(1),
    @GECodePath varchar(255),
    @VirtualDirectoryPath varchar(255),
    @UseAspNetTemplateFlag char(1),
  @UrlVars varchar(1000),
    @MissingIncludeURL varchar(255)
  
  SELECT @NavMenuID = a.NavMenuID,
         @CategoryDepth = a.CategoryDepth,
         @NavContentGroupInd = a.NavContentGroupInd,
         @DirectListComboInd = a.DirectListComboInd,
         @MembersOnlyFlag = a.MembersOnlyFlag,
         @Name = a.Name,
         @TemplatePath = IsNull(a.TemplatePath,''),
         @FilePath = a.FilePath,
         @NavContentDisplayPath = b.NavContentDisplayPath,
         @FolderContentDisplayPath = b.FolderContentDisplayPath,
         @DefaultFileName = b.DefaultFileName,
         @DefaultContentID = a.ContentID,
         @UseAspNetTemplateFlag = b.UseAspNetTemplateFlag
    FROM Nav_Menu a WITH (NOLOCK), Website b WITH (NOLOCK)
   WHERE NavMenuID = @InNavMenuID
     AND a.WebsiteKey = b.WebsiteKey

  SET @GenerateDefaultFlag = 'N'
  SET @UrlVars = ''

  IF @NavContentGroupInd = 'N'
    SET @ContentDisplayPath = IsNull(@NavContentDisplayPath,'')
  ELSE
    SET @ContentDisplayPath = IsNull(@FolderContentDisplayPath,'')

  SELECT @GECodePath = Value
    FROM System_Variable
   WHERE Name = 'GECodePath'

  SELECT @VirtualDirectoryPath = Value
    FROM System_Variable
   WHERE Name = 'VirtualDirectoryPath'

  IF Len(@GECodePath) > 1
    SET @GECodePath = RIGHT(@GECodePath,Len(@GECodePath)-1)
  ELSE IF @GECodePath = '/'
    SET @GECodePath = ''

  IF Len(@VirtualDirectoryPath) > 1
    SET @VirtualDirectoryPath = RIGHT(@VirtualDirectoryPath,Len(@VirtualDirectoryPath)-1)
  ELSE IF @VirtualDirectoryPath = '/'
    SET @VirtualDirectoryPath = ''

  -- We are running this for a specific ContentID
  IF @InContentID IS NOT NULL BEGIN
    SET @ContentCount = 1
    SELECT @ShowInTemplateFlag = c.ShowInTemplateFlag,
           @PublishLocation = c.PublishLocation,
           @ContentMembersOnlyFlag = c.MembersOnlyFlag,
           @ContentSecureFlag = c.SecureFlag,
           @LinkURL = (SELECT TOP 1 LinkURL
                         FROM Content_Link z WITH (NOLOCK)
                        WHERE z.ContentID = c.ContentID),
        @FileName = (SELECT TOP 1 FileName
                                     FROM Content_File z WITH (NOLOCK)
                                    WHERE z.ContentID = c.ContentID),
           @HTMLContentID = ch.ContentID,
           @LinkCount = (SELECT Count(*) FROM Content_Link WITH (NOLOCK) WHERE ContentID = c.ContentID),
           @FileCount = (SELECT Count(*) FROM Content_File WITH (NOLOCK) WHERE ContentID = c.ContentID),
           @ContentID = c.ContentID,
           @URLSafeName = c.URLSafeName,
           @PreviousContentID = c.PreviousContentID
    FROM Content c WITH (NOLOCK) LEFT OUTER JOIN Content_HTML ch WITH (NOLOCK) 

      ON c.ContentID = ch.ContentID
   WHERE c.ContentID = @InContentID

   IF @NavContentGroupInd = 'N'
      AND (@DefaultContentID = @InContentID OR @PreviousContentID = @DefaultContentID)
     SET @GenerateDefaultFlag = 'Y'

  END
  -- We're running this for already published menu item.
  ELSE BEGIN
    SET @GenerateDefaultFlag = 'Y'
    
    IF @InPreviewFlag = 0
      SELECT @ContentCount = Count(*)
        FROM Content c WITH (NOLOCK)
       WHERE NavMenuID = @InNavMenuID
         AND c.WorkflowStatusCode = 'P'
         AND c.PublishDateTime <= CURRENT_TIMESTAMP 
         AND (c.ExpirationDate >= CURRENT_TIMESTAMP
               OR c.ArchiveAtExpirationFlag IS NULL 
               OR c.ArchiveAtExpirationFlag = 'N')
    ELSE
      SELECT @ContentCount = Count(*)
        FROM vCurrent_Content c WITH (NOLOCK)
       WHERE NavMenuID = @InNavMenuID

    -- Get the default content.
    SELECT @ShowInTemplateFlag = c.ShowInTemplateFlag,
           @PublishLocation = c.PublishLocation,
           @ContentMembersOnlyFlag = c.MembersOnlyFlag,
           @ContentSecureFlag = c.SecureFlag,
           @LinkURL = (SELECT TOP 1 LinkURL
                         FROM Content_Link z
                        WHERE z.ContentID = c.ContentID),
           @FileName = (SELECT TOP 1 FileName
                                     FROM Content_File z
                                    WHERE z.ContentID = c.ContentID),
           @HTMLContentID = ch.ContentID,
           @LinkCount = (SELECT Count(*) FROM Content_Link WITH (NOLOCK) WHERE ContentID = c.ContentID),
           @FileCount = (SELECT Count(*) FROM Content_File WITH (NOLOCK) WHERE ContentID = c.ContentID),
           @ContentID = c.ContentID,
           @URLSafeName = c.URLSafeName
      FROM Content c WITH (NOLOCK) LEFT OUTER JOIN Content_HTML ch WITH (NOLOCK)
        ON c.ContentID = ch.ContentID, Nav_Menu nm WITH (NOLOCK)
     WHERE c.NavMenuID = @InNavMenuID
       AND nm.ContentID = c.ContentID
  END
  
  IF (@NavContentGroupInd = 'N') BEGIN
  IF @UseAspNetTemplateFlag = 'N' BEGIN
    IF @ShowInTemplateFlag = 'Y' OR @ShowInTemplateFlag IS NULL
      SET @l_PreFuseURL = @GECodePath + 'Template.cfm'
    ELSE
      SET @l_PreFuseURL = @GECodePath + 'AMTemplate.cfm'

    SET @l_PreFuseURL = @l_PreFuseURL + '?Section=' + @Name + '&Template='
    SET @URLParamChar = '&'
    END 
  ELSE BEGIN
    SET @UrlVars = @UrlVars + 'Section=' + @Name
    IF @ShowInTemplateFlag = 'Y' OR @ShowInTemplateFlag IS NULL
      SET @l_PreFuseURL = @GECodePath + 'ContentManagerNet/'
    ELSE BEGIN
      SET @l_PreFuseURL = @GECodePath + 'ContentManagerNet/'
      SET @UrlVars = @UrlVars + '&NoTemplate=1'
    END
    SET @URLParamChar = '?'
  END
  SET @DestDirectory = @ContentDisplayPath + @FilePath
  END
  ELSE BEGIN -- Content Folder
    IF (@UseAspNetTemplateFlag = 'N')BEGIN
    SET @l_PreFuseURL = @GECodePath + 'TemplateRedirect.cfm' + '?Template='
    SET @URLParamChar = '&'
  END
    
  ELSE BEGIN -- ASP.NET TEmplate
    SET @l_PreFuseURL = @GECodePath + 'ContentManagerNet/TemplateRedirect.aspx?Template=/ContentManagerNet/'
    SET @URLParamChar = '&'
  END
  SET @DestDirectory =  @ContentDisplayPath + @FilePath
  END

  IF (@InContentID IS NOT NULL)
  SET @DirectListComboInd = 'D'

  /* Prepare Missing Include URL */
  IF @UseAspNetTemplateFlag = 'N'
  SET @MissingIncludeURL = @l_PreFuseURL + '/MissingInclude.htm'
  ELSE
    SET @MissingIncludeURL = @l_PreFuseURL + 'MissingInclude.aspx' + CASE WHEN Len(@UrlVars) > 0 THEN '?' + @UrlVars ELSE '' END

  /*
  ** A nav menu item will either have no, 1, or multiple content records associated with it.
  */

  /* No content to point to. */

  IF (@ContentCount = 0)
    BEGIN
    SET @l_PreFuseURL = @MissingIncludeURL
      SET @l_PostFuseURL = @l_PreFuseURL
    END

  /*
  ** If the default content record or nav menu record is flagged Members Only, 
  ** Pre- and PostFuseURL will go through MembersOnly.cfm.
  */

  ELSE IF ( (@ContentCount = 1 OR @ContentCount > 1) AND 
             (@MembersOnlyFlag = 'Y' OR @ContentMembersOnlyFlag = 'Y') )
  BEGIN
    /* If content is set to display outside template, use AMTemplate.cfm */
  IF(@UseAspNetTemplateFlag = 'N') BEGIN
    IF (@ShowInTemplateFlag = 'N')
    BEGIN
      SET @l_PreFuseURL = @GECodePath + 'AMTemplate.cfm?Section=' + @Name + '&Template=' + '/MembersOnly.cfm&' + 'NavMenuID=' + convert(varchar(10), @NavMenuID) + '&ContentID=' + convert(varchar(10), @ContentID) + '&DirectListComboInd=' + @DirectListComboInd
      SET @l_PostFuseURL = @l_PreFuseURL
    END
    ELSE IF (@ShowInTemplateFlag = 'Y')
    BEGIN -- Not show inside the template.
      SET @l_PreFuseURL = @l_PreFuseURL + '/MembersOnly.cfm' + @URLParamChar + 'NavMenuID=' + convert(varchar(10), @NavMenuID) + '&ContentID=' + convert(varchar(10), @ContentID) + '&DirectListComboInd=' + @DirectListComboInd
      SET @l_PostFuseURL = @l_PreFuseURL
    END
  END
  ELSE BEGIN -- ASP.NET Template
    IF (@ShowInTemplateFlag = 'N')
    BEGIN
      SET @l_PreFuseURL = @GECodePath + 'ContentManagerNet/MembersOnly.aspx?NavMenuID=' + convert(varchar(10), @NavMenuID) + '&ContentID=' + convert(varchar(10), @ContentID) + '&DirectListComboInd=' + @DirectListComboInd + CASE WHEN Len(@UrlVars) > 0 THEN '&' + @UrlVars ELSE '' END
      SET @l_PostFuseURL = @l_PreFuseURL
    END
    ELSE IF (@ShowInTemplateFlag = 'Y')
    BEGIN -- Not show inside the template.
      SET @l_PreFuseURL = @GECodePath + 'ContentManagerNet/MembersOnly.aspx?NavMenuID=' + convert(varchar(10), @NavMenuID) + '&ContentID=' + convert(varchar(10), @ContentID) + '&DirectListComboInd=' + @DirectListComboInd + CASE WHEN Len(@UrlVars) > 0 THEN '&' + @UrlVars ELSE '' END
      SET @l_PostFuseURL = @l_PreFuseURL
    END
  END
  END

  /*
  ** One content record and multiple content records with the DirectListComboInd set to 
  ** "D" are essentially the same. In the latter case, you go directly to the page and

  ** rely on navigation within the text to point to the other content.
  */

  ELSE IF ( (@ContentCount = 1) OR (@ContentCount > 1 AND @DirectListComboInd = 'D') )
  BEGIN

    /* If content record has no related links, files, or HTML, show MissingInclude.htm. */
    IF (@LinkCount = 0 AND @FileCount = 0 AND @HTMLContentID IS NULL)
    BEGIN
      SET @l_PreFuseURL = @MissingIncludeURL
      SET @l_PostFuseURL = @l_PreFuseURL
    END

    /* Single piece of content consists of a link. */
    ELSE IF (@LinkCount = 1 AND @FileCount = 0 AND @HTMLContentID IS NULL)
    BEGIN
      SET @LinkURL = Rtrim(Ltrim(@LinkURL))
      IF (Left(@LinkURL,1) = '/')  AND (CHARINDEX('TEMPLATEREDIRECT.CFM',UPPER(@LinkURL)) =0)
      BEGIN
        IF ((CHARINDEX('SECTION=', UPPER(@LinkURL)) = 0)
			AND (CHARINDEX('.CFM', UPPER(@LinkURL)) != 0 OR CHARINDEX('.HTM', UPPER(@LinkURL)) != 0 OR CHARINDEX('.GIF', UPPER(@LinkURL)) != 0 OR CHARINDEX('.JPG', UPPER(@LinkURL)) != 0 ) 
			AND (@ShowInTemplateFlag = 'Y')) 
        BEGIN
			IF (@UseAspNetTemplateFlag = 'N')
				SET @l_PreFuseURL = @GECodePath + 'Template.cfm' + '?Section=' + @Name + '&Template=' + @LinkURL
			ELSE
				SET @l_PreFuseURL = @GECodePath + 'ContentManagerNet/Default.aspx?Section=' + @Name + '&Template=' + @LinkURL
        END
        ELSE IF ((CHARINDEX('SECTION=', UPPER(@LinkURL)) = 0) 
			AND (CHARINDEX('.CFM', UPPER(@LinkURL)) != 0 OR CHARINDEX('.GIF', UPPER(@LinkURL)) != 0 OR CHARINDEX('.JPG', UPPER(@LinkURL)) != 0 ) 
			AND (@ShowInTemplateFlag = 'N')) 
        BEGIN
			IF (@UseAspNetTemplateFlag = 'N')
				SET @l_PreFuseURL = @GECodePath + 'AMTemplate.cfm?Section=' + @Name + '&Template=' + @LinkURL
			ELSE
				SET @l_PreFuseURL = @GECodePath + 'ContentManagerNet/Default.aspx?Section=' + @Name + '&NoTemplate=1&Template=' + @LinkURL
        END 
		ELSE IF ((CHARINDEX('.ASPX', UPPER(@LinkURL)) != 0))BEGIN
			IF (@UseAspNetTemplateFlag = 'N')
				SET @l_PreFuseURL = @l_PreFuseURL + '/CM/ContentDisplay.cfm' + @URLParamChar + 'ContentID=' + convert(varchar(10), @ContentID)
			ELSE 
				SET @l_PreFuseURL = @l_PreFuseURL + 'ContentDisplay.aspx' + @URLParamChar + 'ContentID=' + convert(varchar(10), @ContentID) + CASE WHEN Len(@UrlVars) > 0 THEN '&' + @UrlVars ELSE '' END
		END
        ELSE BEGIN
           SET @l_PreFuseURL = @LinkURL
        END
      END

      ELSE BEGIN
        IF (Upper(Left(@LinkURL, 4)) = 'HTTP') OR ((CHARINDEX('TEMPLATEREDIRECT.CFM',UPPER(@LinkURL)) != 0))
           SET @l_PreFuseURL = @LinkURL
        ELSE
           SET @l_PreFuseURL = 'http://' + @LinkURL
      END

      /* PostFuseURL will equal the PreFuseURL if content is a link. */
      SET @l_PostFuseURL = @l_PreFuseURL
    END

    /* Single piece of content consists of a file. */
    ELSE IF (@FileCount = 1 AND @LinkCount = 0 AND @HTMLContentID IS NULL)
    BEGIN
      IF (@UseAspNetTemplateFlag = 'N')
    SET @l_PreFuseURL = @l_PreFuseURL + '/CM/ContentDisplay.cfm' + @URLParamChar + 'ContentID=' + convert(varchar(10), @ContentID)
      ELSE 
    SET @l_PreFuseURL = @l_PreFuseURL + 'ContentDisplay.aspx' + @URLParamChar + 'ContentID=' + convert(varchar(10), @ContentID) + CASE WHEN Len(@UrlVars) > 0 THEN '&' + @UrlVars ELSE '' END
      IF @NavContentGroupInd = 'C'
        SET @l_PostFuseURL = @l_PreFuseURL
      --Only when we are figuring out default page for a navigation, set it to generated defaulg page.
      ELSE IF @GenerateDefaultFlag = 'Y' AND @DefaultFileName IS NOT NULL AND @InContentID IS NULL
        SET @l_PostFuseURL = @DestDirectory + @DefaultFileName
      ELSE 
        SET @l_PostFuseURL = @DestDirectory + @FileName
    END

    /* Single piece of content is an HTML record. */
    ELSE IF (@HTMLContentID IS NOT NULL AND @FileCount = 0 AND @LinkCount = 0) BEGIN
    IF(@UseAspNetTemplateFlag = 'N')
    SET @l_PreFuseURL = @l_PreFuseURL + '/CM/HTMLDisplay.cfm' + @URLParamChar + 'ContentID=' + convert(varchar(10), @HTMLContentID)
      ELSE
    SET @l_PreFuseURL = @l_PreFuseURL + 'HTMLDisplay.aspx' + @URLParamChar + 'ContentID=' + convert(varchar(10), @HTMLContentID) + CASE WHEN Len(@UrlVars) > 0 THEN '&' + @UrlVars ELSE '' END
    IF @NavContentGroupInd = 'C'
        SET @l_PostFuseURL = @l_PreFuseURL
      -- Only if we are generating default file for single piece of content (not the one for combo or list),
      -- use default name.
      ELSE IF @GenerateDefaultFlag = 'Y' AND @DefaultFileName IS NOT NULL AND @DirectListComboInd = 'D'
        SET @l_PostFuseURL = @DestDirectory + @DefaultFileName
      ELSE
        SET @l_PostFuseURL = @DestDirectory + @URLSafeName + '.htm'
    END
    
    /* Single piece of content is a mix of links, files, and/or HTML. */
    ELSE BEGIN
    IF @UseAspNetTemplateFlag = 'N'
    SET @l_PreFuseURL = @l_PreFuseURL + '/CM/ContentDisplay.cfm' + @URLParamChar + 'ContentID=' + convert(varchar(10), @ContentID)
      ELSE
    SET @l_PreFuseURL = @l_PreFuseURL + 'ContentDisplay.aspx' + @URLParamChar + 'ContentID=' + convert(varchar(10), @ContentID) + CASE WHEN Len(@UrlVars) > 0 THEN '&' + @UrlVars ELSE '' END
      IF @NavContentGroupInd = 'C'
        SET @l_PostFuseURL = @l_PreFuseURL
      ELSE IF @GenerateDefaultFlag = 'Y' AND @DefaultFileName IS NOT NULL
        SET @l_PostFuseURL = @DestDirectory + @DefaultFileName
      ELSE
        SET @l_PostFuseURL = @DestDirectory + @URLSafeName + '.htm'

    END
  END -- ENDS @DirectListComboInd = 'D'

  /* Multiple content records and DirectListComboInd set to "C". */
  ELSE IF (@ContentCount > 1 AND @DirectListComboInd = 'C')
  BEGIN
    /* If content record has no related links, files, or HTML, show MissingInclude.htm. */
    IF (@LinkCount = 0 AND @FileCount = 0 AND @HTMLContentID IS NULL)
    BEGIN
    SET @l_PreFuseURL = @MissingIncludeURL
      SET @l_PostFuseURL = @l_PreFuseURL
    END
    ELSE BEGIN
    IF @UseAspNetTemplateFlag = 'N'
    SET @l_PreFuseURL = @l_PreFuseURL + '/CM/ContentCombo.cfm' + @URLParamChar + 'NavMenuID=' + convert(varchar(10), @NavMenuID) + '&ContentID=' + convert(varchar(10), @ContentID)
    ELSE 
        SET @l_PreFuseURL = @l_PreFuseURL + 'ContentCombo.aspx' + @URLParamChar + 'NavMenuID=' + convert(varchar(10), @NavMenuID) + '&ContentID=' + convert(varchar(10), @ContentID) + (CASE WHEN Len(@UrlVars) > 0 THEN '&' + @UrlVars ELSE '' END)
      IF @NavContentGroupInd = 'C'
        SET @l_PostFuseURL = @l_PreFuseURL
      ELSE IF @GenerateDefaultFlag = 'Y' AND @DefaultFileName IS NOT NULL
        SET @l_PostFuseURL = @DestDirectory + @DefaultFileName
      ELSE
        SET @l_PostFuseURL = @DestDirectory + 'Default' + CONVERT(varchar(20),@InNavMenuID) + '.htm'
    END
  END

  /* Multiple content records and DirectListComboInd set to "L". */
  ELSE IF (@ContentCount > 1 AND @DirectListComboInd = 'L')
  BEGIN
    /* If content record has no related links, files, or HTML, show MissingInclude.htm. */
    IF (@LinkCount = 0 AND @FileCount = 0 AND @HTMLContentID IS NULL)
    BEGIN
      SET @l_PreFuseURL = @MissingIncludeURL
      SET @l_PostFuseURL = @l_PreFuseURL
    END
    ELSE BEGIN
      IF @UseAspNetTemplateFlag = 'N'
    SET @l_PreFuseURL = @l_PreFuseURL + '/CM/ContentList.cfm' + @URLParamChar + 'NavMenuID=' + convert(varchar(10), @NavMenuID)
      ELSE
        SET @l_PreFuseURL = @l_PreFuseURL + 'ContentList.aspx' + @URLParamChar + 'NavMenuID=' + convert(varchar(10), @NavMenuID) + '&' + @UrlVars
      IF @GenerateDefaultFlag = 'Y' AND @DefaultFileName IS NOT NULL
        SET @l_PostFuseURL = @DestDirectory + @DefaultFileName
      ELSE
        SET @l_PostFuseURL = @DestDirectory + 'Default' + CONVERT(varchar(20),@InNavMenuID) + '.htm'
    END
  END
  
  IF(@UseAspNetTemplateFlag = 'Y' AND CHARINDEX('templateredirect',LOWER(@l_PostFuseURL)) = 0 AND CHARINDEX('.aspx',LOWER(@l_PostFuseURL)) > 0 AND LEFT(@l_PostFuseURL,LEN(@VirtualDirectoryPath)) = @VirtualDirectoryPath)
  BEGIN
    IF (@VirtualDirectoryPath <> '')
      SET @l_PostFuseURL = @VirtualDirectoryPath + '/' + @Name + SUBSTRING(@l_PostFuseURL,LEN(@VirtualDirectoryPath) + 1, LEN(@l_PostFuseURL) - LEN(@VirtualDirectoryPath))
    ELSE
      SET @l_PostFuseURL = '/' + @Name + '/' + @l_PostFuseURL
  END
  
  IF LEFT(@l_PostFuseURL,1) = '/'
	SET @l_PostFuseURL = SUBSTRING(@l_PostFuseURL,2,Len(@l_PostFuseURL)-1)

  IF LEFT(@l_PreFuseURL,1) = '/'
	SET @l_PreFuseURL = SUBSTRING(@l_PreFuseURL,2,Len(@l_PreFuseURL)-1)

  SET @OutPreFuseURL = @l_PreFuseURL
  SET @OutPostFuseURL = @l_PostFuseURL

END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetNavMenuToRegenerate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetNavMenuToRegenerate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This procedure figures out which menu items need to be regenerated 
-- when item specified as @InNavMenuID is changed.
--
-- Modifications
-- 06/19/2003  E.Tatsui   Created
-- =============================================

CREATE                    PROCEDURE amsp_CMGetNavMenuToRegenerate
  @InNavMenuID numeric
AS
  DECLARE 
    @MinDepth numeric,
    @NavMenuID numeric,
    @PostFuseURL varchar(255)

  CREATE TABLE #Changed (NavMenuID numeric, ParentNavMenuID numeric, CategoryDepth numeric, PostFuseURL varchar(255))

  if object_id('tempdb..#Regenerate') is null
    CREATE TABLE #Regenerate (NavMenuID numeric)

  -- First put in our boy 
  INSERT INTO #Changed(NavMenuID, ParentNavMenuID, CategoryDepth)
  SELECT a.NavMenuID, a.ParentNavMenuID, a.CategoryDepth
    FROM Nav_Menu a WITH (NOLOCK)
   WHERE a.NavMenuID = @InNavMenuID
  
  -- then, let's go down from here to get all descendants
  WHILE @@RowCount > 0
    INSERT INTO #Changed(NavMenuID, ParentNavMenuID, CategoryDepth)
    SELECT b.NavMenuID, b.ParentNavMenuID, b.CategoryDepth
      FROM #Changed a, Nav_Menu b WITH (NOLOCK) LEFT OUTER JOIN #Changed c
        ON b.NavMenuID = c.NavMenuID
     WHERE a.NavMenuID = b.ParentNavMenuID
       AND c.NavMenuID IS NULL
       AND b.WorkflowStatusCode = 'P'

  -- make sure we start with @@Rowcount > 0, even if our boy had no descendants
  SELECT @MinDepth = 1

  -- and then, as long as we are getting records, let's go directly back up
  WHILE @@RowCount > 0
    INSERT INTO #Changed(NavMenuID, ParentNavMenuID, CategoryDepth)
    SELECT b.NavMenuID, b.ParentNavMenuID, b.CategoryDepth
      FROM #Changed a, Nav_Menu b WITH (NOLOCK) LEFT OUTER JOIN #Changed c
        ON b.NavMenuID = c.NavMenuID
     WHERE (b.NavMenuID = a.ParentNavMenuID OR b.ParentNavMenuID = a.ParentNavMenuID)
       AND c.NavMenuID IS NULL
       AND (b.WorkflowStatusCode = 'P' OR b.WorkflowStatusCode = 'D')

  -- now, we have a table of all of the items that could have changed. Find the highest level item
  -- (lowest depth) that changed according to the Nav_Menu_Log
  -- Note: Include WorkflowStatusCode = 'D' so that if one nav item is about to be deleted,
  -- we can regenerate items affected by the deletion.
  SELECT @MinDepth = IsNULL(Min(a.CategoryDepth), 999)
    FROM Nav_Menu a WITH (NOLOCK), #Changed b LEFT OUTER JOIN Nav_Menu_Setup_Log c WITH (NOLOCK)
      ON b.NavMenuID = c.NavMenuID
   WHERE a.NavMenuID = b.NavMenuID
     AND (a.Name != IsNull(c.Name, '') 
      OR a.Title != IsNull(c.Title, '')
      OR a.ParentNavMenuID != IsNull(c.ParentNavMenuID, 0)
      OR a.AncestorNavMenuID != IsNull(c.AncestorNavMenuID, 0)
      OR a.CategoryDepth != IsNull(c.CategoryDepth, 0)
      OR IsNULL(a.MembersOnlyFlag, '') != IsNull(c.MembersOnlyFlag, '')
      OR IsNull(a.PostFuseURL,'') != IsNull(c.PostFuseURL, '') 
      OR IsNull(a.FilePath,'') != IsNull(c.FilePath,'')
      OR a.WorkflowStatusCode = 'D')

  -- ok, so now that we have the lowest depth, we can get the parent of that guy (or
  -- that guy if he is the ultimate ancestor), then get everyone on down.
  INSERT INTO #Regenerate
  SELECT DISTINCT ISNULL(ParentNavMenuID, NavMenuID) AS NavMenuID
    FROM #Changed
   WHERE CategoryDepth = @MinDepth
     
  -- then, as long as we are getting records, let's keep going down
  WHILE @@RowCount > 0
	
  BEGIN
    INSERT INTO #Regenerate(NavMenuID)
    SELECT b.NavMenuID
      FROM #Regenerate a, Nav_Menu b WITH (NOLOCK) LEFT OUTER JOIN #Regenerate c
        ON b.NavMenuID = c.NavMenuID
           LEFT OUTER JOIN #Changed d
        ON b.NavMenuID = d.NavMenuID
     WHERE a.NavMenuID = b.ParentNavMenuID
       AND c.NavMenuID IS NULL
       AND b.WorkflowStatusCode = 'P'
  END

  BEGIN TRANSACTION

    DELETE Nav_Menu_Setup_Log
      FROM Nav_Menu_Setup_Log a, #Regenerate b
     WHERE a.NavMenuID = b.NavMenuID

    INSERT INTO Nav_Menu_Setup_Log (
           NavMenuID,
           Name,
           Title,
           ParentNavMenuID,
           AncestorNavMenuID,
           CategoryDepth,
           MembersOnlyFlag,
           PostFuseURL,
           FilePath)
    SELECT a.NavMenuID,
           a.Name,
    	     a.Title,
           a.ParentNavMenuID,
           IsNull(a.AncestorNavMenuID, a.NavMenuID),
           a.CategoryDepth,
           a.MembersOnlyFlag,
           a.PostFuseURL,
           a.FilePath
      FROM Nav_Menu a WITH (NOLOCK), #Regenerate b
     WHERE a.NavMenuID = b.NavMenuID

  COMMIT TRANSACTION

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMRequestPublish]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMRequestPublish]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure inserts a record to Publish_Request table to request content
-- to be published by publishing server.
--
-- Modificaitons
-- 06/12/2003    E.Tatsui      Created
-- =============================================

CREATE                 PROCEDURE [dbo].[amsp_CMRequestPublish]
	@InNavMenuID numeric = NULL,
  @InWebsiteKey uniqueidentifier = NULL,
  @InContactID numeric,
  @InPublishDescendants char(1) = 'N',
  @InForcePublishFlag char(1) = 'N',
  @InPublishRegenerateInd char(1) = 'P',
  @InMicrositeID numeric = 0,
  @InPublishRequestID numeric = NULL,
  @OutPublishRequestID numeric OUTPUT
AS
BEGIN

  IF @InNavMenuID IS NULL AND @InWebsiteKey IS NULL
    RAISERROR('Either NavMenuID or WebsiteKey is required', 16,1)  

  DECLARE
    @PublishRequestID numeric,
    @NavMenuID numeric,
    @WebsiteKey uniqueidentifier,
    @ContentID numeric,
    @PublishFrequency integer,
    @MinSort numeric(28,18),
    @MaxSort numeric(28,18),
    @PreFuseURL varchar(255),
    @PostFuseURL varchar(255),
    @NewPreFuseURL varchar(255),
    @NewPostFuseURL varchar(255),
    @NavContentGroupInd char(1),
    @ContentCount integer,
    @PreviousWebsiteKey uniqueidentifier,
    @SuperUserFlag bit

  -- First, find out if this user is a member of a super group as a nav creator or editor.
  SET @SuperUserFlag = 0
  SELECT @SuperUserFlag = 1
    FROM Content_Authority_Group a WITH (NOLOCK), Content_Authority_Producer b WITH (NOLOCK)
   WHERE a.ContentAuthorityGroupID = b.ContentAuthorityGroupID
     AND b.ContactID = @InContactID
     AND (b.NavCreatorFlag = 'Y' OR b.NavEditorFlag = 'Y')
     AND a.SuperGroupFlag = 'Y'

  SELECT @NavContentGroupInd = NavContentGroupInd,
         @WebsiteKey = WebsiteKey
    FROM Nav_Menu WITH (NOLOCK)
   WHERE NavMenuID = @InNavMenuID

  -- If PublishRequestID is not passed in, create a new request.
  IF @InPublishRequestID IS NULL BEGIN
    INSERT INTO Publish_Request
                (ContactID,
                 RequestDateTime,
                 NavMenuID)
    VALUES (@InContactID,
            CURRENT_TIMESTAMP,
            @InNavMenuID)
  
    SET @PublishRequestID = @@Identity
  END
  ELSE
    SET @PublishRequestID = @InPublishRequestID

  -- When this is publishing process.
  IF @InPublishRegenerateInd = 'P' BEGIN
    -- Build a temp table which holds all the nav items to publish.
    CREATE TABLE #NavMenu
                 (NavMenuID numeric,
                  SortOrder numeric(28,18),
                  ContentID numeric,
                  FilePath varchar(255),
                  WebsiteKey uniqueidentifier,
                  PreviousWebsiteKey uniqueidentifier,
                  MicrositeFlag char(1))

    -- When NavMenuID is specified.
    IF @InNavMenuID IS NOT NULL BEGIN
      -- Add the actual item that was specified.
      INSERT INTO #NavMenu
      SELECT NavMenuID,
             SortOrder,
             ContentID,
             FilePath,
             WebsiteKey,
             PreviousWebsiteKey,
             MicrositeFlag
        FROM Nav_Menu WITH (NOLOCK)
       WHERE NavMenuID = @InNavMenuID
    
      -- If decendants need to be published also, add them to the temp table.
      IF @InPublishDescendants = 'Y' BEGIN
        SELECT @MinSort = a.SortOrder,
               @MaxSort = (SELECT IsNull(Min(x.SortOrder),0)
                             FROM Nav_Menu x WITH (NOLOCK)
                             WHERE x.SortOrder > a.SortOrder
                               AND x.CategoryDepth <= a.CategoryDepth)
          FROM Nav_Menu a  WITH (NOLOCK)
         WHERE a.NavMenuID = @InNavMenuID
        -- Super user can publish anything.
        IF @SuperUserFlag = 1
          INSERT INTO #NavMenu
          SELECT a.NavMenuID,
                 a.SortOrder,
                 a.ContentID,
                 a.FilePath,
                 a.WebsiteKey,
                 a.PreviousWebsiteKey,
                 a.MicrositeFlag
            FROM Nav_Menu a WITH (NOLOCK)
           WHERE a.SortOrder > @MinSort
             AND a.SortOrder < @MaxSort
           ORDER BY a.SortOrder
        ELSE 
          -- We only care about the ones this user has permission to publish.
          INSERT INTO #NavMenu
          SELECT a.NavMenuID,
                 a.SortOrder,
                 a.ContentID,
                 a.FilePath,
                 a.WebsiteKey,
                 a.PreviousWebsiteKey,
                 a.MicrositeFlag
            FROM Nav_Menu a WITH (NOLOCK), Content_Authority_Producer b WITH (NOLOCK)
           WHERE a.ContentAuthorityGroupID = b.ContentAuthorityGroupID
             AND b.ContactID = @InContactID
             AND (b.NavCreatorFlag = 'Y' OR b.NavEditorFlag = 'Y')
             AND a.SortOrder > @MinSort
             AND a.SortOrder < @MaxSort
           ORDER BY a.SortOrder
        END   
    END -- Ends when NavMenuID is specified

    ELSE BEGIN-- When WebsiteKey is specified
      INSERT INTO #NavMenu
      SELECT NavMenuID,
             SortOrder,
             ContentID,
             FilePath,
             WebsiteKey,
             PreviousWebsiteKey,
             MicrositeFlag
        FROM Nav_Menu WITH (NOLOCK)
       WHERE WebsiteKey = @InWebsiteKey
         AND NavContentGroupInd = 'N'
      ORDER BY SortOrder
    END

    -- For alll these nav items, let's update the status.
    -- if it's not in Published status yet.
    UPDATE a
       SET WorkflowStatusCode = 'P',
           PublishedDateTime = CURRENT_TIMESTAMP,
           PublishedFlag = 'Y',
           ReminderSentDateTime = NULL,
           LastUpdatedByContactID = @InContactID
      FROM Nav_Menu a, #NavMenu b
     WHERE a.NavMenuID = b.NavMenuID
       AND a.WorkflowStatusCode <> 'P'

    INSERT INTO Nav_Menu_Workflow_Log (
           NavMenuID,
           ContactID,
           WorkflowStatusCode,
           ChangeDateTime)
    SELECT a.NavMenuID,
           @InContactID,
           'P',
           CURRENT_TIMESTAMP
      FROM #NavMenu a, Nav_Menu b WITH (NOLOCK)
     WHERE a.NavMenuID = b.NavMenuID
       AND b.WorkflowStatusCode <> 'P'

    /*  At this point we want to get the content records that are either:
        1) A content Record that is in the 'A'pproved status for a Nav Item being published, or
        2) The default content Record that is in the 'P'ublished status with no new version in 'A'pproved status
          OR if attributes.ForcePublish EQ "Yes" then all content records, not just the default.
        3) A content Record in the 'W'orking status for a MicroSite
      For each Nav Item, Sort will ensure the non-default records are published first. */
  
    DECLARE c_ContentRecords CURSOR FOR
    SELECT a.NavMenuID,
           a.WebsiteKey,
           a.PreviousWebsiteKey,
           b.ContentID,
           b.PublishFrequency,
           b.PreFuseURL,
           b.PostFuseURL
      FROM (Content b WITH (NOLOCK) LEFT OUTER JOIN Nav_Menu c WITH (NOLOCK) 
        ON b.ContentID = c.ContentID), #NavMenu a WITH (NOLOCK)
     WHERE a.NavMenuID = b.NavMenuID
       AND ( b.WorkflowStatusCode = 'A'
             OR ( b.WorkflowStatusCode = 'P'
                   AND ISNULL(a.MicrositeFlag, 'N') = 'N'
                 AND 1 = CASE WHEN @InForcePublishFlag ='N' AND c.ContentID IS NULL AND a.PreviousWebsiteKey IS NULL THEN 0
                     ELSE 1 END 
                 AND NOT EXISTS ( SELECT 1
                                    FROM Content x WITH (NOLOCK)
                                   WHERE x.PreviousContentID = b.ContentID
                                     AND x.WorkflowStatusCode = 'A' )
               )
             OR ( b.WorkflowStatusCode = 'W' AND
                 a.MicrositeFlag = 'Y'
               )
            )
     ORDER BY a.SortOrder, IsNULL(c.ContentID, 0)

  END
  -- Regenerating content that have been affected by a change.
  ELSE BEGIN
    CREATE TABLE #Regenerate (NavMenuID numeric)
  
    EXEC amsp_CMGetNavMenuToRegenerate @InNavMenuID

    /* Let's get all the content records in the 'P'ublished status.  It is important 
       to get the non-default records first so when we publish the List or Combo 
       default records, the links/titles for the non-default records will be correct. */
    DECLARE c_ContentRecords CURSOR FOR
    SELECT n.NavMenuID, 
           n.WebsiteKey,
           n.PreviousWebsiteKey,
           b.ContentID,
           b.PublishFrequency,
           b.PreFuseURL,
           b.PostFuseURL
      FROM (Content b WITH (NOLOCK) LEFT OUTER JOIN Nav_Menu c WITH (NOLOCK) 
        ON b.ContentID = c.ContentID)
      LEFT OUTER JOIN Content x WITH (NOLOCK)
        ON b.ContentID = x.PreviousContentID, Nav_Menu n WITH (NOLOCK)
     WHERE b.NavMenuID = n.NavMenuID
       AND b.WorkflowStatusCode = 'P'
       AND n.NavMenuID IN (SELECT NavMenuID FROM #Regenerate)
       AND x.ContentID IS NULL
     ORDER BY n.SortOrder, IsNULL(c.ContentID, 0)
  END


  OPEN c_ContentRecords

  FETCH NEXT FROM c_ContentRecords
   INTO @NavMenuID,
        @WebsiteKey,
        @PreviousWebsiteKey,
        @ContentID,
        @PublishFrequency,
        @PreFuseURL,
        @PostFuseURL

  WHILE @@FETCH_STATUS = 0 BEGIN

    -- Make sure PreFuseURL and PostFuseURL is up to date.
    EXEC amsp_CMGetFuseURL @NavMenuID, @ContentID, @NewPreFuseURL OUTPUT, @NewPostFuseURL OUTPUT

    IF IsNull(@NewPreFuseURL,'') <> IsNull(@PreFuseURL,'') 
       OR IsNull(@NewPostFuseURL,'') <> IsNull(@PostFuseURL,'') BEGIN
      UPDATE Content
         SET PreFuseURL = @NewPreFuseURL,
             PostFuseURL = @NewPostFuseURL
       WHERE ContentID = @ContentID
    END
    -- Publishing server for navigation items are determined by the Website.
    INSERT INTO Publish_Request_Detail
                (PublishRequestID,
                 ContentID,
                 PublishRegenerateInd,
                 PublishServerCode,
                 Frequency,
                 WebsiteKey)
    SELECT @PublishRequestID,
           @ContentID,
           @InPublishRegenerateInd,
           a.PublishServerCode,
           IsNull(@PublishFrequency,0) * 3600,
           a.WebsiteKey
      FROM Website a WITH (NOLOCK) LEFT OUTER JOIN Publish_Request_Detail x WITH (NOLOCK)
        ON a.WebsiteKey = x.WebsiteKey
       AND x.ContentID = @ContentID
       AND (x.PublishRequestStatusCode = 'N' OR x.Frequency > 0)
       AND x.PublishRegenerateInd = @InPublishRegenerateInd
     WHERE a.WebsiteKey = @WebsiteKey
       AND x.PublishRequestDetailID IS NULL

   -- If website key has been changed since the last publish, create another line
   -- to delete old files.
   IF @PreviousWebsiteKey IS NOT NULL AND @PreviousWebsiteKey <> @WebsiteKey BEGIN
      DELETE FROM Publish_Request_Detail
       WHERE WebsiteKey = @PreviousWebsiteKey
         AND ContentID = @ContentID
  
      INSERT INTO Publish_Request_Detail
                  (PublishRequestID,
                   ContentID,
                   PublishRegenerateInd,
                   PublishServerCode,
                   Frequency,
                   WebsiteKey,
                   DeleteFlag)
      SELECT @PublishRequestID,
             @ContentID,
             @InPublishRegenerateInd,
             PublishServerCode,
             0,
             WebsiteKey,
             'Y'
        FROM Website a WITH (NOLOCK)
       WHERE WebsiteKey = @PreviousWebsiteKey
    END
    /*  Commented out. Might be used in future versions.
    --Content from bucket may be published to more than 1 servers.
    ELSE BEGIN
      INSERT INTO Publish_Request_Detail
                  (PublishRequestID,
                   ContentID,
                   PublishRegenerateInd,
                   PublishServerCode,
                   Frequency)
      SELECT @PublishRequestID,
             @ContentID,
             @InPublishRegenerateInd,
             PublishServerCode,
             CASE WHEN @InPublishRegenerateInd = 'R' THEN 0
             ELSE IsNull(@PublishFrequency,0) * 3600 END
        FROM Content_Publish_Server a 
       WHERE ContentID = @ContentID
         AND NOT EXISTS (SELECT 1
                           FROM Publish_Request_Detail x
                          WHERE ContentID = @ContentID
                            AND (PublishedDateTime IS NULL OR Frequency > 0)
                            AND x.PublishServerCode = a.PublishServerCode
                            AND x.PublishRegenerateInd = @InPublishRegenerateInd)
       ORDER BY a.DefaultServerFlag DESC
    END      
    */
    FETCH NEXT FROM c_ContentRecords
     INTO @NavMenuID,
          @WebsiteKey,
          @PreviousWebsiteKey,
          @ContentID,
          @PublishFrequency,
          @PreFuseURL,
          @PostFuseURL

  END -- End while loop

  CLOSE c_ContentRecords
  DEALLOCATE c_ContentRecords  

  
  IF @InPublishRegenerateInd = 'P' BEGIN

    -- Let's also update PreFuseURL and PostFuseURL.
    DECLARE c_MenuItems CURSOR FOR
    SELECT a.NavMenuID,
           (SELECT Count(*)
              FROM Content b WITH (NOLOCK), Publish_Request_Detail c WITH (NOLOCK)
             WHERE a.NavMenuID = b.NavMenuID
               AND b.ContentID = c.ContentID
               AND c.PublishRequestID = @PublishRequestID)
      FROM #NavMenu a WITH (NOLOCK)

    OPEN c_MenuItems

    FETCH NEXT FROM c_MenuItems
     INTO @NavMenuID,
          @ContentCount
    
    WHILE @@FETCH_STATUS = 0 BEGIN
      EXEC amsp_CMGetFuseURL @NavMenuID, DEFAULT, @NewPreFuseURL OUTPUT, @NewPostFuseURL OUTPUT

      -- If there are no content associated with the nav item, update PostURL too.
      UPDATE Nav_Menu
         SET PreFuseURL = @NewPreFuseURL,
             PostFuseURL = CASE WHEN @ContentCount = 0 THEN @NewPostFuseURL
                           ELSE PostFuseURL END
       WHERE NavMenuID = @NavMenuID
      
      -- If no content is associated, see if we need to regenerate any nav items.
      IF @ContentCount = 0
        EXECUTE amsp_CMRequestPublish @NavMenuID, NULL, @InContactID, 'N', 'Y', 'R', DEFAULT, @PublishRequestID, NULL

      FETCH NEXT FROM c_MenuItems
       INTO @NavMenuID,
            @ContentCount
    END

    CLOSE c_MenuItems
    DEALLOCATE c_MenuItems
  END

  SET @OutPublishRequestID = @PublishRequestID
END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMRequestPublishContent]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMRequestPublishContent]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- Request individual content to be published.
--
-- Modifications
-- 07/11/2003  E.Tatsui
-- =============================================

CREATE                          PROCEDURE [dbo].[amsp_CMRequestPublishContent]
  @InContentID numeric,
  @InContactID numeric,
  @OutPublishRequestID numeric OUTPUT
AS
BEGIN

  DECLARE
  @NavContentGroupInd char(1),
  @PublishFrequency int,
  @PublishRequestID numeric,
  @WebsiteKey uniqueidentifier,
  @PreviousWebsiteKey uniqueidentifier,
  @PreFuseURL varchar(255),
  @PostFuseURL varchar(255),
  @NewPreFuseURL varchar(255),
  @NewPostFuseURL varchar(255),
  @NavMenuID numeric,
  @WorkflowStatusCode char(1),
  @HTMLContentID numeric,
  @FileCount numeric,
  @LinkCount numeric
  
  SELECT @NavContentGroupInd = b.NavContentGroupInd,
         @PublishFrequency = a.PublishFrequency,
         @WebsiteKey = b.WebsiteKey,
         @PreviousWebsiteKey = b.PreviousWebsiteKey,
         @PreFuseURL = a.PreFuseURL,
         @PostFuseURL = a.PostFuseURL,
         @NavMenuID = b.NavMenuID,
         @WorkflowStatusCode = a.WorkflowStatusCode,
         @HTMLContentID = ch.ContentID,
         @FileCount = (SELECT COUNT(*) FROM Content_File x WITH (NOLOCK) WHERE x.ContentID = a.ContentID),
         @LinkCount = (SELECT COUNT(*) FROM Content_Link x WITH (NOLOCK) WHERE x.ContentID = a.ContentID)
    FROM Content a WITH (NOLOCK) 
    LEFT OUTER JOIN Content_HTML ch WITH (NOLOCK)
      ON a.ContentID = ch.ContentID, Nav_Menu b WITH (NOLOCK)
   WHERE a.NavMenuID = b.NavMenuID
     AND a.ContentID = @InContentID

  INSERT INTO Publish_Request
              (ContactID,
               RequestDateTime)
  VALUES (@InContactID,
          CURRENT_TIMESTAMP)

  -- Make sure PreFuseURL is up to date.
  EXEC amsp_CMGetFuseURL @NavMenuID, @InContentID, @NewPreFuseURL OUTPUT, @NewPostFuseURL OUTPUT

  IF @WorkflowStatusCode IN ('P','A') AND
     (IsNull(@NewPreFuseURL,'') <> IsNull(@PreFuseURL,'') 
       OR IsNull(@NewPreFuseURL,'') <> IsNull(@PostFuseURL,'')) BEGIN
    UPDATE Content
       SET PreFuseURL = @NewPreFuseURL,
           PostFuseURL = @NewPostFuseURL
     WHERE ContentID = @InContentID
  END

  SELECT @PublishRequestID = @@Identity

  -- Insert this request as long it's not already there.
  IF @HTMLContentID IS NOT NULL OR @FileCount > 0 OR @LinkCount > 0 BEGIN
    INSERT INTO Publish_Request_Detail
              (PublishRequestID,
               ContentID,
               PublishRegenerateInd,
               PublishServerCode,
               Frequency,
               WebsiteKey)
    SELECT @PublishRequestID,
           @InContentID,
           'P',
           a.PublishServerCode,
           IsNull(@PublishFrequency,0) * 3600,
           @WebsiteKey
      FROM Website a WITH (NOLOCK) LEFT OUTER JOIN Publish_Request_Detail x WITH (NOLOCK)
        ON x.ContentID = @InContentID
       AND (x.PublishRequestStatusCode = 'N' OR x.Frequency > 0)
       AND x.WebsiteKey = a.WebsiteKey
       AND x.PublishRegenerateInd = 'P'
       AND x.PublishRequestStatusCode = 'N'
     WHERE a.WebsiteKey = @WebsiteKey
       AND x.PublishRequestDetailID IS NULL
  END

  IF @PreviousWebsiteKey IS NOT NULL AND @PreviousWebsiteKey <> @WebsiteKey BEGIN
    DELETE FROM Publish_Request_Detail
     WHERE WebsiteKey = @PreviousWebsiteKey
       AND ContentID = @InContentID

    INSERT INTO Publish_Request_Detail
              (PublishRequestID,
               ContentID,
               PublishRegenerateInd,
               PublishServerCode,
               Frequency,
               WebsiteKey,
               DeleteFlag)
    SELECT @PublishRequestID,
           @InContentID,
           'P',
           PublishServerCode,
           0,
           @PreviousWebsiteKey,
           'Y'
      FROM Website a WITH (NOLOCK)
     WHERE WebsiteKey = @PreviousWebsiteKey

  END

  /* Commented out for now. Might be used in future releases.
  ELSE BEGIN -- @NavContentGroupInd = 'C' 
    INSERT INTO Publish_Request_Detail
                (PublishRequestID,
                 ContentID,
                 PublishRegenerateInd,
                 PublishServerCode,
                 Frequency)
    SELECT @PublishRequestID,
           @InContentID,
           'P',
           PublishServerCode,
           IsNull(@PublishFrequency,0) * 3600
      FROM Content_Publish_Server a 
     WHERE ContentID = @InContentID
       AND NOT EXISTS (SELECT 1
                         FROM Publish_Request_Detail x
                        WHERE ContentID = @InContentID
                          AND (PublishedDateTime IS NULL OR Frequency > 0)
                          AND x.PublishServerCode = a.PublishServerCode
                          AND x.PublishRegenerateInd = 'P')
    
  END  */

  SET @OutPublishRequestID = @PublishRequestID
END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMDeleteContent]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMDeleteContent]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This procedure deletes specified content record from Content management system.
--
-- Modifications
-- 07/11/2003    E.Tatsui
-- 03/23/2004    E.Tatsui   Moved update statement to reset Default Content ID for a nav item
--                          to the end, because it shouldn't be run for "Revert" action.
-- =============================================

CREATE                                   PROCEDURE [dbo].[amsp_CMDeleteContent]
  @InContentID numeric,
  @InContactID numeric,
  @InRevertToPublishVerFlag char(1) = 'N',
  @OutPreviousContentID numeric OUTPUT
AS

BEGIN

  DECLARE
    @WorkflowStatusCode char(1),
    @PreviousContentID numeric,
    @DeletedFlag char(1),
    @NewDefaultContentID numeric,
    @NavMenuID numeric,
    @SortOrder numeric,
    @PreviousSortOrder numeric,
    @PreviousNavMenuID numeric,
    @NavContentGroupInd char(1),
    @DefaultContentID numeric,
    @RepublishNavItem bit

  SET @DeletedFlag = 'N'
  SET @RepublishNavItem = 0

  SELECT @WorkflowStatusCode = a.WorkflowStatusCode,
         @PreviousContentID = a.PreviousContentID,
         @NavMenuID = a.NavMenuID,
         @SortOrder = a.SortOrder,
         @NavContentGroupInd = b.NavContentGroupInd,
         @DefaultContentID = b.ContentID
    FROM Content a WITH (NOLOCK), Nav_Menu b WITH (NOLOCK)
   WHERE a.ContentID = @InContentID
     AND a.NavMenuID = b.NavMenuID

  -- If this is the default content record for any nav item, designate another content record (if any)
  -- as the default content. 
  IF @NavContentGroupInd = 'N' AND @InRevertToPublishVerFlag = 'N' 
     AND @DefaultContentID = @InContentID BEGIN
    SELECT TOP 1 @NewDefaultContentID = ContentID
      FROM vCurrent_Content WITH (NOLOCK)
     WHERE NavMenuID = @NavMenuID
       AND ContentID <> @InContentID
     ORDER BY SortOrder
  
    UPDATE Nav_Menu
       SET ContentID = @NewDefaultContentID
     WHERE NavMenuID = @NavMenuID

    SET @RepublishNavItem = 1
  END
  ELSE IF @NavContentGroupInd = 'C' AND @DefaultContentID = @InContentID 
     UPDATE Nav_Menu
        SET ContentID = NULL
      WHERE NavMenuID = @NavMenuID


  -- WorkflowStatus is Published
  IF @WorkflowStatusCode = 'P' BEGIN
    -- Delete prevoius publishing requests for this content.
    DELETE FROM Publish_Request_Detail WHERE ContentID = @InContentID

    -- Put the content in recycled status.
    UPDATE Content
       SET WorkflowStatusCode = 'D',
           ContactID = @InContactID
     WHERE ContentID = @InContentID

    INSERT 
      INTO Content_Workflow_Log (
           ContentID,
           WorkflowStatusCode,
           ContactID,
           ChangeDateTime)
    VALUES (@InContentID,
           'D',
            @InContactID,
            CURRENT_TIMESTAMP)

    -- We need to remove this from file system. Request to publishing server.
    EXEC amsp_CMRequestPublishContent @InContentID, @InContactID, NULL

    SET @DeletedFlag = 'Y'
  END 
  -- Working/approved/pending approval content
  ELSE IF @WorkflowStatusCode IN ('W','A','E','Q') BEGIN 
    
    BEGIN TRAN
    -- Delete the content. We don't need it any more.
    DELETE FROM Publish_Request_Detail WHERE ContentID = @InContentID
    DELETE FROM Content_HTML WHERE ContentID = @InContentID
    DELETE FROM Content_File WHERE ContentID = @InContentID
    DELETE FROM Content_Link WHERE ContentID = @InContentID
    DELETE FROM Content_Workflow_Log WHERE ContentID = @InContentID
    DELETE FROM Content_Security_Group WHERE ContentID = @InContentID
    DELETE FROM Component_Interest_Category WHERE ComponentID = @InContentID
    DELETE FROM Tagged_Page_Interest_Category WHERE ContentID = @InContentID
    DELETE FROM Content_Change_Request WHERE ContentID = @InContentID
    DELETE FROM Content WHERE ContentID = @InContentID
    COMMIT TRAN
  
    -- When we're simply deleting this, we want to make sure that the previous version
    -- is also recycled. Otherwise, previous version that is published is going to
    -- show up.
    IF @InRevertToPublishVerFlag = 'N' AND @PreviousContentID IS NOT NULL BEGIN

      UPDATE Content
         SET WorkflowStatusCode = 'D',
             ContactID = @InContactID
       WHERE ContentID = @PreviousContentID
  
      INSERT 
        INTO Content_Workflow_Log (
             ContentID,
             WorkflowStatusCode,
             ContactID,
             ChangeDateTime)
      VALUES (@PreviousContentID,
             'D',
              @InContactID,
              CURRENT_TIMESTAMP)

      -- We need to remove this from file system. Request to publishing server.
      EXEC amsp_CMRequestPublishContent @PreviousContentID, @InContactID, NULL

     SET @DeletedFlag = 'Y'
    END  -- Deleting.
    -- When we are reverting to published version and this is nav menu.
    ELSE IF @NavContentGroupInd = 'N' BEGIN
      -- See what has been changed.
      SELECT @PreviousNavMenuID = NavMenuID,
             @PreviousSortOrder = SortOrder
        FROM Content WITH (NOLOCK)
       WHERE ContentID = @PreviousContentID
      
      -- If this contet has been moved within the same folder/menu, 
      -- update previous version's sort order.
      IF @PreviousNavMenuID = @NavMenuID AND @PreviousSortOrder != @SortOrder
        UPDATE Content
           SET SortOrder = @SortOrder
         WHERE ContentID = @PreviousContentID
      -- If it has been moved, re-sort contents in the previous menu/folder.
      ELSE IF @PreviousNavMenuID != @NavMenuID
        EXEC amsp_CMRenumCurrentContent @PreviousNavMenuID
    END
  END -- Working/approved contents.

  IF @DeletedFlag = 'Y' AND @NavContentGroupInd = 'N' BEGIN
    -- If deleting this content record reduces the number of content records for the nav menu item to
    -- one, we must reset the DirectListComboInd to "D". This query will take care of every nav menu item.
    UPDATE Nav_Menu
       SET DirectListComboInd = 'D'
     WHERE NavMenuID IN (SELECT b.NavMenuID
                           FROM Nav_Menu b LEFT OUTER JOIN Content a
                             ON a.NavMenuID = b.NavMenuID
                          WHERE a.WorkflowStatusCode IN ('A','P')
                          GROUP BY b.NavMenuID
                         HAVING COUNT(a.NavMenuID) = 1)

    IF @RepublishNavItem = 1 BEGIN
      -- Re-publish the nav item.
      DECLARE @OutPublishRequestID numeric
      EXEC amsp_CMRequestPublish @InNavMenuID = @NavMenuID,
                                 @InContactID = @InContactID,
                                 @InPublishRegenerateInd = 'P',
                                 @OutPublishRequestID  = @OutPublishRequestID OUTPUT
    END
  END
  EXEC amsp_CMRenumCurrentContent @NavMenuID
  SET @OutPreviousContentID = @PreviousContentID
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMDeleteNavMenu]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMDeleteNavMenu]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure deletes specified NavMenu and all if its descendants
-- as well as associated content.
--
-- Modifications
-- 07/11/2003    E.Tatsui
-- =============================================

CREATE                                PROCEDURE amsp_CMDeleteNavMenu
  @InNavMenuID numeric,
  @InContactID numeric,
  @InIgnorePrivilege char(1) = 'N',
  @OutErrorMessage varchar(255) OUTPUT
AS
BEGIN
  DECLARE
    @ContentID numeric,
    @WebsiteKey uniqueidentifier,
    @ParentNavMenuID numeric,
    @UnAuthorizedNum numeric,
    @NavMenuID numeric,
    @ContentCount int

  CREATE TABLE #NavMenuToDelete 
  (NavMenuID numeric, 
   ContentCount numeric, 
   ContentAuthorityGroupID numeric,
   SortOrder numeric(28,18))

  -- Include the descendants as long as they have permission to delete this record.
  INSERT INTO #NavMenuToDelete
  SELECT a.NavMenuID,
         0,
         a.ContentAuthorityGroupID,
         a.SortOrder
    FROM Nav_Menu a WITH (NOLOCK)
   WHERE a.NavMenuID = @InNavMenuID

  WHILE @@RowCount > 0 BEGIN
    INSERT INTO #NavMenuToDelete
    SELECT a.NavMenuID,
           0,
           a.ContentAuthorityGroupID,
           a.SortOrder
      FROM Nav_Menu a WITH (NOLOCK)
     WHERE ParentNavMenuID IN (SELECT NavMenuID FROM #NavMenuToDelete)
       AND NavMenuID NOT IN (SELECT NavMenuID FROM #NavMenuToDelete)
  END

  -- Check to make sure the user has authorization to delete everything.
  IF @InIgnorePrivilege = 'N' BEGIN
    SELECT @UnAuthorizedNum = Count(*)
      FROM #NavMenuToDelete a LEFT OUTER JOIN Content_Authority_Producer b WITH (NOLOCK)
        ON a.ContentAuthorityGroupID = b.ContentAuthorityGroupID
       AND b.NavCreatorFlag = 'Y'
       AND b.ContactID = @InContactID
     WHERE b.ContentAuthorityGroupID IS NULL

    IF @UnAuthorizedNum > 0 BEGIN
      SET @OutErrorMessage = 'You are not allowed to delete this item, because there are descendants of this item you don''t have privileges to delete.'
      RETURN
    END
  END

  -- Mark all the nav item as deleted.
  UPDATE Nav_Menu
     SET WorkflowStatusCode = 'D'
   WHERE NavMenuID IN (SELECT NavMenuID FROM #NavMenuToDelete)

  -- Request each content record to be deleted.
  DECLARE cContentToDelete CURSOR FOR
  SELECT a.ContentID
    FROM vCurrent_Content a WITH (NOLOCK), #NavMenuToDelete b
   WHERE a.NavMenuID = b.NavMenuID
   ORDER BY b.SortOrder

  OPEN cContentToDelete
  
  FETCH NEXT FROM cContentToDelete
   INTO @ContentID

  WHILE @@FETCH_STATUS = 0 BEGIN
    EXEC amsp_CMDeleteContent @ContentID, @InContactID, 'N', NULL
  
    FETCH NEXT FROM cContentToDelete
     INTO @ContentID
  END
  CLOSE cContentToDelete
  DEALLOCATE cContentToDelete
  -- Ends taking care of content records.

  UPDATE #NavMenuToDelete
     SET ContentCount = (SELECT COUNT(*) FROM vCurrent_Content WHERE NavMenuID = #NavMenuToDelete.NavMenuID)

  -- For nav item that doesn't have any current content records, let's just delete them now.
  DECLARE c_NavMenuToDelete CURSOR FOR
   SELECT NavMenuID, ContentCount
     FROM #NavMenuToDelete

  OPEN c_NavMenuToDelete
  FETCH NEXT FROm c_NavMenuToDelete
   INTO @NavMenuID,
        @ContentCount
  WHILE @@FETCH_STATUS = 0 BEGIN
    -- For both the items deleted and items requested to be deleted...
    -- Grab the parent parent, unless it's also being deletecd.    
    SET @ParentNavMenuID = NULL
    SELECT @ParentNavMenuID = ParentNavMenuID
      FROM Nav_Menu WITH (NOLOCK)
     WHERE NavMenuID = @NavMenuID
       AND ParentNavMenuID NOT IN (SELECT NavMenuID FROM #NavMenuToDelete)

    -- Do the rest only if we're deleting right nwo.
    IF @ContentCount = 0 BEGIN
        UPDATE Content
         SET NavMenuID = (SELECT NavMenuID FROM Nav_Menu WHERE Name = 'Content_Recycle_Bin')
       WHERE NavMenuID = @NavMenuID

      -- IF there are no published content associated with this NavMenuID, go ahead and
      -- delete the record.
      UPDATE Publish_Request
         SET NavMenuID = NULL
       WHERE NavMenuID = @NavMenuID
  
      DELETE FROM Nav_Menu_Workflow_Log WHERE NavMenuID = @NavMenuID
      DELETE FROM Nav_Menu_Feature WHERE NavMenuID = @NavMenuID
      DELETE FROM Nav_Menu_Security_Group WHERE NavMenuID = @NavMenuID
      DELETE FROM Nav_Menu_Setup_Log WHERE NavMenuID = @NavMenuID
      DELETE FROM Nav_Menu WHERE NavMenuID = @NavMenuID
    END

    -- If we set the parent earlier, update it to reflect the changes.
    IF @ParentNavMenuID IS NOT NULL
      EXEC amsp_CMUpdateNavProperties @ParentNavMenuID

    FETCH NEXT FROm c_NavMenuToDelete
     INTO @NavMenuID, @ContentCount
  END
  CLOSE c_NavMenuToDelete
  DEALLOCATE c_NavMenuToDelete   
  
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMDeleteWebsite]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMDeleteWebsite]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- Stored procedure to delete Website table.
--
-- Modifications
-- 09/30/2003  E.Tatsui   Created
-- =============================================

CREATE      PROCEDURE amsp_CMDeleteWebsite
  @InWebsiteKey uniqueidentifier,
  @InContactID numeric
AS
BEGIN
  DECLARE
  @NavMenuID numeric,
  @ActiveContentCount numeric,
  @NavMenuLeft integer

  SELECT @ActiveContentCount = Count(*)
    FROM Nav_Menu a, vCurrent_Content b
   WHERE a.NavMenuID = b.NavMenuID
     AND a.WebsiteKey = @InWebsiteKey

  -- If there is active content, simply inactivate the Website.
  IF @ActiveContentCount = 0 BEGIN
    UPDATE Website
       SET ActiveFlag = 'N'
     WHERE WebsiteKey = @InWebsiteKey
  END
  ELSE BEGIN -- If there is no active content, go ahead and delete all the nav menus.
    DECLARE c_NMToDelete CURSOR FOR
     SELECT NavMenuID
       FROM Nav_Menu
      WHERE WebsiteKey = @InWebsiteKey
  
    OPEN c_NMToDelete
    FETCH NEXT FROM c_NMToDelete
     INTO @NavMenuID
  
    WHILE @@FETCH_STATUS = 0 BEGIN
      EXEC amsp_CMDeleteNavMenu @NavMenuID, @InContactID, 'Y', NULL
  
      FETCH NEXT FROM c_NMToDelete
       INTO @NavMenuID
    END
  
    CLOSE c_NMToDelete
    DEALLOCATE c_NMToDelete
    
    SELECT @NavMenuLeft = COUNT(*)
      FROM Nav_Menu
     WHERE WebsiteKey = @InWebsiteKey

    -- If we were successful in deleting all the navigation/folders, let's delete this website.
    IF @NavMenuLeft = 0 BEGIN
      DELETE FROM Website_Content_Authority WHERE WebsiteKey = @InWebsiteKey
      DELETE FROM Website_Security_Group WHERE WebsiteKey = @InWebsiteKey
      DELETE FROM Nav_Menu_Website WHERE WebsiteKey = @InWebsiteKey
      DELETE FROM Website WHERE WebsiteKey = @InWebsiteKey
    END
    ELSE BEGIN -- Otherwise, mark it as inactive.
      UPDATE Website
         SET ActiveFlag = 'N'
       WHERE WebsiteKey = @InWebsiteKey
    END
  END
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMFinalizePublish]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMFinalizePublish]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure should be called at the end of publishing process
-- to update all the necessary fields.
--
-- Modifications
-- 06/12/2003   E.Tatsui   Created
-- 04/16/2007	W.Archer   Updated
-- =============================================

CREATE                        PROCEDURE [dbo].[amsp_CMFinalizePublish]
	@InPublishRequestDetailID int,
  @InPublishedDateTime datetime,
  @InContactID numeric
  AS

BEGIN
  DECLARE
    @ContentID numeric,
    @NavMenuID numeric,
    @PreviousContentID numeric,
    @HTMLContentID numeric,
    @NavContentGroupInd char(1),
    @ParentNavMenuID numeric,
    @DefaultContentID numeric,
    @FilePath varchar(255),
    @FileName varchar(255),
    @WorkflowStatusCode char(1),
    @PublicationDate datetime,
    @DestDirectory varchar(255),
    @NewPreFuseURL varchar(255),
    @NewPostFuseURL varchar(255),
    @OldPreFuseURL varchar(255),
    @OldPostFuseURL varchar(255),
    @NewNavMenuPreFuseURL varchar(255),
    @NewNavMenuPostFuseURL varchar(255),
    @OldNavMenuPreFuseURL varchar(255),
    @OldNavMenuPostFuseURL varchar(255),
    @ExpirationDate datetime,
    @CMResetAllContentExpDate varchar(10),
    @ExpirationDays integer,
    @NavWorkflowStatusCode char(1),
    @ContentCount int,
    @PublishRegenerateInd char(1),
    @PublishRequestID int,
    @PublishedDirectory varchar(255),
    @PublishDirectory varchar(255),
    @NewDefaultContentID numeric,
    @RequestPublishedDateTime datetime,
    @RequestNavMenuID numeric,
    @WebsiteKey uniqueidentifier

  SELECT @ContentID = a.ContentID,
         @PreviousContentID = a.PreviousContentID,
         @HTMLContentID = b.ContentID,
         @OldPreFuseURL = a.PreFuseURL,
         @OldPostFuseURL = a.PostFuseURL,
         @WorkflowStatusCode = a.WorkflowStatusCode,
         @PublicationDate = a.PublicationDate,
         @ExpirationDate = a.ExpirationDate,
         @ExpirationDays = a.ExpirationDays,
         @NavContentGroupInd = c.NavContentGroupInd,
         @FilePath = c.FilePath,
         @NavMenuID = c.NavMenuID,
         @ParentNavMenuID = c.ParentNavMenuID,
         @DefaultContentID = c.ContentID,
         @OldNavMenuPreFuseURL = c.PreFuseURL,
         @OldNavMenuPostFuseURL = c.PostFuseURL,
         @NavWorkflowStatusCode = c.WorkflowStatusCode,
         @PublishRegenerateInd = d.PublishRegenerateInd,
         @PublishRequestID = d.PublishRequestID,
         @PublishedDirectory = c.PublishedDirectory,
         @PublishDirectory = Replace(CASE WHEN c.NavContentGroupInd = 'N' THEN IsNull(e.NavPublishDirectory,'')
                                          ELSE IsNull(e.ContentFolderPublishDirectory,'') END
                                     + c.FilePath,'\','/'),
         @WebsiteKey = e.WebsiteKey,
         @RequestPublishedDateTime = f.PublishedDateTime,
         @RequestNavMenuID = f.NavMenuID
    FROM Content a WITH (NOLOCK) LEFT OUTER JOIN Content_HTML b WITH (NOLOCK)
      ON a.ContentID = b.ContentID, Nav_Menu c WITH (NOLOCK), Publish_Request_Detail d WITH (NOLOCK),
         Website e WITH (NOLOCK), Publish_Request f WITH (NOLOCK)
   WHERE a.NavMenuID = c.NavMenuID
     AND a.ContentID = d.ContentID
     AND c.WebsiteKey = e.WebsiteKey
     AND d.PublishRequestDetailID = @InPublishRequestDetailID
     AND d.PublishRequestID = f.PublishRequestID

  -- Take care of Publish_Request first.
  IF @RequestPublishedDateTime IS NULL BEGIN
    UPDATE Publish_Request
       SET PublishedDateTime = @InPublishedDateTime
     WHERE PublishRequestID = @PublishRequestID
  END

  -- If we published the content (instead of deleting them).
  IF @WorkflowStatusCode = 'A' OR @WorkflowStatusCode = 'P' BEGIN
    SELECT @CMResetAllContentExpDate = Value
      FROM System_Variable
     WHERE Name = 'CMResetAllContentExpDate'
  
    -- Archive the previous content if there is one.
    IF @PreviousContentID IS NOT NULL AND @WorkflowStatusCode = 'A' BEGIN
      UPDATE Content
         SET WorkflowStatusCode = 'R'
       WHERE ContentID = @PreviousContentID
  
      INSERT INTO Content_Workflow_Log (
             ContentID,
             WorkflowStatusCode,
             ContactID,
             ChangeDateTime)
      VALUES (
             @PreviousContentID,
             'R',
             @InContactID,
             CURRENT_TIMESTAMP)
    END  -- Ends archiving
    
    -- Are we resetting expiration date?
    -- CMResetAllContentExpDate determines whether to reset expiration date when Nav_Menu is published. 
    -- If set to True, a content record will have a new expiration date every time it is published.
    -- If set to False, the content record will have a new expiration date only when the content has actually been 
    -- modified.

    IF (@WorkflowStatusCode = 'A' OR UPPER(@CMResetAllContentExpDate) = 'TRUE') AND @ExpirationDays IS NOT NULL AND @ExpirationDays > 0
      SET @ExpirationDate = DateAdd(dd,@ExpirationDays,CURRENT_TIMESTAMP)
    ELSE IF (@WorkflowStatusCode = 'A' OR UPPER(@CMResetAllContentExpDate) = 'TRUE') 
            AND (@ExpirationDays IS NULL OR @ExpirationDays = 0)
      SET @ExpirationDate = NULL

    -- Set PublicationDate only if it's null.
    IF @PublicationDate IS NULL
      SET @PublicationDate = @InPublishedDateTime 

    UPDATE Content
       SET WorkflowStatusCode = 'P',
           PublishDateTime = @InPublishedDateTime,
           ReminderSentDateTime = NULL,
           ExpirationDate = @ExpirationDate,
           PublicationDate = @PublicationDate,
           ContactID = @InContactID
     WHERE ContentID = @ContentID
  
    INSERT INTO Content_Workflow_Log (ContentID,
                                      WorkflowStatusCode,
                                      ContactID,
                                      ChangeDateTime)
         VALUES (@ContentID,
                 'P',
                 @InContactID,
                 CURRENT_TIMESTAMP)
  
    -- Update Pre & PostFuseURL if necessary.
    EXECUTE amsp_CMGetFuseURL @NavMenuID, @ContentID, @NewPreFuseURL OUTPUT, @NewPostFuseURL OUTPUT
    
    -- If PostFuseURL changes, update it.
    IF IsNull(@NewPreFuseURL,'') <> IsNull(@OldPreFuseURL,'') 
       OR IsNull(@NewPostFuseURL,'') <> IsNull(@OldPostFuseURL,'') BEGIN
      UPDATE Content
         SET PostFuseURL = @NewPostFuseURL
       WHERE ContentID = @ContentID
    END
    
    -- Default Content?
    IF @PreviousContentID = @DefaultContentID BEGIN
      SET @DefaultContentID = @ContentID
      UPDATE Nav_Menu
         SET ContentID = @ContentID
       WHERE NavMenuID = @NavMenuID
    END

  END -- When content's status is A or P.
  -- If Content's workflow status was "D"
  ELSE IF @WorkflowStatusCode = 'D' BEGIN

    -- Move the content to recycle bin. Change the ID to recycle bin's ID when Nav Item is deleted.
    UPDATE Content
       SET WorkflowStatusCode = 'Y',
           NavMenuID = CASE WHEN @NavWorkflowStatusCode = 'D' THEN (SELECT NavMenuID FROM Nav_Menu WHERE Name = 'Content_Recycle_Bin') 
                       ELSE NavMenuID END
     WHERE ContentID = @ContentID

    INSERT 
      INTO Content_Workflow_Log (
           ContentID,
           WorkflowStatusCode,
           ContactID,
           ChangeDateTime)
    VALUES (@ContentID,
           'Y',
            @InContactID,
            CURRENT_TIMESTAMP)
  END

  -- If NavMenu is marked for deletion, find out if there are more content associated with this nav item.
  IF @NavWorkflowStatusCode = 'D' BEGIN

    SELECT @ContentCount = Count(*)
      FROM Content
     WHERE NavMenuID = @NavMenuID

    IF @ContentCount = 0 BEGIN
      EXECUTE amsp_CMRequestPublish @NavMenuID, NULL, @InContactID, 'N', 'Y', 'R', DEFAULT, @PublishRequestID, NULL

      UPDATE Publish_Request
         SET NavMenuID = NULL
       WHERE NavMenuID = @NavMenuID

      -- Delete all the related records.
      DELETE FROM Nav_Menu_Workflow_Log WHERE NavMenuID = @NavMenuID
      DELETE FROM Nav_Menu_Feature WHERE NavMenuID = @NavMenuID
      DELETE FROM Nav_Menu_Security_Group WHERE NavMenuID = @NavMenuID
      DELETE FROM Nav_Menu WHERE NavMenuID = @NavMenuID
    END
  END
  -- Not marked for deletion. For default content only.
  ELSE IF @DefaultContentID = @ContentID BEGIN
    -- Update Nav_Menu table.
    EXECUTE amsp_CMGetFuseURL @NavMenuID, NULL, @NewNavMenuPreFuseURL OUTPUT, @NewNavMenuPostFuseURL OUTPUT
    -- If this is the default content, also update Nav_Menu table.
    IF IsNull(@NewNavMenuPreFuseURL,'')  <> IsNull(@OldNavMenuPreFuseURL,'')
       OR IsNull(@NewNavMenuPostFuseURL,'')  <> IsNull(@OldNavMenuPostFuseURL,'') BEGIN
      UPDATE Nav_Menu
         SET PreFuseURL = @NewNavMenuPreFuseURL,
             PostFuseURL = @NewNavMenuPostFuseURL
       WHERE NavMenuID = @NavMenuID
    END

    -- Store the new publish path.
    IF IsNull(@PublishedDirectory,'') <> @PublishDirectory
      UPDATE Nav_Menu
         SET PublishedDirectory =  @PublishDirectory
       WHERE NavMenuID = @NavMenuID

    -- Regenererate navigations if this is default content record for a nav item.
    IF @PublishRegenerateInd = 'P' AND @NavContentGroupInd = 'N' 
      EXECUTE amsp_CMRequestPublish @NavMenuID, NULL, @InContactID, 'N', 'Y', 'R', DEFAULT, @PublishRequestID, NULL
  END

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMFindContentIDtoEdit]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMFindContentIDtoEdit]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure looks for contentID based on the URL provided.
-- Used for "Surf to Edit" functionality.
-- 
-- Modifiations
-- 07/08/2003   E.Tatsui    Created
-- =============================================

CREATE              PROCEDURE amsp_CMFindContentIDtoEdit
	@InURL varchar(500),
  @OutContentID numeric OUTPUT,
  @OutEditable bit OUTPUT
AS
BEGIN

  DECLARE
    @HTMLContentID numeric,
    @ContentID numeric,
    @GECodePath varchar(255),
    @Rowcount numeric,
    @StartIndex smallint,
    @EndIndex smallint,
    @URLContentID int,
    @URLIDLen int

  SET @OutEditable = 0
  SET @Rowcount = 0

  SET @StartIndex = CHARINDEX ('&CONTENTID=', @InURL) 

  -- If there is ContactID in URL, use that instead of trying to figure out
  IF @StartIndex > 0 BEGIN

    SELECT @EndIndex = CHARINDEX ('&', @InURL, @StartIndex + 1) 
  
    IF @EndIndex = 0
      SET @EndIndex = LEN(@InURL) + 1
  
    SET @URLIDLen = @EndIndex - @StartIndex - 11
    SET @URLContentID = SUBSTRING(@InURL,@StartIndex+11,@URLIDLen)
  
    SELECT @ContentID = a.ContentID,
           @HTMLContentID = b.ContentID
      FROM Content a LEFT OUTER JOIN Content_HTML b
        ON a.ContentID = b.ContentID
     WHERE a.ContentID = b.ContentID
       AND a.ContentID = @URLContentID
       AND a.WorkflowStatusCode = 'P'

    SET @Rowcount = @@Rowcount
  END
  -- If we didn't find ContentID from URL or it wasn't a valid ContentID.
  IF @@Rowcount = 0 BEGIN
    SELECT @GECodePath = Value
      FROM System_Variable
     WHERE Name = 'GECodePath'

    IF Len(@GECodePath) > 1
      SET @GECodePath = RIGHT(@GECodePath,Len(@GECodePath)-1)
    ELSE IF @GECodePath = '/'
      SET @GECodePath = ''
  
    -- First match with content record.
    SELECT @ContentID = a.ContentID, 
           @HTMLContentID = b.ContentID
      FROM Content a LEFT OUTER JOIN Content_HTML b
        ON a.ContentID = b.ContentID, Nav_Menu c, Website d
     WHERE a.NavMenuID = c.NavMenuID
       AND c.WebsiteKey = d.WebsiteKey
       AND a.WorkflowStatusCode = 'P'
       AND @InURL = CASE WHEN a.SecureFlag = 'Y' THEN d.SecureWebsiteRootURL
                         ELSE d.WebsiteRootURL END
                    + a.PostFuseURL
    
    SET @Rowcount = @@Rowcount
    
    -- If there wasn't a match with content record, try nav_menu.
    IF @Rowcount = 0   BEGIN
  
      SELECT @ContentID = a.ContentID, 
             @HTMLContentID = b.ContentID
        FROM Content a LEFT OUTER JOIN Content_HTML b
          ON a.ContentID = b.ContentID, Nav_Menu c, Website d
       WHERE a.NavMenuID = c.NavMenuID
         AND c.ContentID = a.ContentID
         AND c.WebsiteKey = d.WebsiteKey
         AND a.WorkflowStatusCode = 'P'
         AND (@InURL = CASE WHEN a.SecureFlag = 'Y' THEN d.SecureWebsiteRootURL
                           ELSE d.WebsiteRootURL END
                       + c.PostFuseURL
           OR @InURL = CASE WHEN a.SecureFlag = 'Y' THEN d.SecureWebsiteRootURL
                           ELSE d.WebsiteRootURL END
                       + CASE WHEN c.NavContentGroupInd = 'C' 
                              THEN REPLACE(c.PublishedDirectory, REPLACE(IsNull(d.ContentFolderPublishDirectory,''),'\','/'), IsNull(d.FolderContentDisplayPath,''))
                              ELSE REPLACE(c.PublishedDirectory, REPLACE(IsNull(d.NavPublishDirectory,''),'\','/'), IsNull(d.NavContentDisplayPath,''))
                              END)
      SET @Rowcount = @@Rowcount
    END
  
  END -- Ends if @@Rowcount = 0

  -- If there is a record in Content_HTML, we can redirect the user to Ektron page.
  IF @Rowcount > 0 AND @HTMLContentID IS NOT NULL BEGIN
    SET @OutContentID = @ContentID
    SET @OutEditable = 1
    print 'here'
  END

 -- If there is a content record, use it.
  ELSE IF @Rowcount > 0 AND @ContentID IS NOT NULL
    SET @OutContentID = @ContentID
  ELSE IF @Rowcount = 0 BEGIN  
    -- If not, look for content_file.
    SELECT @ContentID = a.ContentID
      FROM Content_File a, Content b, Nav_Menu c, Website d
     WHERE a.ContentID = b.ContentID
       AND b.NavMenuID = c.NavMenuID
       AND c.WebsiteKey = d.WebsiteKey
       AND b.WorkflowStatusCode = 'P'
       AND @InURL = 
                    CASE WHEN b.SecureFlag = 'Y' THEN d.SecureWebsiteRootURL
                         ELSE d.WebsiteRootURL END
                    + CASE WHEN c.NavContentGroupInd = 'C' 
                           THEN REPLACE(c.PublishedDirectory, REPLACE(IsNull(d.ContentFolderPublishDirectory,''),'\','/'), IsNull(d.FolderContentDisplayPath,''))
                           ELSE REPLACE(c.PublishedDirectory, REPLACE(IsNull(d.NavPublishDirectory,''),'\','/'), IsNull(d.NavContentDisplayPath,''))
                           END + a.FileName

    IF @Rowcount > 0
      SET @OutContentID = @ContentID
  END

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetContentAuthority]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetContentAuthority]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- Stored procedure to get authority groups for a specified user.
--
-- Modifications
-- 10/10/2003  E.Tatsui   Created
-- =============================================

CREATE     PROCEDURE amsp_CMGetContentAuthority
	@InContactID numeric
AS
BEGIN
  DECLARE
    @SuperUserFlag bit,
    @SuperGroupID numeric
  
  SET @SuperUserFlag = 0
  -- First, find out if this user is a member of a super group.
  SELECT @SuperUserFlag = 1,
         @SuperGroupID = a.ContentAuthorityGroupID
    FROM Content_Authority_Group a, Content_Authority_Producer b
   WHERE a.ContentAuthorityGroupID = b.ContentAuthorityGroupID
     AND b.ContactID = @InContactID
     AND a.SuperGroupFlag = 'Y'

  -- If super user, they have access to all the groups.
  IF @SuperUserFlag = 1
    SELECT a.ContentAuthorityGroupID,
           b.ContactID,
           b.ContentEditorFlag,
           b.ContentApproverFlag,
           b.NavEditorFlag,
           b.NavCreatorFlag,
           b.LayoutFlag,
           b.EditorFlag,
           b.CustomPageFlag,
           b.ComponentScriptFlag,
           b.UploadFlag,
           b.DefaultOwnerFlag,
           b.HighestToolbarLevelInd,
           'Y' AS SuperGroupFlag
      FROM Content_Authority_Group a, Content_Authority_Producer b
     WHERE b.ContactID = @InContactID
       AND b.ContentAuthorityGroupID = @SuperGroupID
  ELSE
    SELECT b.*, 'N' AS SuperGroupFlag
      FROM Producer a LEFT OUTER JOIN Content_Authority_Producer b 
        ON a.ContactID = b.ContactID
     WHERE a.ContactID = @InContactID

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetContentFiles]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetContentFiles]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- Procedure to get all the files for the specified Content.
--
-- Modifications
-- 06/27/2003     E.Tatsui   Created
-- =============================================


CREATE       PROCEDURE amsp_CMGetContentFiles
  @InContentID numeric = 0 ,
  @InContentFileID numeric = 0
AS
BEGIN
  SELECT a.ContentID,
         a.ContentFileID,
         a.FileName,
         a.SourceLocation,
         a.PublishLocation,
         a.Description,
         b.MimeType,
         b.FileTypeCode,
         b.FileTypeDesc,
         c.OpenInNewWindowFlag,
         CASE WHEN c.MembersOnlyFlag = 'Y' THEN e.ProtectedRootPath
              ELSE e.PublishRootPath END AS PublishRootPath,
         CASE WHEN d.NavContentGroupInd = 'N' THEN
              REPLACE(a.PublishLocation,REPLACE(IsNull(e.NavPublishDirectory,''),'\','/'), IsNull(e.NavContentDisplayPath,''))
         ELSE 
              REPLACE(a.PublishLocation,REPLACE(IsNull(e.ContentFolderPublishDirectory,''),'\','/'), IsNull(e.FolderContentDisplayPath,''))
         END AS DisplayPublishLocation
    FROM Content_File a,
         File_Type_Ref b, 
				 Content c, Nav_Menu d 
    LEFT OUTER JOIN Website e
      ON d.WebsiteKey = e.WebsiteKey
   WHERE a.FileTypeCode = b.FileTypeCode
		 AND a.ContentID = c.ContentID
     AND c.NavMenuID = d.NavMenuID
     AND a.ContentID = CASE WHEN @InContentID > 0 THEN @InContentID
                            ELSE a.ContentID END
     AND a.ContentFileID =  CASE WHEN @InContentFileID > 0 THEN @InContentFileID
                                 ELSE a.ContentFileID END
		ORDER by a.SortOrder 

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetContentSecurity]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetContentSecurity]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure takes ContentID and ContactID and returns a row
-- from Content_Authority_Producer
-- 
-- Modifications
-- 08/12/2003    E.Tatsui   Created
-- =============================================

CREATE     PROCEDURE amsp_CMGetContentSecurity
	@InContentID numeric = NULL,
  @InNavMenuID numeric = NULL,
  @InContactID numeric
AS
BEGIN	
  DECLARE
    @SuperUserFlag bit
  
  SET @SuperUserFlag = 0
  -- First, find out if this user is a member of a super group.
  SELECT @SuperUserFlag = 1
    FROM Content_Authority_Group a, Content_Authority_Producer b
   WHERE a.ContentAuthorityGroupID = b.ContentAuthorityGroupID
     AND b.ContactID = @InContactID
     AND a.SuperGroupFlag = 'Y'

  IF @SuperUserFlag = 1
    SELECT b.*
      FROM Content_Authority_Group a, Content_Authority_Producer b
     WHERE a.ContentAuthorityGroupID = b.ContentAuthorityGroupID
       AND b.ContactID = @InContactID
       AND a.SuperGroupFlag = 'Y'
  ELSE IF @InContentID IS NOT NULL
    SELECT cap.*
      FROM Content c, Nav_Menu nm, Content_Authority_Producer cap
     WHERE c.NavMenuID = nm.NavMenuID
       AND nm.ContentAuthorityGroupID = cap.ContentAuthorityGroupID
       AND cap.ContactID = @InContactID
       AND c.ContentID = @InContentID
  ELSE IF @InNavMenuID IS NOT NULL
    SELECT cap.*
      FROM Nav_Menu nm, Content_Authority_Producer cap
     WHERE nm.NavMenuID = @InNavMenuID
       AND nm.ContentAuthorityGroupID = cap.ContentAuthorityGroupID
       AND cap.ContactID = @InContactID
  ELSE
    RAISERROR('Either NavMenuID or ContentID is required.',16,1)
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetContentToPublish]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetContentToPublish]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This procedures gets all the documents that need to be published.
--
-- Modofications
-- 06/16/2003     E.Tatsui
-- =============================================


CREATE  PROCEDURE [dbo].[amsp_CMGetContentToPublish]
  @InPublishRequestDetailID numeric,
  @InDeleteFlag char(1) = 'N'
AS
BEGIN
  
  DECLARE
    @ContentID numeric,
    @NavMenuID numeric,
    @FileCount integer,
    @LinkCount integer,
    @HTMLContentID numeric,
    @HTMLTitle varchar(255),
    @ContentName varchar(255),
    @SourceLocation varchar(255),
    @PublishLocation varchar(255),
    @WorkflowStatusCode char(1),
    @NavContentGroupInd char(1),
    @MicrositeID numeric,
    @PreFuseURL varchar(255),
    @PostFuseURL varchar(255),
    @NavMenuPreFuseURL varchar(255),
    @NavMenuPostFuseURL varchar(255),
    @FilePath varchar(255),
    @URLSafeName varchar(255),
    @DefaultContentID numeric,
    @PreviousContentID numeric,
    @ShowInTemplateFlag char(1),
    @FileTypeCode varchar(4),
    @FileName varchar(255),
    @Description varchar(255),
    @DirectListComboInd char(1),
    @WebsiteRootURL varchar(255),
    @SecureWebsiteRootURL varchar(255),
    @TemplatePath varchar(255),
    @SectionName varchar(255),
    @MembersOnlyFlag char(1),
    @PrevMembersOnlyFlag char(1),
    @SourceRootLocation varchar(255),
    @PublishDirectory varchar(255),
    @Header varchar(500),
    @Footer varchar(500),
    @Keywords varchar(255),
    @DefaultGenerated bit,
    @PublishRegenerateInd char(1),
    @DefaultFileName varchar(255),
    @DefaultContentFlag char(1),
    @OldPublishedDefaultFileName varchar(255),
    @NewPublishedDefaultFileName varchar(255),
    @NavMenuWorkflowStatus char(1),
    @PublishedDirectory varchar(255),
    @LinkURL varchar(510),
    @SecureFlag char(1),
    @Root varchar(255),
    @PreviousWebsiteKey uniqueidentifier,
    @WebsiteKey uniqueidentifier

  SELECT @ContentID = c.ContentID,
         @NavMenuID = c.NavMenuID,
         @ContentName = c.Name,
         @PreFuseURL = c.PreFuseURL,
         @PostFuseURL = c.PostFuseURL,
         @URLSafeName = c.URLSafeName,
         @MembersOnlyFlag = IsNull(c.MembersOnlyFlag,'N'),
         @PrevMembersOnlyFlag = IsNull(pv.MembersOnlyFlag,'N'),
         @WorkflowStatusCode = c.WorkflowStatusCode,
         @PreviousContentID = c.PreviousContentID,
         @ShowInTemplateFlag = c.ShowInTemplateFlag,
         @Keywords = c.Keywords,
         @SecureFlag = c.SecureFlag,
         @LinkCount = (SELECT Count(*) FROM Content_Link  WITH (NOLOCK) WHERE ContentID = c.ContentID),
         @FileCount = (SELECT Count(*) FROM Content_File  WITH (NOLOCK) WHERE ContentID = c.ContentID),
         @HTMLContentID = ch.ContentID,
         @HTMLTitle = ch.Title,
         @DefaultContentID = n.ContentID,
         @NavContentGroupInd = n.NavContentGroupInd,
         @FilePath = n.FilePath,
         @DirectListComboInd = n.DirectListComboInd,
         @TemplatePath = n.TemplatePath,
         @SectionName = n.Name,
         @WebsiteRootURL = w.WebsiteRootURL,
         @SecureWebsiteRootURL = w.SecureWebsiteRootURL,
         @PublishRegenerateInd = p.PublishRegenerateInd,
         @DefaultFileName = w.DefaultFileName,
         @OldPublishedDefaultFileName = n.PublishedDefaultFileName,
         @NavMenuWorkflowStatus = n.WorkflowStatusCode,
         @PublishedDirectory = n.PublishedDirectory,
         @PublishDirectory = Replace(CASE WHEN n.NavContentGroupInd = 'N' THEN IsNull(w.NavPublishDirectory,'')
                                          ELSE IsNull(w.ContentFolderPublishDirectory,'') END
                                     + n.FilePath,'\','/'),
         @PreviousWebsiteKey = n.PreviousWebsiteKey,
         @WebsiteKey = n.WebsiteKey
    FROM Nav_Menu n WITH (NOLOCK), Content c WITH (NOLOCK) LEFT OUTER JOIN Content_HTML ch WITH (NOLOCK)

      ON c.ContentID = ch.ContentID
    LEFT OUTER JOIN Content pv WITH (NOLOCK)
      ON c.PreviousContentID = pv.ContentID, Publish_Request_Detail p WITH (NOLOCK), Website w WITH (NOLOCK)
   WHERE n.NavMenuID = c.NavMenuID
     AND c.ContentID = p.ContentID
     AND p.WebsiteKey = w.WebsiteKey
     AND p.PublishRequestDetailID = @InPublishRequestDetailID


  -- Is this a default content for the nav item?
  IF (@PreviousContentID = @DefaultContentID OR @ContentID = @DefaultContentID)
      AND @NavContentGroupInd = 'N'
    SET @DefaultContentFlag = 'Y'

  SET @DefaultGenerated = 0
  SET @Header = ''
  SET @Footer = '<!--- Generated by eContentManager - Advanced Solutions International, Inc. --->' + Char(13) + Char(10)

  -- Approved or already published contents.
  IF @InDeleteFlag = 'N' AND (@WorkflowStatusCode = 'A' OR @WorkflowStatusCode = 'P') BEGIN

    IF (@FileCount > 0 OR @LinkCount > 0 OR @HTMLContentID IS NOT NULL) BEGIN
      IF @MicrositeID > 0 BEGIN
        SET @SourceLocation = NULL
      
      END -- Ends special rule for microsite contents.
  
      ELSE BEGIN -- Non-microsite contents
        IF @FileCount > 0 AND @PublishRegenerateInd = 'P' BEGIN
          -- Add all the uploaded files to copy
          INSERT INTO #PublishContent
                      (PublishRequestDetailID,
                       SourceLocation,
                       PublishLocation,
                       PublishDirectory,
                       ContentFileID,
                       UseProtectedPath)
          SELECT @InPublishRequestDetailID,
                 SourceLocation,
                 @PublishDirectory + FileName,
                 @PublishDirectory,
                 ContentFileID,
                 @MembersOnlyFlag
            FROM Content_File WITH (NOLOCK)
           WHERE ContentID = @ContentID
        END

        -- If this is a default content and it's a list or combo mode,
        -- create a default document.
        IF @MembersOnlyFlag = 'N' AND @DirectListComboInd IN ('L','C') AND @DefaultContentFlag = 'Y'
          BEGIN
          EXEC amsp_CMGetFuseURL @NavMenuID, NULL, @NavMenuPreFuseURL OUTPUT, @NavMenuPostFuseURL OUTPUT, 1

          SET @SourceLocation = @WebsiteRootURL + @NavMenuPreFuseURL + '&FuseFlag=1'

          -- If DefaultFileName is specified, use it.
          IF @DefaultFileName IS NOT NULL BEGIN
            SET @PublishLocation = @PublishDirectory + @DefaultFileName
            SET @NewPublishedDefaultFileName = @DefaultFileName
          END
          ELSE BEGIN
            SET @PublishLocation = @PublishDirectory + 'Default' + Convert(varchar(20),@NavMenuID) + '.htm'
            SET @NewPublishedDefaultFileName = 'Default' + Convert(varchar(20),@NavMenuID) + '.htm'
          END
          SET @DefaultGenerated = 1

          INSERT INTO #PublishContent
                      (PublishRequestDetailID,
                       SourceLocation,
                       PublishLocation,
                       PublishDirectory,
                       Header,
                       Footer,
                       UseProtectedPath,
                       DefaultContentFlag)
          VALUES (@InPublishRequestDetailID,
                  @SourceLocation,
                  @PublishLocation,
                  @PublishDirectory,
                  @Header,
                  @Footer,
                  @MembersOnlyFlag,
                  'Y')
        END

        -- If there is only a single file/link or this content is Member's only file, 
        -- and we're using default page,
        -- let's generate a file which simply redirects to the file.
        -- This file should always be in non-member's only directory (accessible through Web)
        IF @DefaultContentFlag = 'Y' AND @DefaultFileName IS NOT NULL
           AND @DefaultGenerated = 0
           AND ((@FileCount = 1 AND @LinkCount = 0 AND @HTMLContentID IS NULL)
                OR (@LinkCount = 1 AND @FileCount = 0 AND @HTMLContentID IS NULL)
                OR  @MembersOnlyFlag = 'Y')BEGIN

          SET @NewPublishedDefaultFileName = @DefaultFileName
          
          IF UPPER(LEFT(@PostFuseURL,4)) = 'HTTP'
            SET @LinkURL = @PostFuseURL
          ELSE IF @SecureFlag = 'Y'
            SET @LinkURL = @SecureWebsiteRootURL + @PostFuseURL
          ELSE 
            SET @LinkURL = @WebsiteRootURL + @PostFuseURL

          SET @DefaultGenerated = 1
          INSERT INTO #PublishContent
                      (PublishRequestDetailID,
                       SourceLocation,
                       PublishLocation,
                       PublishDirectory,
                       Header,
                       Footer,
                       UseProtectedPath,
                       RedirectFileFlag,
                       DefaultContentFlag)
          VALUES (@InPublishRequestDetailID,
                  @LinkURL,
                  @PublishDirectory + @DefaultFileName,
                  @PublishDirectory,
                  @Header,
                  @Footer,
                  'N',
                  'Y',
                  'N')
        END

        -- This content has mix of links, html and files, create a main page to go to.
        IF @MembersOnlyFlag = 'N' AND
            (@FileCount > 1 OR @LinkCount > 1
                 OR (@HTMLContentID IS NOT NULL AND (@FileCount > 0 OR @LinkCount > 0))
                 OR (@FileCount > 0 AND @LinkCount > 0)) BEGIN
          SET @SourceLocation = @WebsiteRootURL + @PreFuseURL + '&FuseFlag=1'
          -- If DefaultFileName is specified, use it.
          IF @DefaultFileName IS NOT NULL AND @DefaultContentFlag = 'Y' AND @DefaultGenerated = 0 BEGIN
            SET @PublishLocation = @PublishDirectory + @DefaultFileName
            SET @NewPublishedDefaultFileName = @DefaultFileName
            SET @DefaultGenerated = 1
          END
          ELSE BEGIN
            SET @PublishLocation = @PublishDirectory + @URLSafeName + '.htm'
            IF @DefaultContentFlag = 'Y'
              SET @NewPublishedDefaultFileName = @URLSafeName + '.htm'
          END
          INSERT INTO #PublishContent
                      (PublishRequestDetailID,
                       SourceLocation,
                       PublishLocation,
                       PublishDirectory,
                       Header,
                       Footer,
                       UseProtectedPath,
                       DefaultContentFlag)
          VALUES (@InPublishRequestDetailID,
                  @SourceLocation,
                  @PublishLocation,
                  @PublishDirectory,
                  @Header,
                  @Footer,
                  @MembersOnlyFlag,
                  'Y')
        END
  
        -- If this content record has only Content_HTML record, set source loc & publish loc.
        IF @HTMLContentID IS NOT NULL BEGIN
          DECLARE
            @TempDefaultFlag char(1)

          IF @MembersOnlyFlag = 'Y' BEGIN
      DECLARE @MembersOnlyURL varchar(255)
            SET @MembersOnlyURL = Replace(UPPER(@PreFuseURL),UPPER('/MembersOnly.cfm'),'/CM/HTMLDisplay.cfm')
            SET @MembersOnlyURL = Replace(UPPER(@MembersOnlyURL),UPPER('/MembersOnly.aspx'),'/HTMLDisplay.aspx')
            SET @SourceLocation = @WebsiteRootURL + @MembersOnlyURL + '&FuseFlag=1'
          END
          ELSE
            SET @SourceLocation = @WebsiteRootURL + @PreFuseURL + '&FuseFlag=1'
          IF @DefaultFileName IS NOT NULL AND @DefaultContentFlag = 'Y' AND @DefaultGenerated = 0 BEGIN
            SET @PublishLocation = @PublishDirectory + @DefaultFileName
            SET @NewPublishedDefaultFileName = @DefaultFileName
            SET @DefaultGenerated = 1
            SET @TempDefaultFlag = 'Y'
          END
          ELSE BEGIN
            SET @PublishLocation = @PublishDirectory + @URLSafeName + '.htm'
            IF @DefaultContentFlag = 'Y' AND @DefaultGenerated = 0
              SET @NewPublishedDefaultFileName = @URLSafeName + '.htm'
            SET @TempDefaultFlag = 'N'
          END

          INSERT INTO #PublishContent
                      (PublishRequestDetailID,
                       SourceLocation,
                       PublishLocation,
                       PublishDirectory,
                       Header,
                       Footer,
                       HTMLContentID,
                       UseProtectedPath,
                       DefaultContentFlag)
          VALUES (@InPublishRequestDetailID,
                  @SourceLocation,
                  @PublishLocation,
                  @PublishDirectory,
                  @Header,
                  @Footer,
                  @HTMLContentID,
                  @MembersOnlyFlag,
                  @TempDefaultFlag)
        END    
      END -- Ends non-microsite Contents
    END -- @FileCount > 0 OR @LinkCount > 0 OR @HTMLContentID IS NOT NULL

    -- Finally, add files to be deleted.
    IF @PublishRegenerateInd = 'P' BEGIN
      -- If default file name has changed, add the old default file to the delete list
      IF @DefaultContentFlag = 'Y' AND @OldPublishedDefaultFileName IS NOT NULL 
        AND (IsNull(@NewPublishedDefaultFileName,'') != @OldPublishedDefaultFileName) BEGIN
        INSERT INTO #PublishContent
                    (PublishRequestDetailID,
                     PublishLocation,
                     RemoveFlag,
                     UseProtectedPath)
        VALUES (@InPublishRequestDetailID,
                @PublishedDirectory + @OldPublishedDefaultFileName,
                'Y',
                @MembersOnlyFlag)

        IF @MembersOnlyFlag = 'Y'
          INSERT INTO #PublishContent
                      (PublishRequestDetailID,
                       PublishLocation,
                       RemoveFlag,
                       UseProtectedPath)
          VALUES (@InPublishRequestDetailID,
                  @PublishedDirectory + @OldPublishedDefaultFileName,
                  'Y',
                  'Y')
      END

      -- Save the new DefaultFileName
      IF @DefaultContentFlag = 'Y' AND IsNull(@NewPublishedDefaultFileName,'') != IsNull(@OldPublishedDefaultFileName,'')
        UPDATE Nav_Menu
           SET PublishedDefaultFileName = @NewPublishedDefaultFileName
         WHERE NavMenuID = @NavMenuID

      INSERT INTO #PublishContent
                  (PublishRequestDetailID,
                   PublishLocation,
                   RemoveFlag,
                   UseProtectedPath)
      SELECT @InPublishRequestDetailID,
             a.PublishLocation,
             'Y',
             @MembersOnlyFlag
        FROM Content a WITH (NOLOCK) LEFT OUTER JOIN #PublishContent x
          ON a.PublishLocation = x.PublishLocation
       WHERE a.ContentID IN (@PreviousContentID, @ContentID)
         AND a.PublishLocation IS NOT NULL
         AND (@PreviousWebsiteKey IS NULL OR a.PublishLocation LIKE @PublishDirectory + '%')
         AND x.PublishLocation IS NULL

      INSERT INTO #PublishContent
                  (PublishRequestDetailID,
                   PublishLocation,
                   RemoveFlag,
                   UseProtectedPath)
      SELECT @InPublishRequestDetailID,
             a.PublishLocation,
             'Y',
             @MembersOnlyFlag
        FROM Content_File a WITH (NOLOCK) LEFT OUTER JOIN #PublishContent x
          ON a.PublishLocation = x.PublishLocation
       WHERE a.ContentID IN (@PreviousContentID, @ContentID)
         AND a.PublishLocation IS NOT NULL
         AND x.PublishLocation IS NULL
         AND (@PreviousWebsiteKey IS NULL OR a.PublishLocation LIKE @PublishDirectory + '%')

      -- If FilePath has been changed since the last publish, 
      -- add the folder to the delete list.
      IF @DefaultContentFlag = 'Y' AND @PublishedDirectory IS NOT NULL AND @PublishedDirectory <> @PublishDirectory
        INSERT INTO #PublishContent
                    (PublishRequestDetailID,
                     PublishDirectory,
                     DeleteFolderFlag,
                     UseProtectedPath)
        VALUES (@InPublishRequestDetailID,
                @PublishedDirectory,
                'Y',
                @MembersOnlyFlag)

      -- If Member's only flag has been changed, remove files from old location.
      IF @WorkflowStatusCode = 'A' AND IsNull(@PrevMembersOnlyFlag,'N') <> IsNull(@MembersOnlyFlag,'N')
        INSERT INTO #PublishContent
                    (PublishRequestDetailID,
                     PublishLocation,
                     RemoveFlag,
                     UseProtectedPath)
        SELECT @InPublishRequestDetailID,
               a.PublishLocation,
               'Y',
               a.MembersOnlyFlag
          FROM Content a WITH (NOLOCK)
         WHERE a.ContentID = @PreviousContentID
        UNION
        SELECT @InPublishRequestDetailID,
               a.PublishLocation,
               'Y',
               IsNull(@PrevMembersOnlyFlag,'N')
          FROM Content_File a WITH (NOLOCK)
         WHERE a.ContentID = @PreviousContentID

    END --- PublishRegenrateInd = 'P'
  END -- Approved or already published contents
  -- If delete flag is set, delete the entire directory.
  ELSE IF @InDeleteFlag = 'Y' AND @PreviousWebsiteKey IS NOT NULL BEGIN
    DECLARE
      @PreviousDirectory varchar(255)

      SELECT @PreviousDirectory = Replace(CASE WHEN @NavContentGroupInd = 'N' THEN IsNull(w.NavPublishDirectory,'')
                                          ELSE IsNull(w.ContentFolderPublishDirectory,'') END
                                     + @FilePath,'\','/')
        FROM Website w WITH (NOLOCK)
       WHERE WebsiteKey = @PreviousWebsiteKey

      INSERT INTO #PublishContent
                  (PublishRequestDetailID,
                   PublishDirectory,
                   DeleteFolderContentFlag,
                   UseProtectedPath)
      VALUES (@InPublishRequestDetailID,
              @PreviousDirectory,
              'Y',
              @MembersOnlyFlag)

      IF @MembersOnlyFlag = 'Y' AND @OldPublishedDefaultFileName IS NOT NULL
        INSERT INTO #PublishContent
                    (PublishRequestDetailID,
                     PublishDirectory,
                     DeleteFolderContentFlag,
                     UseProtectedPath)
        VALUES (@InPublishRequestDetailID,
                @PreviousDirectory,
                'Y',
                'N')
  END
  ELSE IF (@WorkflowStatusCode = 'D' OR @WorkflowStatusCode = 'R') BEGIN -- Content to Delete
    -- Delete all the files from Content, Content_HTML and Content_File.
    INSERT INTO #PublishContent
                (PublishRequestDetailID,
                 PublishLocation,
                 RemoveFlag,
                 UseProtectedPath)
    SELECT @InPublishRequestDetailID,
           PublishLocation,
           'Y',
           a.MembersOnlyFlag
      FROM Content a WITH (NOLOCK)
     WHERE ContentID = @ContentID
       AND PublishLocation IS NOT NULL

    INSERT INTO #PublishContent
                (PublishRequestDetailID,
                 PublishLocation,
                 RemoveFlag,
                 UseProtectedPath)
    SELECT @InPublishRequestDetailID,
           PublishLocation,
           'Y',
           @MembersOnlyFlag
      FROM Content_HTML a WITH (NOLOCK)
     WHERE ContentID = @ContentID
       AND PublishLocation IS NOT NULL

    INSERT INTO #PublishContent
                (PublishRequestDetailID,
                 PublishLocation,
                 RemoveFlag,
                 UseProtectedPath)
    SELECT @InPublishRequestDetailID,
           PublishLocation,
           'Y',
           @MembersOnlyFlag
      FROM Content_File a WITH (NOLOCK)
     WHERE ContentID = @ContentID
       AND PublishLocation IS NOT NULL

    -- For Member's only flag, remove default file from regular path as well.
    IF @MembersOnlyFlag = 'Y'
      INSERT INTO #PublishContent
                  (PublishRequestDetailID,
                   PublishLocation,
                   RemoveFlag,
                   UseProtectedPath)
      SELECT @InPublishRequestDetailID,
             PublishLocation,
             'Y',
             'N'
        FROM Content a WITH (NOLOCK)
       WHERE ContentID = @ContentID
         AND PublishLocation IS NOT NULL

    --If Nav_Menu record is marked for deletion, add the folder to delete list.
    IF @NavMenuWorkflowStatus = 'D' BEGIN
        INSERT INTO #PublishContent
                    (PublishRequestDetailID,
                     PublishDirectory,
                     DeleteFolderFlag)
        VALUES (@InPublishRequestDetailID,
                @PublishedDirectory,
                'Y')

       -- If member's only, we need to remove member's only directory as well.
       IF @MembersOnlyFlag = 'Y'
        INSERT INTO #PublishContent
                    (PublishRequestDetailID,
                     PublishDirectory,
                     DeleteFolderFlag,
                     UseProtectedPath)
        VALUES (@InPublishRequestDetailID,
                @PublishedDirectory,
                'Y',
                'Y')
    END
  END 
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetCurrentContents]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetCurrentContents]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure gets current contents for specified NavMenuID
--
-- Modifications
-- 09/03/2003    E.Tatsui   Created
-- =============================================

CREATE          PROCEDURE [dbo].[amsp_CMGetCurrentContents]
	@InNavMenuID numeric
AS

  DECLARE
    @ContentID numeric,
    @HTMLCount integer,
    @TaggedPageLayoutID numeric,
    @LinkCount integer,
    @FileCount integer,
    @IconFileName varchar(255),
    @FileTypeDesc varchar(255),
    @EditPage varchar(255),
    @PreFuseURL varchar(500),
    @RecycleBinID numeric

  SELECT @RecycleBinID = NavMenuID
    FROM Nav_Menu
   WHERE Name = 'Content_Recycle_Bin'

  CREATE TABLE #Contents
  (ContentID numeric,
   PreviousContentID numeric,
   NavMenuID numeric,
   Name varchar(255),
   PublishLocation varchar(255),
   ShowInTemplateFlag char(1),
   WorkflowStatusCode char(1),
   MembersOnlyFlag char(1),
   HTMLCount integer,
   TaggedPageLayoutID integer,
   LinkCount integer,
   FileCount integer,
   IconFileName varchar(255),
   FileTypeDesc varchar(255),
   EditPage varchar(255),
   PreFuseURL varchar(500))

  -- Normal folder
  IF @RecycleBinID <> @InNavMenuID 
    INSERT INTO #Contents
    SELECT ContentID,
           PreviousContentID,
           NavMenuID,
           Name,
           PublishLocation,
           ShowInTemplateFlag,
           WorkflowStatusCode,
           MembersOnlyFlag,
           (SELECT count(*) FROM Content_HTML WITH (NOLOCK) WHERE ContentID = a.ContentID),
           (SELECT TOP 1 TaggedPageLayoutID FROM Content_Link  WITH (NOLOCK) WHERE ContentID = a.ContentID),
           (SELECT Count(*) FROM Content_Link WHERE ContentID = a.ContentID),
           (SELECT Count(*) FROM Content_File WHERE ContentID = a.ContentID),
           SPACE(255),
           SPACE(255),
           SPACE(255),
           SPACE(500)
      FROM vCurrent_Content a WITH (NOLOCK)
     WHERE NavMenuID = @InNavMenuID
  ELSE  -- Recycle bin
    INSERT INTO #Contents
    SELECT a.ContentID,
           a.PreviousContentID,
           a.NavMenuID,
           a.Name,
           a.PublishLocation,
           a.ShowInTemplateFlag,
           a.WorkflowStatusCode,
           a.MembersOnlyFlag,
           (SELECT count(*) FROM Content_HTML WITH (NOLOCK) WHERE ContentID = a.ContentID),
           (SELECT TOP 1 TaggedPageLayoutID FROM Content_Link  WITH (NOLOCK) WHERE ContentID = a.ContentID),
           (SELECT Count(*) FROM Content_Link WHERE ContentID = a.ContentID),
           (SELECT Count(*) FROM Content_File WHERE ContentID = a.ContentID),
           SPACE(255),
           SPACE(255),
           SPACE(255),
           SPACE(500)
      FROM vRecycle_Bin a WITH (NOLOCK)
 
  DECLARE c_Contents CURSOR FOR 
   SELECT ContentID,
          HTMLCount,
          TaggedPageLayoutID,
          LinkCount,
          FileCount
     FROM #Contents
 
  OPEN c_Contents
  FETCH NEXT FROM c_Contents
   INTO @ContentID,
        @HTMLCount,
        @TaggedPageLayoutID,
        @LinkCount,
        @FileCount

  WHILE @@FETCH_STATUS = 0 BEGIN
    IF @TaggedPageLayoutID IS NOT NULL BEGIN
      SET @IconFileName = 'TaggedPage_icon.gif'
      SET @FileTypeDesc = 'Tagged Page'
      SET @EditPage = 'ContentProperties'
    END
    ELSE IF @HTMLCount = 1 AND @FileCount = 0 AND @LinkCount = 0 BEGIN
      SET @IconFileName = 'html_icon.gif'
      SET @FileTypeDesc = 'HTML Document'
      SET @EditPage = 'Editor' 
    END
    ELSE IF @HTMLCount = 0 AND @FileCount = 0 AND @LinkCount = 1 BEGIN
      SET @IconFileName = 'link_icon.gif'
      SET @FileTypeDesc = 'Link'
      SET @EditPage = 'ContentProperties'
    END
    ELSE IF @HTMLCount = 0 AND @FileCount = 1 AND @LinkCount = 0 BEGIN
      SELECT @IconFileName = IsNull(b.IconFileName, 'OtherType_icon.gif'),
             @FileTypeDesc = IsNull(b.FileTypeDesc, 'OtherType_icon.gif')
        FROM Content_File a, File_Type_Ref b
       WHERE a.FileTypeCode = b.FileTypeCode
         AND a.ContentID = @ContentID
      SET @EditPage = 'ContentProperties'
    END
    ELSE IF (@HTMLCount + @FileCount + @LinkCount) > 0 BEGIN
      SET @IconFileName = 'list_icon.gif'
      SET @FileTypeDesc = 'Mixed Content'
      SET @EditPage = 'ContentProperties'
    END
    ELSE  BEGIN
      SET @IconFileName = 'none_icon.gif'
      SET @FileTypeDesc = 'Not defined'
    END

    EXECUTE amsp_CMGetFuseURL @InNavMenuID, @ContentID, @PreFuseURL OUTPUT, NULL
    
    UPDATE #Contents
       SET IconFileName = @IconFileName,
           FileTypeDesc = @FileTypeDesc,
           EditPage = @EditPage,
           PreFuseURL = @PreFuseURL
     WHERE ContentID = @ContentID

    FETCH NEXT FROM c_Contents
     INTO @ContentID,
          @HTMLCount,
          @TaggedPageLayoutID,
          @LinkCount,
          @FileCount
  END

  CLOSE c_Contents
  DEALLOCATE c_Contents
  
  SELECT * FROM #Contents ORDER BY Name

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetFuturePublishPath]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetFuturePublishPath]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This is a stored procedure to get future publish path.
--
-- Modifications
-- 06/05/2003  E.Tatsui   Coverted from CFML.
-- =============================================

CREATE                     PROCEDURE [dbo].[amsp_CMGetFuturePublishPath]
	@InContentID numeric,
  @InContentFileID numeric = 0,
  @InMicrositeID numeric = 0,
  @OutPublishPath varchar(255) OUTPUT 
AS
BEGIN

  DECLARE
    @Name varchar(255),
    @TemplatePath varchar(255),
    @NavContentGroupInd char(1),
    @URLSafeName varchar(255),
    @MembersOnlyFlag char(1),
    @ShowInTemplateFlag char(1),
    @FileName varchar(255),
    @l_TemplatePath varchar(255),
    @l_PublishPath varchar(255),
    @FilePath varchar(255),
    @NavMenuID numeric,
    @NavContentDisplayPath varchar(255),
    @GECodePath varchar(255),
    @UseAspNetTemplateFlag char(1),
    @NextURLChar char(1),
    @URLParams varchar(255)

    SET @URLParams = ''

    SELECT @GECodePath = Value
      FROM System_Variable
     WHERE Name = 'GECodePath'
 
    -- If ContentFileID is passed, figure out the location.
    IF @InContentFileID > 0 BEGIN
      SELECT @Name = a.Name,
             @NavContentGroupInd = a.NavContentGroupInd,
             @TemplatePath = a.TemplatePath,
             @MembersOnlyFlag = b.MembersOnlyFlag,
             @ShowInTemplateFlag = b.ShowInTemplateFlag,
             @FileName = c.FileName,
             @FilePath = a.FilePath,
             @NavContentDisplayPath = IsNull(w.NavContentDisplayPath,''),
             @UseAspNetTemplateFlag = w.UseAspNetTemplateFlag
        FROM Nav_Menu a WITH (NOLOCK),
             Content b WITH (NOLOCK),
             Content_File c WITH (NOLOCK), Website w WITH (NOLOCK)
       WHERE b.ContentID = @InContentID
         AND b.NavMenuID = a.NavMenuID
         AND a.WebsiteKey = w.WebsiteKey
         AND b.ContentID = c.ContentID
         AND c.ContentFileID = @InContentFileID
	  
	  IF (@UseAspNetTemplateFlag = 'N') BEGIN
		  IF @NavContentGroupInd = 'C' AND @ShowInTemplateFlag = 'Y'
			SET @l_TemplatePath = @GECodePath + 'TemplateRedirect.cfm?Template='
		  ELSE IF @ShowInTemplateFlag = 'N'
			SET @l_TemplatePath = @GECodePath + 'AMTemplate.cfm?Section=' + @Name + '&Template='
		  ELSE
			SET @l_TemplatePath = @GECodePath + 'Template.cfm?Section=' + @Name + '&Template='
	  
		  IF @MembersOnlyFlag = 'Y'
			SET @l_PublishPath = @l_TemplatePath + '/MembersOnly.cfm&ContentFileID=' + CONVERT(varchar(20),@InContentFileID)
		  ELSE IF @NavContentGroupInd = 'C' AND @MembersOnlyFlag = 'N'
			SET @l_PublishPath = @l_TemplatePath + '/CM/ContentDisplay.cfm&ContentFileID=' + CONVERT(varchar(20),@InContentFileID)
		  ELSE BEGIN
			SET @l_PublishPath = '/' + REPLACE(@NavContentDisplayPath,'\','/') + @FilePath
			SET @l_PublishPath = @l_PublishPath + @FileName
		   END
	  END
	  ELSE BEGIN--- ASP.NET Template
		  SET @NextURLChar = '?'
		  IF @NavContentGroupInd = 'C' AND @ShowInTemplateFlag = 'Y'BEGIN
			SET @l_TemplatePath = @GECodePath + 'ContenManagerNet/TemplateRedirect.aspx?Template=/ContentManagerNet/'
            SET @NextURLChar = '&'
		  END
		  ELSE IF @ShowInTemplateFlag = 'N' BEGIN
			SET @l_TemplatePath = @GECodePath + 'ContentManagerNet/'
            SET @URLParams = '&Section=' + @Name + '&NoTemplate=1'
		  END
		  ELSE BEGIN
			SET @l_TemplatePath = @GECodePath + 'ContentManagerNet/'
			SET @URLParams = '&Section=' + @Name
		  END
		  IF @MembersOnlyFlag = 'Y'
			SET @l_PublishPath = @l_TemplatePath + 'MembersOnly.aspx' + @NextURLChar + 'ContentFileID=' + CONVERT(varchar(20),@InContentFileID) + @URLParams
		  ELSE IF @NavContentGroupInd = 'C' AND @MembersOnlyFlag = 'N'
			SET @l_PublishPath = @l_TemplatePath + 'ContentDisplay.aspx' + @NextURLChar + 'ContentFileID=' + CONVERT(varchar(20),@InContentFileID) + @URLParams
		  ELSE BEGIN
			SET @l_PublishPath = '/' + REPLACE(@NavContentDisplayPath,'\','/') + @FilePath
			SET @l_PublishPath = @l_PublishPath + @FileName
		   END
	END
    END
    ELSE BEGIN -- Otherwise, use asmp_CMGetFuseURL sp.  
      SELECT @NavMenuID = NavMenuID
        FROM Content WITH (NOLOCK)
       WHERE ContentID = @InContentID
      EXEC amsp_CMGetFuseURL @NavMenuID, @InContentID, NULL, @l_PublishPath OUTPUT

      IF LEFT(UPPER(@l_PublishPath),4) <> 'HTTP' AND LEFT(UPPER(@l_PublishPath),1) <> '/'
        SET @l_PublishPath = '/' + @l_PublishPath
    END
      
  SET @OutPublishPath = @l_PublishPath
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetMenuItems]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetMenuItems]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This procedure gets all the menu items to display on the admin side.
--
-- MODIFICATION HISTORY
--
-- 01/03/2001	  N.Malhotra	Simplified joins in sub-selects for DescendantCount and AuthorizedDescendantCount for Performance Reasons
-- 02/23/2002   N.Malhotra	Increased Max Sort Value to 999999999
-- 02/27/2003   R.Wenger	Added NOLOCKs to fix problems deadlocking with massive concurrency
-- 08/01/2003   E.Tatsui    Added sub query for error count. Added logic to filter out by website key.
-- 10/10/2003   E.Tatsui    Added super user logic.
-- 09/26/2005   E.Tatsui    Updated super user logic.
-- =============================================

CREATE                                  procedure amsp_CMGetMenuItems
	@ContactID numeric,
	@NavContentGroupInd char(1),
  @WebsiteKey uniqueidentifier = NULL
as
BEGIN

  DECLARE
    @AdminWebsiteKey uniqueidentifier,
    @SuperGroupID numeric

  -- Find out if this user is a member of a super group.
  SELECT @SuperGroupID = a.ContentAuthorityGroupID
    FROM Content_Authority_Group a, Content_Authority_Producer b
   WHERE a.ContentAuthorityGroupID = b.ContentAuthorityGroupID
     AND b.ContactID = @ContactID
     AND a.SuperGroupFlag = 'Y'

  SELECT DISTINCT a.*,
         b.ContentEditorFlag,
         b.ContentApproverFlag,
         b.NavCreatorFlag,
         b.NavEditorFlag,
         b.CustomPageFlag,
         b.LayoutFlag,
         b.UploadFlag,
         b.EditorFlag,
         b.ComponentScriptFlag,
         c.HideFlag AS ParentHideFlag,
        (SELECT count(*)
           FROM Nav_Menu z WITH (NOLOCK)
          WHERE (z.NavContentGroupInd = 'C' OR z.WebsiteKey = a.WebsiteKey)
            AND z.NavContentGroupInd = a.NavContentGroupInd
            AND z.WorkflowStatusCode <> 'D'
            AND z.SortOrder > a.SortOrder
            AND z.SortOrder <
               (SELECT IsNull(Min(x.SortOrder),999999999)
                  FROM Nav_Menu x
                   WITH (NOLOCK)
                 WHERE x.SortOrder > a.SortOrder
                   AND x.CategoryDepth <= a.CategoryDepth
                   AND (x.NavContentGroupInd = 'C' OR x.WebsiteKey = a.WebsiteKey)
                   AND x.NavContentGroupInd = a.NavContentGroupInd)
            AND (@SuperGroupID IS NOT NULL
             OR z.ContentAuthorityGroupID IN (SELECT ContentAuthorityGroupID
						                                    FROM Content_Authority_Producer WITH (NOLOCK)
						                                   WHERE ContactID = @ContactID))) AS AuthorizedDescendantCount,
         NULL As AncestoryHideFlag,
         (SELECT count(*)
            FROM Content z
             WITH (NOLOCK)
           WHERE z.NavMenuID = a.NavMenuID
             AND z.WorkflowStatusCode = 'W') AS WorkingContentCount,
         (SELECT count(*)
            FROM Content z
             WITH (NOLOCK)
          WHERE z.NavMenuID = a.NavMenuID
             AND (z.WorkflowStatusCode = 'Q' OR z.WorkflowStatusCode = 'E')) AS PendingContentCount,
         (SELECT count(*)
            FROM Content z
            WITH (NOLOCK)
           WHERE z.NavMenuID = a.NavMenuID
             AND z.WorkflowStatusCode = 'A') AS ApprovedContentCount,
         (SELECT Count(ContentID)
            FROM vCurrent_Content z
             WITH (NOLOCK)
           WHERE z.NavMenuID = a.NavMenuID) AS CurrentContentCount,
         (SELECT MAX(ContentID)
            FROM vCurrent_Content z
             WITH (NOLOCK)
           WHERE z.NavMenuID = a.NavMenuID
             AND (z.ContentID = a.ContentID OR z.PreviousContentID = a.ContentID)) AS WorkingContentID,
         (SELECT Count(*)
            FROM Content z WITH (NOLOCK), Publish_Request_Detail y WITH (NOLOCK), Publish_Message_Log x WITH (NOLOCK)
           WHERE z.ContentID = y.ContentID
             AND y.PublishRequestDetailID = x.PublishRequestDetailID
             AND y.PublishRequestStatusCode = 'F'
             AND z.NavMenuID = a.NavMenuID
             AND x.DisplayFlag = 'Y') AS ErrorCount
    INTO #Temp
    FROM (Nav_Menu a WITH (NOLOCK) LEFT OUTER JOIN Content_Authority_Producer b
     WITH (NOLOCK)
      ON (@SuperGroupID IS NULL AND a.ContentAuthorityGroupID = b.ContentAuthorityGroupID
	        AND b.ContactID = @ContactID)
      OR (@SuperGroupID IS NOT NULL AND b.ContentAuthorityGroupID = @SuperGroupID
	         AND b.ContactID = @ContactID))
     LEFT OUTER JOIN Nav_Menu c WITH (NOLOCK)
    ON a.ParentNavMenuID = c.NavMenuID
   WHERE a.NavContentGroupInd = @NavContentGroupInd
     AND (a.MicrositeFlag IS NULL OR a.MicrositeFlag = 'N')
     AND (a.WebsiteKey = CASE WHEN @NavContentGroupInd = 'N' THEN @WebsiteKey
                            ELSE a.WebsiteKey END
      OR a.WebsiteKey IS NULL)
     AND a.WorkflowStatusCode <> 'D'
   ORDER BY a.SortOrder

        
  SELECT @AdminWebsiteKey = Value
    FROM System_Variable WITH (NOLOCK)
   WHERE Name = 'CMAdminWebsiteKey'
     

  -- For Admin site, only show licensed components.
  IF @WebsiteKey = @AdminWebsiteKey BEGIN
    DECLARE
      @NavMenuID numeric,
      @ParentNavMenuID numeric,
      @AncestorNavMenuID numeric,
      @LoopID numeric

    DECLARE c_Inactives CURSOR FOR
    SELECT NavMenuID,
           ParentNavMenuID,
           AncestorNavMenuID
      FROM #Temp
     WHERE ComponentCode IS NOT NULL 
       AND NOT EXISTS(SELECT 1
                        FROM Component_Ref x WITH (NOLOCK)
                       WHERE #Temp.ComponentCode = x.ComponentCode
                         AND x.ActiveFlag = 'Y')
     ORDER BY SortOrder

    OPEN c_Inactives
    FETCH NEXT FROM c_Inactives
          INTO @NavMenuID,
               @ParentNavMenuID,
               @AncestorNavMenuID

    WHILE @@FETCH_STATUS = 0 BEGIN
      SET @LoopID = @ParentNavMenuID
      -- Decrement DescendantCount for all the ancestors.
      WHILE @LoopID IS NOT NULL OR @LoopID <> @AncestorNavMenuID BEGIN
        UPDATE #Temp
           SET DescendantCount = DescendantCount -1
         WHERE NavMenuID = @LoopID

        SELECT @LoopID = ParentNavMenuID
          FROM #Temp
         WHERE NavMenuID = @LoopID

        IF @LoopID IS NULL OR @@RowCount = 0 
          BREAK
      END

      DELETE FROM #Temp
       WHERE NavMenuID = @NavMenuID

      FETCH NEXT FROM c_Inactives
            INTO @NavMenuID,
                 @ParentNavMenuID,
                 @AncestorNavMenuID
    END
    CLOSE c_Inactives
    DEALLOCATE c_Inactives
  END

  SELECT a.*,
         CASE WHEN c.ContentID IS NOT NULL THEN 'Y'
         ELSE 'N' END AS HTMLContentFlag
    FROM #Temp a LEFT OUTER JOIN Content b  WITH (NOLOCK)
      ON a.WorkingContentID = b.ContentID
    LEFT OUTER JOIN Content_HTML c  WITH (NOLOCK)
      ON b.ContentID = c.ContentID
   ORDER BY a.SortOrder

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetMissingTagContent]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetMissingTagContent]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- Stored Procedure to get all the content records from content fodlers that do not have
-- any tags associated.
--
-- 10/11/2003   E.Tatsui   Created
-- =============================================

CREATE     PROCEDURE amsp_CMGetMissingTagContent
  @InNavMenuID numeric = NULL,
  @InContentID numeric = NULL,
  @InContactID numeric,
  @InIncludeDescendants char(1) = 'N'
AS
BEGIN
  DECLARE
    @NavMenuID numeric,
    @MaxSort numeric(28,18),
    @MinSort numeric(28,18),
    @SuperUserFlag bit

  -- Find out if this user is a member of a super group as a nav creator or editor.
  SET @SuperUserFlag = 0
  SELECT @SuperUserFlag = 1
    FROM Content_Authority_Group a WITH (NOLOCK), Content_Authority_Producer b WITH (NOLOCK)
   WHERE a.ContentAuthorityGroupID = b.ContentAuthorityGroupID
     AND b.ContactID = @InContactID
     AND (b.NavCreatorFlag = 'Y' OR b.NavEditorFlag = 'Y')
     AND a.SuperGroupFlag = 'Y'

  IF @InContentID IS NOT NULL
    SELECT @NavMenuID = NavMenuID
      FROM Content WITH (NOLOCK)
     WHERE ContentID = @InContentID

  ELSE IF @InNavMenuID IS NOT NULL AND @InIncludeDescendants  = 'Y'
    SELECT @MinSort = a.SortOrder,
           @MaxSort = (SELECT IsNull(Min(x.SortOrder),0)
              FROM Nav_Menu x
              WITH (NOLOCK)
             WHERE x.SortOrder > a.SortOrder
               AND x.CategoryDepth <= a.CategoryDepth)
      FROM Nav_Menu a  WITH (NOLOCK)
     WHERE a.NavMenuID = @InNavMenuID
 ELSE
   SET @NavMenuID = @InNavMenuID

  -- Get all the content records w/o tags the user is authorized to publish.
  IF @SuperUserFlag = 1
    SELECT a.ContentID,
           a.Name,
           c.Title,
           c.NavMenuID
      FROM vCurrent_Content a WITH (NOLOCK) 
      LEFT OUTER JOIN Component_Interest_Category b WITH (NOLOCK)
        ON a.ContentID = b.ComponentID
       AND b.ComponentCode = 'CM', Nav_Menu c WITH (NOLOCK)
     WHERE a.WorkflowStatusCode IN ('P','A')
       AND a.NavMenuID = c.NavMenuID
       AND c.NavContentGroupInd = 'C'
       AND b.ComponentID IS NULL
       AND ((@NavMenuID IS NOT NULL AND a.NavMenuID = @NavMenuID)
            OR (@NavMenuID IS NULL 
                AND c.SortOrder >= @MinSort
                AND c.SortOrder < @MaxSort))
      ORDER BY c.SortOrder, a.SortOrder
  ELSE
    SELECT a.ContentID,
           a.Name,
           c.Title,
           c.NavMenuID
      FROM vCurrent_Content a WITH (NOLOCK) 
      LEFT OUTER JOIN Component_Interest_Category b WITH (NOLOCK)
        ON a.ContentID = b.ComponentID
       AND b.ComponentCode = 'CM', Nav_Menu c WITH (NOLOCK),
           Content_Authority_Producer d
     WHERE a.WorkflowStatusCode IN ('P','A')
       AND a.NavMenuID = c.NavMenuID
       AND c.NavContentGroupInd = 'C'
       AND b.ComponentID IS NULL
       AND c.ContentAuthorityGroupID = d.ContentAuthorityGroupID
       AND d.ContactID = @InContactID
       AND (d.NavCreatorFlag = 'Y' OR d.NavEditorFlag = 'Y')
       AND ((@NavMenuID IS NOT NULL AND a.NavMenuID = @NavMenuID)
            OR (@NavMenuID IS NULL 
                AND c.SortOrder >= @MinSort
                AND c.SortOrder < @MaxSort))
      ORDER BY c.SortOrder, a.SortOrder
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetPublishableDescendants]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetPublishableDescendants]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure gets descendatns for nav item.
--
-- Modifications
-- 06/11/2003    E.Tatsui   Created
-- =============================================

CREATE   PROCEDURE amsp_CMGetPublishableDescendants
  @InNavMenuID numeric,
  @InContactID numeric
AS
BEGIN

  DECLARE 
    @MaxSort numeric(28,18),
    @MinSort numeric(28,18),
    @SuperUserFlag bit

  SET @SuperUserFlag = 0
  -- First, find out if this user is a member of a super group as a nav creator or editor.
  SELECT @SuperUserFlag = 1
    FROM Content_Authority_Group a, Content_Authority_Producer b
   WHERE a.ContentAuthorityGroupID = b.ContentAuthorityGroupID
     AND b.ContactID = @InContactID
     AND (b.NavCreatorFlag = 'Y' OR b.NavEditorFlag = 'Y')
     AND a.SuperGroupFlag = 'Y'

  SELECT @MinSort = a.SortOrder,
         @MaxSort = (SELECT IsNull(Min(x.SortOrder),0)
            FROM Nav_Menu x
            WITH (NOLOCK)
           WHERE x.SortOrder > a.SortOrder
             AND x.CategoryDepth <= a.CategoryDepth)
    FROM Nav_Menu a  WITH (NOLOCK)
   WHERE a.NavMenuID = @InNavMenuID

  -- Super admin can publish anything.
  IF @SuperUserFlag = 1
    SELECT a.NavMenuID,
           a.Title,
           a.CategoryDepth,
           (SELECT count(*)
              FROM Content z WITH (NOLOCK)
             WHERE z.NavMenuID = a.NavMenuID
               AND (z.PublishDateTime IS NULL OR z.PublishDateTime < CURRENT_TIMESTAMP)
               AND (z.WorkflowStatusCode = 'A' OR z.WorkflowStatusCode = 'P')) AS ContentCount
      FROM Nav_Menu a WITH (NOLOCK)
     WHERE a.SortOrder > @MinSort
       AND a.SortOrder < @MaxSort
       AND a.WorkflowStatusCode <> 'D'
     ORDER BY a.SortOrder
  ELSE -- Everyone else needs to worry about which group they belong.
    SELECT a.NavMenuID,
           a.Title,
           a.CategoryDepth,
           (SELECT count(*)
              FROM Content z WITH (NOLOCK)
             WHERE z.NavMenuID = a.NavMenuID
               AND (z.PublishDateTime IS NULL OR z.PublishDateTime < CURRENT_TIMESTAMP)
               AND (z.WorkflowStatusCode = 'A' OR z.WorkflowStatusCode = 'P')) AS ContentCount
      FROM Nav_Menu a WITH (NOLOCK), Content_Authority_Producer b WITH (NOLOCK)
     WHERE a.ContentAuthorityGroupID = b.ContentAuthorityGroupID
       AND b.ContactID = @InContactID
       AND (b.NavCreatorFlag = 'Y' OR b.NavEditorFlag = 'Y')
       AND a.SortOrder > @MinSort
       AND a.SortOrder < @MaxSort
       AND a.WorkflowStatusCode <> 'D'
     ORDER BY a.SortOrder

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetPublishableNavMenu]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetPublishableNavMenu]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure gets descendatns for nav item.
--
-- Modifications
-- 06/11/2003    E.Tatsui   Created
-- =============================================

CREATE PROCEDURE amsp_CMGetPublishableNavMenu
  @InNavMenuID numeric,
  @InContactID numeric
AS
BEGIN

  DECLARE 
    @MaxSort numeric(28,18),
    @MinSort numeric(28,18)

  SELECT @MinSort = a.SortOrder,
         @MaxSort = (SELECT IsNull(Min(x.SortOrder),0)
            FROM Nav_Menu x
            WITH (NOLOCK)
           WHERE x.SortOrder > a.SortOrder
             AND x.CategoryDepth <= a.CategoryDepth)
    FROM Nav_Menu a
   WHERE a.NavMenuID = @InNavMenuID

  SELECT a.NavMenuID,
         a.Title,
         a.CategoryDepth,
         (SELECT count(*)
            FROM Content z WITH (NOLOCK)
           WHERE z.NavMenuID = a.NavMenuID
             AND (z.PublishDateTime IS NULL OR z.PublishDateTime < CURRENT_TIMESTAMP)
             AND (z.WorkflowStatusCode = 'A' OR z.WorkflowStatusCode = 'P')) AS ContentCount
    FROM Nav_Menu a WITH (NOLOCK), Content_Authority_Producer b WITH (NOLOCK)
   WHERE a.ContentAuthorityGroupID = b.ContentAuthorityGroupID
     AND b.ContactID = @InContactID
     AND (b.NavCreatorFlag = 'Y' OR b.NavEditorFlag = 'Y')
     AND a.SortOrder > @MinSort
     AND a.SortOrder < @MaxSort
   ORDER BY a.SortOrder

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetPublishedContentID]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetPublishedContentID]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/**************************************************************
** Finds the version of the content that is published.
**
**
***************************************************************
*/


CREATE    PROCEDURE amsp_CMGetPublishedContentID
    @InContentID numeric,
    @OutContentID numeric OUTPUT,
    @InFuseFlag Numeric = 0
AS
BEGIN
  DECLARE
    @MyWorkflowStatusCode char(1),
    @ParentWorkflowStatusCode char(1),
    @ChildWorkflowStatusCode char(1),
    @ChildContentID numeric,
    @ParentContentID numeric,
    @Counter integer
    
  -- Initialize our return code
  SET @OutContentID = 0
   
  -- First, figure out if this one is published, or there is one that is published associated
  -- with this one.
  SELECT @MyWorkflowStatusCode = a.WorkflowStatusCode, 
         @ParentContentID = a.PreviousContentID,
         @ParentWorkflowStatusCode = c.WorkflowStatusCode, 
         @ChildContentID = b.ContentID, 
         @ChildWorkflowStatusCode = b.WorkflowStatusCode
    FROM (Content a LEFT OUTER JOIN Content b ON a.ContentID = b.PreviousContentID)
         LEFT OUTER JOIN Content c ON a.PreviousContentID = c.ContentID
   WHERE a.ContentID = @InContentID
   
  -- If the status of the contentID sent in is P for Published, just return it
  -- IK: Check for @InFuseFlag to handle "Approved" status for fusing.
  IF @MyWorkflowStatusCode = 'P' OR (@InFuseFlag = '1' AND @MyWorkflowStatusCode = 'A')
    SET @OutContentID = @InContentID
  ELSE
    BEGIN
      -- Otherwise, if the status of the Parent is P for Published, return the Parent's ID
      -- this should occur if the current one is working
      IF @ParentWorkflowStatusCode = 'P'
        SET @OutContentID = @ParentContentID
      ELSE
        BEGIN
          -- Otherwise, if there is a child, check it's status
          IF @ChildWorkflowStatusCode = 'P'
            SET @OutContentID = @ChildContentID
          ELSE BEGIN
            -- Otherwise, if there is a child, it must have or need a child, so loop
            -- To make sure a bad content list doesn't lock the server, we also
            -- limit this to 50 iterations.
            SET @Counter = 0
              
            WHILE (@ChildWorkflowStatusCode IS NOT NULL AND @OutContentID = 0 AND @Counter < 50) BEGIN
              SET @Counter = @Counter + 1
              SELECT @ChildWorkflowStatusCode = WorkflowStatusCode,
                     @ChildContentID = ContentID
                FROM Content
               WHERE PreviousContentID = @ChildContentID
               
              IF (@@RowCount = 1) BEGIN
                IF (@ChildWorkflowStatusCode = 'P') BEGIN
                  SET @OutContentID = @ChildContentID
                END
              END
            END
          END
        END
    END
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetPublishingServer]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetPublishingServer]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- SP to get publishing server information based on the information provided.
--
-- Modifications
-- 06/20/2003    E.Tatsui    Created
-- =============================================
CREATE   PROCEDURE amsp_CMGetPublishingServer 
	@InServerCode char(1),
	@InIPAddress varchar(15),
	@InPollRequestInd char(1)

AS

BEGIN
   
  SELECT *
    FROM Publish_Server_Ref
   WHERE PublishServerCode = @InServerCode
     AND ServerIPAddress = @InIPAddress
     AND PollRequestInd = @InPollRequestInd;

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetPublishRequests]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetPublishRequests]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- Gets publishing requests that need to be executed.
--
-- Modifications
-- 06/05/2003  E.Tatsui   Converted from CFML.
-- =============================================

CREATE                                 PROCEDURE [dbo].[amsp_CMGetPublishRequests]
  @InServerCode char(1),
  @InServerIPAddress varchar(15),
  @InPublishRegenerateInd char(1)
AS

BEGIN

  DECLARE
    @PublishRequestDetailID numeric,
    @GECodePath varchar(255),
    @DeleteFlag char(1),
    @PublishingSpeed int,
    @RequestNum int,
    @SQL nvarchar (2500)

  SET @PublishingSpeed = 100

  SELECT @PublishingSpeed = PublishingSpeed
    FROM Publish_Server_Ref
   WHERE PublishServerCode = @InServerCode

  CREATE TABLE #PublishRequests
  (NextPublishDate datetime,
   PublishRequestID integer,
   PublishRequestDetailID integer,
   ContentID integer,
   SourceRootLocation varchar(255) COLLATE database_default,
   PublishRootPath varchar(255) COLLATE database_default,
   ProtectedRootPath varchar(255) COLLATE database_default,
   PublishRegenerateInd char(1) COLLATE database_default,
   WebsiteKey uniqueidentifier,
   ReloadMenuURL varchar(255) COLLATE database_default,
   DefaultServerFlag char(1) COLLATE database_default,
   DeleteFlag char(1) COLLATE database_default,
   PublishPriorityCode smallint)

  -- SET ROWCOUNT @PublishingSpeed
  SET @SQL = 'INSERT INTO #PublishRequests 
         SELECT TOP ' + CAST(@PublishingSpeed as varchar(20)) + 
         ' DATEADD(second, prd.Frequency, prd.PublishedDateTime) AS NextPublishDate, 
         pr.PublishRequestID,
         prd.PublishRequestDetailID, 
         Convert(int,prd.ContentID),
         psr.SourceRootLocation,
         w.PublishRootPath,
         w.ProtectedRootPath,
         prd.PublishRegenerateInd,
         w.WebsiteKey,
         w.WebsiteRootURL,
         ''Y'',
         prd.DeleteFlag,
         pr.PublishPriorityCode
    FROM Publish_Request pr WITH (NOLOCK), Publish_Request_Detail prd WITH (NOLOCK),
         Website w WITH (NOLOCK), Publish_Server_Ref psr WITH (NOLOCK), Content c
   WHERE pr.PublishRequestID = prd.PublishRequestID
     AND prd.WebsiteKey = w.WebsiteKey
     AND prd.PublishServerCode = psr.PublishServerCode
     AND prd.PublishRequestID = pr.PublishRequestID
     AND prd.ContentID = c.ContentID
     AND (c.PublishDateTime IS NULL OR c.PublishDateTime < GetDate())
     AND (prd.PublishRequestStatusCode = ''N''
          OR ((DATEADD(second, prd.Frequency, prd.PublishedDateTime) <= GetDate())
               AND (prd.Frequency <> 0))
          )
     AND pr.RequestDateTime <= GetDate()
     AND psr.ServerIPAddress = ''' + @InServerIPAddress + '''' + 
    'AND psr.PublishServerCode = ''' + @InServerCode + '''' + 
    'AND IsNull(prd.PublishRegenerateInd,''P'') = ''' + @InPublishRegenerateInd + '''' + 
  'ORDER BY pr.PublishPriorityCode, NextPublishDate, prd.PublishRequestDetailID'

  --print @SQL

  EXEC sp_executesql @SQL

  SET @RequestNum = @@Rowcount

  --SET ROWCOUNT 0

  ALTER TABLE #PublishRequests
  ALTER COLUMN PublishRequestDetailID int NULL

  ALTER TABLE #PublishRequests
  ALTER COLUMN ReloadMenuURL varchar(500) COLLATE database_default

  -- If this is publish requests, add requests to publish navigaiton.
  IF @InPublishRegenerateInd = 'P' AND @RequestNum < @PublishingSpeed
     INSERT INTO #PublishRequests
     SELECT  NULL AS NextPublishDate, 
             pr.PublishRequestID,
             NULL, 
             NULL AS ContentID,
             psr.SourceRootLocation,
             w.PublishRootPath,
             w.ProtectedRootPath,
             'P',
             w.WebsiteKey,
             w.WebsiteRootURL,
             'Y' AS DefaultServerFlag,
             'N' AS DeleteFlag,
             pr.PublishPriorityCode
        FROM Publish_Request pr WITH (NOLOCK) LEFT OUTER JOIN Publish_Request_Detail prd WITH (NOLOCK)
          ON pr.PublishRequestID = prd.PublishRequestID
         AND IsNull(prd.PublishRegenerateInd,'P') = 'P'
        LEFT OUTER JOIN Publish_Message_Log pml WITH (NOLOCK)
          ON pr.PublishRequestID = pml.PublishRequestID, Nav_Menu nm WITH (NOLOCK),
             Website w WITH (NOLOCK), Publish_Server_Ref psr WITH (NOLOCK)
       WHERE pr.NavMenuID = nm.NavMenuID
         AND nm.WebsiteKey = w.WebsiteKey
         AND w.PublishServerCode = psr.PublishServerCode
         AND (pr.PublishedDateTime is NULL)
         AND pr.RequestDateTime <= GetDate()
         AND psr.ServerIPAddress = @InServerIPAddress
         AND psr.PublishServerCode = @InServerCode
         AND prd.PublishRequestID IS NULL
         AND pml.PublishRequestID IS NULL

  SELECT @GECodePath = Value
    FROM System_Variable WITH (NOLOCK)
   WHERE Name = 'GECodePath'

  IF Len(@GECodePath) > 1
    SET @GECodePath = RIGHT(@GECodePath,Len(@GECodePath)-1)
  ELSE IF @GECodePath = '/'
    SET @GECodePath = ''

  UPDATE #PublishRequests
     SET ReloadMenuURL = ReloadMenuURL + @GECodePath + 'NavMenuSetup.cfm'

  CREATE TABLE #PublishContent
               (PublishRequestDetailID numeric,
                SourceLocation varchar(255) COLLATE database_default,
                PublishLocation varchar(255) COLLATE database_default,
                PublishDirectory varchar(255) COLLATE database_default,
                Header varchar(500) COLLATE database_default,
                Footer varchar(500) COLLATE database_default,
                ContentFileID int,
                HTMLContentID int,
                DefaultContentFlag char(1) DEFAULT('N') COLLATE database_default,
                RemoveFlag char(1) DEFAULT('N') COLLATE database_default,
                UseProtectedPath char(1) DEFAULT ('N') COLLATE database_default,
                RedirectFileFlag char(1) DEFAULT('N') COLLATE database_default,
                DeleteFolderFlag char(1) DEFAULT ('N') COLLATE database_default,
                DeleteFolderContentFlag char(1) DEFAULT('N') COLLATE database_default)

  DECLARE c_Request CURSOR FOR
   SELECT PublishRequestDetailID,
          DeleteFlag
     FROM #PublishRequests

  OPEN c_Request
  FETCH NEXT FROM c_Request
   INTO @PublishRequestDetailID,
        @DeleteFlag
  WHILE @@FETCH_STATUS = 0 BEGIN
    EXEC amsp_CMGetContentToPublish @PublishRequestDetailID, @DeleteFlag

    FETCH NEXT FROM c_Request
     INTO @PublishRequestDetailID,
          @DeleteFlag
  END
  CLOSE c_Request
  DEALLOCATE c_Request

  SELECT DISTINCT 
         a.WebsiteKey,
         a.NextPublishDate,
         a.PublishRequestID,
         a.PublishRequestDetailID,
         a.ContentID,
         a.SourceRootLocation,
         CASE WHEN b.UseProtectedPath = 'Y' THEN a.ProtectedRootPath
              ELSE a.PublishRootPath END AS PublishRootPath,
         a.PublishRegenerateInd,
         a.WebsiteKey,
         a.ReloadMenuURL,
         a.DefaultServerFlag,
         a.PublishPriorityCode,
         b.SourceLocation,
         b.PublishLocation,
         b.PublishDirectory,
         b.Header,
         b.Footer,
         b.ContentFileID,
         b.HTMLContentID,
         b.DefaultContentFlag,
         b.RemoveFlag,
         b.RedirectFileFlag,
         b.DeleteFolderFlag,
         b.DeleteFolderContentFlag,
         b.PublishRequestDetailID AS ContentExists
    FROM #PublishRequests a LEFT OUTER JOIN #PublishContent b
      ON a.PublishRequestDetailID = b.PublishRequestDetailID
  ORDER BY a.PublishPriorityCode, NextPublishDate, a.PublishRequestID, a.PublishRequestDetailID, b.RemoveFlag DESC, b.DefaultContentFlag
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetUniqueDirectoryName]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetUniqueDirectoryName]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure creates a unique directory name for a specified nav menu record
--
-- Modifications
-- 08/22/2003    E.Tatsui
-- =============================================

CREATE          PROCEDURE amsp_CMGetUniqueDirectoryName
  @InNavMenuID numeric,
  @InUpdate bit = 0,
  @OutDirectoryName varchar(255) OUTPUT
AS
BEGIN

  DECLARE
    @CategoryDepth integer,
    @ParentNavMenuID numeric,
    @DirectoryName varchar(255),
    @Title varchar(255),
    @RowNum integer,
    @WebsiteKey uniqueidentifier,
    @Counter integer,
    @Temp varchar(255),
    @Index int,
    @Ascii int

  SELECT @ParentNavMenuID = ParentNavMenuID,
         @CategoryDepth = CategoryDepth,
         @DirectoryName = DirectoryName,
         @Title = Title,
         @WebsiteKey = WebsiteKey
    FROM Nav_Menu WITH (NOLOCK)
   WHERE NavMenuID = @InNavMenuID

  -- If directory name is not provided, let's create it from name.
  IF @DirectoryName IS NULL BEGIN
    SET @DirectoryName = @Title
  END

  -- Remove special characters (Everything except for 0-9,a-z,A-Z,and "_")
  SET @Index = 0
  SET @Temp = ''
  WHILE @Index < = LEN(@DirectoryName) BEGIN
    SET @Index = @Index + 1
    SET @Ascii = ASCII(SUBSTRING(@DirectoryName,@Index,1)) 
    IF (@Ascii between 48 and 57 )
       or(@Ascii between 65 and 90)
       or(@Ascii = 95)
       or(@Ascii between 97 and 122)
     SET @Temp = @Temp + Substring(@DirectoryName,@Index,1)
  END
  SET @DirectoryName = @Temp
 
  SET @DirectoryName = Left(@DirectoryName,100)
  
  -- Now find out if this DirectoryName is unique.
  IF @CategoryDepth = 1 BEGIN

    -- For level ones, it needs to be unique regardless of nav item or content folder.
    SELECT @RowNum = COUNT(*)
      FROM Nav_Menu WITH (NOLOCK)
     WHERE DirectoryName = @DirectoryName
       AND WebsiteKey = @WebsiteKey
       AND CategoryDepth = 1
       AND NavMenuID <> @InNavMenuID

    -- If we find a record with the same directory name, let's append a number at the end.    
    SET @Counter = 0
    WHILE @RowNum > 0 BEGIN
      SET @Counter = @Counter + 1
      SELECT @RowNum = COUNT(*)
        FROM Nav_Menu WITH (NOLOCK)
       WHERE DirectoryName = @DirectoryName + Cast(@Counter as varchar(255))
         AND WebsiteKey = @WebsiteKey
         AND CategoryDepth = 1
         AND NavMenuID <> @InNavMenuID
      SET @Counter = @Counter + 1
    END    
    
    IF @Counter > 0
      SET @OutDirectoryName = @DirectoryName + Cast(@Counter as varchar(255))
    ELSE
      SET @OutDirectoryName = @DirectoryName
  END --Ends Level 1s.
  ELSE BEGIN -- For all others, it needs to be unique between sibilings.

    -- For level ones, it needs to be unique regardless of nav item or content folder.
    SELECT @RowNum = COUNT(*)
      FROM Nav_Menu WITH (NOLOCK)
     WHERE DirectoryName = @DirectoryName
       AND WebsiteKey = @WebsiteKey
       AND CategoryDepth = @CategoryDepth
       AND ParentNavMenuID = @ParentNavMenuID
       AND NavMenuID <> @InNavMenuID

    -- If we find a record with the same directory name, let's append a number at the end.    
    SET @Counter = 0
    WHILE @RowNum > 0 BEGIN
      SET @Counter = @Counter + 1
      SELECT @RowNum = COUNT(*)
        FROM Nav_Menu WITH (NOLOCK)
       WHERE DirectoryName = @DirectoryName + Cast(@Counter as varchar(255))
         AND WebsiteKey = @WebsiteKey
         AND CategoryDepth = @CategoryDepth
         AND ParentNavMenuID = @ParentNavMenuID
         AND NavMenuID <> @InNavMenuID
    END    
    
    IF @Counter > 0
      SET @OutDirectoryName = @DirectoryName + Cast(@Counter as varchar(255))
    ELSE
      SET @OutDirectoryName = @DirectoryName
  END -- Ends all other levels.

  -- If "Update" is 1, and the directory name changed, update it.
  IF @InUpdate = 1
    UPDATE Nav_Menu
       SET DirectoryName = @OutDirectoryName
     WHERE NavMenuID = @InNavMenuID

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMNavMenuSetup]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMNavMenuSetup]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE           procedure [dbo].[amsp_CMNavMenuSetup] 

@WebsiteKey uniqueidentifier = null, 
@NavContentGroupInd char(1) = 'N', @Runtime bit = 0

AS
BEGIN

/*
** MODIFICATION HISTORY
**
**    01/02/2001  N.Malhotra  Changed c_ChildNav to use #NavMenu instead of Nav_Menu
**    01/04/2002  E.Tatsui  Added logic for MicrositeFlag
**    01/22/2002  N.Malhotra  Added logic to keep level 1's dynamic
**    01/28/2002  N.Malhotra  Added @InFuseNavMenuID - If provided, the sp is being called to 
**                      calculate the lowest CategoryDepth value where a difference exists
**                      between the current and previous publish operation for the same level 1
**    02/14/2002    N.Malhotra  Changed logic on how PrefuseURL is generated for content with a single link
**    02/23/2002  N.Malhotra  Added indexes to #NavMenu for performance
**    03/04/2002  N.Malhotra  Fixed problem with single link content records where .HTM files were being 
**                      displayed using AMTemplate
**    03/06/2002  N.Malhotra  Deprecated retrieval of app vars to pre 4.1 versions only
**    04/09/2002  N.Malhotra  Added @App_RootPath or @App_SecurePath to beginning of all PostFuseURL values
**    04/11/2002  N.Malhotra  Changed base SQL statement from PublishedDateTime < CURRENT_TIMESTAMP to 
**                      PublishedDateTime <= CURRENT_TIMESTAMP
**    04/12/2002    E.Pfleckl Changed variable and column names for compatibility with case-sensitive DBs
**    10/22/2002    C.Jewell    Changed PreFuseURL for content consisting of a single file to coincide with
**                          Source folder consolidation.
**    01/03/2003    C.Jewell  Added logic for Members Only content to be displayed outside of the template
**    02/13/2003        R.Wenger        Rewrote logic that figures out what content needs to be regenerated, if InNavMenuID is passed.
**                                      It used to just return the category depth below which all content needs to be
**                                      regenerated (see Nitin's note 1/28/2002 above).  Now it returns a result set of all
**                                      nav items that need regeneration. The ended up doing too many
**    03/28/2003        E.Tatsui        Changed so that amsp_SetNavProperties is not run when the sp is run to get modified contents.
**    05/12/2003        E.Tatsui        Changed so that http:// is not appended when URL includes [TemplatePath]
**    05/28/2003        E.Tatsui        Replaced [TemplatePath] solution with /TemplateRedirect.cfm
**    06/18/2003        E.Tatsui        Removed input parameters and simplified the procedure.
**                                      - PostFuseURLs and PreFuseURLS are now stored in the Database.
**                                      - Logic to look for modified nav menus are moved to amsp_CMGetNavMenuToRegenerate
**                                      Limit the result to Navigation items.
**    09/12/2003         R.Wenger     Added @WebsiteKey parameter and code that filters the result set by the websitekey, for use in CM6
**                                                    Added @Runtime parameter and code that filters the result set by whether hidden things need to be included
**                                                   (they don't at runtime, just at design time)
**    10/12/2003       E.Tatsui        Removed a call to amsp_CMSetNavProperties. AncestoryList is stored in Nav_Menu table now.
**    06/09/2006    R.Wenger    Added  COLLATE database_default NULL to the alter table line on the temp
**                    table #Nav_Menu because if the default collation of the system (i.e., in the temp DB
**                    is different that that of this db, the alter will use the temp db's collation.                                
*/

  DECLARE
    @AncestoryHideFlag    char(1),
    @AncestoryNotPublishedFlag  char(1),
    @TemplatePath   varchar(255),
    @CategoryDepth    integer,
    @Name     varchar(255),
    @AncestoryList    varchar(255),
    @ChildNavMenuID        numeric,
    @NumChildren           numeric,
    @ContentID      numeric,
    @NavMenuID      numeric,
    @OldNavMenuID   numeric,
    @ParentNavMenuID    numeric,
    @OldPreFuseURL    varchar(255),
    @PreFuseURL     varchar(255),
    @PostFuseURL    varchar(255),
    @URLParamChar   char(1),
    @GECodePath    varchar(255),
    @AdminWebsiteKey varchar(50),
    @VirtualDirectoryPath varchar(255)

  /*
  ** Gets the currrent, published Nav_Menu into a temp table for use by the template. 
  ** This script reads the info into the table, and adds a few columns that it calculates
  ** to make the template's job a lot easier.
  */

  SELECT a.*,
         e.ImageInitial,
         e.ImageOther,
         e.ImageRollover,
         e.BreadCrumb,
         e.ImageWidth,
         e.ImageHeight,
         b.HideFlag AS ParentHideFlag,
         b.PublishedDateTime AS ParentPubValue,
         b.Name AS ParentName,
         c.ShowInTemplateFlag,
         c.OpenInNewWindowFlag,
         c.SecureFlag AS ContentSecureFlag,
         a.HideFlag AS AncestoryHideFlag,
         'N' AS AncestoryNotPublishedFlag,
         w.WebsiteRootURL,
         w.SecureWebsiteRootURL,
         w.GraphicsDirectory,
         w.TemplateHeaderFileName,
         w.TemplateFooterFileName,
         w.SiteStyleSheet,
         w.UseHierMenuFlag,
         w.ShowBreadCrumbFlag,
     w.UseAspNetTemplateFlag
    INTO #NavMenu
    FROM ((((Nav_Menu a WITH (NOLOCK)
         LEFT OUTER JOIN Nav_Menu b WITH (NOLOCK) ON a.ParentNavMenuID = b.NavMenuID) 
         LEFT OUTER JOIN Content c WITH (NOLOCK) ON a.ContentID = c.ContentID AND c.WorkflowStatusCode = 'P' 
          AND c.PublishDateTime <= CURRENT_TIMESTAMP AND (c.ExpirationDate >= CURRENT_TIMESTAMP
           OR c.ArchiveAtExpirationFlag IS NULL OR c.ArchiveAtExpirationFlag = 'N'))
         LEFT OUTER JOIN Content_HTML d WITH (NOLOCK)  ON c.ContentID = d.ContentID)
         LEFT OUTER JOIN Nav_Menu_Feature e WITH (NOLOCK) ON a.NavMenuID = e.NavMenuID),
         Website w
   WHERE ((a.NavContentGroupInd = 'N' AND a.PublishedDateTime <= CURRENT_TIMESTAMP)
      OR a.NavContentGroupInd = 'C')
     AND (a.MicrositeFlag = 'N' OR a.MicrositeFlag IS NULL)
     AND a.WebsiteKey = w.WebsiteKey
     AND a.NavContentGroupInd = @NavContentGroupInd
   ORDER BY a.NavContentGroupInd DESC, a.SortOrder

  ALTER TABLE #NavMenu
  ALTER Column PostFuseURL varchar(500) COLLATE database_default NULL

  -- For admin template, delete any products that are not licensed.
  SELECT @AdminWebsiteKey = Value
    FROM System_Variable WITH (NOLOCK)
   WHERE Name = 'CMAdminWebsiteKey'

   DELETE FROM #NavMenu
   WHERE WebsiteKey = @AdminWebsiteKey
     AND ComponentCode IS NOT NULL
     AND ComponentCode NOT IN (SELECT ComponentCode FROM Component_Ref WITH (NOLOCK) WHERE ActiveFlag = 'Y')

  /*
  ** Performance Boost
  */

  CREATE INDEX #IDX1 on #NavMenu(NavMenuID)
  CREATE INDEX #IDX2 on #NavMenu(ParentNavMenuID)
 
 /*
  ** Loop through Nav_Menu determine the URL each nav menu item points to. 
  */
  
  DECLARE c_Nav CURSOR FOR 
    SELECT Name,
           ContentID,
           NavMenuID,
           ParentNavMenuID,
           PreFuseURL,
           PostFuseURL
      FROM #NavMenu
     WHERE IsNull(HideFlag,'N') = 'N'
     ORDER BY SortOrder
  
  OPEN c_Nav

  FETCH NEXT FROM c_Nav INTO
    @Name,
    @ContentID,
    @NavMenuID,
    @ParentNavMenuID,
    @PreFuseURL,
    @PostFuseURL
    
  SET @OldPreFuseURL = 'NOT INITIALIZED'

  WHILE (@@FETCH_STATUS=0)
  BEGIN


    /*
    ** also, as long as we are looping through here, determine if the menu item has
    ** a place to link to.  If not, determine if he has a descendant.  If so, copy
    ** the link info from his first descendant. But don't do it for the last item in
    ** the query, it has no children.
    */

    IF (CHARINDEX('MissingInclude',@OldPreFuseURL) > 0 AND 
        @ParentNavMenuID = @OldNavMenuID AND
        CHARINDEX('MissingInclude',@PreFuseURL) =0) 
    BEGIN

      UPDATE #NavMenu
         SET PreFuseURL = @PreFuseURL,
             PostFuseURL = @PostFuseURL
       WHERE NavMenuID = @OldNavMenuID
    END

    SET @OldPreFuseURL = @PreFuseURL
    SET @OldNavMenuID = @NavMenuID

    FETCH NEXT FROM c_Nav 
      INTO
      @Name,
      @ContentID,
      @NavMenuID,

      @ParentNavMenuID,
      @PreFuseURL,
      @PostFuseURL
    
  END /* End While */
    
  
  CLOSE c_Nav
  DEALLOCATE c_Nav

  /*
  ** For items with Level = 1, the PostFuse should be dynamic (i.e. use section)
  ** UNLESS this is a single Link in which case, PostFuse should equal PreFuse.
  ** 04/09/2002 - We want to always nclude @App_RootPath or @App_SecurePath
  */

  SELECT @GECodePath = Value
    FROM System_Variable
   WHERE Name = 'GECodePath'

  SELECT @VirtualDirectoryPath = Value
    FROM System_Variable
   WHERE Name = 'VirtualDirectoryPath'

  IF Len(@GECodePath) > 1
    SET @GECodePath = RIGHT(@GECodePath,Len(@GECodePath)-1)
  ELSE IF @GECodePath = '/'
    SET @GECodePath = ''

  IF Len(@VirtualDirectoryPath) > 1
    SET @VirtualDirectoryPath = RIGHT(@VirtualDirectoryPath,Len(@VirtualDirectoryPath)-1)
  ELSE IF @VirtualDirectoryPath = '/'
    SET @VirtualDirectoryPath = ''

  UPDATE #NavMenu
     SET PostFuseURL = CASE
        WHEN IsNull(ShowInTemplateFlag,'Y') = 'Y' AND ContentSecureFlag = 'Y' THEN 
          a.SecureWebsiteRootURL + @GECodePath + 'Template.cfm' + '?Section=' + Name
        WHEN IsNull(ShowInTemplateFlag,'Y') = 'Y' AND IsNULL(ContentSecureFlag, 'N') = 'N' THEN 
          a.WebsiteRootURL + @GECodePath + 'Template.cfm' + '?Section=' + Name
        WHEN IsNULL(ShowInTemplateFlag, 'Y') = 'N' AND CHARINDEX('.CFM',UPPER(PreFuseURL)) > 0  AND ContentSecureFlag = 'Y' THEN 
          a.SecureWebsiteRootURL + @GECodePath + 'AMTemplate.cfm?Section=' + Name
        WHEN IsNULL(ShowInTemplateFlag, 'Y') = 'N' AND CHARINDEX('.CFM',UPPER(PreFuseURL)) > 0  AND IsNULL(ContentSecureFlag, 'N') = 'N' THEN 
          a.WebsiteRootURL + @GECodePath + 'AMTemplate.cfm?Section=' + Name
        ELSE 
          a.PreFuseURL
      END
    FROM #NavMenu a, Website b
   WHERE CategoryDepth = 1
     AND PostFuseURL != PreFuseURL
     AND a.WebsiteKey = b.WebsiteKey
     AND b.UseAspNetTemplateFlag = 'N'

  /* Added for ASP.NET Templates)*/
  UPDATE #NavMenu
     SET PostFuseURL = CASE
        WHEN IsNull(ShowInTemplateFlag,'Y') = 'Y' AND ContentSecureFlag = 'Y' THEN 
          a.SecureWebsiteRootURL + @VirtualDirectoryPath + '/' + Name + '/AM/ContentManagerNet/Default.aspx' + '?Section=' + Name
        WHEN IsNull(ShowInTemplateFlag,'Y') = 'Y' AND IsNULL(ContentSecureFlag, 'N') = 'N' THEN 
          a.WebsiteRootURL + @VirtualDirectoryPath + '/' + Name + '/AM/ContentManagerNet/Default.aspx' + '?Section=' + Name
        WHEN IsNULL(ShowInTemplateFlag, 'Y') = 'N' AND CHARINDEX('.ASPX',UPPER(PreFuseURL) ) > 0  AND ContentSecureFlag = 'Y' THEN 
          a.SecureWebsiteRootURL + @VirtualDirectoryPath + '/' + Name + '/AM/ContentManagerNet/Default.aspx?NoTemplate=1&Section=' + Name
        WHEN IsNULL(ShowInTemplateFlag, 'Y') = 'N' AND CHARINDEX('.ASPX',UPPER(PreFuseURL) ) > 0  AND IsNULL(ContentSecureFlag, 'N') = 'N' THEN 
          a.WebsiteRootURL + @VirtualDirectoryPath + '/' + Name + '/AM/ContentManagerNet/Default.aspx?NoTemplate=1&Section=' + Name
        ELSE 
          a.PreFuseURL
      END
    FROM #NavMenu a, Website b
   WHERE CategoryDepth = 1
     AND PostFuseURL != PreFuseURL
     AND a.WebsiteKey = b.WebsiteKey
     AND b.UseAspNetTemplateFlag = 'Y'

  /* Unless it's a link outside of this website, add root path or secure root to the URL. */

  UPDATE #NavMenu
     SET PreFuseURL = CASE 
                        WHEN ContentSecureFlag = 'Y' THEN SecureWebsiteRootURL 
                        ELSE WebsiteRootURL END + 
                      CASE WHEN Left(PreFuseURL,1) = '/' THEN Right(PreFuseURL,Len(PreFuseURL)-1)
                        ELSE PreFuseURL END
   WHERE PreFuseURL NOT LIKE 'htt%'

  UPDATE #NavMenu
     SET PostFuseURL =  CASE 
                        WHEN ContentSecureFlag = 'Y' THEN SecureWebsiteRootURL
                        ELSE WebsiteRootURL END + 
                        CASE WHEN Left(PostFuseURL,1) = '/' THEN Right(PostFuseURL,Len(PostFuseURL)-1)
                        ELSE PostFuseURL END
   WHERE PostFuseURL NOT LIKE 'http%'
  

  /* Set AncestoryHideFlag and AncestoryNotPublishedFlag*/
  UPDATE #NavMenu
     SET AncestoryHideFlag = 'Y',
         AncestoryNotPublishedFlag = CASE WHEN b.PublishedDateTime > CURRENT_TIMESTAMP
                                               OR b.PublishedDateTime IS NULL THEN 'Y'
                                     ELSE 'N' END
    FROM #NavMenu a, Nav_Menu b WITH (NOLOCK)
   WHERE a.AncestorNavMenuID = b.NavMenuID
     AND b.HideFlag = 'Y'

  /* Added 09/12/2003 - R. Wenger 
     Removes nav items that you can't see at runtime */
  IF @Runtime = 1
      DELETE FROM #NavMenu
      WHERE AncestoryHideFlag = 'Y'
              OR AncestoryNotPublishedFlag = 'Y'
              OR HideFlag = 'Y'
              OR PublishedFlag = 'N'

  /* Return the entire #NavMenu table if not filtering for CM6 */
  IF @WebsiteKey IS NULL
     SELECT * from #NavMenu
     ORDER BY NavContentGroupInd DESC, SortOrder
  /* Added 09/12/2002 - R.Wenger 
     otherwise, CM6 is per website, and we don't need all the crap you can't show anyway */
  ELSE
     SELECT *
       FROM #NavMenu
    WHERE WebsiteKey = @WebsiteKey
     ORDER BY NavContentGroupInd DESC, SortOrder
END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetWebsiteNavigation]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetWebsiteNavigation]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure amsp_CMGetWebsiteNavigation (@WebsiteKey uniqueidentifier) AS
BEGIN
 SELECT a.*,
        e.ImageInitial,
        e.ImageOther,
        e.ImageRollover,
        e.BreadCrumb,
        e.ImageWidth,
        e.ImageHeight,
        b.HideFlag AS ParentHideFlag,
        b.PublishedDateTime AS ParentPubValue,
        b.Name AS ParentName,
        c.ShowInTemplateFlag,
        c.OpenInNewWindowFlag,
        c.SecureFlag AS ContentSecureFlag,
        space(255) AS AncestoryList,
        a.HideFlag AS AncestoryHideFlag,
        ' ' AS AncestoryNotPublishedFlag,
        w.WebsiteRootURL,
        w.SecureWebsiteRootURL,
        w.TemplateHeaderFileName,
        w.TemplateFooterFileName,
        w.SiteStyleSheet,
        w.UseHierMenuFlag,
        w.ShowBreadCrumbFlag
    INTO #NavMenu
    FROM Nav_Menu a, Nav_Menu b, Content c, Nav_Menu_Feature e, Website w
   WHERE 1 = 0

  exec amsp_CMNavMenuSetup;

  SELECT TOP 1 * FROM #NavMenu
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMGetWorkingContentID]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMGetWorkingContentID]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.amsp_GetWorkingContentID    Script Date: 12/10/2001 10:54:33 AM ******/
-- This procedure takes a ContentID as a parameter and makes a new content row
-- to work on if the one given is already published and has no record in a working state
-- (which includes statuses of Working, PendingApproval, or Approved, .  It does this by 
-- duplicating the content record and all of the child records that reference that content 
-- row, including:
--   Content_HTML
--   Content_Link
--   Content_File
--   Custom_Page_Object
--   Custom_Page_Object_Text
--   Component_Interest_Category
--   Tagged_Page_Interest_Category
--
-- Parameters:
--   IN - InContentID - The contentID of the content to be worked on
--   OUT - OutContentID - The contentID of the working record
--   IN - InCreateFlag - indicates whether or not to ALTER  a working row if the latest is
--        Published or Archived.  By default, it does ALTER  a working row if there is not one
--
-- Modification History
--   09/27/2001  N.Malhotra  Added Tagged_Page_Interest_Category to list of Tables
--   12/10/2001  N.Malhotra  Changed 3rd parameter in call to amsp_GetTableColumnList to 'Y' for
--                           Tagged_Page_Interest_Category to include InterestCategoryID in result set.
--   04/11/2002  N.Malhotra  Added Update statement for Content_Link entries that are using the old ContentID
--                           in the link itself (e.g. tagged page links). 
--   04/15/2002  E.Pfleckl   Commented out the Custom_Page_Object and Custom_Page_Object_Text inserts                    
--   09/09/2003  E.Tatsui    Moved the logic to ALTER  a new record to amsp_CMCopyContentRow so that
--                           it can be used from other sps.
--
-- Copyright 2005 Advanced Solutions Intl., All Rights Reserved
CREATE             PROCEDURE amsp_CMGetWorkingContentID 
    @InContentID numeric,
    @InContactID numeric,
    @OutContentID numeric OUTPUT,
    @InCreateFlag char(1) = 'Y' AS
BEGIN
  DECLARE
    @MyWorkflowStatusCode char(1),
    @ChildWorkflowStatusCode char(1),
    @ChildContentID numeric
    
  -- First, figure out if this one is working, or there is one that is working associated
  -- with this one.
  SELECT @MyWorkflowStatusCode = a.WorkflowStatusCode, 
         @ChildContentID = b.ContentID, 
         @ChildWorkflowStatusCode = b.WorkflowStatusCode
    FROM Content a LEFT OUTER JOIN Content b ON a.ContentID = b.PreviousContentID
   WHERE a.ContentID = @InContentID
   
  -- If the status of the contentID sent in is one of the working statuses, just return it
  IF @MyWorkflowStatusCode IN ('W','E','A')
    SET @OutContentID = @InContentID
  ELSE
    BEGIN
      -- Otherwise, if the status of the child is one of the working ones, return the child's ID
      IF @ChildWorkflowStatusCode IN ('W','E','A')
        SET @OutContentID = @ChildContentID
      ELSE
        BEGIN
          -- Otherwise, if there is a child, it must have or need a child, so recurse
          IF @ChildWorkflowStatusCode IS NOT NULL
            EXECUTE amsp_CMGetWorkingContentID @ChildContentID, @InContactID, @OutContentID
          ELSE
            -- Otherwise, the one at the end of the line is not a working one, so make a new one
            EXECUTE amsp_CMCopyContentRow @InContentID, @InContactID, @OutContentID OUTPUT
        END
    END
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMInsertContent]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMInsertContent]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- Creates a Content record
--
-- Modifications:
-- 07/30/2003  E.Tatsui    Created
-- =============================================

CREATE           PROCEDURE amsp_CMInsertContent
	@InNavMenuID numeric,
  @InContactID numeric,
  @InContentTitle varchar(255),
  @OutContentID numeric OUTPUT
AS

BEGIN
  DECLARE
    @DefaultOwnerMeGroupSpecificInd char(1),
    @DefaultOwnerContactID numeric,
    @DefaultReminderDays int,
    @DefaultOwnerID numeric,
    @l_OwnerContactID numeric,
    @ExpirationDays int,
    @l_ExpirationDays int,
    @MembersOnlyFlag char(1),
    @OwnerContactID numeric,
    @DefaultContentID numeric,
    @RowNum int,
    @URLSafeName varchar(255),
    @Counter int,
    @SuperGroupID numeric
  
  -- Get producer's preferences.
  SELECT @DefaultOwnerMeGroupSpecificInd = DefaultOwnerMeGroupSpecificInd,
         @DefaultOwnerContactID = DefaultOwnerContactID,
         @DefaultReminderDays = DefaultReminderDays
    FROM Producer
   WHERE ContactID = @InContactID

  -- Find out if this user is a member of a super group.
  SELECT @SuperGroupID = a.ContentAuthorityGroupID
    FROM Content_Authority_Group a, Content_Authority_Producer b
   WHERE a.ContentAuthorityGroupID = b.ContentAuthorityGroupID
     AND b.ContactID = @InContactID
     AND a.SuperGroupFlag = 'Y'

  -- Get nav_menu's info.
  SELECT @DefaultOwnerID = (SELECT TOP 1 ContactID FROM Content_Authority_Producer  WHERE DefaultOwnerFlag = 'Y' AND ContentAuthorityGroupID = a.ContentAuthorityGroupID),
         @OwnerContactID = a.OwnerContactID,
         @ExpirationDays = a.ExpirationDays,
         @DefaultContentID = a.ContentID,
         @MembersOnlyFlag = a.MembersOnlyFlag
    FROM Nav_Menu a, Content_Authority_Producer b
   WHERE NavMenuID = @InNavMenuID
     AND (a.ContentAuthorityGroupID = b.ContentAuthorityGroupID OR b.ContentAuthorityGroupID = @SuperGroupID)
     AND b.ContactID = @InContactID
     AND b.ContentEditorFlag = 'Y' 
  
  -- Make sure the user has privilege to insert content record here.
  IF @@Rowcount = 0
    RAISERROR('You do not have privilege to create a content record for this navigation item/content folder.',16,1)

  -- Set default values according to preferences.
  IF @DefaultOwnerMeGroupSpecificInd = 'G'
    SET @l_OwnerContactID = @DefaultOwnerID
  ELSE IF @DefaultOwnerMeGroupSpecificInd = 'M'
    SET @l_OwnerContactID = @InContactID
  ELSE IF @DefaultOwnerMeGroupSpecificInd = 'S' AND @DefaultOwnerContactID IS NOT NULL
    SET @l_OwnerContactID = @DefaultOwnerContactID
  ELSE
    SET @l_OwnerContactID = @OwnerContactID

  IF @DefaultReminderDays IS NOT NULL
    SET @l_ExpirationDays = @DefaultReminderDays
  ELSE
    SET @l_ExpirationDays = @ExpirationDays

  --Make sure URLSafeName is unqiue.
  EXEC amsp_CMGetUniqueContentName NULL, @InContentTitle, @InNavMenuID, @URLSafeName OUTPUT

  INSERT
    INTO Content (
         WorkflowStatusCode,
         NavMenuID,
         Name,
         URLSafeName,
         ShowInTemplateFlag,
         OpenInNewWindowFlag,
         FuseFlag,
         SecureFlag,
         SuppressBannersFlag,
         OwnerContactID,
         ContactID,
         ExpirationDays,
         ArchiveAtExpirationFlag,
         MembersOnlyFlag)
  VALUES ('W',
          @InNavMenuID,
          @InContentTitle,
          @URLSafeName,
          'Y',
          'N',
          'Y',
          'N',
          'N',
          @l_OwnerContactID,
          @InContactID,
          @l_ExpirationDays,
          'N',
          @MembersOnlyFlag)

  SET @OutContentID = @@Identity

  -- If the Nav_Menu record doesn't have a default content record yet,
  -- make this a default.

  IF @DefaultContentID IS NULL
    UPDATE Nav_Menu
       SET ContentID = @OutContentID
     WHERE NavMenuID = @InNavMenuID

  --Copy security settings from Nav_Menu if there are any.
  IF @MembersOnlyFlag = 'Y'
      INSERT INTO Content_Security_Group
                  (ContentID,
                   SecurityGroupCode)
      SELECT @OutContentID,
             SecurityGroupCode
        FROM Nav_Menu_Security_Group
       WHERE NavMenuID = @InNavMenuID
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMNavMenuRenum]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMNavMenuRenum]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE             procedure amsp_CMNavMenuRenum AS
BEGIN
/*
** 02/22/2002  N.Malhotra  Extended Max Value for SortOrder to 999999999
** 04/18/2002  N.Malhotra  Added index to #temp.NavMenuID
** 08/20/2002  I.Kim       Changed UPDATE statement to not use inner select (to improve performance)
** 09/04/2003  E.Tatsui    
*/
  DECLARE 
    @NavMenuID		numeric,
    @NewSortOrder	numeric,
    @SortIncrement	integer,
    @NumNavMenuItems	integer

  CREATE TABLE #temp (
    ID Numeric Identity not null,
    NavMenuID numeric,
    SortOrder numeric)

  BEGIN TRANSACTION
   
  -- First insert all the nave item.
  INSERT INTO #temp (NavMenuID, SortOrder)
  SELECT NavMenuID, SortOrder
    FROM Nav_Menu
   WHERE NavContentGroupInd = 'N'
   ORDER BY SortOrder

  -- Then all the content folders.
  INSERT INTO #temp (NavMenuID, SortOrder)
  SELECT NavMenuID, SortOrder
    FROM Nav_Menu
   WHERE NavContentGroupInd = 'C'
   ORDER BY SortOrder

  SELECT @NumNavMenuItems = count(*)
    FROM Nav_Menu

  SET @SortIncrement = CEILING(999990000.0 / @NumNavMenuItems) - 1

  UPDATE #temp
     SET SortOrder = ID * @SortIncrement

  CREATE UNIQUE INDEX IDX_TEMP_1 ON #temp(NavMenuID)

  UPDATE Nav_Menu
     SET SortOrder = t.SortOrder
    FROM #temp t
   WHERE Nav_Menu.NavMenuID = t.NavMenuID

  COMMIT TRANSACTION
END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMMoveNavMenu]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMMoveNavMenu]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure moves a specified item to a target location.
-- 
-- Notes:
-- When @InMoveLevel is "Lower", it means that the move item should go 
-- right below the target item as a child. This is not the same as simply moving under
-- the target.
-- 
--
-- Modifications
-- 06/06/2003   E.Tatsui   Converted from NavMenuModifyCode.cfm
-- 02/06/2004   E.Tatsui   Removed transactions. 
-- 09/22/2005   E.Tatsui   Fixed a problem moving an item to an empty website.
-- 09/26/2005   E.Tatsui   Fixed a problem with missing children when a parent item is moved.
-- =============================================

CREATE                            PROCEDURE amsp_CMMoveNavMenu
  @InMoveNavMenuID numeric,
  @InTargetNavMenuID numeric = NULL,
  @InMovePromoteDemoteInd char(1) = 'M',
  @InMoveLevel varchar(10) = NULL,
  @OutErrorMessage varchar(255) OUTPUT
AS
BEGIN

  DECLARE
    @WebsiteKey uniqueidentifier,
    @MinSort numeric(28,18),
    @MaxSort numeric(28,18),
    @NavContentGroupInd char(1),
    @Move_ParentNavMenuID numeric,
    @Move_AncestorNavMenuID numeric,
    @Move_CategoryDepth numeric,
    @Move_ParentName varchar(255),
    @Move_SortOrder numeric(28,18),
    @Target_CategoryDepth numeric,
    @Target_SortOrder numeric(28,18),
    @Target_AncestorNavMenuID numeric,
    @Target_ParentNavMenuID numeric,
    @LowestSortOrder numeric(28,18),
    @Below_SortOrder numeric(28,18),
    @IncrementValue numeric(28,18),
    @DescendantCount integer,
    @Counter integer,
    @Loop_NavMenuID numeric,
    @Loop_SortOrder numeric(28,18),
    @Loop_LowestSortOrder numeric(28,18),
    @New_SortOrder numeric(28,18),
    @New_ParentNavMenuID numeric,
    @New_AncestorNavMenuID numeric,
    @New_CategoryDepth numeric,
    @IsTargetDescendant bit,
    @Sib_NavMenuID numeric,
    @Sib_SortOrder numeric(28,18),
    @Level varchar(10),
    @Error integer
    
  EXEC amsp_CMNavMenuRenum
  
  -- Get info of item to move. 
  SELECT @Move_ParentNavMenuID = a.ParentNavMenuID,
         @Move_AncestorNavMenuID = a.AncestorNavMenuID,
         @Move_CategoryDepth = a.CategoryDepth,
         @Move_ParentName = b.Name,
         @Move_SortOrder = a.SortOrder,
         @NavContentGroupInd = a.NavContentGroupInd,
         @WebsiteKey = a.WebsiteKey
    FROM Nav_Menu a WITH (NOLOCK) LEFT OUTER JOIN Nav_Menu b WITH (NOLOCK)
      ON a.ParentNavMenuID = b.NavMenuID
   WHERE a.NavMenuID = @InMoveNavMenuID

  IF @@Rowcount = 0
    RETURN

  -- For promote, look for the target ID
  IF @InMovePromoteDemoteInd = 'P' BEGIN
    SELECT TOP 1 @InTargetNavMenuID = NavMenuID
      FROM Nav_Menu WITH (NOLOCK)
     WHERE CategoryDepth = @Move_CategoryDepth - 1
       AND SortOrder < @Move_SortOrder
       AND NavContentGroupInd = @NavContentGroupInd
    ORDER BY SortOrder DESC

    SET @Level = 'Same'
  END
  -- Also for demote, look for the target ID
  ELSE IF @InMovePromoteDemoteInd = 'D' BEGIN
    SELECT TOP 1 
           @Sib_NavMenuID = NavMenuID, 
           @Sib_SortOrder = SortOrder
      FROM Nav_Menu WITH (NOLOCK)
     WHERE CategoryDepth = @Move_CategoryDepth
       AND SortOrder < @Move_SortOrder
       AND NavContentGroupInd = @NavContentGroupInd
     ORDER BY SortOrder DESC

    SELECT TOP 1 
           @InTargetNavMenuID = NavMenuID
      FROM Nav_Menu WITH (NOLOCK)
     WHERE CategoryDepth = @Move_CategoryDepth + 1
       AND SortOrder < @Move_SortOrder
       AND SortOrder > @Sib_SortOrder
       AND NavContentGroupInd = @NavContentGroupInd
     ORDER BY SortOrder DESC
  
    IF @@Rowcount > 0
      SET @Level = 'Same'
    ELSE BEGIN
      SET @InTargetNavMenuID = @Sib_NavMenuID
      SET @Level = 'Lower'
    END

  END

  -- For Move, if level is specified, set to the value. Otherwise, set to "Same"
  ELSE IF @InMoveLevel IS NOT NULL
    SET @Level = @InMoveLevel
  ELSE
    SET @Level = 'Same'

  -- Make sure we found a valid target ID.
  IF @InMoveNavMenuID = @InTargetNavMenuID
    SET @OutErrorMessage = 'Error! The target item can''t be the item you want to move.'
  IF @InTargetNavMenuID IS NULL  
    SET @OutErrorMessage = 'Error! Can''t find the target item.'

  IF @OutErrorMessage IS NULL BEGIN   
    -- Build a table of item's descendants
    SELECT @MinSort = a.SortOrder,
           @MaxSort = (SELECT IsNull(Min(x.SortOrder),0)
                         FROM Nav_Menu x
                         WITH (NOLOCK)
                        WHERE x.SortOrder > a.SortOrder
                          AND x.CategoryDepth <= a.CategoryDepth)
      FROM Nav_Menu a WITH (NOLOCK)
     WHERE a.NavMenuID = @InMoveNavMenuID
    
    SELECT a.NavMenuID, a.SortOrder
      INTO #Descendants
      FROM Nav_Menu a WITH (NOLOCK)
     WHERE a.SortOrder > @MinSort
       AND a.SortOrder < @MaxSort
 
    SET @DescendantCount = @@Rowcount

    SELECT 1
      FROM #Descendants
     WHERE NavMenuID = @InTargetNavMenuID

    IF @@Rowcount >= 1 
      SET @OutErrorMessage = 'Error! The target item can''t be a descendant of the item you want to move.'
  END -- @OutErrorMessage is null
  
  IF @OutErrorMessage IS NULL BEGIN
    -- Get info of the target item
    SELECT @Target_CategoryDepth = a.CategoryDepth,
           @Target_SortOrder = a.SortOrder,
           @Target_AncestorNavMenuID = a.AncestorNavMenuID,
           @Target_ParentNavMenuID = a.ParentNavMenuID
      FROM Nav_Menu a WITH (NOLOCK)
     WHERE NavMenuID = @InTargetNavMenuID

    IF @@Rowcount = 0
      RETURN
    SET @LowestSortOrder = @Target_SortOrder

    -- If first row (Navigation Menu/Content Groups heading) is target,
    -- we want inserted/moved items to appear up top. --->
    IF @Target_AncestorNavMenuID IS NOT NULL BEGIN
      SELECT @MinSort = a.SortOrder,
             @MaxSort = (SELECT IsNull(Min(x.SortOrder),0)
                           FROM Nav_Menu x
                           WITH (NOLOCK)
                          WHERE x.SortOrder > a.SortOrder
                            AND x.CategoryDepth <= a.CategoryDepth)
        FROM Nav_Menu a WITH (NOLOCK)
       WHERE a.NavMenuID = @InTargetNavMenuID

      SELECT a.NavMenuID, a.SortOrder
        INTO #TargetDescendants
        FROM Nav_Menu a WITH (NOLOCK)
       WHERE a.SortOrder > @MinSort
         AND a.SortOrder < @MaxSort
        ORDER BY a.SortOrder

      IF @@RowCount > 0
        SELECT @LowestSortOrder = Max(SortOrder)
          FROM #TargetDescendants
    END
    ELSE
      SET @Level = 'Lower'

    -- Also get information about the item below
    SELECT TOP 1 @Below_SortOrder = SortOrder
      FROM Nav_Menu WITH (NOLOCK)
     WHERE SortOrder > @LowestSortOrder
     ORDER BY SortOrder

    -- Create a cursor for Descendant
    DECLARE c_Descendant CURSOR LOCAL SCROLL FOR
    SELECT NavMenuID, SortOrder
      FROM #Descendants
     ORDER BY SortOrder 

    SET @Counter = 1
    SET @New_SortOrder = @Move_SortOrder
    SET @New_ParentNavMenuID = @Move_ParentNavMenuID
    SET @New_AncestorNavMenuID = @Move_AncestorNavMenuID
    SET @New_CategoryDepth = @Move_CategoryDepth

    -- At the same level?
    IF @Level = 'Same' BEGIN
      -- Creating a new main item.
      IF @Target_CategoryDepth = 1 BEGIN
        -- If we're moving around main menu items, adjust sort order and nothing else.
        IF @Move_CategoryDepth = 1 BEGIN
print 'case 1'
          SET @New_SortOrder = (@LowestSortOrder + @Below_SortOrder)/2

        END -- Ends @Move_CategoryDepth = 1
        ELSE BEGIN -- Something is promoted.
print 'case 2'
          SET @New_ParentNavMenuID = NULL
          SET @New_AncestorNavMenuID = @InMoveNavMenuID
          SET @New_CategoryDepth = @Target_CategoryDepth
          SET @New_SortOrder = (@LowestSortOrder + @Below_SortOrder)/2
        END -- Ends something is promoted.
      END -- Ends @Target_CategoryDepth = 1
      ELSE BEGIN -- Not creating main menu.
print 'case 3'
        SET @New_ParentNavMenuID = @Target_ParentNavMenuID
        SET @New_AncestorNavMenuID = @Target_AncestorNavMenuID
        SET @New_CategoryDepth = @Target_CategoryDepth
        SET @New_SortOrder = (@LowestSortOrder + @Below_SortOrder)/2

      END -- Ends not creating main menu
    END -- Ends @Level = 'Same'
    ELSE IF @Level = 'Lower' BEGIN
      -- Is target Web site name?
      IF @Target_CategoryDepth = 0 BEGIN
        -- Change BelowSortOrder to sort order of second item in menu.
        IF @NavContentGroupInd = 'N'
          SELECT TOP 1  @Below_SortOrder = SortOrder
            FROM Nav_Menu
           WHERE CategoryDepth = 1
             AND NavContentGroupInd = @NavContentGroupInd
             AND WebsiteKey = @WebsiteKey
	     AND NavMenuID <> @InMoveNavMenuID
           ORDER BY SortOrder
        ELSE
          SELECT TOP 1  @Below_SortOrder = SortOrder
            FROM Nav_Menu
           WHERE CategoryDepth = 1
             AND NavContentGroupInd = @NavContentGroupInd
             AND NavMenuID <> @InMoveNavMenuID
           ORDER BY SortOrder
print 'case 4'
        SET @Target_CategoryDepth = 1
        SET @New_ParentNavMenuID = NULL
        SET @New_AncestorNavMenuID = @InMoveNavMenuID
        SET @New_CategoryDepth = @Target_CategoryDepth
        SET @New_SortOrder = @Target_SortOrder + (@Below_SortOrder - @Target_SortOrder)/2
      END

      ELSE BEGIN -- Target is not Web site name.
        -- If item to move is a main menu item
        IF @Move_CategoryDepth = 1 BEGIN
print 'case 5'
          SET @New_ParentNavMenuID = @InTargetNavMenuID
          SET @New_AncestorNavMenuID = @Target_AncestorNavMenuID
          SET @New_CategoryDepth = @Target_CategoryDepth + 1
          SET @New_SortOrder = (@LowestSortOrder + @Below_SortOrder)/2
        END
        -- Otherwise, replace parent directory with target's directory.
        ELSE BEGIN
          -- If item to move is a descendant of target, or we are moving to
          -- right below the target on purpose, change l_BelowSortOrder to sort
          -- order of item immediately below target.
          SET @IsTargetDescendant = 0
    
          IF @Target_AncestorNavMenuID IS NOT NULL BEGIN
            SELECT @IsTargetDescendant = 1
              FROM #TargetDescendants
             WHERE NavMenuID = @InMoveNavMenuID
          END

          IF @IsTargetDescendant = 1 OR @InMoveLevel = 'Lower'  BEGIN
            IF @NavContentGroupInd = 'N' 
              SELECT TOP 1 @Below_SortOrder = SortOrder 
                FROM Nav_Menu
               WHERE SortOrder > @Target_SortOrder
                 AND WebsiteKey = @WebsiteKey
               ORDER BY SortOrder
            ELSE
              SELECT TOP 1 @Below_SortOrder = SortOrder 
                FROM Nav_Menu
               WHERE SortOrder > @Target_SortOrder
                 AND NavContentGroupInd = @NavContentGroupInd
               ORDER BY SortOrder
          END -- Ends: the item to move is a descendant of target
print 'case 6'
          SET @New_ParentNavMenuID = @InTargetNavMenuID
          SET @New_AncestorNavMenuID = @Target_AncestorNavMenuID
          SET @New_CategoryDepth = @Target_CategoryDepth + 1
          SET @New_SortOrder = (@Target_SortOrder + @Below_SortOrder) /2
        END -- Ends : Not moving a main item.
      END -- Ends: Target is not Web site name.
    
    END -- Ends @Level = Lower


    -- Update the item
    UPDATE Nav_Menu
       SET ParentNavMenuID = @New_ParentNavMenuID,
           AncestorNavMenuID = @New_AncestorNavMenuID,
           CategoryDepth = @New_CategoryDepth,
           SortOrder = @New_SortOrder,
			     WorkflowStatusCode = 'W',
					 PublishedDateTime = NULL
	   WHERE NavMenuID = @InMoveNavMenuID

    -- Make sure directory name is unique.
    EXECUTE amsp_CMGetUniqueDirectoryName @InMoveNavMenuID, 1, NULL


    -- Update properties of the old parent record.
    IF IsNull(@New_ParentNavMenuID,0) <> IsNull(@Move_ParentNavMenuID,0)
      EXEC amsp_CMUpdateNavProperties @Move_ParentNavMenuID

    SET @Loop_LowestSortOrder = @New_SortOrder
    SET @IncrementValue = (@Below_SortOrder - @Loop_LowestSortOrder) / (@DescendantCount + 2)

    -- Update descendants
    OPEN c_Descendant
    FETCH NEXT FROM c_Descendant
     INTO @Loop_NavMenuID,
          @Loop_SortOrder

    WHILE @@FETCH_STATUS = 0 BEGIN

      UPDATE Nav_Menu
         SET AncestorNavMenuID = @New_AncestorNavMenuID,
             CategoryDepth = CategoryDepth + @New_CategoryDepth - @Move_CategoryDepth,
             SortOrder = @Loop_LowestSortOrder + (@IncrementValue * @Counter),
				     WorkflowStatusCode = 'W',
						 PublishedDateTime = NULL
       WHERE NavMenuID = @Loop_NavMenuID

      EXECUTE amsp_CMGetUniqueDirectoryName @Loop_NavMenuID, 1, NULL

      SET @Counter = @Counter + 1
      FETCH NEXT FROM c_Descendant
       INTO @Loop_NavMenuID,
            @Loop_SortOrder
    END -- Ends while loop

    -- Figure out FilePath, DescendantCount and AncestoryList.
    EXEC amsp_CMUpdateNavProperties @InMoveNavMenuID

    -- Update properties of descendants
     FETCH FIRST FROM c_Descendant
      INTO @Loop_NavMenuID,
	   @Loop_SortOrder
    WHILE @@FETCH_STATUS = 0 BEGIN
      -- Figure out FilePath, DescendantCount and AncestoryList
      EXEC amsp_CMUpdateNavProperties @Loop_NavMenuID

    FETCH NEXT FROM c_Descendant
     INTO @Loop_NavMenuID,
          @Loop_SortOrder
    END

    CLOSE c_Descendant
    DEALLOCATE c_Descendant

  END -- @OutErrorMessage is null
END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMMoveContentFolder]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMMoveContentFolder]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure is used to content folder to a specified location.
-- InTargetNavMenuID represents a new parent folder for InMoveNavMenuID.
-- Content folders are ordered alphabetically, so the sp figures out the
-- correct position and calls amsp_CMMoveNavMenu 
--
-- Modifications
-- 09/10/2003    E.Tatsui
-- =============================================

CREATE PROCEDURE amsp_CMMoveContentFolder
  @InMoveNavMenuID numeric,
  @InTargetNavMenuID numeric,
  @OutErrorMessage varchar(255) = NULL OUTPUT
AS
BEGIN
  DECLARE
    @Title varchar(255),
    @BeforeID numeric,
    @ChildNum integer,
    @TargetCategoryDepth integer

  SELECT @TargetCategoryDepth = CategoryDepth
    FROM Nav_Menu
   WHERE NavMenuID = @InTargetNavMenuID

  -- If the target is the root of content folder, get all the level 1s.
  IF @TargetCategoryDepth = 0
    SELECT @ChildNum = Count(*)
      FROM Nav_Menu
     WHERE CategoryDepth = 1
       AND NavContentGroupInd = 'C'
  ELSE
    SELECT @ChildNum = Count(*)
      FROM Nav_Menu
     WHERE IsNull(ParentNavMenuID,0)  = IsNull(@InTargetNavMenuID,0)

  IF @ChildNum = 0
    EXEC amsp_CMMoveNavMenu @InMoveNavMenuID, @InTargetNavMenuID, 'M', 'Lower', @OutErrorMessage OUTPUT
  ELSE BEGIN
    SELECT @Title = Title
      FROM Nav_Menu
     WHERE NavMenuID = @InMoveNavMenuID
    
    -- Get the item that is going to be right before this item.
    IF @TargetCategoryDepth = 0
      SELECT TOP 1 @BeforeID = NavMenuID
        FROM Nav_Menu
       WHERE CategoryDepth = 1
         AND NavContentGroupInd = 'C'
         AND Title < @Title
       ORDER BY Title DESC
    ELSE
      SELECT TOP 1 @BeforeID = NavMenuID
        FROM Nav_Menu
       WHERE IsNull(ParentNavMenuID,0) = IsNull(@InTargetNavMenuID,0)
         AND Title < @Title
       ORDER BY Title DESC

    IF @BeforeID IS NOT NULL
      EXEC amsp_CMMoveNavMenu @InMoveNavMenuID, @BeforeID, 'M', 'Same', @OutErrorMessage OUTPUT
    ELSE -- If this item goes to the top, add it right below the parent.
      EXEC amsp_CMMoveNavMenu @InMoveNavMenuID, @InTargetNavMenuID, 'M', 'Lower', @OutErrorMessage OUTPUT
  END

END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMInsertNavMenu]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMInsertNavMenu]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure inserts a new Nav_Menu record at a specified location.
--
-- Modifications
-- 07/10/2003    E.Tatsui
-- =============================================

CREATE                           PROCEDURE [dbo].[amsp_CMInsertNavMenu]
  @InTargetNavMenuID numeric,
  @InTitle varchar(255),
  @InName varchar(255),
  @InContactID numeric,
  @InWebsiteKey uniqueidentifier,
  @InContentAuthorityGroupID numeric,
  @OutNavMenuID numeric OUTPUT
AS
BEGIN

  DECLARE
  @LowestSortOrder numeric(28,18),
  @TargetAncestorNavMenuID numeric,
  @TargetExpirationDays int,
  @TargetCategoryDepth int,
  @TargetTemplatePath varchar(255),
  @TargetNavContentGroupInd char(1),
  @TargetContentAuthorityGroupID numeric,
  @TargetMicrositeFlag char(1),
  @TargetWebsiteKey uniqueidentifier,
  @ParentNavMenuID numeric,
  @AncestorNavMenuID numeric,
  @ExpirationDays int,
  @MaxSortOrder numeric(28,18),
  @MinSortOrder numeric(28,18),
  @LastSortOrder numeric(28,18),
  @BelowSortOrder numeric(28,18),
  @WebsiteKey uniqueidentifier,
  @CMExpDaysDefault int,
  @NavMenuID numeric
  
  EXEC amsp_CMNavMenuRenum
  
  -- Creating a new website. Set default properties.
  IF @InTargetNavMenuID IS NULL BEGIN
    SELECT @LowestSortOrder = Max(SortOrder)
      FROM Nav_Menu
     WHERE NavContentGroupInd = 'N'
    SET @TargetCategoryDepth = -1
    SET @TargetNavContentGroupInd = 'N'
    SET @TargetContentAuthorityGroupID = @InContentAuthorityGroupID
  END
  ELSE 
    -- Get info on target item. 
    SELECT @LowestSortOrder = SortOrder,
           @TargetAncestorNavMenuID = AncestorNavMenuID,
           @TargetExpirationDays = ExpirationDays,
           @TargetCategoryDepth = CategoryDepth,
           @TargetTemplatePath = TemplatePath,
           @TargetNavContentGroupInd = NavContentGroupInd,
           @TargetContentAuthorityGroupID = ContentAuthorityGroupID,
           @TargetMicrositeFlag = MicrositeFlag,
           @TargetWebsiteKey = WebsiteKey
      FROM Nav_Menu
     WHERE NavMenuID = @InTargetNavMenuID
  
  IF @InContentAuthorityGroupID IS NOT NULL AND @TargetContentAuthorityGroupID <> @InContentAuthorityGroupID
    SET @TargetContentAuthorityGroupID = @InContentAuthorityGroupID

  SELECT @CMExpDaysDefault = CAST(Value as numeric)
    FROM System_Variable
   WHERE Name = 'CMExpDaysDefault'
  
  -- Is target Web site name? If so, must create new main menu item.
  IF @TargetAncestorNavMenuID IS NULL BEGIN
    SET @ParentNavMenuID = NULL
    SET @AncestorNavMenuID = NULL
    SET @ExpirationDays = @CMExpDaysDefault
  END
  ELSE BEGIN -- Target NOT Web site name or content folder.
    SET @ParentNavMenuID = @InTargetNavMenuID
    SET @AncestorNavMenuID = @TargetAncestorNavMenuID
    SET @ExpirationDays = @TargetExpirationDays
  END

  -- Get the min and max sort order of the target family.
  SELECT @MinSortOrder = a.SortOrder,
         @MaxSortOrder = (SELECT Min(x.SortOrder)
		            FROM Nav_Menu x
		            WITH (NOLOCK)
		           WHERE x.SortOrder > a.SortOrder
		             AND x.CategoryDepth <= a.CategoryDepth)
    FROM Nav_Menu a WITH (NOLOCK)
   WHERE a.NavMenuID = @InTargetNavMenuID

  -- Find out the last sort order from target descendants.
  IF @MaxSortOrder IS NOT NULL
    SELECT @LastSortOrder = Max(a.SortOrder)
      FROM Nav_Menu a WITH (NOLOCK)
     WHERE a.SortOrder > @MinSortOrder
       AND a.SortOrder < @MaxSortOrder
       AND a.NavContentGroupInd = @TargetNavContentGroupInd
  ELSE
    SELECT @LastSortOrder = Max(a.SortOrder)
      FROM Nav_Menu a WITH (NOLOCK)
     WHERE a.SortOrder > @MinSortOrder
       AND a.NavContentGroupInd = @TargetNavContentGroupInd

  IF @LastSortOrder IS NOT NULL
    SET @LowestSortOrder = @LastSortOrder

  -- Find the item right below the target item. 
  SELECT @BelowSortOrder = Min(SortOrder)
    FROM Nav_Menu WITH (NOLOCK)
   WHERE SortOrder > @LowestSortOrder
  
  IF @BelowSortOrder IS NULL
    SET @BelowSortOrder = @LowestSortOrder + 1

  IF @TargetWebsiteKey IS NOT NULL
    SET @WebsiteKey = @TargetWebsiteKey
  ELSE IF @TargetNavContentGroupInd = 'C'
    SELECT TOP 1 @WebsiteKey = WebsiteKey
      FROM Website
     WHERE SimpleAdvancedInd = 'A'
       AND ActiveFlag = 'Y'
       AND IsiMISWebsite = 0
       AND Cast(WebsiteKey as varchar(100)) <> (SELECT Value FROM System_Variable WHERE Name = 'CMAdminWebsiteKey')
  ELSE
    SET @WebsiteKey = @InWebsiteKey

  INSERT INTO Nav_Menu (
         Name,
         Title,
         ParentNavMenuID,
         AncestorNavMenuID,
         CategoryDepth,
         SortOrder,
         TemplatePath,
         WorkflowStatusCode,
         NavContentGroupInd,
         ContentAuthorityGroupID,
         DirectListComboInd,
         OwnerContactID,
         LastUpdatedByContactID,
         ExpirationDays,
         MicrositeFlag,
         WebsiteKey)
  VALUES (
         @InName,
         @InTitle,
         @ParentNavMenuID,
         @AncestorNavMenuID,
         @TargetCategoryDepth + 1,
         (@LowestSortOrder + @BelowSortOrder)/2,
         @TargetTemplatePath,
         'W',
         @TargetNavContentGroupInd,
         @TargetContentAuthorityGroupID,
         'D',
         @InContactID,
         @InContactID,
         @ExpirationDays,
         @TargetMicrositeFlag,
         @WebsiteKey)
  
  SELECT @NavMenuID = @@Identity
    
  -- If ancestor is not set previously, set it to itself now.
  IF @AncestorNavMenuID IS NULL AND @InTargetNavMenuID IS NOT NULL
    UPDATE Nav_Menu
       SET AncestorNavMenuID = @NavMenuID
     WHERE NavMenuID = @NavMenuID

  INSERT INTO Nav_Menu_Workflow_Log (
         NavMenuID,
         WorkflowStatusCode,
         ContactID,
         ChangeDateTime)
  VALUES (
         @NavMenuID,
         'W',
         @InContactID,
         CURRENT_TIMESTAMP)

  -- For content folder, we need to move it to right place.
  IF @TargetNavContentGroupInd = 'C'
    EXEC amsp_CMMoveContentFolder @NavMenuID, @InTargetNavMenuID, NULL

  -- Figure out FilePath, DescendantCount and AncestoryList
  EXEC amsp_CMUpdateNavProperties @NavMenuID

  SET @OutNavMenuID = @NavMenuID
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMInsertPublishMessageLog]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMInsertPublishMessageLog]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- Inserts a record to Publish_Message_Log
--
-- Modifications
-- 07/07/2003    E.Tatsui
-- =============================================


CREATE        PROCEDURE amsp_CMInsertPublishMessageLog
  @InPublishRequestID integer,
  @InPublishRequestDetailID integer,
  @InMessageNumber integer,
  @InMessageText varchar(2000),
  @InLocation varchar(100),
  @InPublishServerCode char(1) = NULL
AS
BEGIN
  DECLARE
    @RowNum integer,
    @PublishRequestStatusCode char(1),
    @NumOfAttempts integer,
    @MaxNumOfAttempts integer

  IF @InPublishRequestID = 0 OR @InPublishRequestDetailID = 0
    SET @RowNum = 0
  ELSE
    SELECT @RowNum = Count(*)
      FROM Publish_Message_Log
     WHERE PublishRequestDetailID = @InPublishRequestDetailID
       AND PublishRequestID = @InPublishRequestID
 
  IF @RowNum = 1
    UPDATE Publish_Message_Log
       SET MessageNumber = @InMessageNumber,
           MessageText = @InMessageText,
           Location = @InLocation,
           DisplayFlag = 'Y',
           MessageDateTime = CURRENT_TIMESTAMP
     WHERE PublishRequestDetailID = @InPublishRequestDetailID
       AND PublishRequestID = @InPublishRequestID

  ELSE
    INSERT INTO Publish_Message_Log
                (PublishRequestID,
                 PublishRequestDetailID,
                 MessageNumber,
                 MessageText,
                 MessageDateTime,
                 Location,
                 PublishServerCode)
    VALUES (@InPublishRequestID,
            @InPublishRequestDetailID,
            @InMessageNumber,
            @InMessageText,
            CURRENT_TIMESTAMP,
            @InLocation,
            @InPublishServerCode)

  IF @InPublishRequestDetailID IS NOT NULL AND @InPublishRequestDetailID <> 0 BEGIN
    UPDATE Publish_Request_Detail
       SET NumOfAttempts = NumOfAttempts + 1
     WHERE PublishRequestDetailID = @InPublishRequestDetailID

    SELECT @MaxNumOfAttempts = Convert(integer,Value)
      FROM System_Variable WITH (NOLOCK)
     WHERE Name = 'CMPublishingMaxNumOfAttempts'

    SELECT @PublishRequestStatusCode = PublishRequestStatusCode,
           @NumOfAttempts = NumOfAttempts
      FROM Publish_Request_Detail WITH (NOLOCK)
     WHERE PublishRequestDetailID = @InPublishRequestDetailID

    IF @PublishRequestStatusCode = 'N' AND @NumOfAttempts >= @MaxNumOfAttempts
      -- Mark this request as failed after the max tries.
      UPDATE Publish_Request_Detail
         SET PublishRequestStatusCode = 'F'
       WHERE PublishRequestDetailID = @InPublishRequestDetailID
  END
  -- If detail id is not specified, see if we can update using the request id.
  ELSE IF @InPublishRequestDetailID = 0 AND @InPublishRequestID <> 0 BEGIN
      UPDATE Publish_Request_Detail
         SET NumOfAttempts = NumOfAttempts + 1,
             PublishRequestStatusCode = CASE WHEN (NumOfAttempts + 1) >= @MaxNumOfAttempts
                                             THEN 'F' 
                                        ELSE PublishRequestStatusCode END
       WHERE PublishRequestID = @InPublishRequestID
  END
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMMoveContent]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMMoveContent]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure takes two ContentIDs from same Nav_Menu 
-- and move the first one below the second one.
--
-- Modifications
-- 08/20/2003  E.Tatsui
-- =============================================

CREATE              PROCEDURE amsp_CMMoveContent
  @InMoveContentID numeric,
  @InTargetContentID numeric	
AS
BEGIN
  DECLARE
    @NavMenuID numeric,
    @TargetSortOrder numeric,
    @MoveSortOrder numeric

  -- If TargetSortOrder is 0, it means it wants to go to the top of the list.
  IF @InTargetContentID = 0 BEGIN
    SET @TargetSortOrder = 0
    SELECT @NavMenuID = NavMenuID
      FROM Content WITH (NOLOCK) 
     WHERE ContentID = @InMoveContentID
  END
  ELSE BEGIN
    SELECT @NavMenuID = a.NavMenuID,
           @TargetSortOrder = IsNull(b.SortOrder,0),
           @MoveSortOrder = IsNull(a.SortOrder, 0)
      FROM Content a WITH (NOLOCK), Content b WITH (NOLOCK), Nav_Menu c WITH (NOLOCK)
     WHERE a.NavMenuID = b.NavMenuID
       AND a.ContentID = @InMoveContentID
       AND b.ContentID = @InTargetContentID
       AND a.NavMenuID = c.NavMenuID


    IF @@RowCount = 0 BEGIN
      RAISERROR ('The record to move and target record must have same NavMenuID.', 16, 1)
      RETURN
    END
  END

  -- Move everything below target by one.
  UPDATE Content
     SET SortOrder = IsNull(SortOrder,1) + 1
   WHERE NavMenuID = @NavMenuID
     AND SortOrder > @TargetSortOrder
     AND ContentID <> @InMoveContentID

  -- Move the request item right below the target.
  UPDATE Content
     SET SortOrder = @TargetSortOrder + 1
   WHERE ContentID = @InMoveContentID

  -- If SortOrder was changed to 1, make it the default content.
  IF @TargetSortOrder = 0
    UPDATE Nav_Menu
       SET ContentID = @InMoveContentID,
           WorkflowStatusCode = 'W',
           PublishedDateTime = NULL,
           ComponentCode = 'CM', 
           ComponentScriptCode = 'SC' 
     WHERE NavMenuID = @NavMenuID
       AND ContentID <> @InMoveContentID

  -- Now, re-sort everything.
  EXEC amsp_CMRenumCurrentContent @NavMenuID

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMMoveContentFile]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMMoveContentFile]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure moves a specified Content File record.
--
-- Modifications
-- 08/28/2003  E.Tatsui   Created
-- =============================================
CREATE     PROCEDURE amsp_CMMoveContentFile
  @InMoveContentFileID numeric,
  @InTargetContentFileID numeric,
  @InContentID numeric
AS
BEGIN
  DECLARE 
    @TargetSortOrder numeric,
    @ContentID numeric,
    @ContentFileID numeric,
    @SortOrder numeric,
    @Counter integer,
    @MoveContentFileID numeric,
    @TargetContentFileID numeric

  SELECT @TargetSortOrder = SortOrder,
         @ContentID = ContentID,
         @TargetContentFileID = ContentFileID
    FROM Content_File  WITH (NOLOCK)
   WHERE (ContentFileID = @InTargetContentFileID
      OR PreviousContentFileID = @InTargetContentFileID)
     AND ContentID = @InContentID

  SELECT @MoveContentFileID = ContentFileID
    FROM Content_File WITH (NOLOCK)
   WHERE (ContentFileID = @InMoveContentFileID
      OR PreviousContentFileID = @InMoveContentFileID)
     AND ContentID = @InContentID

  -- If we can't find either of the record, exit.
  IF @MoveContentFileID IS NULL OR @TargetContentFileID IS NULL
    RETURN

  -- Move everything below target by one.
  UPDATE Content_File
     SET SortOrder = SortOrder + 1
   WHERE ContentID = @ContentID
     AND SortOrder > @TargetSortOrder

  -- Move the request item right below the target.
  UPDATE Content_File
     SET SortOrder = @TargetSortOrder + 1
   WHERE ContentFileID = @MoveContentFileID

  -- Now, re-sort everything.
  DECLARE c_Files CURSOR FOR
   SELECT ContentFileID,
          SortOrder
     FROM Content_File WITH (NOLOCK)
    WHERE ContentID = @ContentID
    ORDER BY SortOrder

  SET @Counter = 0

  OPEN c_Files
  FETCH NEXT FROM c_Files
   INTO @ContentFileID,
        @SortOrder

  WHILE @@FETCH_STATUS = 0 BEGIN
    SET @Counter = @Counter + 1

    IF @Counter <> @SortOrder BEGIN
      UPDATE Content_File
         SET SortOrder = @Counter
       WHERE ContentFileID = @ContentFileID
    END

    FETCH NEXT FROM c_Files
     INTO @ContentFileID,
          @SortOrder
  END
  CLOSE c_Files
  DEALLOCATE c_Files
  
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMMoveContentLink]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMMoveContentLink]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure moves a specified ContentLink
--
-- Modifications
-- 08/28/2003  E.Tatsui   Created
-- =============================================
CREATE      PROCEDURE amsp_CMMoveContentLink
  @InMoveContentLinkID numeric,
  @InTargetContentLinkID numeric,
  @InContentID numeric
AS
BEGIN
  DECLARE 
    @TargetSortOrder numeric,
    @ContentID numeric,
    @ContentLinkID numeric,
    @SortOrder numeric,
    @Counter integer,
    @TargetContentLinkID numeric,
    @MoveContentLinkID numeric

  SELECT @ContentID = ContentID,
         @TargetSortOrder = SortOrder,
         @TargetContentLinkID = ContentLinkID
    FROM Content_Link WITH (NOLOCK)
   WHERE (ContentLinkID = @InTargetContentLinkID
      OR PreviousContentLinkID = @InTargetContentLinkID)
     AND ContentID = @InContentID

  SELECT @MoveContentLinkID = ContentLinkID
    FROM Content_Link WITH (NOLOCK)
   WHERE (ContentLinkID = @InMoveContentLinkID
      OR PreviousContentLinkID = @InMoveContentLinkID)
     AND ContentID = @InContentID

  IF @TargetContentLinkID IS NULL OR @MoveContentLinkID IS NULL
    RETURN

  -- Move everything below target by one.
  UPDATE Content_Link
     SET SortOrder = SortOrder + 1
   WHERE ContentID = @ContentID
     AND SortOrder > @TargetSortOrder

  -- Move the request item right below the target.
  UPDATE Content_Link
     SET SortOrder = @TargetSortOrder + 1
   WHERE ContentLinkID = @MoveContentLinkID

  -- Now, re-sort everything.
  DECLARE c_Links CURSOR FOR
   SELECT ContentLinkID,
          SortOrder
     FROM Content_Link WITH (NOLOCK)
    WHERE ContentID = @ContentID
    ORDER BY SortOrder

  SET @Counter = 0

  OPEN c_Links
  FETCH NEXT FROM c_Links
   INTO @ContentLinkID,
        @SortOrder

  WHILE @@FETCH_STATUS = 0 BEGIN
    SET @Counter = @Counter + 1
    IF @Counter <> @SortOrder BEGIN
      UPDATE Content_Link
         SET SortOrder = @Counter
       WHERE ContentLinkID = @ContentLinkID
    END

    FETCH NEXT FROM c_Links
     INTO @ContentLinkID,
          @SortOrder
  END
  CLOSE c_Links
  DEALLOCATE c_Links
  
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMMoveNavMenuToWebsite]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMMoveNavMenuToWebsite]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This SP moves the specified Nav_Menu record to the end of a Website.
--
-- Modifications
-- 07/16/2003   E.Tatsui
-- 09/22/2005   E.Tatsui  Changed so that an item can be moved to a website w/o any nav items.
-- =============================================
CREATE     PROCEDURE amsp_CMMoveNavMenuToWebsite
  @InToMoveNavMenuID numeric,
  @InWebsiteKey varchar(50)
AS 

BEGIN
  DECLARE
    @TargetNavMenuID numeric,
    @ErrorMessage varchar(255),
    @MinSort numeric(28,18),
    @MaxSort numeric(28,18)

  --Figure out what the target NavMenuID should be.
  SELECT TOP 1 @TargetNavMenuID = NavMenuID
    FROM Nav_Menu WITH (NOLOCK)
   WHERE WebsiteKey = @InWebsiteKey
     AND NavContentGroupInd = 'N'
     AND CategoryDepth = 1
   ORDER BY SortOrder DESC

  UPDATE Nav_Menu
     SET WebsiteKey = @InWebsiteKey
   WHERE NavMenuID = @InToMoveNavMenuID

  -- Build a table of item's descendants
  SELECT @MinSort = a.SortOrder,
         @MaxSort = (SELECT IsNull(Min(x.SortOrder),0)
                       FROM Nav_Menu x
                       WITH (NOLOCK)
                      WHERE x.SortOrder > a.SortOrder
                        AND x.CategoryDepth <= a.CategoryDepth)
    FROM Nav_Menu a WITH (NOLOCK)
   WHERE a.NavMenuID = @InToMoveNavMenuID
  
  SELECT a.NavMenuID, a.SortOrder
    INTO #Descendants
    FROM Nav_Menu a WITH (NOLOCK)
   WHERE a.SortOrder > @MinSort
     AND a.SortOrder < @MaxSort

  UPDATE Nav_Menu
     SET WebsiteKey = @InWebsiteKey
    FROM Nav_Menu a WITH (NOLOCK), #Descendants b
   WHERE a.NavMenuID = b.NavMenuID

  DROP TABLE #Descendants

  -- If we found out, go ahead and move to the position.
  IF @TargetNavMenuID IS NOT NULL BEGIN
    EXEC amsp_CMMoveNavMenu @InToMoveNavMenuID, @TargetNavMenuID, 'M', NULL, @ErrorMessage OUTPUT
  END
  -- Moving as the first item on the website
  ELSE BEGIN
    SELECT @TargetNavMenuID = NavMenuID
    FROM Nav_Menu WITH (NOLOCK)
   WHERE WebsiteKey = @InWebsiteKey
     AND NavContentGroupInd = 'N'
     AND CategoryDepth = 0
    EXEC amsp_CMMoveNavMenu @InToMoveNavMenuID, @TargetNavMenuID, 'M', 'Lower', @ErrorMessage OUTPUT
  END

  IF @ErrorMessage IS NOT NULL
    RAISERROR(@ErrorMessage,1,1)

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMProcessFolderDeletion]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMProcessFolderDeletion]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE amsp_CMProcessFolderDeletion
  @InContentID numeric,
  @InWebsiteKey uniqueidentifier
AS
BEGIN
  DECLARE
    @NavMenuID numeric,
    @PreviousWebsiteKey uniqueidentifier

  -- For now, we're only going to take care of the situation where
  -- we need to update PreviousWebsiteKey
  SELECT @NavMenuID = b.NavMenuID,
         @PreviousWebsiteKey = b.PreviousWebsiteKey
    FROM Content a WITH (NOLOCK), Nav_Menu b WITH (NOLOCK)
   WHERE a.NavMenuID = b.NavMenuID
     AND a.ContentID = @InContentID

  IF @PreviousWebsiteKey IS NOT NULL AND @PreviousWebsiteKey = @InWebsiteKey BEGIN
    UPDATE Nav_Menu
       SET PreviousWebsiteKey = NULL
     WHERE NavMenuID = @NavMenuID
  END
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMReorderContentFolder]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMReorderContentFolder]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure places specified content folder at the correct position.
-- Content folders are ordered alphabetically.
--
-- Modifications
-- 09/04/2003  E.Tatsui    Created
-- =============================================


CREATE            PROCEDURE amsp_CMReorderContentFolder
  @InNavMenuID numeric
AS
BEGIN
  DECLARE
    @ParentNavMenuID numeric,
    @RootFolderID numeric


  SELECT @ParentNavMenuID = ParentNavMenuID
    FROM Nav_Menu WITH (NOLOCK)
   WHERE NavMenuID = @InNavMenuID

  -- If there is a parent for this item, just call another sp and let it move.
  IF @ParentNavMenuID IS NOT NULL
    EXEC amsp_CMMoveContentFolder @InNavMenuID, @ParentNavMenuID, NULL
  ELSE BEGIN
  -- if this is level 1 and no parent, pass the root of content folder as parent id.
    SELECT TOP 1 @RootFolderID = NavMenuID
      FROM Nav_Menu WITH (NOLOCK)
     WHERE NavContentGroupInd = 'C'
       AND CategoryDepth = 0
     ORDER BY SortOrder
    EXEC amsp_CMMoveContentFolder @InNavMenuID, @RootFolderID, NULL
  END
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMResetNavContentURL]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMResetNavContentURL]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure resets Nav_Menu records and content records
-- with proper Pre and PostFuseURL.

-- This should be run on setup, deployment or whenever GECodePath changes.
-- Normally should be used for admin website or a site with only dynamic contents.
-- This is because for fused site, published files need to be moved and link should be updated.
-- =============================================
CREATE  PROCEDURE amsp_CMResetNavContentURL
  @InWebsiteKey uniqueidentifier  
AS
BEGIN
  DECLARE
    @NavMenuID numeric,
    @ContentID numeric,
    @PreFuseURL varchar(500),
    @PostFuseURL varchar(500),
    @NewPreFuseURL varchar(500),
    @NewPostFuseURL varchar(500)

  DECLARE c_NavMenu CURSOR FOR 
   SELECT NavMenuID,
          PreFuseURL,
          PostFuseURL
     FROM Nav_Menu
    WHERE WebsiteKey = @InWebsiteKey

  OPEN c_NavMenu
  FETCH NEXT FROM c_NavMenu
   INTO @NavMenuID,
        @PreFuseURL,
        @PostFuseURL

  WHILE @@FETCH_STATUS = 0 BEGIN
    EXECUTE amsp_CMGetFuseURL @NavMenuID, NULL, @NewPreFuseURL OUTPUT, @NewPostFuseURL OUTPUT
    
    IF IsNull(@NewPreFuseURL,'') <> IsNull(@PreFuseURL,'') OR IsNull(@NewPostFuseURL,'') <> IsNull(@PostFuseURL,'')
      UPDATE Nav_Menu
         SET PreFuseURL = @NewPreFuseURL,
             PostFuseURL = @NewPostFuseURL
       WHERE NavMenuID = @NavMenuID 

    FETCH NEXT FROM c_NavMenu
     INTO @NavMenuID,
          @PreFuseURL,
          @PostFuseURL
  END
  CLOSE c_NavMenu
  DEALLOCATE c_NavMenu


  DECLARE c_Content CURSOR FOR
   SELECT a.NavMenuID,
          a.ContentID,
          a.PreFuseURL,
          a.PostFuseURL
     FROM Content a, Nav_Menu b
    WHERE a.NavMenuID = b.NavMenuID
      AND b.WebsiteKey = @InWebsiteKey

  OPEN c_Content
  FETCH NEXT FROM c_Content
   INTO @NavMenuID,
        @ContentID,
        @PreFuseURL,
        @PostFuseURL

  WHILE @@FETCH_STATUS = 0 BEGIN
    EXECUTE amsp_CMGetFuseURL @NavMenuID, @ContentID, @NewPreFuseURL OUTPUT, @NewPostFuseURL OUTPUT

    IF IsNull(@NewPreFuseURL,'') <> IsNull(@PreFuseURL,'') OR IsNull(@NewPostFuseURL,'') <> IsNull(@PostFuseURL,'')
      UPDATE Content
         SET PreFuseURL = @NewPreFuseURL,
             PostFuseURL = @NewPostFuseURL
       WHERE ContentID = @ContentID

    FETCH NEXT FROM c_Content
     INTO @NavMenuID,
          @ContentID,
          @PreFuseURL,
          @PostFuseURL
  END
  CLOSE c_Content
  DEALLOCATE c_Content

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMRetrieveContentAsNew]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMRetrieveContentAsNew]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure deletes currently active content record
-- and creates a working version of old content record.
--
-- Modifications
-- 09/08/2003    E.Tatsui   Created
-- =============================================


CREATE       PROCEDURE amsp_CMRetrieveContentAsNew
  @InContentID numeric,
  @InContactID numeric,
  @OutWorkingContentID numeric OUTPUT
AS
BEGIN
  DECLARE 
    @CurrentContentID numeric,
    @CurrentContentStatus char(1),
    @OriginalContentID numeric,
    @CurrentNavMenuID numeric
    
  SELECT @CurrentContentID = b.ContentID,
         @CurrentContentStatus = b.WorkflowStatusCode,
         @OriginalContentID = b.OriginalContentID,
         @CurrentNavMenuID = b.NavMenuID
    FROM Content a, vCurrent_Content b
   WHERE a.OriginalContentID = b.OriginalContentID
     AND a.ContentID = @InContentID

  IF @CurrentNavMenuID IS NULL
     SELECT @CurrentNavMenuID = NavMenuID
       FROM Content
      WHERE ContentID = @InContentID

  IF @CurrentContentStatus IN ('A','W')
    EXEC amsp_CMDeleteContent @CurrentContentID, @InContactID, 'Y', NULL

  EXEC amsp_CMCopyContentRow @InContentID, @InContactID, @OutWorkingContentID OUTPUT
  
  -- Store the previous current content id as previous id.
  -- Also update NavMenuID to current nav menu id, in case it has been changed by moving.
  UPDATE Content
     SET PreviousContentID = (SELECT Max(ContentID)
                                FROM Content
                               WHERE OriginalContentID = @OriginalContentID
                                 AND ContentID <> @OutWorkingContentID),
         NavMenuID = @CurrentNavMenuID,
         SortOrder = (SELECT IsNull(Max(SortOrder),0) + 1
                        FROM Content
                       WHERE NavMenuID = @CurrentNavMenuID)
   WHERE ContentID = @OutWorkingContentID
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMSetMembersOnlyContent]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMSetMembersOnlyContent]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure sets Member's Only Content for simple websites.
-- For simple websites, Member's only flag is set on Nav_Menu table.
-- This sp reflects the change in Nav_Menu table to content records.
--
-- Modifications
-- 10/13/2003    E.Tatsui    Created
-- =============================================
CREATE PROCEDURE amsp_CMSetMembersOnlyContent
  @InNavMenuID numeric,
  @InMembersOnlyFlag char(1),
  @InContactID numeric
AS
BEGIN
  DECLARE
    @ContentID numeric,
    @OutContentID numeric

  -- All the outstanding content for this nav item needs to 
  DECLARE c_Content CURSOR FOR
  SELECT ContentID
    FROM vCurrent_Content
   WHERE NavMenuID = @InNavMenuID
  
  OPEN c_Content
  FETCH NEXT FROM c_Content
   INTO @ContentID

  WHILE @@FETCH_STATUS = 0 BEGIN
    -- In order to change Member's Only Flag, we need to make working versions of Content record.
    EXEC amsp_CMGetWorkingContentID @ContentID, @InContactID, @OutContentID OUTPUT
    -- Change the status to approved since this is simple site.
    EXEC amsp_CMChangeStatus @OutContentID, 'A', @InContactID
  
    SET @ContentID = @OutContentID
  
    -- Set Member's Only Flag.
    UPDATE Content
       SET MembersOnlyFlag = @InMembersOnlyFlag
     WHERE ContentID = @ContentID

    DELETE FROM Content_Security_Group
     WHERE ContentID = @ContentID

    -- If this is member's only, copy security group.
    IF @InMembersOnlyFlag = 'Y'
      INSERT INTO Content_Security_Group
                  (ContentID,
                   SecurityGroupCode)
      SELECT @ContentID,
             SecurityGroupCode
        FROM Nav_Menu_Security_Group
       WHERE NavMenuID = @InNavMenuID
    
    FETCH NEXT FROM c_Content
     INTO @ContentID
  END
  CLOSE c_Content
  DEALLOCATE c_Content
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMUpdateContentNavMenu]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMUpdateContentNavMenu]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure moves a content record to a specified folder/nav menu.
-- 
-- Modification
-- 09/08/2003    E.Tatsui   Created
-- =============================================

CREATE          PROCEDURE amsp_CMUpdateContentNavMenu
	@InMoveContentID numeric,
  @InTargetNavMenuID numeric,
  @InContactID numeric,
  @OutErrorMessage varchar(255) OUTPUT
AS
BEGIN
  DECLARE
    @OrigURLSafeName varchar(255),
    @URLSafeName varchar(255),
    @OriginalNavMenuID numeric,
    @DefaultContentID numeric,
    @ContentNum numeric,
    @NavContentGroupInd char(1),
    @RecycleBinID numeric,
    @WorkflowStatusCode char(1),
    @ContentID numeric,
    @OrigNavContentGroupInd char(1)

  SELECT @RecycleBinID = NavMenuID
    FROM Nav_Menu
   WHERE Name = 'Content_Recycle_Bin'

  SELECT @OrigURLSafeName = a.URLSafeName,
         @OriginalNavMenuID = a.NavMenuID,
         @DefaultContentID = b.ContentID,
         @ContentNum = (SELECT Count(*) FROM vCurrent_Content WHERE NavMenuID = b.NavMenuID),
         @OrigNavContentGroupInd = b.NavContentGroupInd,
         @WorkflowStatusCode = a.WorkflowStatusCode
    FROM Content a WITH (NOLOCK), Nav_Menu b WITH (NOLOCK)
   WHERE a.ContentID = @InMoveContentID
     AND a.NavMenuID = b.NavMenuID

  SELECT @NavContentGroupInd = NavContentGroupInd
    FROM Nav_Menu WITH (NOLOCK)
   WHERE NavMenuID = @InTargetNavMenuID

  -- If the target is recycle bin, delete the content.
  IF @InTargetNavMenuID = @RecycleBinID BEGIN  
    IF @WorkflowStatusCode IN ('P')
      EXEC amsp_CMDeleteContent @InMoveContentID, @InContactID, 'N', NULL
    ELSE BEGIN -- There is a working version. Mark it as recycled.
      UPDATE Content
         SET WorkflowStatusCode = 'Y',
             ContactID = @InContactID
       WHERE ContentID = @InMoveContentID

      INSERT INTO Content_Workflow_Log (
             ContentID,
             WorkflowStatusCode,
             ContactID,
             ChangeDateTime)
      VALUES (@InMoveContentID,
             'Y',
              @InContactID,
              CURRENT_TIMESTAMP)
    END
  END
  ELSE BEGIN -- Normal move.
    -- If there is no working version, create one.
    IF @WorkflowStatusCode NOT IN  ('W','A','E')
      EXEC amsp_CMGetWorkingContentID @InMoveContentID, @InContactID, @ContentID OUTPUT, 'N'
    ELSE
      SET @ContentID = @InMoveContentID

    -- Since ContentID has changed, get the values again.
    IF @ContentID <> @InMoveContentID 
      SELECT @OrigURLSafeName = a.URLSafeName,
             @OriginalNavMenuID = a.NavMenuID,
             @DefaultContentID = b.ContentID,
             @ContentNum = (SELECT Count(*) FROM vCurrent_Content WHERE NavMenuID = b.NavMenuID),
             @OrigNavContentGroupInd = b.NavContentGroupInd,
             @WorkflowStatusCode = a.WorkflowStatusCode
        FROM Content a WITH (NOLOCK), Nav_Menu b WITH (NOLOCK)
       WHERE a.ContentID = @ContentID
         AND a.NavMenuID = b.NavMenuID

    EXEC amsp_CMGetUniqueContentName NULL, @OrigURLSafeName, @InTargetNavMenuID, @URLSafeName OUTPUT

    UPDATE Content
       SET NavMenuID = @InTargetNavMenuID,
           URLSafeName = @URLSafeName,
           SortOrder = (SELECT IsNull(Max(SortOrder),0)+1
                          FROM vCurrent_Content
                         WHERE NavMenuID = @InTargetNavMenuID),
           ContactID = @InContactID
     WHERE ContentID = @ContentID 
  
    -- If destination is navigation menu.
    IF @NavContentGroupInd = 'N' BEGIN
      -- If this is the first content, make it default one.
      UPDATE Nav_Menu
         SET ContentID = @ContentID
       WHERE NavMenuID = @InTargetNavMenuID
         AND ContentID IS NULL
    END
    -- If content belonged to a nav item before.
    IF @OrigNavContentGroupInd = 'N' BEGIN
      -- If this is default content, need to assign a new default content.
      IF @DefaultContentID = @InMoveContentID BEGIN
        IF @ContentNum > 2
          UPDATE Nav_Menu
             SET ContentID = (SELECT TOP 1 ContentID 
                                FROM vCurrent_Content 
                               WHERE NavMenuID = @OriginalNavMenuID
                               ORDER BY SortOrder),
                 WorkflowStatusCode = 'W',
                 PublishedDateTime = NULL
           WHERE NavMenuID = @OriginalNavMenuID
        ELSE
          UPDATE Nav_Menu
             SET ContentID = NULL,
                 DirectListComboInd = 'D',
                 WorkflowStatusCode = 'W',
                 PublishedDateTime = NULL
           WHERE NavMenuID = @OriginalNavMenuID
      END
      -- Resort content.
      EXEC amsp_CMRenumCurrentContent @OriginalNavMenuID
    END

  END

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMUpdatePublishDate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMUpdatePublishDate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- Procedure to update PUblishedDateTime.
-- =============================================
CREATE         PROCEDURE amsp_CMUpdatePublishDate 
	@InPublishRequestDetailId numeric = NULL,
  @InPublishRequestID numeric =  NULL
AS

BEGIN

  DECLARE
    @ContactID numeric,
    @PublishedDateTime datetime

  IF @InPublishRequestDetailId IS NOT NULL BEGIN
     SET @PublishedDateTime = GetDATE()
     UPDATE Publish_Request_Detail
        SET PublishedDateTime = @PublishedDateTime,
            PublishRequestStatusCode = 'P'
      WHERE PublishRequestDetailID = @InPublishRequestDetailId

     UPDATE Publish_Message_Log
        SET DisplayFlag = 'N'
      WHERE PublishRequestDetailID = @InPublishRequestDetailId
  
    SELECT @ContactID = a.ContactID
      FROM Publish_Request a, Publish_Request_Detail b
     WHERE a.PublishRequestID = b.PublishRequestID
       AND b.PublishRequestDetailID = @InPublishRequestDetailId

    EXECUTE amsp_CMFinalizePublish @InPublishRequestDetailId, @PublishedDateTime, @ContactID
  END
  IF @InPublishRequestID IS NOT NULL BEGIN
     UPDATE Publish_Request
        SET PublishedDateTime = GetDATE()
      WHERE PublishRequestID = @InPublishRequestID

     UPDATE Publish_Message_Log
        SET DisplayFlag = 'N'
      WHERE PublishRequestDetailID = 0
        AND PublishRequestID = @InPublishRequestID
  END
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_CMUpdatePublishLocation]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_CMUpdatePublishLocation]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- Store published location in Content_File, Content_HTML or Content.
--
-- Modifications
-- 06/16/2003      E.Tatsui
-- =============================================

CREATE       PROCEDURE amsp_CMUpdatePublishLocation
  @InContentID numeric,
  @InContentFileID numeric = 0,
  @InHTMLContentID numeric = 0,
  @InDefaultContentFlag char(1) = 'N',
  @InPublishLocation varchar(255)
AS
BEGIN
  DECLARE
    @PublishLocation varchar(255)

  SET @PublishLocation = Replace(@InPublishLocation, '\','/')

  IF @InContentFileID > 0 AND @InPublishLocation IS NOT NULL
    UPDATE Content_File
       SET PublishLocation = @PublishLocation
     WHERE ContentFileID = @InContentFileID

  IF @InHTMLContentID > 0 AND @InPublishLocation IS NOT NULL
    UPDATE Content_HTML
       SET PublishLocation = @PublishLocation
     WHERE ContentID = @InHTMLContentID

  IF @InDefaultContentFlag = 'Y' AND @InPublishLocation IS NOT NULL
    UPDATE Content
       SET PublishLocation =  @PublishLocation
     WHERE ContentID = @InContentID

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_GetChildMenuItems]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_GetChildMenuItems]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE        PROCEDURE amsp_GetChildMenuItems
  @NavMenuID integer,
  @ContactID numeric
AS
BEGIN

  DECLARE
    @counter integer

  create table #temp (NavMenuID integer)

  /*
  ** First insert selfe
  */

  INSERT INTO #temp
  SELECT NavMenuID 
  FROM Nav_Menu
  WHERE NavMenuID = @NavMenuID
  
  /*
  ** As long as there are new children, keep adding them to #temp.
  ** To make sure a bad nav_menu item doesn't lock the server, we also
  ** limit this to 50 iterations.
  */
  SET @counter = 0
  WHILE @@rowCount > 0 AND @counter < 50 BEGIN
    SET @counter = @counter + 1
    INSERT INTO #temp
    SELECT a.NavMenuID
      FROM Nav_Menu a, #temp b
     WHERE a.ParentNavMenuID = b.NavMenuID
       AND a.NavMenuID NOT IN (SELECT NavMenuID FROM #temp)
  END

  /*
  ** Return our results
  */

  SELECT a.*,
         b.ContentEditorFlag,
         b.ContentApproverFlag,
         b.NavCreatorFlag,
         b.NavEditorFlag,
         b.CustomPageFlag,
         b.LayoutFlag,
         b.UploadFlag,
         b.EditorFlag,
         b.ComponentScriptFlag,
         c.HideFlag AS ParentHideFlag,
        (SELECT count(*)
           FROM Nav_Menu z
          WHERE z.SortOrder > a.SortOrder
            AND z.SortOrder <
               (SELECT IsNull(Min(x.SortOrder),99999)
                  FROM Nav_Menu x
                 WHERE x.SortOrder > a.SortOrder
                   AND x.CategoryDepth <= a.CategoryDepth)) AS DescendantCount,
        (SELECT count(*)
           FROM Nav_Menu z
          WHERE z.SortOrder > a.SortOrder
            AND z.SortOrder <
               (SELECT IsNull(Min(x.SortOrder),99999)
                  FROM Nav_Menu x
                 WHERE x.SortOrder > a.SortOrder
                   AND x.CategoryDepth <= a.CategoryDepth)
            AND z.ContentAuthorityGroupID IN (SELECT ContentAuthorityGroupID
						FROM Content_Authority_Producer
						WHERE ContactID = @ContactID)) AS AuthorizedDescendantCount,
         NULL AS AncestoryList,
         NULL As AncestoryHideFlag,
         (SELECT count(*)
            FROM Content z
           WHERE z.NavMenuID = a.NavMenuID
             AND z.WorkflowStatusCode = 'W') AS WorkingContentCount,
         (SELECT count(*)
            FROM Content z
           WHERE z.NavMenuID = a.NavMenuID
             AND (z.WorkflowStatusCode = 'D' OR z.WorkflowStatusCode = 'E')) AS PendingContentCount,
         (SELECT count(*)
            FROM Content z
           WHERE z.NavMenuID = a.NavMenuID
             AND z.WorkflowStatusCode = 'A') AS ApprovedContentCount,
         (SELECT MAX(ContentID)
            FROM vCurrent_Content z
           WHERE z.NavMenuID = a.NavMenuID
             AND (z.ContentID = a.ContentID OR z.PreviousContentID = a.ContentID)) AS WorkingContentID
    FROM (Nav_Menu a LEFT OUTER JOIN Content_Authority_Producer b
      ON a.ContentAuthorityGroupID = b.ContentAuthorityGroupID
     AND b.ContactID = @ContactID) LEFT OUTER JOIN Nav_Menu c
      ON a.ParentNavMenuID = c.NavMenuID, #temp t
   WHERE a.NavMenuID = t.NavMenuID
   ORDER BY a.SortOrder

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_GetSearchableComponents]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_GetSearchableComponents]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE                     procedure [dbo].[amsp_GetSearchableComponents] 
  @SearchComponentList varchar(1000),
  @KeyID numeric
AS
BEGIN
 
  /*
  ** DESCRIPTION:
  ** ------------
  ** This sp returns the desired fields to be indexed for searching
  **
  ** This sp is designed to support the following component codes:
  **
  ** CM - URL Links from Content_Link
  **
  ** INPUTS:
  ** -------
  ** @SearchComponentList -> A comma separated list of Component Codes for
  **                         which to generate search records
  ** @KeyID               -> The primary key value of a specific record to be retrieved.  If
  **                         this is 0 then return all records for the specified component codes. 
  **    
  ** 
  ** RESULT SET:
  ** -----------
  **   SearchKey            -> The Unique Search Key for the Record
  **   Title                -> Display Title in Search Results
  **   Body1                -> Main Content to be Indexed
  **   Body2                -> Optional Additional Content to Index
  **   InterestCategoryList -> Comma Separated List of IC's
  **   CustomField          -> Initially Set to Date, but may be Customized
  **
  ** NOTES:
  ** ------
  **   SearchKey has the following format:
  **     Position 1   -> 'Y' or 'N' indicating Members Only Content
  **     Position 2   -> ':'
  **     Position 3-4 -> 2 Character Component Code
  **     Position 5   -> ':' 
  **     Position 6-? -> Component ID
  **
  ** PROGRAMMING CONSIDERATIONS:
  ** ---------------------------
  ** Dynamic SQL is intentionally not used.  Speed overrides elegance.
  ** Do not convert to dynamic SQL - It cannot be parsed until runtime.
  **
  ** HISTORY:
  ** --------
  ** 06/02/2001   N.Malhotra  Initial Version Created
  ** 06/15/2001   N.Malhotra  Added Date and CustomField2
  ** 09/04/2001   N.Malhotra  Added template to handle sites with more than one template
  ** 09/27/2001   N.Malhotra  Fixed a bug where the InterestCategroyList for the
  **                          first matchind content record was not being set properly.
  ** 10/25/2001   I.Kim       Fixed Newsletter to refer Sent_Email table.
  **                          However, you must configure Component_Ref table.
  **                          Also commented out Conference section (to be fixed by Nitin)
  ** 03/20/2002   I.Kim       For PR --> ISNULL(ArchiveFlag,'N') since ArchiveFlag can
  **                          contain null.
  ** 03/07/2003   E.Pfleckl   Changed the description for conferences to be NULL.
  **                          Added Calendar Events
  **                          Fixed several issues in Forums block and added
  **                          where clause to only include active forums
  ** 03/10/2003   E.Pfleckl   Changed Conference block to only return active conferences
  ** 08/25/2003   J.Stopple   Updated 'NL' section for new Newsletter Manager
  ** 10/14/2003   E.Tatsui    Modified to exclude admin websites.
  **                          Changed UserDefinedField1 to PublicationDate
  ** 05/12/2004   E.Tatsui    Added changes for conference and ecommerce.
  */
 
  DECLARE 
    @ComponentCode                 char(2),
    @OldComponentCode              char(2),
    @ComponentID                   numeric,
    @OldComponentID                numeric,
    @InterestCategoryID            numeric,
    @InterestCategoryList          varchar(1000),
    @l_FirstRow                    int,
    @AdminWebsiteKey               uniqueidentifier,
    @NavMenuID                     numeric,
    @WebsiteKey                    uniqueidentifier
 
  /*
  ** Create a temp table that we'll fill with each type of component code 
  ** specified in ComponentCodeList.
  **
  ** NOTE: CustomField is not used in the standard deployment.  This field is

  ** included in the results so that deployments requiring a custom field in 

  ** their search (e.g. copyright date) need only modify this sp and not the CF
  ** code within each product utilizing this sp.
  */
 
  CREATE TABLE #temp (
    ComponentID            varchar(50),
    TemplatePath           varchar(255),
    ComponentCode          char(2),
    MembersOnlyFlag        char(1),
    Title                  varchar(255),
    Body1                  text,
    Body2                  text,
    InterestCategoryList   varchar(3000),
    CustomField2           varchar(255),
    NavMenuID              numeric,
    AllWebsiteKeys         varchar(1000),
    CustomID               varchar(50),
    IncludeInCrossSiteSearchFlag char(1) Default('Y')
  )
 
  SELECT @AdminWebsiteKey = Value
    FROM System_Variable
   WHERE Name = 'CMAdminWebsiteKey'

  /*
  ** For ComponentCode = 'CM' we need to pull Links
  */
  IF (CHARINDEX('CM', @SearchComponentList) > 0)
 
    IF @KeyID > 0
      INSERT INTO #temp (ComponentID, TemplatePath, ComponentCode, MembersOnlyFlag, Title, Body1, Body2, CustomField2, NavMenuID, AllWebsiteKeys, IncludeInCrossSiteSearchFlag, CustomID)
	SELECT     cl.ContentID, NULLIF (n.TemplatePath, '') AS Expr1, 'CM' AS Expr2, c.MembersOnlyFlag, cl.LinkName, c.Description, c.Keywords, 
	           CONVERT(VARCHAR(18), ISNULL(M.MicrositeID, '0')) + ',' + CONVERT(varchar(20), ISNULL(c.PublicationDate, CURRENT_TIMESTAMP), 102) AS Expr3, 
	           n.NavMenuID, n.WebsiteKey, w.IncludeInCrossSiteSearchFlag, cl.ContentLinkID
	FROM         Content_Link AS cl INNER JOIN
	                      vCurrent_Content AS c ON cl.ContentID = c.ContentID INNER JOIN
	                      Nav_Menu AS n ON c.NavMenuID = n.NavMenuID LEFT OUTER JOIN
	                      Microsite AS M ON n.AncestorNavMenuID = M.HomeNavMenuID INNER JOIN
	                      Website AS w ON n.WebsiteKey = w.WebsiteKey
	WHERE     (n.WebsiteKey <> @AdminWebsiteKey) AND (cl.ContentLinkID = @KeyID) AND (ISNULL(n.HideFlag, 'N') = 'N') 
    ELSE
      INSERT INTO #temp (ComponentID, TemplatePath, ComponentCode, MembersOnlyFlag, Title, Body1, Body2, CustomField2, NavMenuID, AllWebsiteKeys, IncludeInCrossSiteSearchFlag, CustomID)
	SELECT     cl.ContentID, NULLIF (n.TemplatePath, '') AS Expr1, 'CM' AS Expr2, c.MembersOnlyFlag, cl.LinkName, c.Description, c.Keywords, 
	                      CONVERT(VARCHAR(18), ISNULL(M.MicrositeID, '0')) + ',' + CONVERT(varchar(20), ISNULL(c.PublicationDate, CURRENT_TIMESTAMP), 102) AS Expr3, 
	                      n.NavMenuID, n.WebsiteKey, w.IncludeInCrossSiteSearchFlag, cl.ContentLinkID
	FROM         Content_Link AS cl INNER JOIN
	                      vCurrent_Content AS c ON cl.ContentID = c.ContentID INNER JOIN
	                      Nav_Menu AS n ON c.NavMenuID = n.NavMenuID LEFT OUTER JOIN
	                      Microsite AS M ON n.AncestorNavMenuID = M.HomeNavMenuID INNER JOIN
	                      Website AS w ON n.WebsiteKey = w.WebsiteKey
	WHERE     (n.WebsiteKey <> @AdminWebsiteKey) AND (c.WorkflowStatusCode = 'P') AND (ISNULL(n.HideFlag, 'N') = 'N')

  /*
  ** Finally, after all rows have been added to the temp table, we need to 
  ** generate the comma separated list of Interest Categories
  */
   DECLARE c_InterestCategory CURSOR FOR
    SELECT cic.ComponentCode, 
           cic.InterestCategoryID,
           cic.ComponentID
      FROM Component_Interest_Category cic, #temp t
     WHERE cic.ComponentCode = t.ComponentCode
       AND cic.ComponentID = t.ComponentID
     ORDER BY cic.ComponentCode, cic.ComponentID
 
  OPEN c_InterestCategory
  
  FETCH NEXT FROM c_InterestCategory INTO
    @ComponentCode,
    @InterestCategoryID,
    @ComponentID
 
  SET @OldComponentCode = @ComponentCode
  SET @OldComponentID = @ComponentID
  SET @InterestCategoryList = @InterestCategoryID
  SET @l_FirstRow = 1
 
  WHILE (@@FETCH_STATUS=0) BEGIN
    IF ( @OldComponentCode != @ComponentCode or @OldComponentID != @ComponentID ) BEGIN
      UPDATE #temp
         SET InterestCategoryList = @InterestCategoryList
       WHERE ComponentCode = @OldComponentCode
         AND ComponentID = @OldComponentID
 
      SET @InterestCategoryList = @InterestCategoryID
    END
    ELSE BEGIN
      IF ( @l_FirstRow = 1 ) BEGIN
        SET @InterestCategoryList = @InterestCategoryList + ',' + convert(varchar(10), @InterestCategoryID)      
      END
      ELSE BEGIN
        SET @l_FirstRow = 0
      END
    END
 
    SET @OldComponentCode = @ComponentCode
    SET @OldComponentID = @ComponentID
 
    FETCH NEXT FROM c_InterestCategory INTO
      @ComponentCode,
      @InterestCategoryID,
      @ComponentID
 
  END
 
  UPDATE #temp
     SET InterestCategoryList = @InterestCategoryList
   WHERE ComponentCode = @OldComponentCode
     AND ComponentID = @OldComponentID
 
  CLOSE c_InterestCategory
  DEALLOCATE c_InterestCategory

  -- For each nav item, add Websites are marked to include in the search
  -- and only include those websites that has the setting on.
  UPDATE #temp
     SET AllWebsiteKeys = AllWebsiteKeys + ','
   WHERE AllWebsiteKeys IS NOT NULL

  DECLARE c_NavMenu CURSOR FOR 
   SELECT DISTINCT b.NavMenuID, b.WebsiteKey
     FROM #temp a, Nav_Menu_Website b, Website c
    WHERE a.NavMenuID = b.NavMenuID
      AND a.AllWebsiteKeys NOT LIKE Convert(varchar(50),b.WebsiteKey) + '%'
      AND b.WebsiteKey = Convert(varchar(50),c.WebsiteKey)
      AND c.IncludeInCrossSiteSearchFlag = 'Y'

  OPEN c_NavMenu
  FETCH NEXT FROM c_NavMenu
   INTO @NavMenuID,
        @WebsiteKey
  WHILE @@FETCH_STATUS = 0 BEGIN
  
    UPDATE #temp
       SET AllWebsiteKeys = IsNull(AllWebsiteKeys,'') + Convert(varchar(50),@WebsiteKey) + ','
     WHERE NavMenuID = @NavMenuID

    FETCH NEXT FROM c_NavMenu
     INTO @NavMenuID,
          @WebsiteKey
  END
  CLOSE c_NavMenu
  DEALLOCATE c_NavMenu

  -- Remove extra ","
  UPDATE #temp
     SET AllWebsiteKeys = Left(AllWebsiteKeys,Len(AllWebsiteKeys)-1)
   WHERE AllWebsiteKeys IS NOT NULL

  UPDATE #temp
     SET ComponentID = ComponentID + '-' + CustomID
   WHERE CustomID IS NOT NULL 

  SELECT IsNull(MembersOnlyFlag, 'N') + ':' + ComponentCode + ':' + ComponentID + ':' + IsNull(TemplatePath, 'NONE') as SearchKey,
         Title,
         Body1,
         Body2,
         InterestCategoryList,
         CASE WHEN AllWebsiteKeys IS NULL THEN ''
              ELSE 'WKEY:' + AllWebsiteKeys  + ','
         END + 'CSEARCH:' + IsNull(IncludeInCrossSiteSearchFlag,'Y') + ',' + CustomField2 AS CustomField2
    FROM #temp
 
END

set ANSI_NULLS ON
set QUOTED_IDENTIFIER ON

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_GetSearchableFiles]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_GetSearchableFiles]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE                   procedure [dbo].[amsp_GetSearchableFiles]
    @InFileRootPath   varchar(255),
    @InWebRootPath    varchar(255),
    @InUseNewWindowFlag   char(1)='N',
    @InNewWindowWidth   int=500,
    @InNewWindowHeight    int=500,
    @InNewWindowToolbar   varchar(3)='no',
    @InNewWindowMenubar   varchar(3)='no',
    @InNewWindowStatusbar varchar(3)='no'

AS
BEGIN

  /*
  ** DESCRIPTION:
  ** ------------
  ** This sp returns the desired fields to be indexed for searching files
  **
  ** INPUTS:
  ** -------
  **   @InFileRootPath            -> Full path to root directory above Web root
  **   @InWebRootPath             -> Full path to the Web root
  **   @InUseNewWindowFlag        -> Should we use Content.OpenInNewWindowFlag
  **   @InNewWindowWidth          -> Width of new window
  **   @InNewWindowHeight         -> Height of new window
  **   @InNewWindowToolbar        -> Should new window have a toolbar (yes/no)
  **   @InNewWindowMenuBar        -> Should new window have a menubar (yes/no)
  **   @InNewWindowStatusBar      -> Should new window include the status bar (yes/no)
  ** 
  ** RESULT SET:
  ** -----------
  **   FilePath               -> Full Path to File to Index
  **   URL                    -> How to Display the Resulting File
  **   Title                  -> Display Title for File in Search Results
  **   InterestCategoryList   -> Comma Separated List of IC's
  **   CustomField            -> UserDefinedDate1 (Copyright Date)
  **
  ** NOTES:
  ** ------
  **
  ** PROGRAMMING CONSIDERATIONS:
  ** ---------------------------
  ** In General, the SQL used here is not all that fast ... this SP is
  ** designed to be used in batch as part of the daily re-indexing operation.
  ** It is not designed for real-time (i.e. while the user is waiting) use.
  **
  ** HISTORY:
  ** --------
  ** 06/01/2001  N.Malhotra   Initial Version Created
  ** 06/15/2001  N.Malhotra   Added Date and CustomField2
  ** 08/11/2001  N.Malhotra   Changed to use input parameters for File Paths and Admin Section
  **                          instead of querying application_variable table from within the proc.
  ** 09/04/2001  N.Malhotra   There are instances where PublishLocation is NULL or is the empty
  **                          string in content_file and content_html - added logic to deal with this.
  ** 09/27/2001  N.Malhotra   Fixed a bug where the InterestCategoryList for the
  **                          first matching content record was not being set properly.
  ** 10/22/2001  N.Malhotra   For MembersOnly content, changed logic to use the template specified 
  **                          by the NavMenuID --- no longer hard-code to use template.cfm
  ** 10/25/2001  N.Malhotra   Clients are expecting that if they specify 'Open in New Window' then
  **                          this will even flow through to search results.  So, added input variables
  **                          to define the behavior and added code to use Content.OpenInNewWindowFlag.
  ** 11/30/2001  N.Malhotra   Fixed a bug that was setting the filepath for MembersOnly files incorrectly
  ** 10/02/2003  B. Harbin    Rewritten for use with the new advanced search engine.
  ** 10/14/2003  E.Tatsui     Changed to exclude admin website.
  **                          Changed UserDefinedField1 to PublicationDate
  **                          Added logic so that ContentFolders are dynamic link and Navigations are 
  **                          linked to fused page.
  **                          Changed logic for directory structure to fit CM5\
  ** 05/04/2004  E.Tatsui     Added Nitin's change to use vCurrent_Content insead of content
  ** 01/30/2008  C.Robertson  Add "/" to @LeftNewWinString
  **                          Fixed bug where w.UseAspNetTemplateFlag = 'N' AND n.NavContentGroupInd = 'C' AND 
  **                          c.OpenInNewWindowFlag = 'Y' AND @InUseNewWindowFlag = 'Y' AND isNULL(c.MembersOnlyFlag, 'N') != 'Y'
  **                          was going to an aspx page
  */

  Declare  
    @ComponentID    numeric,
    @OldComponentID   numeric,
    @InterestCategoryID   numeric,
    @InterestCategoryName   varchar(255),
    @InterestCategoryList   varchar(1000),
    @InterestCategoryNameList   varchar(2000),
@LeftNewWinString   varchar(512),
    @RightNewWinString    varchar(512),
    @l_FirstRow  int,
    @AdminWebsiteKey uniqueidentifier,
    @GECodePath varchar(255),
    @NavMenuID numeric,
    @WebsiteKey uniqueidentifier,
    @VirtualDirectoryPath varchar(255)

  /*
  ** Create a temp table to hold our result set
  */
  CREATE table #temp (
    ContentID     numeric,
    FilePath      varchar(255),
    URL       varchar(1000),
    Title     varchar(255),
    InterestCategoryList  varchar(1000),
    CustomField2    varchar(255),
    Keywords      varchar(1000),
    Description     varchar(2000),
    WebsiteKey    uniqueidentifier,
    AllWebsiteKeys varchar(1000),
    IncludeInCrossSiteSearchFlag char(1) Default('N'),
    NavContentGroupInd char(1),
    NavMenuID     numeric
  )

  SELECT @AdminWebsiteKey = Value
    FROM System_Variable
   WHERE Name = 'CMAdminWebsiteKey'

  SELECT @GECodePath = Value
    FROM System_Variable
   WHERE Name = 'GECodePath'

  SELECT @VirtualDirectoryPath = Value
    FROM System_Variable
   WHERE Name = 'VirtualDirectoryPath'

  IF Len(@GECodePath) > 1
    SET @GECodePath = RIGHT(@GECodePath,Len(@GECodePath)-1)
  ELSE IF @GECodePath = '/'
    SET @GECodePath = ''

  IF Len(@VirtualDirectoryPath) > 1
    SET @VirtualDirectoryPath = RIGHT(@VirtualDirectoryPath,Len(@VirtualDirectoryPath)-1)
  ELSE IF @VirtualDirectoryPath = '/'
    SET @VirtualDirectoryPath = ''
    
  /* 
  ** If we are using Content.OpenInNewWindowFlag, then let's setup our string
  ** one time so it's not as messy in the SQL below
  */

  IF @InUseNewWindowFlag = 'Y' BEGIN
    SET @LeftNewWinString = '" target="_blank" onClick="newWin=open(''/'
    SET @RightNewWinString = ''', ''viewer'', ''width=' + 
                             Convert(varchar(4), @InNewWindowWidth) +
                             ',height=' + Convert(varchar(4), @InNewWindowHeight) +
                             ',toolbar=' + @InNewWindowToolbar + 
                             ',directories=no,menubar=' + + @InNewWindowMenubar + 
                             ',status=' + @InNewWindowStatusbar + 
                             ',resizable=yes,scrollbars=yes''); newWin.focus(); return false;"' 
  END
  
  /*
  ** A little ugly, but for performance I don't want to cursor loop if I don't
  ** have to.  So, we'll do all the data manipulation in the query.  We are 
  ** creating the complete FilePath a complete URL to be used direcly by verity.  
  */
  INSERT INTO #temp (ContentID, FilePath, URL, Title, Keywords, Description, CustomField2, WebsiteKey, IncludeInCrossSiteSearchFlag, NavContentGroupInd, NavMenuID)
    SELECT
      c.ContentID,
      FilePath = CASE
        WHEN c.MembersOnlyFlag = 'Y' THEN w.ProtectedRootPath + REPLACE(IsNULL(cf.PublishLocation, c.PublishLocation),'/','\')
        ELSE w.PublishRootPath + REPLACE(IsNull(cf.PublishLocation,c.PublishLocation),'/','\')
        END ,
      URL =  '"' +
       CASE WHEN n.NavContentGroupInd = 'C' THEN '/'
            WHEN c.SecureFlag = 'Y' THEN w.SecureWebsiteRootURL
            ELSE w.WebsiteRootURL END
      + CASE
        WHEN w.UseAspNetTemplateFlag = 'N' AND c.MembersOnlyFlag = 'Y' AND n.NavContentGroupInd = 'C'  AND c.OpenInNewWindowFlag = 'Y' AND @InUseNewWindowFlag = 'Y' THEN 
           @GECodePath + 'TemplateRedirect.cfm?template=/MembersOnly.cfm&ContentID=' + convert(varchar(18), c.ContentID) + @LeftNewWinString + @GECodePath + 'TemplateRedirect.cfm?template=/MembersOnly.cfm&ContentID=' + convert(varchar(18), c.ContentID) + @RightNewWinString
        WHEN w.UseAspNetTemplateFlag = 'N' AND c.MembersOnlyFlag = 'Y' AND n.NavContentGroupInd = 'C'  THEN 
           @GECodePath + 'TemplateRedirect.cfm?template=/MembersOnly.cfm&ContentID=' + convert(varchar(18), c.ContentID) + '"'
        WHEN w.UseAspNetTemplateFlag = 'N' AND c.MembersOnlyFlag = 'Y' AND c.OpenInNewWindowFlag = 'Y' AND @InUseNewWindowFlag = 'Y' THEN 
           @GECodePath + 'Template.cfm?section=' + n.Name + '&template=/MembersOnly.cfm&ContentID=' + convert(varchar(18), c.ContentID) + @LeftNewWinString + @GECodePath + 'Template.cfm?section=' + n.Name + '&template=/MembersOnly.cfm&ContentID=' + convert(varchar(18), c.ContentID) + @RightNewWinString
        WHEN w.UseAspNetTemplateFlag = 'N' AND c.MembersOnlyFlag = 'Y' THEN 
           @GECodePath + 'Template.cfm?section=' + n.Name + '&template=/MembersOnly.cfm&ContentID=' + convert(varchar(18), c.ContentID) + '"'
        WHEN w.UseAspNetTemplateFlag = 'N' AND n.NavContentGroupInd = 'C' AND c.OpenInNewWindowFlag = 'Y' AND @InUseNewWindowFlag = 'Y' AND isNULL(c.MembersOnlyFlag, 'N') != 'Y' THEN 
           @GECodePath + 'TemplateRedirect.cfm?section=' + n.Name + '&template=/CM/ContentDisplay.cfm&ContentFileID=' + convert(varchar(18), cf.ContentFileID) + @LeftNewWinString + @GECodePath + 'TemplateRedirect.cfm?section=' + n.Name + '&template=/CM/ContentDisplay.cfm&ContentFileID=' + convert(varchar(18), cf.ContentFileID) + @RightNewWinString
        WHEN w.UseAspNetTemplateFlag = 'N' AND n.NavContentGroupInd = 'C' THEN
           @GECodePath + 'TemplateRedirect.cfm?section=' + n.Name + '&template=/CM/ContentDisplay.cfm&ContentFileID=' + convert(varchar(18), cf.ContentFileID) +  + '"'
        WHEN w.UseAspNetTemplateFlag = 'N' AND c.OpenInNewWindowFlag = 'Y' AND @InUseNewWindowFlag = 'Y' AND isNULL(c.MembersOnlyFlag, 'N') != 'Y' THEN
           REPLACE(ISNULL(cf.PublishLocation, c.PublishLocation), REPLACE(IsNull(w.NavPublishDirectory,''),'\','/'), IsNull(w.NavContentDisplayPath,''))           
           + @LeftNewWinString + REPLACE(ISNULL(cf.PublishLocation, c.PublishLocation), REPLACE(IsNull(w.NavPublishDirectory,''),'\','/'), IsNull(w.NavContentDisplayPath,'')) + @RightNewWinString  
        WHEN w.UseAspNetTemplateFlag = 'Y' AND c.MembersOnlyFlag = 'Y' AND n.NavContentGroupInd = 'C'  AND c.OpenInNewWindowFlag = 'Y' AND @InUseNewWindowFlag = 'Y' THEN 
           @GECodePath + 'ContentManagerNet/TemplateRedirect.aspx?template=/ContentManagerNet/MembersOnly.aspx&ContentID=' + convert(varchar(18), c.ContentID) + @LeftNewWinString + @GECodePath + 'ContentManagerNet/TemplateRedirect.aspx?template=/ContentManagerNet/MembersOnly.aspx&ContentID=' + convert(varchar(18), c.ContentID) + @RightNewWinString
        WHEN w.UseAspNetTemplateFlag = 'Y' AND c.MembersOnlyFlag = 'Y' AND n.NavContentGroupInd = 'C'  THEN 
           @GECodePath + 'ContentManagerNet/TemplateRedirect.aspx?template=/ContentManagerNet/MembersOnly.aspx&ContentID=' + convert(varchar(18), c.ContentID) + '"'
        WHEN w.UseAspNetTemplateFlag = 'Y' AND c.MembersOnlyFlag = 'Y' AND c.OpenInNewWindowFlag = 'Y' AND @InUseNewWindowFlag = 'Y' THEN 
           @VirtualDirectoryPath + '/' + n.Name +  + '/AM/ContentManagerNet/MembersOnly.aspx?Section=' + n.Name + '&ContentID=' + convert(varchar(18), c.ContentID) + @LeftNewWinString + @VirtualDirectoryPath + '/' + n.Name +  + '/AM/ContentManagerNet/MembersOnly.aspx?Section=' + n.Name + '&ContentID=' + convert(varchar(18), c.ContentID) + @RightNewWinString
        WHEN w.UseAspNetTemplateFlag = 'Y' AND c.MembersOnlyFlag = 'Y' THEN 
           @VirtualDirectoryPath + '/' + n.Name +  + '/AM/ContentManagerNet/MembersOnly.aspx?Section=' + n.Name + '&ContentID=' + convert(varchar(18), c.ContentID) + '"'
        WHEN w.UseAspNetTemplateFlag = 'Y' AND n.NavContentGroupInd = 'C' AND c.OpenInNewWindowFlag = 'Y' AND @InUseNewWindowFlag = 'Y' AND isNULL(c.MembersOnlyFlag, 'N') != 'Y' THEN 
           @GECodePath + 'ContentManagerNet/TemplateRedirect.aspx?Section=' + n.Name + '&template=/ContentManagerNet/ContentDisplay.aspx&ContentFileID=' + convert(varchar(18), cf.ContentFileID) + @LeftNewWinString + @GECodePath + 'ContentManagerNet/TemplateRedirect.aspx?Section=' + n.Name + '&template=/ContentManagerNet/ContentDisplay.aspx&ContentFileID=' + convert(varchar(18), cf.ContentFileID) + @RightNewWinString
        WHEN w.UseAspNetTemplateFlag = 'Y' AND n.NavContentGroupInd = 'C' THEN
           @GECodePath + 'ContentManagerNet/TemplateRedirect.aspx?Section=' + n.Name + '&template=/ContentManagerNet/ContentDisplay.aspx&ContentFileID=' + convert(varchar(18), cf.ContentFileID) +  + '"'
        WHEN w.UseAspNetTemplateFlag = 'Y' AND c.OpenInNewWindowFlag = 'Y' AND @InUseNewWindowFlag = 'Y' AND isNULL(c.MembersOnlyFlag, 'N') != 'Y' THEN
           REPLACE(ISNULL(cf.PublishLocation, c.PublishLocation), REPLACE(IsNull(w.NavPublishDirectory,''),'\','/'), IsNull(w.NavContentDisplayPath,''))           
           + @LeftNewWinString + REPLACE(ISNULL(cf.PublishLocation, c.PublishLocation), REPLACE(IsNull(w.NavPublishDirectory,''),'\','/'), IsNull(w.NavContentDisplayPath,'')) + @RightNewWinString  
        ELSE 
           REPLACE(ISNULL(cf.PublishLocation, c.PublishLocation), REPLACE(IsNull(w.NavPublishDirectory,''),'\','/'), IsNull(w.NavContentDisplayPath,'')) + '"'
      END,
      IsNULL(cf.Description, cf.FileName),
      c.Keywords,
      c.Description,
      convert(varchar(20), IsNULL(c.PublicationDate, '01/01/1950'), 102),
      w.WebsiteKey,
      w.IncludeInCrossSiteSearchFlag,
      n.NavContentGroupInd,
      n.NavMenuID
    FROM
      vCurrent_Content c, Nav_Menu n, 
      Content_File cf, Website w
    WHERE c.WorkflowStatusCode = 'P'
      and c.NavMenuID = n.NavMenuID
      and n.WebsiteKey != @AdminWebsiteKey
      and c.ContentID = cf.ContentID
      and n.WebsiteKey = w.WebsiteKey
      and (LEN(RTrim(cf.PublishLocation)) > 0 OR LEN(RTrim(c.PublishLocation)) > 0)
      and cf.FileTypeCode not in ('JPG', 'GIF')
      AND IsNull(n.HideFlag,'N') = 'N'
    UNION
    SELECT
      c.ContentID,
      FilePath = 
        CASE
        WHEN c.MembersOnlyFlag = 'Y' THEN w.ProtectedRootPath + REPLACE(IsNULL(ch.PublishLocation, c.PublishLocation),'/','\')
        ELSE w.PublishRootPath + REPLACE(IsNull(ch.PublishLocation,c.PublishLocation),'/','\')
        END ,
      URL =  '"' +
       CASE WHEN n.NavContentGroupInd = 'C' THEN '/'
            WHEN c.SecureFlag = 'Y' THEN w.SecureWebsiteRootURL
            ELSE w.WebsiteRootURL END
      + CASE
        WHEN w.UseAspNetTemplateFlag = 'N' AND c.MembersOnlyFlag = 'Y' AND n.NavContentGroupInd = 'C' AND c.OpenInNewWindowFlag = 'Y' AND @InUseNewWindowFlag = 'Y' THEN 
           @GECodePath + 'TemplateRedirect.cfm?template=/MembersOnly.cfm&ContentID=' + convert(varchar(18), c.ContentID) + @LeftNewWinString + @GECodePath + 'TemplateRedirect.cfm?template=/MembersOnly.cfm&ContentID=' + convert(varchar(18), c.ContentID) + @RightNewWinString
        WHEN w.UseAspNetTemplateFlag = 'N' AND c.MembersOnlyFlag = 'Y' AND n.NavContentGroupInd = 'C' THEN 
           @GECodePath + 'TemplateRedirect.cfm?template=/MembersOnly.cfm&ContentID=' + convert(varchar(18), c.ContentID) + '"'    
        WHEN w.UseAspNetTemplateFlag = 'N' AND c.MembersOnlyFlag = 'Y' AND c.OpenInNewWindowFlag = 'Y' AND @InUseNewWindowFlag = 'Y' THEN 
           @GECodePath + 'Template.cfm?section=' + n.Name + '&template=/MembersOnly.cfm&ContentID=' + convert(varchar(18), c.ContentID) + @LeftNewWinString + @GECodePath + 'Template.cfm?section=' + n.Name + '&template=/MembersOnly.cfm&ContentID=' + convert(varchar(18), c.ContentID) + @RightNewWinString
        WHEN w.UseAspNetTemplateFlag = 'N' AND c.MembersOnlyFlag = 'Y' THEN 
           @GECodePath + 'Template.cfm?section=' + n.Name + '&template=/MembersOnly.cfm&ContentID=' + convert(varchar(18), c.ContentID) + '"'
        WHEN w.UseAspNetTemplateFlag = 'N' AND n.NavContentGroupInd = 'C' AND c.OpenInNewWindowFlag = 'Y' AND @InUseNewWindowFlag = 'Y' AND isNULL(c.MembersOnlyFlag, 'N') != 'Y' THEN 
           @GECodePath + 'TemplateRedirect.cfm?' + 'template=/CM/HTMLDisplay.cfm&ContentID=' + convert(varchar(18), c.ContentID) + @LeftNewWinString + @GECodePath + 'TemplateRedirect.cfm?'+ '?template=/HTMLDisplay.cfm&ContentID=' + convert(varchar(18), c.ContentID) + @RightNewWinString
        WHEN w.UseAspNetTemplateFlag = 'N' AND n.NavContentGroupInd = 'C' THEN
           @GECodePath + 'TemplateRedirect.cfm?' +'template=/CM/HTMLDisplay.cfm&ContentID=' + convert(varchar(18), c.ContentID) + '"'
        WHEN w.UseAspNetTemplateFlag = 'Y' AND c.MembersOnlyFlag = 'Y' AND n.NavContentGroupInd = 'C' AND c.OpenInNewWindowFlag = 'Y' AND @InUseNewWindowFlag = 'Y' THEN 
           @GECodePath + 'ContentManagerNet/TemplateRedirect.aspx?template=/ContentManagerNet/MembersOnly.aspx&ContentID=' + convert(varchar(18), c.ContentID) + @LeftNewWinString + @GECodePath + 'ContentManagerNet/TemplateRedirect.aspx?template=/ContentManagerNet/MembersOnly.aspx&ContentID=' + convert(varchar(18), c.ContentID) + @RightNewWinString
        WHEN w.UseAspNetTemplateFlag = 'Y' AND c.MembersOnlyFlag = 'Y' AND n.NavContentGroupInd = 'C' THEN 
           @GECodePath + 'ContentManagerNet/TemplateRedirect.aspx?template=/ContentManagerNet/MembersOnly.aspx&ContentID=' + convert(varchar(18), c.ContentID) + '"'    
        WHEN w.UseAspNetTemplateFlag = 'Y' AND c.MembersOnlyFlag = 'Y' AND c.OpenInNewWindowFlag = 'Y' AND @InUseNewWindowFlag = 'Y' THEN 
           @VirtualDirectoryPath + '/' + n.Name +  + '/AM/ContentManagerNet/MembersOnly.aspx?Section=' + n.Name + '&ContentID=' + convert(varchar(18), c.ContentID) + @LeftNewWinString + @VirtualDirectoryPath + '/' + n.Name +  + '/AM/ContentManagerNet/MembersOnly.aspx?Section=' + n.Name + '&ContentID=' + convert(varchar(18), c.ContentID) + @RightNewWinString
        WHEN w.UseAspNetTemplateFlag = 'Y' AND c.MembersOnlyFlag = 'Y' THEN 
           @VirtualDirectoryPath + '/' + n.Name +  + '/AM/ContentManagerNet/MembersOnly.aspx?Section=' + n.Name + '&ContentID=' + convert(varchar(18), c.ContentID) + '"'
        WHEN w.UseAspNetTemplateFlag = 'Y' AND n.NavContentGroupInd = 'C' AND c.OpenInNewWindowFlag = 'Y' AND @InUseNewWindowFlag = 'Y' AND isNULL(c.MembersOnlyFlag, 'N') != 'Y' THEN 
           @GECodePath + 'ContentManagerNet/TemplateRedirect.aspx?' + 'template=/ContentManagerNet/HTMLDisplay.aspx&ContentID=' + convert(varchar(18), c.ContentID) + @LeftNewWinString + @GECodePath + 'ContentManagerNet/TemplateRedirect.aspx?'+ '?template=/ContentManagerNet/HTMLDisplay.aspx&ContentID=' + convert(varchar(18), c.ContentID) + @RightNewWinString
        WHEN w.UseAspNetTemplateFlag = 'Y' AND n.NavContentGroupInd = 'C' THEN
           @GECodePath + 'ContentManagerNet/TemplateRedirect.aspx?' +'template=/ContentManagerNet/HTMLDisplay.aspx&ContentID=' + convert(varchar(18), c.ContentID) + '"'
        WHEN c.OpenInNewWindowFlag = 'Y' AND @InUseNewWindowFlag = 'Y' AND isNULL(c.MembersOnlyFlag, 'N') != 'Y' THEN
           REPLACE(ISNULL(ch.PublishLocation, c.PublishLocation), REPLACE(IsNull(w.NavPublishDirectory,''),'\','/'), IsNull(w.NavContentDisplayPath,''))+ @LeftNewWinString + REPLACE(ISNULL(ch.PublishLocation, c.PublishLocation), REPLACE(IsNull(w.NavPublishDirectory,''),'\','/'), IsNull(w.NavContentDisplayPath,'')) + @RightNewWinString
        ELSE 
           REPLACE(ISNULL(ch.PublishLocation, c.PublishLocation), REPLACE(IsNull(w.NavPublishDirectory,''),'\','/'), IsNull(w.NavContentDisplayPath,'')) + '"'
      END,
      c.Name,
      c.Keywords,
      c.Description,
      convert(varchar(20), IsNULL(c.PublicationDate, '01/01/1950'), 102),
      w.WebsiteKey,
      w.IncludeInCrossSiteSearchFlag,
      n.NavContentGroupInd,
      n.NavMenuID
    FROM
      vCurrent_Content c, Nav_Menu n,
      Content_HTML ch, Website w
    WHERE c.WorkflowStatusCode = 'P'
      and c.NavMenuID = n.NavMenuID
      and n.WebsiteKey <> @AdminWebsiteKey
      and c.ContentID = ch.ContentID
      and n.WebsiteKey = w.WebsiteKey
      and (LEN(RTrim(ch.PublishLocation)) > 0 OR LEN(RTrim(c.PublishLocation)) > 0)
      AND IsNull(n.HideFlag,'N') = 'N'

  /*
  ** Finally, after all rows have been added to the temp table, we need to 
  ** generate the comma separated list of Interest Categories
  */
  
  DECLARE c_InterestCategory CURSOR FOR
    select cic.InterestCategoryID,
           cic.ComponentID,
           ic.Name
      from Component_Interest_Category cic, #temp t, Interest_Category ic
     where cic.ComponentCode = 'CM'
       and cic.ComponentID = t.ContentID
       and cic.InterestCategoryID = ic.InterestCategoryID
     order by cic.ComponentID

  OPEN c_InterestCategory
  
  FETCH NEXT FROM c_InterestCategory INTO
    @InterestCategoryID,
    @ComponentID,
    @InterestCategoryName

  SET @OldComponentID = @ComponentID
  SET @InterestCategoryList = @InterestCategoryID
  SET @InterestCategoryNameList = @InterestCategoryName
  SET @l_FirstRow = 1
    
  WHILE (@@FETCH_STATUS=0) BEGIN
    IF ( @OldComponentID != @ComponentID ) BEGIN
      UPDATE #temp
         SET InterestCategoryList = @InterestCategoryList,
             Keywords = Keywords + ' ' + Left(@InterestCategoryNameList, 1000 - Len(Keywords) - 1)
       WHERE ContentID = @OldComponentID

      SET @InterestCategoryList = @InterestCategoryID
      SET @InterestCategoryNameList = @InterestCategoryName
    END
    ELSE BEGIN
      IF ( @l_FirstRow = 1 ) BEGIN
        SET @InterestCategoryList = @InterestCategoryID
        SET @InterestCategoryNameList = @InterestCategoryName
        SET @l_FirstRow = 0
      END
      ELSE BEGIN
        SET @InterestCategoryList = @InterestCategoryList + ',' + convert(varchar(10), @InterestCategoryID)      
        SET @InterestCategoryNameList = @InterestCategoryNameList + ' ' + @InterestCategoryName      
      END
    END

    SET @OldComponentID = @ComponentID

    FETCH NEXT FROM c_InterestCategory INTO
      @InterestCategoryID,
      @ComponentID,
      @InterestCategoryName

  END

  UPDATE #temp
     SET InterestCategoryList = @InterestCategoryList,
         Keywords = Keywords + ' ' + Left(@InterestCategoryNameList, 1000 - Len(Keywords) - 1)
    WHERE ContentID = @OldComponentID

  CLOSE c_InterestCategory
  DEALLOCATE c_InterestCategory

  /* Do the similar thing for WebsiteKey */
  UPDATE #temp
     SET AllWebsiteKeys = Convert(varchar(50),WebsiteKey) + ','

  -- For each nav item, add Websites are marked to include in the search
  -- and only include those websites that has the setting on.
  DECLARE c_NavMenu CURSOR FOR 
   SELECT DISTINCT b.NavMenuID, b.WebsiteKey
     FROM #temp a, Nav_Menu_Website b, Website c
    WHERE a.NavMenuID = b.NavMenuID
      AND a.WebsiteKey <> b.WebsiteKey
      AND b.WebsiteKey = c.WebsiteKey
      AND c.IncludeInCrossSiteSearchFlag = 'Y'

  OPEN c_NavMenu
  FETCH NEXT FROM c_NavMenu
   INTO @NavMenuID,
        @WebsiteKey
  WHILE @@FETCH_STATUS = 0 BEGIN
  
    UPDATE #temp
       SET AllWebsiteKeys = IsNull(AllWebsiteKeys,'') + Convert(varchar(50),@WebsiteKey) + ','
     WHERE NavMenuID = @NavMenuID

    FETCH NEXT FROM c_NavMenu
     INTO @NavMenuID,
          @WebsiteKey
  END
  CLOSE c_NavMenu
  DEALLOCATE c_NavMenu

  -- Remove extra ","
  UPDATE #temp
     SET AllWebsiteKeys = Left(AllWebsiteKeys,Len(AllWebsiteKeys)-1)
   WHERE AllWebsiteKeys IS NOT NULL

  /* 
  ** Return our Result Set
  */

  SELECT t.FilePath, 
         t.URL, 
         t.Title, 
         t.InterestCategoryList, 
         t.Keywords,
         t.Description,
         Convert(Varchar(10), IsNull(t.ContentID,0)) + ',NCInd:' + NavContentGroupInd + ',WKEY:' + t.AllWebsiteKeys + ',' +  'CSEARCH:' + IsNull(IncludeInCrossSiteSearchFlag,'Y') + ',' + CustomField2 AS CustomField2,
         t.WebsiteKey,
         t.AllWebsiteKeys
    FROM #temp t 

end

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_GetSiblingTree]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_GetSiblingTree]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create    procedure amsp_GetSiblingTree 
	@NavMenuID integer
as
begin

  declare
    @counter integer

  create table #temp (NavMenuID integer)

  /*
  ** First insert self and siblings based on ParentNavMenuID value
  */
  insert into #temp
  select NavMenuID 
  from Nav_Menu
  where IsNull(ParentNavMenuID, -1) = (select IsNull(ParentNavMenuID, -1)
                                         from Nav_Menu
                                        where NavMenuID = @NavMenuID)
  
  /*
  ** As long as there are new children, keep adding them to #temp.
  ** To make sure a bad nav_menu item doesn't lock the server, we also
  ** limit this to 50 iterations.
  */
  set @counter = 0
  while @@rowCount > 0 and @counter < 50 begin
    set @counter = @counter + 1
    insert into #temp
    select a.NavMenuID
      from Nav_Menu a, #temp b
     where a.ParentNavMenuID = b.NavMenuID
       and a.NavMenuID not in (select NavMenuID from #temp)
  end

  /*
  ** Return our results
  */
  select * from #temp

end

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_GetTaggedPage]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_GetTaggedPage]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[amsp_GetTaggedPage]
    @TPLID NUMERIC,
    @LstInterestCategoryID VARCHAR(1000),
    @TPPID NUMERIC,
    @HideMemberOnlyFlag NUMERIC,
    @ExtraURLVar VARCHAR(1000),
    @ContactID NUMERIC = 0,
    @TPOperator CHAR(1) = 'A'
AS
SET NOCOUNT ON
  /*
  ** DESCRIPTION:
  ** ------------
  ** Generate queries for a tagged page layout.  This stored procedure will perform the logic
  ** to follow most of the customization specified via the user interface.  It will filter out
  ** contents by the given interest categories, figures out maximum rows to return, sorting
  ** logic, etc.  
  **   
  ** Then the queries returned will be used by the portlets (components) to generate the output
  **
  ** INPUTS:
  ** -------
  ** @TPLID -> TaggedPageLayoutID - Identifies which tagged page has been called.
  ** @LstInterestCategoryID -> List of additional interest categories (vs ones specified in the tagged page)
  ** @TPPID -> TaggedPagePortletID - (Optional) Identifies "view all" mode.  Therefore, only the
  **           query for this portlet will be generated.
  ** @HideMemberOnlyFlag -> (Optional) Indicates Members only content/record/etc should not be returned (CM).
  ** @ExtraURLVar -> (Optional) Any extra URL variables that may be used by this script.
  ** @ContactID -> User's ContactID.  Currently, only used to retrieve user interest categories
  **               when @TPOperator = "U"
  ** @TPOperator -> An additional variable for indicating special attention.
  **
  ** RESULT SET:
  ** -----------
  ** Query sets for each TaggedPagePorletID (components specified in the tagged page).
  **
  ** NOTES:
  ** ------
  **
  ** PROGRAMMING CONSIDERATIONS:
  ** ---------------------------
  ** Dynamic SQL is only be used when absolutely necessary.
  **
  ** HISTORY:
  ** --------
  ** 01/17/2002   Intae Kim   Initial Version Created
  ** 06/20/2002   Intae Kim   Handles two new input variables, @ContactID and @TPOperator
  ** 10/22/2002   Intae Kim   Added Forum and Survey.  Also allows ability to accomodate more than
  **                          one SQL per component.
  ** 01/21/2003   Intae Kim   Added a feature for handling date range and border info.
  ** 07/08/2003   Intae Kim   Added ability to use a date column specified by the user.
  ** 08/18/2003   Intae Kim   Handles "Hide" feature for CM.
  ** 09/17/2003   Intae Kim   Corrected handling of different "Name" coloums in same query for CM
  ** 10/24/2003   Intae Kim   When no @LstInterestCategoryID is passed in and there are heavy amount
  **                          of data in the system, inserting "all" records into a temp table slowed 
  **                          the SP down.  Adding further checking to limit valid data enhanced performance.
  ** 11/04/2003   Intae Kim   Added ability to handle range instead of just date range
  ** 12/15/2003   E.Tatsui    Added a fix for ECM. It was failing when tables from other products don't exist.
  ** 03/22/2004   E.Tatsui    Removed where clause that filters out items by end date for conference and calendar.
  ** 09/27/2005   E.Tatsui    Added Perfomance changes by Dmitry. Some of the queries replaced with 
			      Views and improved dynamic SQL. Added optmization hints to the queries.
 */
 
BEGIN
  DECLARE
  @SQL                         nVARCHAR(4000),
  @TempVar                     VARCHAR(100),
  @TempList                    VARCHAR(1000),
  @StringPtr                   INT,
  @LastStringPtr               INT,
  @TaggedSectionID             NUMERIC,
  @TaggedPagePortletID         NUMERIC,
  @ComponentCode               CHAR(2),
  @MaxRows                     NUMERIC,
  @PrimarySort                 VARCHAR(50),
  @PrimarySortAscDescInd       CHAR(1),
  @SecondarySort               VARCHAR(50),
  @SecondarySortAscDescInd     CHAR(1),
  @OrderNum                    NUMERIC,
  @SQLNumber                   NUMERIC,
  @RangeColumn                 VARCHAR(50),
  @ColumnType                  VARCHAR(10),
  @RangeFrom                   VARCHAR(25),
  @RangeTo                     VARCHAR(25),
  @TempStr1                    VARCHAR(1000),
  @TempStr2                    VARCHAR(1000),
  @UserDefinedDate1            VARCHAR(50),
  @CurrentDate                 VARCHAR(10),
  @EcmFlag                     bit



DECLARE @DEBUG Datetime
DECLARE @tmpSQL nvarchar(2000)
DECLARE @SQLString nvarchar(4000)
  -- Figure out this database is for eCM.
  IF OBJECT_ID('Press_Release') IS NULL
    SET @EcmFlag = 1
  ELSE
    SET @EcmFlag = 0

  -- Tag page contains one or more "sections" of page, such as top and bottom or
  -- left and right.  Each section can contain one or more "portlets" which handles
  -- the display.  
 
  -- Grab all portlet information for every sections in this tagged page and put it into #TempTPP.
  -- This table will eventually contain records that have been filtered by the interest categories.

SELECT TPS.TaggedSectionID, TPP.TaggedPagePortletID, TT.ComponentCode, TT.SQLNumber, TPP.MaxRows, TPP.PrimarySort, TPP.PrimarySortAscDescInd, 
       TPP.SecondarySort, TPP.SecondarySortAscDescInd, TPP.OrderNum, TPP.UseOR, TPP.RangeFrom, TPP.RangeTo, TPP.RangeColumn, 
       TPCC.ColumnType
  INTO [#TempTPP]
  FROM Tagged_Page_Section AS TPS WITH (UPDLOCK) 
 INNER JOIN Tagged_Page_Portlet AS TPP WITH (UPDLOCK) ON TPS.TaggedPageSectionID = TPP.TaggedPageSectionID 
 INNER JOIN Tagged_Portlet AS TP WITH (UPDLOCK) ON TPP.TaggedPortletID = TP.TaggedPortletID 
 INNER JOIN Tagged_Template AS TT WITH (UPDLOCK) ON TP.TaggedTemplateID = TT.TaggedTemplateID 
  LEFT OUTER JOIN Tagged_Page_Component_Column AS TPCC WITH (UPDLOCK) ON TT.ComponentCode = TPCC.ComponentCode AND TPP.RangeColumn = TPCC.ColumnName
 WHERE (TPS.TaggedPageLayoutID = @TPLID)
 
  -- If TPPID is passed in, then we only care about this TaggedPagePortlet
  IF @TPPID <> 0
  BEGIN
    DELETE FROM #TempTPP WITH (UPDLOCK)
     WHERE TaggedPagePortletID <> @TPPID
  END
  
  -- Temporary table that will initially contain matched rows from Component_Interest_Categories table.
  -- This will be PER TaggedPagePortletID associated through ComponentCode
  CREATE TABLE #TempCIC
  ( 
   TaggedPagePortletID NUMERIC,
   UseOR CHAR(1),
   ComponentCode CHAR(2),
   ComponentID NUMERIC,
   InterestCategoryID NUMERIC
  )
 
  -- For each TaggedPagePortletID, put component info into a temporary table which matched
  -- all the ICs passedin via @LstInterestCategoryID
 
  -- Putting comma at the end to make logic a bit easier when I use CHARINDEX()
  SET @TempList = @LstInterestCategoryID + ','
  SET @LastStringPtr = 1
  SET @StringPtr = CHARINDEX(',', @TempList, @LastStringPtr)
 
  -- If 0 is passed as @LstInterestCategoryID, this means there is no IC to match so insert all
  -- valid records into this temporary table.  
  -- Note: Did join to Tagged_Page_PortletIC and checked for "current" records to cut down on
  -- insert time.
  /* Added on 12/15/2003 */

  IF SUBSTRING(@TempList, @LastStringPtr, @StringPtr - @LastStringPtr) = 0 
  BEGIN 
    INSERT INTO #TempCIC
           (TaggedPagePortletID, UseOR, ComponentCode, ComponentID, InterestCategoryID)
    SELECT TPP.TaggedPagePortletID, TPP.UseOR, CIC.ComponentCode, CIC.ComponentID, CIC.InterestCategoryID
      FROM #TempTPP TPP  WITH (UPDLOCK) LEFT OUTER JOIN Tagged_Page_PortletIC TPPIC WITH (UPDLOCK) ON TPP.TaggedPagePortletID = TPPIC.TaggedPagePortletID, 
           Component_Interest_Category CIC WITH (UPDLOCK)
     WHERE TPP.ComponentCode = CIC.ComponentCode
       AND (CIC.InterestCategoryID = TPPIC.InterestCategoryID
            OR TPPIC.InterestCategoryID IS NULL)
       AND (CIC.ComponentCode = 'CM'
            AND EXISTS (SELECT TOP 1 1
                          FROM Content C WITH (UPDLOCK)
                         WHERE C.ContentID = CIC.ComponentID
                           AND C.WorkflowStatusCode = 'P'))

  END
  -- Special operation to handle user defined interest categories
  ELSE IF @TPOperator = 'U'
  BEGIN
    INSERT INTO #TempCIC
           (TaggedPagePortletID, UseOR, ComponentCode, ComponentID, InterestCategoryID)
    SELECT TPP.TaggedPagePortletID, TPP.UseOR, 
           CIC.ComponentCode, CIC.ComponentID, CIC.InterestCategoryID
      FROM #TempTPP TPP WITH (UPDLOCK), Component_Interest_Category CIC WITH (UPDLOCK)
     WHERE TPP.ComponentCode = CIC.ComponentCode
       AND CIC.InterestCategoryID IN (SELECT CIC2.InterestCategoryID
                                        FROM Contact_Interest_Category CIC2 WITH (UPDLOCK)
                                       WHERE CIC2.ContactID = @ContactID)
  END
  ELSE 
  BEGIN
    IF @TPOperator = 'O'  
    BEGIN
      -- Stored Procedure does not allow something like XX IN (@LstInterestCategoryID)
      -- so do loop.
      INSERT INTO #TempCIC
             (TaggedPagePortletID, UseOR, ComponentCode, ComponentID, InterestCategoryID)
      SELECT TPP.TaggedPagePortletID, TPP.UseOR, 
             CIC.ComponentCode, CIC.ComponentID, CIC.InterestCategoryID
        FROM #TempTPP TPP WITH (UPDLOCK), Component_Interest_Category CIC  WITH (UPDLOCK)
       WHERE TPP.ComponentCode = CIC.ComponentCode
         AND CIC.ComponentID IN (SELECT CIC2.ComponentID 
                                   FROM Component_Interest_Category CIC2 WITH (UPDLOCK)
                                  WHERE CIC2.ComponentCode = CIC.ComponentCode
                                    AND CIC2.InterestCategoryID = SUBSTRING(@TempList, @LastStringPtr, @StringPtr - @LastStringPtr))
  
      SET @LastStringPtr = @StringPtr + 1
      SET @StringPtr = CHARINDEX(',', @TempList, @LastStringPtr)
 
      -- If more than one IC has been provided, loop through the rest of ICs to add
      WHILE @StringPtr > 0 
      BEGIN
        INSERT INTO #TempCIC
               (TaggedPagePortletID, UseOR, ComponentCode, ComponentID, InterestCategoryID)
        SELECT TPP.TaggedPagePortletID, TPP.UseOR, 
               CIC.ComponentCode, CIC.ComponentID, CIC.InterestCategoryID
          FROM #TempTPP TPP WITH (UPDLOCK), Component_Interest_Category CIC  WITH (UPDLOCK)
         WHERE TPP.ComponentCode = CIC.ComponentCode
           AND CIC.ComponentID IN (SELECT CIC2.ComponentID 
                                     FROM Component_Interest_Category CIC2
                                    WHERE CIC2.ComponentCode = CIC.ComponentCode
                                      AND CIC2.InterestCategoryID = SUBSTRING(@TempList, @LastStringPtr, @StringPtr - @LastStringPtr))
           AND CIC.ComponentID NOT IN (SELECT T2.ComponentID 
                                         FROM #TempCIC T2 WITH (UPDLOCK)
                                        WHERE T2.ComponentCode = CIC.ComponentCode
                                          AND T2.InterestCategoryID = SUBSTRING(@TempList, @LastStringPtr, @StringPtr - @LastStringPtr))
        SET @LastStringPtr = @StringPtr + 1
        SET @StringPtr = CHARINDEX(',', @TempList, @LastStringPtr)
      END
    END
    ELSE
    BEGIN
      INSERT INTO #TempCIC
             (TaggedPagePortletID, UseOR, ComponentCode, ComponentID, InterestCategoryID)
      SELECT TPP.TaggedPagePortletID, TPP.UseOR, 
             CIC.ComponentCode, CIC.ComponentID, CIC.InterestCategoryID
        FROM #TempTPP TPP WITH (UPDLOCK), Component_Interest_Category CIC  WITH (UPDLOCK)
       WHERE TPP.ComponentCode = CIC.ComponentCode
         AND CIC.ComponentID IN (SELECT CIC2.ComponentID 
                                   FROM Component_Interest_Category CIC2 WITH (UPDLOCK)
                                  WHERE CIC2.ComponentCode = CIC.ComponentCode
                                    AND CIC2.InterestCategoryID = SUBSTRING(@TempList, @LastStringPtr, @StringPtr - @LastStringPtr))
  
      SET @LastStringPtr = @StringPtr + 1
      SET @StringPtr = CHARINDEX(',', @TempList, @LastStringPtr)
 
      -- If more than one IC has been provided, loop through the rest of ICs to narrow the 
      -- results which match all the ICs
      WHILE @StringPtr > 0 
      BEGIN
        DELETE #TempCIC
         WHERE ComponentID NOT IN (SELECT CIC.ComponentID 
                                     FROM Component_Interest_Category CIC WITH (UPDLOCK)
                                    WHERE CIC.ComponentCode = #TempCIC.ComponentCode
                                      AND CIC.InterestCategoryID = SUBSTRING(@TempList, @LastStringPtr, @StringPtr - @LastStringPtr))
        SET @LastStringPtr = @StringPtr + 1
        SET @StringPtr = CHARINDEX(',', @TempList, @LastStringPtr)
      END
    END

 END
 

  -- Grab any important values passed into the script which can later be used to filter
  -- the result set.
  SET @UserDefinedDate1 = ''
  SET @TempList = @ExtraURLVar + '&'
  SET @LastStringPtr = 1
  SET @StringPtr = CHARINDEX('&', @TempList, @LastStringPtr)
 
  WHILE @StringPtr > 0 
  BEGIN
    SET @TempVar = SUBSTRING(@TempList, @LastStringPtr, @StringPtr - @LastStringPtr)
    IF (CHARINDEX('=',@TempVar) != 0 AND UPPER(SUBSTRING(@TempVar,1,CHARINDEX('=',@TempVar)-1)) = 'USERDEFINEDDATE1')
      SET @UserDefinedDate1 = SUBSTRING(@TempVar,CHARINDEX('=',@TempVar)+1,LEN(@TempVar)-CHARINDEX('=',@TempVar))
 
    SET @LastStringPtr = @StringPtr + 1
    SET @StringPtr = CHARINDEX(',', @TempList, @LastStringPtr)
  END
  
  
  /*
  ** IMPORTANT!!!!
  ** 
  ** Now #TempCIC table contains only and unique results from component_interest_category
  ** for each TaggedPagePortletID that matched the list of ICs passed into this 
  ** stored procedure via @LstInterestCategoryID
  **
  ** Next step is to match all ICs specfied for each TaggedPagePortlet. This is
  ** accomplished by first deleting ICs that are not part of the ICs of each 
  ** TaggedPagePortlet which will result in only the ICs that matched will remain.
  ** So at the end of this delete, there can NOT be more ICs per TaggedPagePortlet
  ** in the #TempCIC than the number of ICs specified for each TaggedPagePortlet.
  ** 
  ** So the logic is if after the delete, there are same number of IC for each
  ** TaggedPagePortlet in #TempCIC table as ICs specified for each TaggedPagePortlet in
  ** TaggedPagePortletIC table, then the condition for matching all ICs is met.
  **
  ** The last step is to select unique values from #TempCIC and save it for SELECT
  ** logic.
  **
  ** Addition: IK Delete on #TempCIC will not occurr if no entry in TPPIC.
  */

  DELETE #TempCIC
   WHERE NOT EXISTS (SELECT *
                       FROM Tagged_Page_PortletIC TPPIC WITH (UPDLOCK)
                      WHERE TPPIC.InterestCategoryID = #TempCIC.InterestCategoryID
                        AND TPPIC.TaggedPagePortletID = #TempCIC.TaggedPagePortletID)
         AND EXISTS (SELECT *
                       FROM Tagged_Page_PortletIC TPPIC2 WITH (UPDLOCK)
                      WHERE TPPIC2.TaggedPagePortletID = #TempCIC.TaggedPagePortletID)

  SELECT TaggedPagePortletID, ComponentID, ComponentCode
    INTO #TempCIC2
    FROM #TempCIC WITH (UPDLOCK)
   GROUP BY TaggedPagePortletID, ComponentID, ComponentCode
  HAVING Count(*) = (SELECT Count(*)
                       FROM Tagged_Page_PortletIC TPPIC WITH (UPDLOCK)
                      WHERE TPPIC.TaggedPagePortletID = #TempCIC.TaggedPagePortletID)

  DELETE #TempCIC
   WHERE NOT EXISTS (SELECT *
                       FROM #TempCIC2 T2 WITH (UPDLOCK)
                      WHERE T2.TaggedPagePortletID = #TempCIC.TaggedPagePortletID
                        AND T2.ComponentID = #TempCIC.ComponentID
                        AND T2.ComponentCode = #TempCIC.ComponentCode)
     AND UseOR = 'N'
     AND EXISTS (SELECT *
                   FROM Tagged_Page_PortletIC TPPIC2 WITH (UPDLOCK)
                  WHERE TPPIC2.TaggedPagePortletID = #TempCIC.TaggedPagePortletID)
 
  SELECT DISTINCT TaggedPagePortletID, ComponentCode, ComponentID
    INTO #Temp
    FROM #TempCIC WITH (UPDLOCK)

  -- Loop through each TaggedPagePortletID (component) in specified order to generate dynamic SQL to excute.
  -- Dynamic SQL is a must since we allow users to specify "Order By" columns

SET @DEBUG=GETDATE()
 
  DECLARE c_TPP CURSOR FAST_FORWARD FOR
    SELECT TPP.TaggedSectionID,
           TPP.TaggedPagePortletID,
           TPP.ComponentCode,
           TPP.MaxRows,
           TPP.PrimarySort,
           TPP.PrimarySortAscDescInd,
           TPP.SecondarySort,
           TPP.SecondarySortAscDescInd,
           TPP.OrderNum,
           TPP.SQLNumber,
           TPP.RangeFrom,
           TPP.RangeTo,
           TPP.RangeColumn,
           TPP.ColumnType
      FROM #TempTPP TPP WITH (NOLOCK)
     ORDER BY TPP.TaggedSectionID, TPP.OrderNum

  SET @CurrentDate = CONVERT(VARCHAR(2),MONTH(CURRENT_TIMESTAMP))+'/'+CONVERT(VARCHAR(2),DAY(CURRENT_TIMESTAMP))+'/'+CONVERT(VARCHAR(4),Year(CURRENT_TIMESTAMP))
  OPEN c_TPP
  
  WHILE (1 = 1) 
  BEGIN
    FETCH NEXT FROM c_TPP INTO
         @TaggedSectionID,
         @TaggedPagePortletID,
         @ComponentCode,
         @MaxRows,
         @PrimarySort,
         @PrimarySortAscDescInd,
         @SecondarySort,
         @SecondarySortAscDescInd,
         @OrderNum,
         @SQLNumber,
         @RangeFrom,
         @RangeTo,
         @RangeColumn,
         @ColumnType
 
    IF @@Fetch_Status <> 0
      BREAK
 
    SET @SQL = 'SELECT'
    IF (@TPPID = 0 AND @MaxRows IS NOT NULL)
      SET @SQL = @SQL + ' TOP ' + CONVERT(VARCHAR(10),@MaxRows)
    ELSE
      SET @MaxRows = 10000
 
    SET @TempStr1 = ''
    SET @TempStr2 = ''
 
    IF @RangeColumn IS NOT NULL
    BEGIN
      IF @ColumnType = 'Date'
      BEGIN
        IF @RangeFrom IS NOT NULL
        BEGIN
          IF ISDATE(@RangeFrom) = 1
          BEGIN
            SET @TempStr1 = ' AND ' + @RangeColumn + ' >= ''' + @RangeFrom + ''''
            SET @TempStr2 = ' AND ' + @RangeColumn + ' >= ''' + @RangeFrom + ''''
          END 
          ELSE IF ISNUMERIC(@RangeFrom) = 1
          BEGIN
            SET @TempStr1 = ' AND ' + @RangeColumn + ' >= DATEADD(d,' + @RangeFrom + ',''' + @CurrentDate + ''')'
            SET @TempStr2 = ' AND ' + @RangeColumn + ' >= DATEADD(d,' + @RangeFrom + ',''' + @CurrentDate + ''')'
          END
        END
        IF @RangeTo IS NOT NULL
        BEGIN
          IF ISDATE(@RangeTo) = 1
          BEGIN
            SET @TempStr1 = @TempStr1 + ' AND ' + @RangeColumn + ' <= ''' + @RangeTo + ' 23:59:59'''
            SET @TempStr2 = @TempStr2 + ' AND ' + @RangeColumn + ' <= ''' + @RangeTo + ' 23:59:59'''
          END 
          ELSE IF ISNUMERIC(@RangeTo) = 1
          BEGIN
            SET @TempStr1 = @TempStr1 + ' AND ' + @RangeColumn + ' <= DATEADD(d,' + @RangeTo + ',''' + @CurrentDate + ' 23:59:59'')'
            SET @TempStr2 = @TempStr2 + ' AND ' + @RangeColumn + ' <= DATEADD(d,' + @RangeTo + ',''' + @CurrentDate + ' 23:59:59'')'
          END
        END
      END
      ELSE IF @ColumnType = 'Numeric'
      BEGIN
        IF @RangeFrom IS NOT NULL AND ISNUMERIC(@RangeFrom) = 1
          BEGIN
            SET @TempStr1 = ' AND ' + @RangeColumn + ' >= ' + @RangeFrom
            SET @TempStr2 = ' AND ' + @RangeColumn + ' >= ' + @RangeFrom
          END
        IF @RangeTo IS NOT NULL AND ISNUMERIC(@RangeTo) = 1
          BEGIN
            SET @TempStr1 = @TempStr1 + ' AND ' + @RangeColumn + ' <= ' + @RangeTo
            SET @TempStr2 = @TempStr2 + ' AND ' + @RangeColumn + ' <= ' + @RangeTo
          END
      END
      ELSE
      BEGIN
        IF @RangeFrom IS NOT NULL
       BEGIN
            SET @TempStr1 = ' AND ' + @RangeColumn + ' >= ''' + @RangeFrom + ''''
            SET @TempStr2 = ' AND ' + @RangeColumn + ' >= ''' + @RangeFrom + ''''
          END
        IF @RangeTo IS NOT NULL
          BEGIN
            SET @TempStr1 = @TempStr1 + ' AND ' + @RangeColumn + ' <= ''' + @RangeTo + ''''
            SET @TempStr2 = @TempStr2 + ' AND ' + @RangeColumn + ' <= ''' + @RangeTo + ''''
          END
      END
    END
    IF @ComponentCode = 'CM'
    BEGIN
      -- Used to filter out any restricted content if the site is set to hide member only data from
      -- registered users.
      IF @HideMemberOnlyFlag = 1
        SET @TempVar = '(''N'','''')'
      ELSE
        SET @TempVar = '(''N'',''Y'','''')'
 
      -- If UserDefinedDate1 is provided, setup the temporary variables to plug into
      -- the SQL construct.
      IF @UserDefinedDate1 != ''
      BEGIN
        SET @TempStr1 = @TempStr1 + ' AND C.UserDefinedDate1 = ''' + @UserDefinedDate1 + ''''
        SET @TempStr2 = @TempStr2 + ' AND C2.UserDefinedDate1 = ''' + @UserDefinedDate1 + ''''
      END

	SET @tmpSQL='
	DECLARE @Flag INT
	SELECT @Flag= (CASE
	 WHEN Count(*) > ' + CONVERT(VARCHAR(10),@MaxRows) + ' THEN 1
	 ELSE 0 END)
	FROM #Temp T2 WITH (UPDLOCK)
	JOIN vContent_TemplatePath C2 on T2.ComponentID = C2.ContentID
	WHERE 
	ISNULL(C2.MembersOnlyFlag,''N'') IN ' + @TempVar + '
	AND T2.TaggedPagePortletID = ' + CONVERT(VARCHAR(10),@TaggedPagePortletID) + @TempStr2 + '  '


	    SET @SQL = @SQL + ' ' + CONVERT(VARCHAR(10),@TaggedSectionID) + ' TaggedSectionID, ' 
	                 + CONVERT(VARCHAR(10),@TaggedPagePortletID) + ' TaggedPagePortletID,  
	                   C.*, C.TemplatePath, @Flag  as MoreFlag
	                     FROM #Temp T WITH (UPDLOCK)
				Join vContent_TemplatePath C on T.ComponentID = C.ContentID
	                    WHERE 
	                     	ISNULL(C.MembersOnlyFlag,''N'') IN ' + @TempVar + ' 
	                      	AND 
				T.TaggedPagePortletID = ' + CONVERT(VARCHAR(10),@TaggedPagePortletID)
	                      + @TempStr1
    END

    ELSE IF @ComponentCode = 'CC'
    BEGIN
      SET @SQL = @SQL + ' ' + CONVERT(VARCHAR(10),@TaggedSectionID) + ' TaggedSectionID, ' 
                 + CONVERT(VARCHAR(10),@TaggedPagePortletID) + ' TaggedPagePortletID,
                   0 MoreFlag'  
    END
    
    IF @PrimarySort IS NOT NULL
    BEGIN
      SET @SQL = @SQL + ' ORDER BY ' + @PrimarySort
      IF @PrimarySortAscDescInd = 'D'
        SET @SQL = @SQL + ' DESC'
      ELSE
        SET @SQL = @SQL + ' ASC'
      IF @SecondarySort IS NOT NULL
      BEGIN
        SET  @SQL = @SQL + ', ' + @SecondarySort
        IF @SecondarySortAscDescInd = 'D'
          SET @SQL = @SQL + ' DESC'
        ELSE
          SET @SQL = @SQL + ' ASC'
      END
    END
 
--PRINT 'Query is: ' + @SQL
--Print '' 
SEt @DEBUG=Getdate()
-- D. Eliseev 03/01/2005 - Combine Final SQL string as SQLBatch String and Quert itself.
set @SQLString=@tmpSQL + @SQL

--PRINT 'Query is: ' + @SQL
--Print '' 

EXECUTE sp_executesql @SQLString

--PRINT 'Dynamic SQL Stime (ms) : ' + cast(datediff(ms,@DEBUG,Getdate()) as varchar(10)) 
  END
 
  CLOSE c_TPP
  DEALLOCATE c_TPP

END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_GetTagsWithHierarchy]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_GetTagsWithHierarchy]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This procedure retrieves all the associated tags for a given component.
-- For nested tags, it retrieves all ancestors leading up to the tag for a
-- more user friendly display. This procedure is currently called by Admin\
-- Admin\TaggedPage\TaggedPageCategories.cfm.
--
-- MODIFICATION HISTORY:
--   DATE        USER          ACTION
--   02/24/2004  C.Jewell      Created.
-- =============================================

Create  PROCEDURE amsp_GetTagsWithHierarchy
  @InComponentCode char(2),
  @InComponentID numeric

AS
BEGIN

CREATE TABLE #TagDisplay (
       InterestCategoryID numeric,
       ParentCategoryID numeric,
       Name varchar(255),
       SortOrder numeric,
       CategoryDepth numeric,
       SelectedFlag char(1))

-- First insert selected tags ...

INSERT INTO #TagDisplay (
       InterestCategoryID,
       ParentCategoryID,
       Name,
       SortOrder,
       CategoryDepth,
       SelectedFlag)
SELECT b.InterestCategoryID,
       b.ParentCategoryID,
       b.Name,
       b.SortOrder,
       b.CategoryDepth,
       'Y'
  FROM Component_Interest_Category a WITH (NOLOCK),
       Interest_Category b WITH (NOLOCK)
 WHERE a.InterestCategoryID = b.InterestCategoryID
   AND a.ComponentCode = @InComponentCode
   AND a.ComponentID = @InComponentID

-- Now add the ancestors ...

WHILE @@RowCount > 0
INSERT INTO #TagDisplay (
       InterestCategoryID,
       ParentCategoryID,
       Name,
       SortOrder,
       CategoryDepth)
SELECT DISTINCT a.InterestCategoryID,
       a.ParentCategoryID,
       a.Name,
       a.SortOrder,
       a.CategoryDepth
  FROM #TagDisplay t,
       Interest_Category a WITH (NOLOCK)
  LEFT OUTER JOIN #TagDisplay t2
    ON a.InterestCategoryID = t2.InterestCategoryID
 WHERE a.InterestCategoryID = t.ParentCategoryID
   AND t2.InterestCategoryID IS NULL

SELECT *
  FROM #TagDisplay
 ORDER BY SortOrder

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_ICFixTree]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_ICFixTree]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE    PROCEDURE amsp_ICFixTree
	@l_ParentCategoryID   Numeric=0 ,
	@l_SortOrder   Numeric(28,18) = 0 OUT, 
	@l_CategoryDepth  Numeric=0,
	@l_AncestorID Numeric=0
AS

  /*
  ** DESCRIPTION:
  ** ------------
  ** Walks the tree and sets the CategoryDepth, SortOrder, AncestorID, AncestorOrder based on the
  ** ParentID relationship.
  **
  ** INPUTS:
  ** -------
  **   none
  ** 
  ** OUTPUTS:
  ** -----------
  **   none
  **
  ** NOTES:
  ** ------
  **   Recursive so only supports 255 levels in the tree... should NOT be a problem.
  ** 
  ** HISTORY:
  ** --------
  **   04/23/2003	N.Malhotra	Initial Version Created
  **
  */

DECLARE @b CURSOR

SET @l_CategoryDepth=@l_CategoryDepth+1

IF @l_ParentCategoryID= 0
  BEGIN
    SET @b=CURSOR STATIC FOR
    SELECT InterestCategoryID
      FROM Interest_Category
     WHERE ParentCategoryID IS NULL
     ORDER BY SortOrder
  END
ELSE
  BEGIN
    SET @b=CURSOR STATIC FOR
    SELECT InterestCategoryID
      FROM Interest_Category
     WHERE ParentCategoryID=@l_ParentCategoryID
     ORDER BY SortOrder
END

DECLARE @l_IntrestID Numeric

OPEN @b
FETCH FROM @b INTO @l_IntrestID
IF NOT @@FETCH_STATUS=0 RETURN
  WHILE @@FETCH_STATUS=0 
    BEGIN
      IF @l_ParentCategoryID= 0
        SET @l_AncestorID=@l_IntrestID    

      SET @l_SortOrder=@l_SortOrder+1000
      SET @l_IntrestID = CAST(@l_IntrestID AS Numeric)

      UPDATE Interest_Category
         SET SortOrder=@l_SortOrder,
             CategoryDepth=@l_CategoryDepth,
             AncestorCategoryID=@l_AncestorID,
             AncestorOrder=@l_SortOrder
      WHERE InterestCategoryID=@l_IntrestID

      EXEC amsp_ICFixTree @l_IntrestID, @l_SortOrder OUT, @l_CategoryDepth, @l_AncestorID

      FETCH FROM @b INTO @l_IntrestID             
    END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_ICDemote]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_ICDemote]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE      procedure amsp_ICDemote
	@InSourceNodeID	numeric
AS
BEGIN

  /*
  ** DESCRIPTION:
  ** ------------
  ** Demotes a node in the Interest_Category tree (InSourceNodeID) to be a child of the next highest
  ** sibling node in the tree (same parent, and highest sort order less than the node being demoted).
  **
  ** INPUTS:
  ** -------
  **   @InSourceNodeID	Source node being demoted
  ** 
  ** OUTPUTS:
  ** -----------
  **   none
  **
  ** NOTES:
  ** ------
  ** 
  ** HISTORY:
  ** --------
  **   04/23/2003	N.Malhotra	Initial Version Created
  **
  */

  Declare  
    @DestSortOrder		numeric,
    @DestDepth			numeric,
    @DestID			numeric,
    @DestAncestorID		numeric,
    @SourceSortOrder		numeric,
    @SourceDepth		numeric,
    @SourceParentID		numeric

  BEGIN TRANSACTION

  /*
  ** Let's find out about our source node
  */

  SELECT 
    @SourceSortOrder  = SortOrder,
    @SourceDepth      = CategoryDepth,
    @SourceParentID   = ParentCategoryID
  FROM
    Interest_Category
  WHERE
    InterestCategoryID = @InSourceNodeID

  /*
  ** Confirm the node can be demoted.  The node being demoted must have a sibling node
  ** above it in the tree (lower sort order but same parent).
  */

  SELECT @DestID = InterestCategoryID,
         @DestAncestorID = AncestorCategoryID,
         @DestDepth = CategoryDepth
    FROM Interest_Category
   WHERE SortOrder = (SELECT Max(SortOrder)
                        FROM Interest_Category
                       WHERE SortOrder < @SourceSortOrder
                         AND IsNULL(ParentCategoryID,0) = IsNULL(@SourceParentID,0))
  
  IF @@RowCount = 1 BEGIN

    /*
    ** Everything's a go.  Let's do it.
    */
   
    UPDATE Interest_Category
       SET ParentCategoryID = @DestID,
           AncestorCategoryID = @DestAncestorID
     WHERE InterestCategoryID = @InSourceNodeID

    /*
    ** amsp_FixTree will set the AncestorID, SortOrder, CategoryDepth for the entire tree.
    */
    
    EXEC amsp_ICFixTree

  END

  COMMIT TRANSACTION

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_ICMove]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_ICMove]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE       procedure amsp_ICMove
	@InSourceNodeID	numeric,
	@InDestNodeID	numeric
AS
BEGIN

  /*
  ** DESCRIPTION:
  ** ------------
  ** Moves a node in the Interest_Category tree (InSourceNodeID) to be a sibling directly
  ** beneath the destination (InDestNodeID) node.
  **
  ** INPUTS:
  ** -------
  **   @InSourceNodeID	Source node being moved
  **   @InDestNodeID	Destination node being moved beneath
  ** 
  ** OUTPUTS:
  ** -----------
  **   none
  **
  ** NOTES:
  ** ------
  **   1) Interest_Category table has AncestorOrder but this stored procedure is wriiten to
  **      allow only SortOrder to be used to fully sort all interest categories (i.e. sort order
  **      covers all IC's, not just IC's for the same ancestor).  This will allow AncestorOrder to 
  **      be removed easily (in the future) so that IC tree and Nav_Menu tree follow the same structure.
  ** 
  ** HISTORY:
  ** --------
  **   03/21/2003	N.Malhotra	Initial Version Created
  **
  */

  Declare  
    @DestSortOrder		numeric,
    @DestDepth			numeric,
    @DestParentID		numeric,
    @DestAncestorID		numeric,
    @SourceSortOrder		numeric,
    @SourceDepth		numeric,
    @SourceParentID		numeric,
    @SourceAncestorID		numeric,
    @InvalidCount		int,
    @Counter			int

  /*
  ** After confirming there is something to move, begin processing 
  */

  IF @InSourceNodeID != @InDestNodeID BEGIN

    SET @InvalidCount = 0

    BEGIN TRANSACTION

    /*
    ** Let's find out about our destination node
    */

    SELECT
      @DestSortOrder  = SortOrder,
      @DestDepth      = CategoryDepth,
      @DestParentID   = ParentCategoryID,
      @DestAncestorID = AncestorCategoryID
    FROM
      Interest_Category
    WHERE
      InterestCategoryID = @InDestNodeID

    /*
    ** Let's find out about our source node
    */

    SELECT 
      @SourceSortOrder  = SortOrder,
      @SourceDepth      = CategoryDepth,
      @SourceParentID   = ParentCategoryID,
      @SourceAncestorID = AncestorCategoryID
    FROM
      Interest_Category
    WHERE
      InterestCategoryID = @InSourceNodeID

    IF @DestAncestorID = @SourceAncestorID BEGIN

      /* 
      ** We need to make sure the destination node is not a direct decendant of the source node.
      ** If it is, the move operation would create a circular relationship and so it is invalid
      */

      SET @Counter = 0

      CREATE TABLE #TEMP (ChildID numeric)

      INSERT INTO #TEMP
      SELECT InterestCategoryID
        FROM Interest_Category
       WHERE ParentCategoryID = @InSourceNodeID

      WHILE (@Counter < 50 AND @@ROWCOUNT > 0) BEGIN

        SET @Counter = @Counter + 1
   
        INSERT INTO #TEMP
        SELECT InterestCategoryID
          FROM Interest_Category
         WHERE ParentCategoryID IN (SELECT ChildID FROM #TEMP)
           AND InterestCategoryID NOT IN (SELECT ChildID FROM #TEMP)
      END

      SELECT @InvalidCount = Count(*)
        FROM #TEMP
       WHERE ChildID = @InDestNodeID

      IF @InvalidCount > 0  BEGIN
        RAISERROR ('You may not move nodes within the same level 1 hierarchy', 16, 1)
      END
    END

    IF @InvalidCount = 0 BEGIN

      /*
      ** Simply adjust the parent pointer
      */
  
      UPDATE 
        Interest_Category
      SET 
        ParentCategoryID   = @DestParentID,
	SortOrder = @DestSortOrder + 1
      WHERE 
        InterestCategoryID = @InSourceNodeID

      /*
      ** amsp_FixTree will set the AncestorID, SortOrder, CategoryDepth for the entire tree.
      */
    
      EXEC amsp_ICFixTree

    END

    COMMIT TRANSACTION

  END

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_ICPromote]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_ICPromote]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE     procedure amsp_ICPromote
	@InSourceNodeID	numeric
AS
BEGIN

  /*
  ** DESCRIPTION:
  ** ------------
  ** Promotes a node in the Interest_Category tree (InSourceNodeID) to be the last sibling of its parent node.
  **
  ** INPUTS:
  ** -------
  **   @InSourceNodeID	Source node being promoted
  ** 
  ** OUTPUTS:
  ** -----------
  **   none
  **
  ** NOTES:
  ** ------
  **   none 
  **
  ** HISTORY:
  ** --------
  **   04/23/2003	N.Malhotra	Initial Version Created
  **
  */

  Declare  
    @DestID			numeric,
    @SourceSortOrder		numeric,
    @SourceDepth		numeric,
    @SourceParentID		numeric


  BEGIN TRANSACTION

  /*
  ** Let's find out about our source node
  */

  SELECT 
    @SourceSortOrder  = SortOrder,
    @SourceDepth      = CategoryDepth,
    @SourceParentID   = ParentCategoryID
  FROM
    Interest_Category
  WHERE
    InterestCategoryID = @InSourceNodeID

  /* 
  ** Can't do anything if it is already a level 1
  */

  IF @SourceDepth > 1 BEGIN

    /*
    ** Get the parent's parent node (this will be the new parent)
    */

    SELECT @DestID = ParentCategoryID
      FROM Interest_Category
     WHERE InterestCategoryID = @SourceParentID

    IF @SourceDepth = 2 BEGIN

      /*
      ** Promoting to a level 1 is a special case scenario
      */

      UPDATE Interest_Category
         SET ParentCategoryID = NULL,
             AncestorCategoryID = InterestCategoryID,
             CategoryDepth = 1
       WHERE InterestCategoryID = @InSourceNodeID

    END
    ELSE BEGIN

      UPDATE Interest_Category
         SET ParentCategoryID = @DestID
       WHERE InterestCategoryID = @InSourceNodeID

    END


    /*
    ** amsp_FixTree will set the AncestorID, SortOrder, CategoryDepth for the entire tree.
    */
    
    EXEC amsp_ICFixTree


    COMMIT TRANSACTION

  END

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_ICRenum]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_ICRenum]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE   procedure amsp_ICRenum AS
BEGIN

/*
** 03/21/2003  N.Malhotra	Created from amsp_NavMenuRenum
*/

  DECLARE 
    @SortIncrement	integer,
    @NumICs		integer

  CREATE TABLE #temp (
    ID Numeric Identity not null,
    InterestCategoryID numeric,
    SortOrder numeric)

  BEGIN TRANSACTION
   
  INSERT INTO #temp (InterestCategoryID, SortOrder)
  SELECT InterestCategoryID, SortOrder
    FROM Interest_Category
   ORDER BY AncestorOrder, SortOrder

  SELECT @NumICs = count(*)
    FROM Interest_Category

  SET @SortIncrement = CEILING(999990000.0 / @NumICs) - 1

  UPDATE #Temp
     SET SortOrder = ID * @SortIncrement

  CREATE UNIQUE INDEX IDX_TEMP_1 ON #Temp(InterestCategoryID)

  UPDATE Interest_Category
     SET SortOrder = t.SortOrder
    FROM #temp t
   WHERE Interest_Category.InterestCategoryID = t.InterestCategoryID
 
  COMMIT TRANSACTION


END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_SCUpdateLoginInfo]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_SCUpdateLoginInfo]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- Procedure to update login info.
-- =============================================
CREATE PROCEDURE amsp_SCUpdateLoginInfo
  @InContactID numeric
AS
BEGIN
  print 'No update for now.'
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_TPGetTagsWithHierarchy]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_TPGetTagsWithHierarchy]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE  PROCEDURE amsp_TPGetTagsWithHierarchy
  @InComponentID numeric

AS
BEGIN

CREATE TABLE #TagDisplay (
       InterestCategoryID numeric,
       ParentCategoryID numeric,
       Name varchar(255),
       SortOrder numeric,
       CategoryDepth numeric,
       SelectedFlag char(1))

-- First insert selected tags ...

INSERT INTO #TagDisplay (
       InterestCategoryID,
       ParentCategoryID,
       Name,
       SortOrder,
       CategoryDepth,
       SelectedFlag)
SELECT b.InterestCategoryID,
       b.ParentCategoryID,
       b.Name,
       b.SortOrder,
       b.CategoryDepth,
       'Y'
  FROM Tagged_Page_Interest_Category a WITH (NOLOCK),
       Interest_Category b WITH (NOLOCK)
 WHERE a.InterestCategoryID = b.InterestCategoryID
   AND a.ContentID = @InComponentID

-- Now add the ancestors ...

WHILE @@RowCount > 0
INSERT INTO #TagDisplay (
       InterestCategoryID,
       ParentCategoryID,
       Name,
       SortOrder,
       CategoryDepth)
SELECT DISTINCT a.InterestCategoryID,
       a.ParentCategoryID,
       a.Name,
       a.SortOrder,
       a.CategoryDepth
  FROM #TagDisplay t,
       Interest_Category a WITH (NOLOCK)
  LEFT OUTER JOIN #TagDisplay t2
    ON a.InterestCategoryID = t2.InterestCategoryID
 WHERE a.InterestCategoryID = t.ParentCategoryID
   AND t2.InterestCategoryID IS NULL

SELECT *
  FROM #TagDisplay
 ORDER BY SortOrder

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[amsp_TreeMove]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[amsp_TreeMove]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE   procedure amsp_TreeMove 
	@InSourceNodeID	numeric,
	@InDestNodeID	numeric
AS
BEGIN

  /*
  ** DESCRIPTION:
  ** ------------
  ** Moves a node in a Nav Menu tree (InSourceNodeID) to be a sibling directly
  ** beneath the destination (InDestNodeID) node.
  **
  ** INPUTS:
  ** -------
  **   @InSourceNodeID	Source node being moved
  **   @InDestNodeID	Destination node being moved beneath
  ** 
  ** OUTPUTS:
  ** -----------
  **   none
  **
  ** NOTES:
  ** ------
  **   none
  ** 
  ** HISTORY:
  ** --------
  ** 06/26/2001		N.Malhotra	Initial Version Created
  **
  */

  Declare  
    @HighSortOrder		numeric,
    @LowSortOrder		numeric,
    @SortIncrement		numeric,
    @NewSortOrder		numeric,
    @DestSortOrder		numeric,
    @DestDepth			numeric,
    @DestParentID		numeric,
    @DestAncestorID		numeric,
    @SourceSortOrder		numeric,
    @SourceDepth		numeric,
    @SourceParentID		numeric,
    @SourceAncestorID		numeric,
    @MaxRelativeSort		numeric,
    @TotalSortSpace		numeric,
    @Counter			int

  IF @InSourceNodeID != @InDestNodeID BEGIN

    BEGIN TRANSACTION

    /*
    ** Let's find out about our destination
    */

    SELECT
      @DestSortOrder = SortOrder,
      @DestDepth = CategoryDepth,
      @DestParentID = ParentNavMenuID,
      @DestAncestorID = AncestorNavMenuID
    FROM
      Nav_Menu
    WHERE
      NavMenuID = @InDestNodeID

    /*
    ** First, let's grab and save the source attributes for use in calculating relative moves later
    */

    SELECT 
      @SourceSortOrder = SortOrder,
      @SourceParentID = ParentNavMenuID,
      @SourceAncestorID = AncestorNavMenuID,
      @SourceDepth = CategoryDepth
    FROM 
      Nav_Menu
    WHERE 
      NavMenuID = @InSourceNodeID

    IF @DestDepth > 1 BEGIN

      /*
      ** If the destination node has a depth > 1 then we simply set the 
      ** Ancestor and Parent to the destination's Ancestor and Parent
      */
  
      UPDATE 
        Nav_Menu
      SET 
        ParentNavMenuID = @DestParentID,
        AncestorNavMenuID = @DestAncestorID,
        CategoryDepth = @DestDepth
      WHERE 
        NavMenuID = @InSourceNodeID
    END
    ELSE BEGIN

      /*
      ** Otherwise, the destination node has a depth of 1 so both the 
      ** Ancestor and Parent need to be set to the node itself
      */
  
      UPDATE 
        Nav_Menu
      SET 
        ParentNavMenuID = @InSourceNodeID,
        AncestorNavMenuID = @DestAncestorID,
        CategoryDepth = @DestDepth
      WHERE 
        NavMenuID = @InSourceNodeID

    END

    /*
    ** Now, let's find the low and high end of our sort order range.
    */

    SELECT 
      @HighSortOrder = IsNULL(MIN(SortOrder), 0)
    FROM
      Nav_Menu
    WHERE
      CategoryDepth <= @DestDepth AND 
      SortOrder > @DestSortOrder

    IF @HighSortOrder = 0
      SELECT
        @HighSortOrder = MAX(SortOrder) + 10
      FROM
        Nav_Menu

    SELECT 
      @LowSortOrder = MAX(SortOrder)
    FROM
      Nav_Menu
    WHERE
      SortOrder < @HighSortOrder

    /*
    ** OK, with our low point and high point established, we can 
    ** easily establish a point in the middle.  It's somewhat arbitrary
    ** but we're going to insert in increments of 1/10 the distance between
    ** high and low because we know all decendants have to still be added.
    */

    SET @NewSortOrder = @LowSortOrder + .1 * (@HighSortOrder - @LowSortOrder)
 
    UPDATE 
      Nav_Menu
    SET
      SortOrder = @NewSortOrder
    WHERE
      NavMenuID = @InSourceNodeID

    /*
    ** Now, sort of a funny way to do this, but it is fast and efficient ...
    ** Were going to throw all of the descendants into a temp table with only
    ** their NavMenuID and their SortOrder relative to the Source Node we're
    ** moving and likewise, relative CategoryDepth.  
    */

    create table #temp (NavMenuID numeric, RelativeSort numeric, RelativeDepth numeric)

    /*
    ** First insert the Source Node
    */

    INSERT INTO #temp VALUES (@InSourceNodeID, 0, 0)
  
    /*
    ** As long as there are new children, keep adding them to #temp.
    ** To make sure a bad nav_menu relationship doesn't lock the server,
    ** we also limit this to 50 iterations (i.e. 50 levels).
    */

    SET @Counter = 0

    WHILE @@rowCount > 0 and @Counter < 50 BEGIN
      SET @Counter = @Counter + 1
      INSERT INTO #temp (NavMenuID, RelativeSort, RelativeDepth)
      SELECT a.NavMenuID, a.SortOrder - @SourceSortOrder, a.CategoryDepth - @SourceDepth
        FROM Nav_Menu a, #temp b
       WHERE a.ParentNavMenuID = b.NavMenuID
         and a.NavMenuID not in (SELECT NavMenuID FROM #temp)
    END

    /*
    ** Now that our table table has all descendants, a single update will
    ** set their values.  Only SortOrder is tricky, and we use the relative 
    ** offset to compute this.
    */
 
    SELECT @MaxRelativeSort = MAX(RelativeSort) from #temp
    SET @TotalSortSpace = @HighSortOrder - @NewSortOrder 
  
    UPDATE Nav_Menu
       SET AncestorNavMenuID = @SourceAncestorID,
           CategoryDepth = (select @DestDepth + t.RelativeDepth
                              from #temp t
                             where t.NavMenuID = NavMenu.NavMenuID),
           SortOrder = (select @NewSortOrder + ((t.RelativeSort / @MaxRelativeSort) * @TotalSortSpace)
                          from #temp t
                         where t.NavMenuID = NavMenu.NavMenuID)
     WHERE 
           NavMenuID in (select NavMenuID from #temp) AND
           NavMenuID != @InSourceNodeID
        
    COMMIT TRANSACTION

  END

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_AccessKeyDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_AccessKeyDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- Will check an access key, and delete all related access items if it's a local custom
-- access key, or do nothing, if it's a shared 'area' access key
CREATE PROCEDURE [dbo].[asi_AccessKeyDelete] 
    @accessKey uniqueidentifier
AS
BEGIN
    SET NOCOUNT ON
    DECLARE @scope nvarchar(20)
    SELECT @scope = [AccessScope] FROM [dbo].[AccessMain] WHERE [AccessKey] = @accessKey
    IF (@scope = 'Local')
    BEGIN
        DELETE FROM [dbo].[AccessItem] WHERE [AccessKey] = @accessKey
        DELETE FROM [dbo].[AccessMain] WHERE [AccessKey] = @accessKey
    END
    SET NOCOUNT OFF
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ActiveSourceCodeBySegment]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ActiveSourceCodeBySegment]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_ActiveSourceCodeBySegment    Script Date: 7/3/2003 4:58:02 PM ******/
CREATE PROCEDURE [dbo].[asi_ActiveSourceCodeBySegment]

@segmentKey uniqueidentifier

 AS

SELECT Count(*) 
FROM 
vBoSourceList sl INNER JOIN vBoSourceCode sc
	ON sl.SourceCodeKey = sc.SourceCodeKey
WHERE 
	CHARINDEX(CAST(@segmentKey AS varchar(36)), sl.OriginListKeys) <> 0
	AND sc.SourceCodeStatusCode=0

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ActiveSourceCodeBySegmentationJob]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ActiveSourceCodeBySegmentationJob]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_ActiveSourceCodeBySegmentationJob    Script Date: 7/3/2003 4:58:02 PM ******/
CREATE PROC [dbo].[asi_ActiveSourceCodeBySegmentationJob]

@jobKey uniqueidentifier

AS
SELECT Count(*)
FROM
	vBoSourceList sl INNER JOIN vBoSourceCode sc
	ON sl.SourceCodeKey = sc.SourceCodeKey
WHERE 
	EXISTS
		(SELECT 1 
		FROM SegmentDefinition sd INNER JOIN SegmentationJob sj
		ON sd.SegmentationJobKey = sj.SegmentationJobKey
		WHERE 
		CHARINDEX(CAST(sd.SegmentDefinitionKey AS varchar(36)), sl.OriginListKeys) <> 0
		AND sj.SegmentationJobKey = @jobKey)
	AND sc.SourceCodeStatusCode = 0

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_AddToPublishQueue]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_AddToPublishQueue]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_AddToPublishQueue]
    @publishedOn datetime,
    @publishedByUserKey uniqueidentifier,
    @type int,
    @minDate datetime = NULL,
    @maxDate datetime = NULL
AS
BEGIN
    INSERT INTO [dbo].[PublishQueue] ([PublishedOn], [PublishedByUserKey], [Status], [Type], [ProcessedOn], [MinDate], [MaxDate], [PublishServerCode])
    SELECT @publishedOn, @publishedByUserKey, 0, @type, NULL, @minDate, @maxDate, [PublishServerCode]
      FROM [dbo].[PublishServerRef]
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_BuildNameAllView]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_BuildNameAllView]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:		Paul Bradshaw
-- Create date: Jan 30th, 2007
-- Description:	Create the Name_All View
-- =============================================
CREATE PROCEDURE [dbo].[asi_BuildNameAllView] 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @rowctr int
	DECLARE @sql1 varchar(max)
	DECLARE @sql2 varchar(max)
	DECLARE @sql3 varchar(max)
	DECLARE @tmpstr varchar(max)
	DECLARE @tmpstr2 varchar(max)
	DECLARE @temp_table table (table_name sysname, col_name sysname null)
	DECLARE @table_name sysname
	DECLARE @col_name sysname
	DECLARE @prev_col_name sysname
	DECLARE @CRLF varchar(3)
	SET @CRLF = char(13) + char(10)

	INSERT INTO @temp_table
		SELECT udf.TABLE_NAME, udf.FIELD_NAME 
		  FROM UD_Field udf  
		       INNER JOIN UD_Table udt ON udf.TABLE_NAME = udt.TABLE_NAME
	     WHERE udt.ALLOW_MULTIPLE_INSTANCES = 0 AND udt.NAME_ALL_TABLE = 1
	           AND EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = udf.TABLE_NAME AND COLUMN_NAME = udf.FIELD_NAME)
	           
	INSERT INTO @temp_table
		SELECT 'Name', COLUMN_NAME 
		  FROM INFORMATION_SCHEMA.COLUMNS 
		 WHERE TABLE_NAME = 'Name' and COLUMN_NAME <> 'TIME_STAMP'

	INSERT INTO @temp_table
		SELECT 'Name_Fin', COLUMN_NAME 
		  FROM INFORMATION_SCHEMA.COLUMNS 
		 WHERE TABLE_NAME = 'Name_Fin' and COLUMN_NAME <> 'ID' and COLUMN_NAME <> 'TIME_STAMP'

	-- should always be at least one column, so no error checking
	SELECT @sql1 = 'CREATE VIEW Name_All (' + @CRLF

	SELECT @tmpstr = ''
	SELECT @prev_col_name = ''
	 
	DECLARE col_cursor CURSOR FAST_FORWARD FOR SELECT table_name, col_name FROM @temp_table ORDER BY col_name
	OPEN col_cursor
	FETCH next FROM col_cursor INTO @table_name, @col_name 
	WHILE @@FETCH_STATUS = 0
		BEGIN	
		IF @col_name <> @prev_col_name
			BEGIN
				SELECT @sql1 = @sql1 +  @col_name + ', ' 
				SELECT @tmpstr = @tmpstr + @table_name + '.' + @col_name + ', ' 
			END
		SET @prev_col_name = @col_name
		FETCH next FROM col_cursor INTO @table_name, @col_name
		END
	CLOSE col_cursor
	DEALLOCATE col_cursor

	SELECT @sql1 = left(@sql1, datalength (@sql1) - 2)
	SELECT @tmpstr = left(@tmpstr, datalength (@tmpstr) - 2)

	SELECT @sql1 = @sql1 + @CRLF + ') AS ' + @CRLF 
	SELECT @sql2 = 'SELECT ' + @tmpstr + @CRLF 
	SELECT @sql3 = '  FROM ' 

	DELETE FROM @temp_table

	INSERT INTO @temp_table (table_name)
		SELECT DISTINCT udf.TABLE_NAME 
		  FROM UD_Field udf  
		       INNER JOIN UD_Table udt ON udf.TABLE_NAME = udt.TABLE_NAME
	     WHERE udt.NAME_ALL_TABLE = 1
	           AND EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = udf.TABLE_NAME AND COLUMN_NAME = udf.FIELD_NAME)

	SELECT @rowctr = count(1) FROM @temp_table
	IF @rowctr = 0  -- no UD Dues billing tables
		BEGIN
		SELECT @sql3 = @sql3 + 'Name, Name_Fin' + @CRLF + 'where Name.ID = Name_Fin.ID'
		END
	ELSE
		BEGIN
		SELECT @tmpstr = ''
		SELECT @tmpstr2 = ''
 
        DECLARE UD_cursor CURSOR FAST_FORWARD FOR SELECT table_name FROM @temp_table ORDER BY table_name
		OPEN UD_cursor
		FETCH next FROM UD_cursor INTO @table_name
		WHILE @@FETCH_STATUS = 0
			BEGIN	
			SELECT @tmpstr = @tmpstr + @table_name + ', '
			SELECT @tmpstr2 = @tmpstr2 + ' Name.ID = ' + @table_name + '.ID and '
			FETCH next FROM UD_cursor INTO @table_name
			END
		CLOSE UD_cursor
		DEALLOCATE UD_cursor
	
		SELECT @sql3 = @sql3 + 'Name, ' 
		SELECT @sql3 = @sql3 + @tmpstr
		SELECT @sql3 = @sql3 + 'Name_Fin' + @CRLF + 'where'
		SELECT @sql3 = @sql3 + @tmpstr2
		SELECT @sql3 = @sql3 + 'Name.ID = Name_Fin.ID'
		END

	EXEC (@sql1 + @sql2 + @sql3)
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_CancelPendingPublishRequest]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_CancelPendingPublishRequest]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_CancelPendingPublishRequest]
	@PublishRequestKey uniqueidentifier,
    @PublishServerCode nchar(1)AS
BEGIN
	UPDATE PublishRequestDetail
	   SET PublishRequestStatusCode = 2 --canceled
	 WHERE PublishRequestKey = @PublishRequestKey
       AND PublishServerCode = @PublishServerCode
       AND PublishRequestStatusCode = 0 -- New
END


SET ANSI_NULLS ON

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_CancelPendingPublishRequestForContent]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_CancelPendingPublishRequestForContent]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_CancelPendingPublishRequestForContent]
	@ContentDocumentKey uniqueidentifier
AS
BEGIN
	UPDATE PublishRequestDetail
	   SET PublishRequestStatusCode = 2 --canceled
	 WHERE ContentDocumentKey = @ContentDocumentKey
       AND (PublishRequestStatusCode = 0
        OR  (PublishRequestStatusCode = 1 AND Frequency > 0))
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_CheckImisNetPrivilegeLevel]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_CheckImisNetPrivilegeLevel]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE   PROC [dbo].[asi_CheckImisNetPrivilegeLevel]
	@userId as varchar(60),
	@systemKeyword as varchar(25)
	AS
BEGIN

set nocount on

declare @userKey as uniqueidentifier
declare @accessKey as uniqueidentifier
declare @permissions as int
declare @tmppermission as int

declare @LevelNet as int

declare @EveryoneRoleKey uniqueidentifier
select @EveryoneRoleKey = ParameterValue from SystemConfig 
	where ParameterName = 'Security.Token.EveryoneRoleKey'

select @userKey = UserKey from UserMain
where UserId = @userId

select @accessKey = ApplicationAccessKey
from SystemEntity
where SystemKeyword = @systemKeyword

CREATE TABLE #permission (permission int)

-- Add Self
INSERT	#permission(permission)
select Permission from AccessItem
where AccessKey = @accessKey
and UserKey = @userKey

-- Everyone Role
INSERT	#permission(permission)
select Permission from AccessItem
where AccessKey = @accessKey
and RoleKey = @EveryoneRoleKey

-- Assigned Roles
INSERT	#permission(permission)
select Permission from AccessItem
where AccessKey = @accessKey
and RoleKey in (SELECT RoleKey FROM UserRole WHERE UserKey = @userKey
    AND RoleKey <> @EveryoneRoleKey)

-- Effective Group Membership
INSERT	#permission(permission)
select Permission from AccessItem
where AccessKey = @accessKey
and GroupKey in (SELECT	DISTINCT GroupKey
 FROM	GroupMember
 WHERE	MemberContactKey = @userKey
   AND	(JoinDate <= getdate() OR JoinDate IS NULL)
   AND	(DropDate >= getdate() OR DropDate IS NULL))

set @permissions = 0
DECLARE Permission_Cursor CURSOR FOR
SELECT permission from #permission
OPEN Permission_Cursor
FETCH NEXT FROM Permission_Cursor
INTO @tmppermission
set @permissions = @permissions | @tmppermission
WHILE @@FETCH_STATUS = 0
BEGIN
	FETCH NEXT FROM Permission_Cursor
	INTO @tmppermission
	set @permissions = @permissions | @tmppermission
END
CLOSE Permission_Cursor
DEALLOCATE Permission_Cursor

IF (@permissions & 4096) > 0
begin
	select 3 as LevelNet
	set @LevelNet = 3
end
ELSE IF (@permissions & 2048) > 0
begin
	select 2 as LevelNet
	set @LevelNet = 2
end
ELSE IF (@permissions & 1024) > 0
begin
	select 1 as LevelNet
	set @LevelNet = 1
end
ELSE
begin
	select 0 as LevelNet
	set @LevelNet = 0
end

drop table #permission

return @LevelNet

set nocount off

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ClearOldQueryResults]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ClearOldQueryResults]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/***************************************************************
Deletes all the QueryResults older then the @LastTime.  Defaults
to the last 2 days if @LastTime is left null
***************************************************************/

CREATE PROCEDURE dbo.asi_ClearOldQueryResults
	@LastTime datetime = NULL
AS 

DECLARE @DeleteTime datetime

SELECT @DeleteTime = CASE WHEN @LastTime IS NULL THEN DateAdd(d, -2, getDate()) ELSE @LastTime END

WHILE (@@ROWCOUNT > 0)
BEGIN
	DELETE
	QueryResultItem FROM
	(
		SELECT TOP 500 QueryResultItem.QueryResultKey
			FROM QueryResultItem
			LEFT OUTER JOIN QueryResultMain ON
				QueryResultItem.QueryResultKey = QueryResultMain.QueryResultKey
		WHERE QueryResultMain.CreatedOn < @DeleteTime
	) q1
	WHERE QueryResultItem.QueryResultKey = q1.QueryResultKey
END

SELECT @DeleteTime = @DeleteTime   --Reset rowcount counter
WHILE (@@ROWCOUNT > 0)
BEGIN
	DELETE
	QueryResultMain FROM
	(
		SELECT TOP 500 QueryResultMain.QueryResultKey
			FROM QueryResultMain
		WHERE QueryResultMain.CreatedOn < @DeleteTime
	) q1
	WHERE QueryResultMain.QueryResultKey = q1.QueryResultKey
END

SELECT @DeleteTime = @DeleteTime --Reset rowcount counter
WHILE (@@ROWCOUNT > 0)
BEGIN
	DELETE
	QueryResultItem FROM
	(	
		SELECT TOP 500 QueryResultItem.QueryResultKey
			FROM QueryResultItem
			LEFT OUTER JOIN QueryResultMain ON
				QueryResultItem.QueryResultKey = QueryResultMain.QueryResultKey
		WHERE QueryResultMain.QueryResultKey IS NULL
	) q1
	WHERE QueryResultItem.QueryResultKey = q1.QueryResultKey
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ComponentRegistryByInterface]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ComponentRegistryByInterface]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_ComponentRegistryByInterface    Script Date: 7/3/2003 4:58:02 PM ******/
CREATE   PROC asi_ComponentRegistryByInterface
@name varchar(50)
AS
BEGIN
	select ComponentKey, Description, InterfaceName, TypeName, AssemblyName, ConfigureWebUserControl, ConfigureWindowsControl from ComponentRegistry
where InterfaceName=@name;
	
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ComponentRegistryByKey]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ComponentRegistryByKey]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_ComponentRegistryByKey    Script Date: 7/3/2003 4:58:02 PM ******/
CREATE   PROC asi_ComponentRegistryByKey
@key uniqueidentifier	
AS
BEGIN
	select Name, Description, InterfaceName, TypeName, AssemblyName, ConfigureWebUserControl, ConfigureWindowsControl from ComponentRegistry
where ComponentKey=@key;
	
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ComponentRegistryByName]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ComponentRegistryByName]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_ComponentRegistryByName    Script Date: 7/3/2003 4:58:02 PM ******/
CREATE   PROC asi_ComponentRegistryByName
@name varchar(50)
AS
BEGIN
	select ComponentKey, Description, InterfaceName, TypeName, AssemblyName, ConfigureWebUserControl, ConfigureWindowsControl from ComponentRegistry
where Name=@name;
	
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ComponentRegistryByNameAndInterface]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ComponentRegistryByNameAndInterface]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE   PROC [dbo].[asi_ComponentRegistryByNameAndInterface]
@name varchar(50),
@interface varchar(100)
AS
BEGIN
	select ComponentKey, Description, InterfaceName, TypeName, AssemblyName, ConfigureWebUserControl, ConfigureWindowsControl from ComponentRegistry
where Name=@name and InterfaceName=@interface;
	
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ContentAdministratorCheck]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ContentAdministratorCheck]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/*
Checks if the user is in any MasterAdmin CAG appart from the one passed in.  
If not the user will be removed from the Content Administrator role.
*/
CREATE PROC [dbo].[asi_ContentAdministratorCheck]
   @contactKey uniqueidentifier,
   @groupKey uniqueidentifier
AS
BEGIN

	DECLARE @count int
	DECLARE @cagRoleKey uniqueidentifier

	SELECT @count = COUNT(*)
	  FROM [dbo].[GroupMemberDetail] gmd INNER JOIN [dbo].[GroupMember] gm ON gmd.[GroupMemberKey] = gm.[GroupMemberKey]
			INNER JOIN [dbo].[ContentManagerAuthorityGroup] cmag ON gmd.[GroupKey] = cmag.[GroupKey]
	 WHERE cmag.[IsMasterAdmin] = 1
	   AND gm.[MemberContactKey] = @contactKey
	   AND gmd.[GroupKey] <> @groupKey

	IF @count = 0
	BEGIN

		-- Remove the user from the Content Administrator role
		SELECT @cagRoleKey = [RoleKey] FROM [dbo].[RoleMain] WHERE [Name] = 'Content Administrator'

		DELETE FROM [dbo].[UserRole] 
		WHERE [UserKey] = @contactKey
		  AND [RoleKey] = @cagRoleKey

	END


END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ContentListByOwnerContactKey]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ContentListByOwnerContactKey]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

/*
Retrieves a list of Content Records owned by the specified contact with the specified status. Security IS enforced.

Returns:
Everything from the DocumentMain table except the blob. Also includes ContentAuthorityGroupKey and OwnerGroupMemberKey 
from ContentWorkflowParameters if Workflow is being used and HierarchyKey from the Hierarchy element representing the document.
*/
CREATE PROC [dbo].[asi_ContentListByOwnerContactKey]
   @contentProducerKey uniqueidentifier,
   @userKey uniqueidentifier,
   @loggedInUserGroupKey uniqueidentifier = '00000000-0000-0000-0000-000000000000', -- if this is empty, we assume the user is not logged in
   @documentStatus int,
   @expiringSoon bit = 0
AS
BEGIN

   DECLARE @conWarningDays1 int
   SELECT @conWarningDays1 = CONVERT(int, ParameterValue) FROM SystemConfig WHERE ParameterName = 'CM.ExpirationWarningDays1'
   IF (@conWarningDays1 IS NULL)
   BEGIN
      SELECT @conWarningDays1 = CONVERT(int, ParameterValue) FROM SystemConfig WHERE ParameterName = 'CM.ExpirationWarningDays2'
   END
   IF (@conWarningDays1 IS NULL)
   BEGIN
      SET @conWarningDays1 = 10
   END

   SELECT a.[HierarchyKey],
          b.[DocumentKey],
          b.[DocumentVersionKey],
          b.[DocumentStatusCode],
          b.[DocumentName],
          b.[AlternateName],
          b.[DocumentDescription],
          b.[DocumentTypeCode],
          b.[IsSystem],
          b.[ContainsChildrenFlag],
          b.[RelatedDocumentVersionKey],
          b.[AccessKey],
          b.[DefaultChildAccessKey],
          b.[StatusUpdatedOn],
          b.[StatusUpdatedByUserKey],
          b.[CreatedOn],
          b.[CreatedByUserKey],
          b.[UpdatedOn],
          b.[UpdatedByUserKey],
          c.[ContentAuthorityGroupKey],
          c.[OwnerGroupMemberKey]
     FROM [dbo].[Hierarchy] a INNER JOIN [dbo].[DocumentMain] b ON a.[UniformKey] = b.[DocumentVersionKey]
	  INNER JOIN [dbo].[ContentWorkflowParameters] c ON b.[DocumentVersionKey] = c.[DocumentVersionKey]
	  INNER JOIN [dbo].[GroupMember] d ON c.[ContentAuthorityGroupKey] = d.[GroupKey] 
    WHERE b.[DocumentStatusCode] = @documentStatus 
      AND b.[DocumentTypeCode] = 'CON' 
      AND ((CASE WHEN @documentStatus >= 40 THEN 1 ELSE 0 END) = c.[PublishedVersion])
      AND (@expiringSoon = 0 
         OR (DATEADD(day, -@conWarningDays1, c.[ExpirationDate]) <= CONVERT(datetime, CONVERT(char, GETDATE(), 103), 103)))
      AND d.[MemberContactKey] = @contentProducerKey
      AND EXISTS(
          SELECT 1 
            FROM [dbo].[AccessItem] INNER JOIN [dbo].[UserToken] ON [AccessItem].[Grantee] = [UserToken].[Grantee] OR AccessItem.Grantee = @loggedInUserGroupKey
           WHERE [AccessItem].[AccessKey] = b.[AccessKey] 
             AND [UserToken].[UserKey]=@userKey 
             AND ([AccessItem].[Permission]&3)>0)
      AND (NOT EXISTS (SELECT 1 FROM [dbo].[UniformLicense] WHERE UniformKey = b.DocumentVersionKey)
		 OR EXISTS(
		  SELECT 1 
		    FROM [dbo].[UniformLicense] INNER JOIN [dbo].[LicenseLegacyList] l ON [UniformLicense].[LicenseKey] = l.[LicenseLegacyKey]
		   WHERE [UniformLicense].[UniformKey] = b.[DocumentVersionKey]))
	UNION
	SELECT a.[HierarchyKey],
          b.[DocumentKey],
          b.[DocumentVersionKey],
          b.[DocumentStatusCode],
          b.[DocumentName],
          b.[AlternateName],
          b.[DocumentDescription],
          b.[DocumentTypeCode],
          b.[IsSystem],
          b.[ContainsChildrenFlag],
          b.[RelatedDocumentVersionKey],
          b.[AccessKey],
          b.[DefaultChildAccessKey],
          b.[StatusUpdatedOn],
          b.[StatusUpdatedByUserKey],
          b.[CreatedOn],
          b.[CreatedByUserKey],
          b.[UpdatedOn],
          b.[UpdatedByUserKey],
          NULL,
          NULL
     FROM [dbo].[Hierarchy] a INNER JOIN [dbo].[DocumentMain] b ON a.[UniformKey] = b.[DocumentVersionKey]
    WHERE @documentStatus <> 40
      AND b.[DocumentVersionKey] NOT IN (SELECT [DocumentVersionKey] FROM [ContentWorkflowParameters])
      AND b.[DocumentStatusCode] = @documentStatus 
      AND b.[DocumentTypeCode] = 'CON' 
       AND EXISTS(
          SELECT 1 
            FROM [dbo].[AccessItem] INNER JOIN [dbo].[UserToken] ON [AccessItem].[Grantee] = [UserToken].[Grantee] OR AccessItem.Grantee = @loggedInUserGroupKey
           WHERE [AccessItem].[AccessKey] = b.[AccessKey] 
             AND [UserToken].[UserKey]=@userKey 
             AND ([AccessItem].[Permission]&3)>0)
      AND (NOT EXISTS (SELECT 1 FROM [dbo].[UniformLicense] WHERE UniformKey = b.DocumentVersionKey)
		 OR EXISTS(
		  SELECT 1 
		    FROM [dbo].[UniformLicense] INNER JOIN [dbo].[LicenseLegacyList] l ON [UniformLicense].[LicenseKey] = l.[LicenseLegacyKey]
		   WHERE [UniformLicense].[UniformKey] = b.[DocumentVersionKey]))
    ORDER BY [DocumentName]
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_CreateGLTransLine]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_CreateGLTransLine]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE  PROCEDURE [dbo].[asi_CreateGLTransLine]
@acctKey uniqueidentifier, 
@amount decimal(18,4), 
@invoiceKey uniqueidentifier, 
@paymentKey uniqueidentifier, 
@invoiceLineKey uniqueidentifier,
@description varchar(50), 
@prodKey uniqueidentifier,
@finEntityKey uniqueidentifier,
@transDate datetime,
@deferralTermsKey uniqueidentifier,
@deferredIncAcctKey uniqueidentifier,
@glEntryType nvarchar(50),
@journalType int


AS 
BEGIN
	INSERT #tmpTransLine(AccountKey, Amount, InvoiceKey, PaymentKey, Description, ProductKey, FinEntityKey, 
	TransDate, DeferralTermsKey, DeferredIncomeGLAccountKey, InvoiceLineKey, GLEntryType, JournalEntryTypeCode) 
	VALUES (@acctKey, @amount, @invoiceKey, @paymentKey, @description , @prodKey, @finEntityKey, 
	@transDate, @deferralTermsKey, @deferredIncAcctKey, @invoiceLineKey, @glEntryType, @journalType)
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GenerateSalutations]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GenerateSalutations]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROC [dbo].[asi_GenerateSalutations] (
	@contactKey uniqueidentifier
)
AS
BEGIN

-- This stored procedure inserts all the required ContactSalutation records for a given
-- contact.  This is useful for triggers that insert contacts and need to insert the
-- required contact salutations as well.

SET NOCOUNT ON

DECLARE @salutationKey uniqueidentifier
DECLARE @tempKey uniqueidentifier
DECLARE @sql nvarchar(2000)
DECLARE @individualFormula nvarchar(2000)
DECLARE @instituteFormula nvarchar(2000)
DECLARE @calcFormula nvarchar(2000) 
DECLARE @tempValue nvarchar(1000)
DECLARE @isInstitute bit
DECLARE @isOverridden bit

SELECT @isInstitute = IsInstitute FROM ContactMain where ContactKey = @contactKey
IF @@ROWCOUNT = 0
    RETURN

SELECT @individualFormula = IndividualFormula, @instituteFormula = InstituteFormula
	FROM SalutationRef
	WHERE SalutationRef.SalutationKey=@salutationKey AND AutoCreateFlag = 1
IF @@ROWCOUNT = 0
    RETURN

DECLARE theSalutationCursor CURSOR FAST_FORWARD FOR 
	SELECT SalutationKey, IndividualFormula, InstituteFormula
		FROM SalutationRef
		WHERE AutoCreateFlag = 1

OPEN theSalutationCursor
FETCH NEXT FROM theSalutationCursor INTO @salutationKey, @individualFormula, @instituteFormula

WHILE @@FETCH_STATUS = 0 -- spin through auto-create salutations
BEGIN

	SET @tempKey = newid()

	SELECT @sql =  
		CASE 
		WHEN @isInstitute = 1 THEN
			' asi_ProcessFormulaOutput ' 
				+ '''' + convert (nvarchar(100), @tempKey) + ''', '
				+ '''' + @instituteFormula + ''', '
				+ '''Institute'', ''ContactKey'', ' 
				+ '''' + convert (nvarchar(50), @contactKey) 
				+ ''''

		WHEN @isInstitute = 0 THEN
			' asi_ProcessFormulaOutput ' 
				+ '''' + convert (nvarchar(100), @tempKey) + ''', '
				+ '''' + @individualFormula + ''', '
				+ '''Individual'', ''ContactKey'', ' 
				+ '''' + convert (nvarchar(50), @contactKey) 
				+ ''''
		END
	FROM ContactMain WHERE ContactKey = @contactKey

	EXEC (@sql)

	SELECT @tempValue = tempValue 
		FROM tempFormula
		WHERE tempKey = @tempKey

	IF @tempValue IS NOT NULL AND datalength (@tempValue) > 0 
	BEGIN
		SELECT @isOverridden = IsOverridden FROM ContactSalutation
			WHERE ContactKey = @contactKey AND SalutationKey = @salutationKey
		IF @isOverridden IS NULL
		BEGIN
			INSERT ContactSalutation
				(ContactSalutationKey, IsOverridden, SalutationText, ContactKey, SalutationKey, IsDeletable)
			VALUES (@tempKey, 0, @tempValue, @contactKey, @salutationKey, 1)
		END
		ELSE
		BEGIN
			IF @isOverridden = 0
			BEGIN
				UPDATE ContactSalutation set IsDeletable = 1, SalutationText = @tempValue
				WHERE ContactKey = @contactKey AND SalutationKey = @salutationKey
			END
		END
	END

	DELETE FROM tempFormula WHERE tempKey = @tempKey

FETCH NEXT FROM theSalutationCursor INTO @salutationKey, @individualFormula, @instituteFormula
END  -- spin through Salutation entries

CLOSE theSalutationCursor
DEALLOCATE theSalutationCursor

SET NOCOUNT OFF

END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_CreateIndividual]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_CreateIndividual]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_CreateIndividual]
    @contactKey uniqueidentifier,
	@id nvarchar(20),
	@fullName nvarchar(110),
	@lastFirst nvarchar(110),
	@prefix nvarchar(25),
    @firstName nvarchar(20),
	@middleName nvarchar(20),
	@lastName nvarchar(30),
	@suffix nvarchar(10),
	@designation nvarchar(20),
	@informal nvarchar(20),
	@gender nvarchar(1),
	@noSolicitationFlag bit,
	@statusCode nvarchar(5),
	@birthdate datetime,
	@companyContactKey uniqueidentifier,
	@companyName nvarchar(80),
	@companyTitle nvarchar(80),
    @createdByUserKey uniqueidentifier
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @now datetime
	DECLARE @entityKey uniqueidentifier
	DECLARE @defaultOrganizationKey uniqueidentifier
	DECLARE @accessKey uniqueidentifier
	DECLARE @individualTypeKey uniqueidentifier
	DECLARE @registryKey uniqueidentifier

    SET @now = getdate()
	SELECT @entityKey = SystemEntityKey FROM SystemEntity WHERE SystemKeyword = 'Organization'
	SELECT @defaultOrganizationKey = OrganizationKey FROM OrganizationMain WHERE IsDefault = 1
	SELECT @accessKey = ParameterValue FROM SystemConfig 
		WHERE ParameterName = 'Security.Token.EveryoneFullControlAccessKey'
			and SystemEntityKey = @entityKey and OrganizationKey = @defaultOrganizationKey
	SELECT @individualTypeKey = ContactTypeKey from ContactTypeRef where IsInstitute = 0

    -- Create UniformRegistry entry for individual
    SELECT @registryKey = ComponentKey FROM ComponentRegistry 
          WHERE Name = 'Individual' and InterfaceName = 'BusinessController'
    INSERT UniformRegistry (UniformKey, ComponentKey)
    VALUES (@contactKey, @registryKey)

    -- Create new contact
    INSERT INTO [ContactMain]
               ([ContactKey], [ContactStatusCode], [FullName], [SortName], [IsInstitute], [NoSolicitationFlag], 
                [SyncContactID], [ID], [IsIDEditable], [CreatedByUserKey], [CreatedOn], [UpdatedByUserKey], [UpdatedOn], [PreferredAddressCategoryCode], 
                [IsSortNameOverridden], [AccessKey], [TextOnlyEmailFlag], [ContactTypeKey], [OptOutFlag])
      VALUES (@contactKey, @statusCode, @fullName, @lastFirst, 0, @noSolicitationFlag, @id, @id, 0,
              @createdByUserKey, @now, @createdByUserKey, @now, '1', 0, @accessKey, 0, @individualTypeKey, 0)

	-- Create prefix and suffix if necessary
    IF @prefix = '' SET @prefix = NULL
    IF @prefix IS NOT NULL AND @prefix NOT IN (SELECT PrefixCode FROM PrefixRef)
        INSERT INTO [PrefixRef] (PrefixCode, PrefixDesc, SyncPrefixCode, PrefixKey)
        VALUES (@prefix, @prefix, @prefix, newid())
    IF @suffix = '' SET @suffix = NULL
    IF @suffix IS NOT NULL AND @suffix NOT IN (SELECT SuffixCode FROM SuffixRef)
        INSERT INTO [SuffixRef] (SuffixCode, SuffixDesc, SyncSuffixCode, SuffixKey)
        VALUES (@suffix, @suffix, @suffix, newid())

    -- Create new Individual
    INSERT INTO [Individual] 
                (ContactKey, PrefixCode, FirstName, MiddleName, LastName, SuffixCode, Designation, Informal, 
                 Gender, BirthDate, PrimaryInstituteContactKey, PrimaryInstituteName, PrimaryInstituteTitle)
    VALUES      (@contactKey, @prefix, @firstName, @middleName, @lastName, @suffix, @designation, @informal,
                 @gender, @birthdate, @companyContactKey, @companyName, @companyTitle)
    
	-- Generate default contact salutations for this new contact
	EXEC asi_GenerateSalutations @contactKey

	-- Generate empty FullAddress records and AddressToUse for this new contact
	-- TODO:  EXEC asi_GenerateFullAddresses
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_CreateInstitute]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_CreateInstitute]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_CreateInstitute]
    @contactKey uniqueidentifier,
    @id nvarchar(20),
    @instituteName nvarchar(80),
    @companysort nvarchar(110),
    @statusCode nvarchar(5),
    @noSolicitationFlag bit,
    @instituteTypeKey uniqueidentifier,
    @createdByUserKey uniqueidentifier
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @accessKey uniqueidentifier
    DECLARE @groupKey uniqueidentifier
    DECLARE @groupTypeKey uniqueidentifier
    DECLARE @systemEntityKey uniqueidentifier
    DECLARE @registryKey uniqueidentifier
    DECLARE @now datetime
    DECLARE @isInvitationOnly bit
    DECLARE @isSimpleGroup bit
    DECLARE @inheritRolesFlag bit
    DECLARE @isSingleRole bit
    DECLARE @instituteTypeName nvarchar(50)

    DECLARE @adminRoleKey uniqueidentifier
    DECLARE @everyoneRoleKey uniqueidentifier
    DECLARE @fullControlAccessKey uniqueidentifier

    SELECT @adminRoleKey = ParameterValue FROM SystemConfig 
        WHERE ParameterName = 'Security.Token.AdministratorsRoleKey'
    SELECT @everyoneRoleKey = ParameterValue FROM SystemConfig 
        WHERE ParameterName = 'Security.Token.EveryoneRoleKey'
    SELECT @fullControlAccessKey = ParameterValue FROM SystemConfig 
        WHERE ParameterName = 'Security.Token.EveryoneFullControlAccessKey'

    SELECT @instituteTypeName = ContactTypeDesc FROM ContactTypeRef 
        WHERE ContactTypeKey = @instituteTypeKey

    SET @now = getdate()
    SET @accessKey = newid()
    SET @groupKey = newid()

    -- Create UniformRegistry entry for institute group
    SELECT @registryKey = ComponentKey FROM ComponentRegistry 
          WHERE Name = 'Group' and InterfaceName = 'BusinessController'
    INSERT UniformRegistry (UniformKey, ComponentKey)
    VALUES (@groupKey, @registryKey)

    -- Create the group access set
    INSERT	AccessMain (AccessKey, AccessScope, CreatedByUserKey, CreatedOn, UpdatedByUserKey, UpdatedOn)
    VALUES	(@accessKey, 'Local', @createdByUserKey, @now, @createdByUserKey, @now)

    -- Grant Administrators role full control permission
    INSERT	AccessItem (AccessKey, Grantee, Permission, RoleKey)
    VALUES  (@accessKey, @adminRoleKey, 1, @adminRoleKey)

    -- Grant Everyone role read permission
    INSERT	AccessItem (AccessKey, Grantee, Permission, RoleKey)
    VALUES  (@accessKey, @everyoneRoleKey, 2, @everyoneRoleKey)
    
    -- Create a new group for the institute
    SELECT @groupTypeKey = [GroupTypeRef].GroupTypeKey,
           @isInvitationOnly = IsInvitationOnly,
           @isSimpleGroup = IsSimpleGroup,
           @inheritRolesFlag = InheritRolesFlag,
           @isSingleRole = IsSingleRole
    FROM [GroupTypeRef]
    INNER JOIN [ContactTypeRef]
    ON [GroupTypeRef].[GroupTypeKey] = [ContactTypeRef].[GroupTypeKey]
    AND [ContactTypeRef].[ContactTypeKey] = @instituteTypeKey

    SELECT @systemEntityKey = SystemEntityKey FROM [SystemEntity] 
        WHERE [IsDefault] = 1 AND [SystemKeyword] = 'Organization'    

    INSERT INTO [GroupMain] (GroupKey, [Name], Description, 
                             CreatedByUserKey, CreatedOn, UpdatedByUserKey, UpdatedOn, 
                             IsSystem, IsAutoGenerated, GroupTypeKey, AccessKey, SystemEntityKey, IsInvitationOnly,
                             GroupStatusCode, IsSimpleGroup, InheritRolesFlag, IsSingleRole, OwnerAccessKey)
    VALUES (@groupKey, @instituteName, 'Group for ' + @instituteName + ' ' + @instituteTypeName, 
            @createdByUserKey, @now, @createdByUserKey, @now, 
            0, 1, @groupTypeKey, @accessKey, @systemEntityKey, @isInvitationOnly, 'A', @isSimpleGroup,
            @inheritRolesFlag, @isSingleRole, NULL)

    -- Create UniformRegistry entry for institute itself
    SELECT @registryKey = ComponentKey FROM ComponentRegistry 
          WHERE Name = 'Institute' and InterfaceName = 'BusinessController'
    INSERT UniformRegistry (UniformKey, ComponentKey)
    VALUES (@contactKey, @registryKey)

    -- Create Contact entry
    INSERT INTO [ContactMain]
           ([ContactKey], [ContactStatusCode], [FullName], [SortName], [IsInstitute], [NoSolicitationFlag], 
            [SyncContactID], [ID], [IsIDEditable], [CreatedByUserKey], [CreatedOn], [UpdatedByUserKey], [UpdatedOn],
             [PreferredAddressCategoryCode], [IsSortNameOverridden], [AccessKey], [TextOnlyEmailFlag], [ContactTypeKey], [OptOutFlag])
    VALUES (@contactKey, @statusCode, @instituteName, @companysort, 1, @noSolicitationFlag, 
            @id, 'C' + @id, 0, @createdByUserKey, @now, @createdByUserKey, @now, '1', 
            0, @fullControlAccessKey, 0, @instituteTypeKey, 0)

    -- Create the new Institute record
    INSERT INTO [Institute] (ContactKey, InstituteName, InstituteGroupKey)
    VALUES (@contactKey, @instituteName, @groupKey)

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_CreateInstituteGroupMember]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_CreateInstituteGroupMember]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_CreateInstituteGroupMember]
    @contactKey uniqueidentifier,
	@companyGroupKey uniqueidentifier,
	@createdByUserKey uniqueidentifier,
	@primaryContact bit
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @groupMemberKey uniqueidentifier
	DECLARE @groupRoleKey uniqueidentifier
    DECLARE @defaultMemberStatusCode nvarchar(4)
	DECLARE @now datetime

    SET @groupMemberKey = newid()
	SET @now = getdate()

	-- Get the default role and member status
	IF @primaryContact = 1
	BEGIN
		SELECT @groupRoleKey = GR.GroupRoleKey, @defaultMemberStatusCode = GTR.DefaultMemberStatusCode
		FROM GroupTypeRole GTR INNER JOIN GroupRoleRef GR ON GTR.GroupRoleKey = GR.GroupRoleKey
		WHERE GR.GroupRoleDesc = 'Primary Contact' AND GTR.IsSystem = 1
	END
	ELSE
	BEGIN
		SELECT @groupRoleKey = GTR.GroupRoleKey, @defaultMemberStatusCode = GTR.DefaultMemberStatusCode
		FROM GroupTypeRole GTR INNER JOIN GroupMain GM ON GM.GroupTypeKey = GTR.GroupTypeKey
		WHERE GM.GroupKey = @companyGroupKey AND GTR.IsDefault = 1
	END

	-- Create GroupMember record
    INSERT INTO [GroupMember] (GroupMemberKey, GroupKey, MemberContactKey, IsActive, CreatedByUserKey, CreatedOn, 
                               UpdatedByUserKey, UpdatedOn)
    VALUES (@groupMemberKey, @companyGroupKey, @contactKey, 1, @createdByUserKey, @now, @createdByUserKey, @now)

	-- Create GroupMemberDetail record
    INSERT INTO [GroupMemberDetail] (GroupMemberDetailKey, GroupMemberKey, GroupKey, GroupRoleKey, EffectiveDate, 
                                     CreatedByUserKey, CreatedOn, UpdatedByUserKey, UpdatedOn, GroupMemberStatusCode, IsActive)
    VALUES (newid(), @groupMemberKey, @companyGroupKey, @groupRoleKey, @now, @createdByUserKey, @now, @createdByUserKey, @now,
            @defaultMemberStatusCode, 1)


END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_CreateOrRenamePK]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_CreateOrRenamePK]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE asi_CreateOrRenamePK @tablename nvarchar(512), @columns nvarchar(512) AS
BEGIN
	DECLARE @keyName nvarchar(512)

	-- get the name of the table's Primary Key
	SELECT @keyName = name
	  FROM sysobjects
	 WHERE parent_obj = OBJECT_ID(@tablename)
	   AND xtype = 'PK'

	-- if the key exists, but it not named according to our conventions, rename it
	IF @keyName IS NOT NULL AND @keyName <> ('PK_' + @tablename)
		EXEC ('sp_rename ''' + @keyName + ''', ''PK_' + @tablename + ''',''OBJECT''')

	-- if the key does not exist
	IF @keyName IS NULL
	BEGIN
		DECLARE @clustered nvarchar(12)
		SET @clustered = 'CLUSTERED'

		-- if a clustered index already exists, make this one non-clustered
		IF EXISTS (SELECT 1 FROM sysindexes where id = OBJECT_ID(@tablename) AND indid = 1)
			SET @clustered = 'NONCLUSTERED'

		-- add the key
		EXEC ('ALTER TABLE ' + @tablename + ' ADD CONSTRAINT PK_' + @tablename + ' PRIMARY KEY ' + @clustered +' (' + @columns + ')')
	END
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_CreatePaymentSchedules]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_CreatePaymentSchedules]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE                            PROCEDURE [dbo].[asi_CreatePaymentSchedules]
AS
DECLARE @invKey uniqueidentifier
DECLARE @invLineKey uniqueidentifier
DECLARE @prevInvKey uniqueidentifier
DECLARE @prevInvLineKey uniqueidentifier
DECLARE @paymentTermsKey uniqueidentifier
DECLARE @prevPaymentTermsKey uniqueidentifier
DECLARE @ARAcctKey uniqueidentifier
DECLARE @scheduleLineKey uniqueidentifier
DECLARE @invDate datetime
DECLARE @prevInvDate datetime
DECLARE @termsCode nvarchar(50)
DECLARE @earlyDiscountDays int
DECLARE @earlyDiscountPercent decimal(18,4)
DECLARE @intSize int
DECLARE @prevIntSize int
DECLARE @intType int
DECLARE @prevIntType int
DECLARE @intCount int
DECLARE @prevIntCount int
DECLARE @payments int
DECLARE @fetchStatus int
DECLARE @firstIteration int
DECLARE @acctMethod nchar(1)
DECLARE @prevAcctMethod nchar(1)
DECLARE @extendedPrice decimal(18,4)
DECLARE @currentTotal decimal(18,4)
DECLARE @invoiceTotal decimal(18,4)
DECLARE @currentPayment int
DECLARE @tempARKey uniqueidentifier
DECLARE @acctTotal decimal(18,4)
DECLARE @acctAmount decimal(18,4)
DECLARE @share decimal(18,4)
DECLARE @paidToCurrentGL decimal(18,4)
DECLARE @priority int
DECLARE @paymentDate datetime
DECLARE @firstPaymentDate datetime
DECLARE @scheduledSoFarForInvoice decimal(18,4)
DECLARE @dueAmount decimal(18,4)
DECLARE @scheduledSoFarForInstallment decimal(18,4)
DECLARE @firstPaymentDateTypeCode int
DECLARE @prevFirstPaymentDateTypeCode int
DECLARE @firstPaymentDateOffset int
DECLARE @prevFirstPaymentDateOffset int
DECLARE @firstPaymentDueDate datetime
DECLARE @prevFirstPaymentDueDate datetime
DECLARE @payPriority int
declare @endOfNextMonth datetime

/* enums */
DECLARE @termsTypeYearly int
DECLARE @termsTypeQuarterly int
DECLARE @termsTypeMonthly int
DECLARE @termsTypeWeekly int
DECLARE @termsTypeDaily int
SET @termsTypeYearly = 0
SET @termsTypeQuarterly = 1
SET @termsTypeMonthly = 2
SET @termsTypeWeekly = 3
SET @termsTypeDaily = 4

DECLARE @firstPaymentDateTypeInvoiceDate int
DECLARE @firstPaymentDateTypeNextMonth int
DECLARE @firstPaymentDateTypeEndOfMonth int
DECLARE @firstPaymentDateTypeSpecificDate int
SET @firstPaymentDateTypeInvoiceDate = 0
SET @firstPaymentDateTypeNextMonth = 1
SET @firstPaymentDateTypeEndOfMonth = 2
SET @firstPaymentDateTypeSpecificDate = 3

/*  This stored procedure creates a payment schedule structure
    for each invoice in the #tmpInvoice table created by the caller.
    - Create a cursor on a left join of the tmpInvoice table and the 
      payment terms table.  The result has one line for every invoice 
      line being processed, ordered by the invoice key.  
    - Read through these lines, accumulating information
      about the current invoice until all  lines for that 
      invoice have been processed.  
    - For each payment required 
      (based on the payment terms) create a PaymentScheduleLine row.  
      There may be multiple PaymentScheduleLine rows based on the applicable GLAccounts.
    TBD: This procedure assumes that we round everything to two decimal places.
         Perhaps the real number ought to passed in as a parameter.
*/
-- invoiceTotal will hold the total amount for the current invoice
SET @invoiceTotal = 0
-- firstIteration is set to 1 initially; during the first iteration of the
-- enclosing cursor loop, it is set to 0
SET @firstIteration = 1

-- The Totals table variable accumulates information about each invoice in turn.
-- The key for this table designates the GLAccount being used by the distribution 
-- lines attached to this invoice.
DECLARE @Totals TABLE
	(GLAccountKey uniqueidentifier PRIMARY KEY, 
 	 Total decimal(18,4), 
	 Share decimal(18,4), 
	 Paid decimal(18,4),
	 Priority int)

-- Create a cursor on the temp table of all invoice distributions joined with the payment terms
DECLARE Get_Invoices CURSOR FOR 
SELECT InvoiceKey, InvoiceLineKey, AccountingMethodCode, PaymentTermsKey = CASE WHEN #tmpInvoice.PaymentTermsKey = '00000000-0000-0000-0000-000000000000' THEN null ELSE #tmpInvoice.PaymentTermsKey END, 
InvoiceDate, ExtendedPrice, PaymentTermsName, EarlyDiscountDays, EarlyDiscountPercent, PaymentIntervalSize, PaymentIntervalTypeCode, PaymentIntervalCount,
ARGLAccountKey, FirstPaymentDueDate, FirstPaymentDateTypeCode, FirstPaymentDateOffset, PayPriority
FROM #tmpInvoice
LEFT OUTER JOIN PaymentTerms ON #tmpInvoice.PaymentTermsKey = PaymentTerms.PaymentTermsKey
WHERE #tmpInvoice.InvoiceTypeCode = 'S'
AND ApplyingCredit = 0
AND ARGLAccountKey is not null
ORDER BY InvoiceKey, InvoiceLineKey
SET @prevInvKey = NEWID()
OPEN Get_Invoices
FETCH next from Get_Invoices into
	@invKey, @invLineKey, @acctMethod, @paymentTermsKey, @invDate, @extendedPrice, @termsCode, @earlyDiscountDays, @earlyDiscountPercent, @intSize, @intType, @intCount,
	@ARAcctKey, @firstPaymentDueDate, @firstPaymentDateTypeCode, @firstPaymentDateOffset, @payPriority
WHILE 1 = 1
BEGIN
	SET @fetchStatus = @@FETCH_STATUS
	IF @fetchStatus = -1 AND @firstIteration = 1
		BREAK
	/* we only want to use the date part; lose the time... */
	SET @invDate = convert(char(10), @invDate, 101)
	/*  We are finished with the most recent invoice IF:
		- we are finished reading all the invoice lines
		OR
		  - the current invoice key is different from the previous one
		  AND
		  - the firstIteration flag is not one.
	    If we are finished with an invoice, we need to use the associated
	    payment terms (if any) to create PaymentScheduleLines.
	 */
	IF ((@fetchStatus = -1)) OR ((@prevInvKey != @invKey) AND @firstIteration != 1)
	BEGIN
		
		/* Compute the shares of each of the accounts in this invoice */
		DECLARE FigureShares cursor for
		SELECT GLAccountKey, Total
		FROM @Totals
		OPEN FigureShares
		FETCH next from FigureShares into
			@tempARKey, @acctTotal
		WHILE @@FETCH_STATUS = 0
		BEGIN
			SET @share = ROUND(@acctTotal / @invoiceTotal, 2)
			UPDATE @Totals SET Share = @share WHERE GLAccountKey = @tempARKey
			FETCH next from FigureShares into
				@tempARKey, @acctTotal
		END
		CLOSE FigureShares
		DEALLOCATE FigureShares
		
		
		/* Next, write the schedule lines */
		/* If there are payment terms for this invoice, use the information in
		   the payment terms object to set the number of payments.  Otherwise, 
		   set it to one.
		*/
		IF @prevPaymentTermsKey IS NULL
			SET @payments = 1
		ELSE
			SET @payments = @prevIntCount
		IF @payments = 0
			SET @payments = 1
		SET @currentPayment = 0
		SET @scheduledSoFarForInvoice = 0
		SET @firstPaymentDate = @prevInvDate
		
		/* compute the first payment date */
		IF @prevPaymentTermsKey IS NOT NULL
		BEGIN
			SET @endOfNextMonth = dateadd(dd,-1,DateAdd(mm, DateDiff(mm, 0, @prevInvDate) + 2, 0)) 
			SET @firstPaymentDate =
				CASE @prevFirstPaymentDateTypeCode
					--  add the supplied offset (or zero if null) to the invoice date
					WHEN @firstPaymentDateTypeInvoiceDate THEN
						DATEADD(dd, ISNULL(@prevFirstPaymentDateOffset, 0), @prevInvDate)
					--  add the supplied offset (or zero if null) to the beginning of next month.
					--  if the result would be greater than the end of next month (e.g. the offset was 30 
					--  and next month February) then just return the end of next month.
					WHEN @firstPaymentDateTypeNextMonth THEN
						CASE WHEN DATEADD(d, ISNULL(@prevFirstPaymentDateOffset, 0), DateAdd(mm, DateDiff(mm, 0, @prevInvDate) + 1, -1)) > @endOfNextMonth 
							 THEN @endOfNextMonth
							 ELSE  DATEADD(d, ISNULL(@prevFirstPaymentDateOffset, 0), DATEADD(m, DATEDIFF(m, 0, @prevInvDate) + 1, -1))
						     END
					-- return the last day of the current month
					WHEN @firstPaymentDateTypeEndOfMonth THEN
						DATEADD(d, -1, DATEADD(m, 1 + DATEDIFF(m, 0, @prevInvDate), 0))
					-- return the indicated date (or the invoice date, if null)
					WHEN @firstPaymentDateTypeSpecificDate THEN
						ISNULL(@prevFirstPaymentDueDate, @firstPaymentDate)
				END
		END
		/* compute the amount */
		SET @dueAmount = ROUND(@invoiceTotal / @payments, 2)
		WHILE @currentPayment < @payments
		BEGIN
			SET @scheduledSoFarForInstallment = 0
			/* Compute the due date 
			   If there are no payment terms, we will just leave the
	                                 the payment date as the invoice date.*/
			IF @prevPaymentTermsKey IS NOT NULL
			BEGIN
				SET @paymentDate = 
					CASE @prevIntType
						WHEN @termsTypeYearly THEN DATEADD(yy, @prevIntSize * @currentPayment, @firstPaymentDate)
						WHEN @termsTypeQuarterly THEN DATEADD(qq, @prevIntSize * @currentPayment, @firstPaymentDate)
						WHEN @termsTypeMonthly THEN DATEADD(mm, @prevIntSize * @currentPayment, @firstPaymentDate)
						WHEN @termsTypeWeekly THEN DATEADD(wk, @prevIntSize * @currentPayment, @firstPaymentDate)
						WHEN @termsTypeDaily THEN DATEADD(dd, @prevIntSize * @currentPayment, @firstPaymentDate)
						/* TBD: what to do otherwise? */
					END
			END
			ELSE
				SET @paymentDate = @firstPaymentDate
			SET @currentPayment = @currentPayment + 1
			SET @scheduledSoFarForInvoice = @scheduledSoFarForInvoice + @dueAmount
			/*
				If we are working on the last payment for this invoice,
				we want to correct for round-off error.  If scheduledSoFar
				is not the same as the invoiceTotal, adjust this last
				payment.
			*/
			IF (@currentPayment = @payments) AND (@scheduledSoFarForInvoice != @invoiceTotal)
				SET @dueAmount = @dueAmount + (@invoiceTotal - @scheduledSoFarForInvoice)
			
			
			IF UPPER(@prevAcctMethod) = 'A'
			BEGIN
				/* For each AR in the invoice, create schedule lines to divide the 
				   installment amount according to the share for this AR */
				DECLARE Account_Info cursor for
				SELECT GLAccountKey, Total, Share, Paid, Priority
				FROM @Totals
				OPEN Account_Info
				FETCH next from Account_Info into
					@tempARKey, @acctTotal, @share, @paidToCurrentGL, @priority
				WHILE @@FETCH_STATUS = 0
				BEGIN
					SET @acctAmount = ROUND(@dueAmount * @share, 2)
					/*
						Round-off correction if this is the last payment
					*/
					if (@currentPayment = @payments) AND (@acctAmount + @paidToCurrentGL != @acctTotal)
						SET @acctAmount = @acctTotal - @paidToCurrentGL

					SET @paidToCurrentGL = @paidToCurrentGL + @acctAmount
					UPDATE @Totals SET Paid = @paidToCurrentGL WHERE GLAccountKey = @tempARKey					
	
					SET @scheduledSoFarForInstallment = @scheduledSoFarForInstallment + @acctAmount
				
					SET @scheduleLineKey = NEWID()
					INSERT PaymentScheduleLine(PaymentScheduleLineKey, InvoiceKey, PaymentNumber, DueDate, AmountDue, OutstandingBalance, GLAccountKey, PayPriority)
					VALUES(@scheduleLineKey, @prevInvKey, @currentPayment, @paymentDate, @acctAmount, @acctAmount, @tempARKey, @priority)
					FETCH next from Account_Info into
						@tempARKey, @acctTotal, @share, @paidToCurrentGL, @priority
				END
				CLOSE Account_Info
				DEALLOCATE Account_Info	
				/* If the total amount we added to the various accounts 
				   does not equal the amount due for this payment, we will
				   adjust the last line to account for the rounding error. */
				IF  @scheduledSoFarForInstallment != @dueAmount
				BEGIN
					SET @acctAmount = @acctAmount + (@dueAmount - @scheduledSoFarForInstallment)
					UPDATE PaymentScheduleLine SET AmountDue = @acctAmount WHERE PaymentScheduleLineKey = @scheduleLineKey
				END
				
			END
			ELSE -- Cash-based; set PayPriority to zero for now -- Revisit this
			BEGIN
				SET @scheduleLineKey = NEWID()
				INSERT PaymentScheduleLine (PaymentScheduleLineKey, InvoiceKey, PaymentNumber, DueDate, AmountDue, OutstandingBalance, PayPriority)
				VALUES (@scheduleLineKey, @prevInvKey, @currentPayment, @paymentDate, @dueAmount, @dueAmount, 0)
			END
				
		END
		/* We are finished processing the previous invoice.  If there are no more
		   lines (fetch status was -1) we are done.  Otherwise we 
		   re-initialize for the current, new, invoice.
		*/
		IF @fetchStatus = -1 BREAK
		IF @fetchStatus = -2 CONTINUE
		SET @invoiceTotal = 0;
		DELETE @Totals
	END
	IF (@prevInvKey != @invKey)
	BEGIN
		-- Starting a new invoice; set all the "prev" variables.
		SET @prevInvKey = @invKey
		SET @prevPaymentTermsKey = @paymentTermsKey
		SET @prevInvDate =  @invDate
		SET @prevIntSize = @intSize
		SET @prevIntType = @intType
		SET @prevIntCount = @intCount
		SET @prevAcctMethod = @acctMethod
		SET @prevFirstPaymentDateTypeCode =  @firstPaymentDateTypeCode
		SET @prevFirstPaymentDateOffset =  @firstPaymentDateOffset
		SET @prevFirstPaymentDueDate = @firstPaymentDueDate
	END
	SET @firstIteration = 0
	IF @prevInvLineKey is null OR @invLineKey != @prevInvLineKey
	BEGIN
		SET @invoiceTotal = @invoiceTotal + @extendedPrice
		/* Associate the invoice distribution amounts with different GLAccounts
		   depending on the accounting method. 
		*/
		IF UPPER(@acctMethod) = 'A'
		BEGIN
			/*
				Update the table variable Totals with information from this
				invoice distribution.  But first, insert into Totals if we have not encountered
				this GLAccount in this invoice yet.
				 
				Note that we run this code only once per invoice line.  Multiple distributions for 
				this invoice line will have the same ARAcctKey, and will share the same ExtendedPrice.
				If we run this for each distribution, we will count the ExtendedPrice multiple times.
			*/
			SET @currentTotal = null
			SELECT @currentTotal = Total, @priority = Priority from @Totals where GLAccountKey = @ARAcctKey
			IF @currentTotal IS NULL
			BEGIN
				INSERT @Totals(GLAccountKey, Total, Share, Paid, Priority)
				VALUES (@ARAcctKey, 0, 0, 0, @payPriority)
				SET @currentTotal = 0
				SET @priority = @payPriority
			END
			SET @currentTotal = @currentTotal + @extendedPrice
			if @payPriority < @priority
				SET @priority = @payPriority
			UPDATE @Totals SET Total = @currentTotal, Priority = @priority WHERE GLAccountKey = @ARAcctKey
		END
	END
	SET @prevInvLineKey = @invLineKey
	FETCH next from Get_Invoices into
		@invKey, @invLineKey, @acctMethod, @paymentTermsKey, @invDate, @extendedPrice, @termsCode, @earlyDiscountDays, @earlyDiscountPercent, @intSize, @intType, @intCount,
		@ARAcctKey, @firstPaymentDueDate, @firstPaymentDateTypeCode, @firstPaymentDateOffset, @payPriority
END
CLOSE Get_Invoices
DEALLOCATE Get_Invoices

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_CreateRebuildOrRenamePK]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_CreateRebuildOrRenamePK]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_CreateRebuildOrRenamePK] 
	@tablename nvarchar(512), 
	@columns nvarchar(512) 
AS
BEGIN
	DECLARE @keyName nvarchar(512)
	DECLARE @indexname nvarchar(512)

	-- get the name of the table's Primary Key
	SELECT @keyName = name
	  FROM sysobjects
	 WHERE parent_obj = OBJECT_ID(@tablename)
	   AND xtype = 'PK'

	SET @indexname = 'PK_' + @tablename

	-- if the key exists...
	IF @keyName IS NOT NULL
	BEGIN
		IF @keyName <> ('PK_' + @tablename)
		BEGIN
			-- if it not named according to our conventions, rename it
			EXEC ('sp_rename ''' + @keyName + ''', ''' + @indexname + ''', ''OBJECT''')
		END
		ELSE
		BEGIN
			-- otherwise rebuild it
			DBCC DBREINDEX (@tablename, @indexname) WITH NO_INFOMSGS
		END
    END

	-- if the key does not exist
	IF @keyName IS NULL
	BEGIN
		DECLARE @clustered nvarchar(12)
		SET @clustered = 'CLUSTERED'

		-- if a clustered index already exists, make this one non-clustered
		IF EXISTS (SELECT 1 FROM sysindexes where id = OBJECT_ID(@tablename) AND indid = 1)
			SET @clustered = 'NONCLUSTERED'

		-- add the key
		EXEC ('ALTER TABLE ' + @tablename + ' ADD CONSTRAINT PK_' + @tablename + ' PRIMARY KEY ' + @clustered +' (' + @columns + ')')
	END
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_CreateRFMStatsAuto]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_CreateRFMStatsAuto]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_CreateRFMStatsAuto Script Date: 9/28/2005 11:04:02 AM ******/
CREATE PROCEDURE [dbo].[asi_CreateRFMStatsAuto]
	@rfmKey UNIQUEIDENTIFIER,
	@numGroupsRecency INT,
	@numGroupsFrequency INT,
	@numGroupsMonetary INT
AS

DECLARE @now DATETIME

SET @now = GETDATE()

-- new code
select 
ContactKey, 
count(*) as CT,
 sum (Amount) as AMT,
 min (Amount) as LOW,
 max (Amount) as HIGH,
 min ([TransactionDate]) as FIRST,
 max ([TransactionDate]) as LAST,
 convert (datetime, '1/1/90') as HIGHCONT,
 10000000.0000 as FIRSTAMT,
 10000000.0000 as LASTAMT
into #tmpTransWork
from #tmpTrans
group by ContactKey

update #tmpTransWork
 set HIGHCONT = #tmpTrans.TransactionDate from #tmpTrans
 where #tmpTransWork.ContactKey = #tmpTrans.ContactKey
 and #tmpTransWork.HIGH = #tmpTrans.Amount

 
update #tmpTransWork
 set FIRSTAMT = #tmpTrans.Amount from #tmpTrans
 where #tmpTransWork.ContactKey = #tmpTrans.ContactKey
 and #tmpTransWork.FIRST = #tmpTrans.TransactionDate

 
update #tmpTransWork
 set LASTAMT = #tmpTrans.Amount from #tmpTrans
 where #tmpTransWork.ContactKey = #tmpTrans.ContactKey
 and #tmpTransWork.LAST = #tmpTrans.TransactionDate

 
-- existing code, updated statement
-- Update the RFMMain Table, set initial values for all columns
UPDATE RFMMain
 SET NumContacts = T1.CT,
 TotalAmount = T1.AMT,
 LowAmount = T1.LOW,
 HighAmount = T1.HIGH,
 FirstContact = T1.FIRST,
 LastContact = T1.LAST,
 HighContact = T1.HIGHCONT,
 FirstContactAmount = T1.FIRSTAMT,
 LastContactAmount = T1.LASTAMT,
 NumDays = DATEDIFF(DAY, T1.LAST, @now),
 Frequency = 0,
 Recency = 0,
 Monetary = 0,
 Combined = 0,
 Total = 0
 FROM
 (SELECT 
 ContactKey, 
 CT, 
 AMT, 
 LOW, 
 HIGH, 
 FIRST, 
 LAST,
 HIGHCONT,
 FIRSTAMT,
 LASTAMT
 FROM #tmpTransWork) AS T1
 WHERE RFMMain.RFMKey = @rfmKey AND RFMMain.ContactKey = T1.ContactKey
 
--DELETE from RFMMain WHERE RFMMain.RFMKey = @rfmKey AND RFMMain.NumContacts = 0  
 
DECLARE @numGroups INT
DECLARE @group_size INT
DECLARE @total_count INT
DECLARE @n INT
DECLARE @sql VARCHAR(500)

if (@numGroupsRecency > 0)
BEGIN
	-- Do the Recency Rankings
	SET @numGroups = @numGroupsRecency

	-- Get the Total Count
	-- Only choose records that have numdays
	select @total_count = count(*) from RFMMain WHERE RFMMain.RFMKey = @rfmKey AND NumDays IS NOT NULL
	
	IF (@total_count > 0)
	BEGIN 
		PRINT 'Recency Total Count = ' + str(@total_count) + ' Num Groups = ' + str(@numGroups)
		SET @group_size = ROUND(CAST(@total_count AS FLOAT) / @numGroups, 0)

		PRINT 'Recency Group Size = ' + str(@group_size)

		IF (@group_size = 0)
			SET @group_size = 1
			
		SET @n = 1

		WHILE (@n <= @numGroups)
		BEGIN
			-- Build the SQL dynamically. We have to do this in order to use
			-- the TOP clause with a variable
			IF (@n < @numGroups)
			BEGIN
				SELECT @sql = 'UPDATE RFMMain SET Recency = ' + str(@n) +
					' FROM ( SELECT TOP ' + str(@group_size) + ' * FROM RFMMain ' +
					' WHERE NumDays IS NOT NULL AND Recency = 0' +
					' ORDER BY NumDays DESC) AS T1' +
					' WHERE RFMMain.RFMKey = T1.RFMKey AND RFMMain.ContactKey = T1.ContactKey';
			END
			ELSE
			BEGIN
				SELECT @sql = 'UPDATE RFMMain SET Recency = ' + str(@n) +
					' FROM ( SELECT * FROM RFMMain ' +
					' WHERE NumDays IS NOT NULL AND Recency = 0' +
					' ) AS T1' +
					' WHERE RFMMain.RFMKey = T1.RFMKey AND RFMMain.ContactKey = T1.ContactKey';
			END
			
			PRINT 'Sql = ' + @sql
			-- Execute the SQL
			EXEC (@sql)
						
			SET @n = @n+1
		END
	END
END

if (@numGroupsFrequency > 0)
BEGIN
	-- Do the Frequency Rankings
	SET @numGroups = @numGroupsFrequency

	-- Get the Total Count
	select @total_count = count(*) from RFMMain WHERE RFMMain.RFMKey = @rfmKey AND NumContacts IS NOT NULL AND NumContacts != 0
	
	IF (@total_count > 0)
	BEGIN
		PRINT 'Frequency Total Count = ' + str(@total_count) + ' Num Groups = ' + str(@numGroups)
		SET @group_size = ROUND(CAST(@total_count AS FLOAT) / @numGroups, 0)

		PRINT 'Frequency Group Size = ' + str(@group_size)
			
		SET @n = 1

		IF (@group_size = 0)
			SET @group_size = 1

		WHILE (@n <= @numGroups)
		BEGIN
			-- Build the SQL dynamically. We have to do this in order to use
			-- the TOP clause with a variable
			IF (@n < @numGroups)
			BEGIN
				SELECT @sql = 'UPDATE RFMMain SET Frequency = ' + str(@n) +
					' FROM ( SELECT TOP ' + str(@group_size) + ' * FROM RFMMain ' +
					' WHERE NumContacts IS NOT NULL AND NumContacts != 0 AND Frequency = 0' +
					' ORDER BY NumContacts ASC) AS T1' +
					' WHERE RFMMain.RFMKey = T1.RFMKey AND RFMMain.ContactKey = T1.ContactKey';
			END
			ELSE
			BEGIN
				SELECT @sql = 'UPDATE RFMMain SET Frequency = ' + str(@n) +
					' FROM ( SELECT * FROM RFMMain ' +
					' WHERE NumContacts IS NOT NULL AND NumContacts != 0 AND Frequency = 0' +
					' ) AS T1' +
					' WHERE RFMMain.RFMKey = T1.RFMKey AND RFMMain.ContactKey = T1.ContactKey';
			END
			
			-- Execute the SQL
			EXEC (@sql)
						
			SET @n = @n+1
		END
	END
END

if (@numGroupsMonetary > 0)
BEGIN
	-- Do the Monetary Rankings
	SET @numGroups = @numGroupsMonetary

	-- Get the Total Count
	select @total_count = count(*) from RFMMain WHERE RFMMain.RFMKey = @rfmKey AND TotalAmount IS NOT NULL AND TotalAmount != 0

	IF (@total_count > 0)
	BEGIN
		PRINT 'Monetary Total Count = ' + str(@total_count) + ' Num Groups = ' + str(@numGroups)
		SET @group_size = ROUND(CAST(@total_count AS FLOAT) / @numGroups, 0)

		PRINT 'Monetary Group Size = ' + str(@group_size)
		IF (@group_size = 0)
			SET @group_size = 1
			
		SET @n = 1

		WHILE (@n <= @numGroups)
		BEGIN
			-- Build the SQL dynamically. We have to do this in order to use
			-- the TOP clause with a variable
			IF (@n < @numGroups)
			BEGIN
				SELECT @sql = 'UPDATE RFMMain SET Monetary = ' + str(@n) +
					' FROM ( SELECT TOP ' + str(@group_size) + ' * FROM RFMMain ' +
					' WHERE TotalAmount IS NOT NULL AND TotalAmount != 0 AND Monetary = 0' +
					' ORDER BY TotalAmount ASC) AS T1' +
					' WHERE RFMMain.RFMKey = T1.RFMKey AND RFMMain.ContactKey = T1.ContactKey';
			END
			ELSE
			BEGIN
				SELECT @sql = 'UPDATE RFMMain SET Monetary = ' + str(@n) +
					' FROM ( SELECT * FROM RFMMain ' +
					' WHERE TotalAmount IS NOT NULL AND TotalAmount != 0 AND Monetary = 0' +
					' ) AS T1' +
					' WHERE RFMMain.RFMKey = T1.RFMKey AND RFMMain.ContactKey = T1.ContactKey';
			END
			
			-- Execute the SQL
			EXEC (@sql)
						
			SET @n = @n+1
		END
	END
END

-- Set the combined and total rankings	
update RFMMain
	set Combined = Recency*10000+Frequency*100+Monetary,
	Total = Recency+Frequency+Monetary
	where RFMMain.RFMKey = @rfmKey

drop table #tmpTrans

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_CreateRFMStatsManual]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_CreateRFMStatsManual]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_CreateRFMStatsManual]

@rfmKey uniqueidentifier

AS

declare @now datetime

set @now = getdate()

-- new code
select 
ContactKey, 
count(*) as CT,
 sum (Amount) as AMT,
 min (Amount) as LOW,
 max (Amount) as HIGH,
 min ([TransactionDate]) as FIRST,
 max ([TransactionDate]) as LAST,
 convert (datetime, '1/1/90') as HIGHCONT,
 10000000.0000 as FIRSTAMT,
 10000000.0000 as LASTAMT
into #tmpTransWork
from #tmpTrans
group by ContactKey

update #tmpTransWork
 set HIGHCONT = #tmpTrans.TransactionDate from #tmpTrans
 where #tmpTransWork.ContactKey = #tmpTrans.ContactKey
 and #tmpTransWork.HIGH = #tmpTrans.Amount
 
update #tmpTransWork
 set FIRSTAMT = #tmpTrans.Amount from #tmpTrans
 where #tmpTransWork.ContactKey = #tmpTrans.ContactKey
 and #tmpTransWork.FIRST = #tmpTrans.TransactionDate
 
update #tmpTransWork
 set LASTAMT = #tmpTrans.Amount from #tmpTrans
 where #tmpTransWork.ContactKey = #tmpTrans.ContactKey
 and #tmpTransWork.LAST = #tmpTrans.TransactionDate
 
-- existing code, updated statement
-- Update the RFMMain Table, set initial values for all columns
UPDATE RFMMain
 SET NumContacts = T1.CT,
 TotalAmount = T1.AMT,
 LowAmount = T1.LOW,
 HighAmount = T1.HIGH,
 FirstContact = T1.FIRST,
 LastContact = T1.LAST,
 HighContact = T1.HIGHCONT,
 FirstContactAmount = T1.FIRSTAMT,
 LastContactAmount = T1.LASTAMT,
 NumDays = DATEDIFF(DAY, T1.LAST, @now),
 Frequency = 0,
 Recency = 0,
 Monetary = 0,
 Combined = 0,
 Total = 0
 FROM
 (SELECT 
 ContactKey, 
 CT, 
 AMT, 
 LOW, 
 HIGH, 
 FIRST, 
 LAST,
 HIGHCONT,
 FIRSTAMT,
 LASTAMT
 FROM #tmpTransWork) AS T1
 WHERE RFMMain.RFMKey = @rfmKey AND RFMMain.ContactKey = T1.ContactKey

-- Update the Recency Rankings
update RFMMain
	set Recency = S1.Ranking
	from (select RFMMain.ContactKey, #tmpRanking.Ranking from RFMMain, #tmpRanking 
	where RFMMain.NumDays is NOT NULL and RFMMain.NumDays between 
	#tmpRanking.RecencyStart and #tmpRanking.RecencyEnd) AS S1
	where RFMMain.RFMKey = @rfmKey and RFMMain.ContactKey = S1.ContactKey
	
-- Update the Frequency Rankings
update RFMMain
	set Frequency = S1.Ranking
	from (select RFMMain.ContactKey, #tmpRanking.Ranking from RFMMain, #tmpRanking 
	where RFMMain.NumContacts is NOT NULL and NumContacts != 0 and RFMMain.NumContacts between 
	#tmpRanking.FrequencyStart and #tmpRanking.FrequencyEnd) AS S1
	where RFMMain.RFMKey = @rfmKey and RFMMain.ContactKey = S1.ContactKey

-- Update the Monetary Rankings
update RFMMain
	set Monetary = S1.Ranking
	from (select RFMMain.ContactKey, #tmpRanking.Ranking from RFMMain, #tmpRanking 
	where RFMMain.TotalAmount is NOT NULL and TotalAmount != 0 and RFMMain.TotalAmount between 
	#tmpRanking.MonetaryStart and #tmpRanking.MonetaryEnd) AS S1
	where RFMMain.RFMKey = @rfmKey and RFMMain.ContactKey = S1.ContactKey

-- Set the combined and total rankings	
update RFMMain
	set Combined = Recency*10000+Frequency*100+Monetary,
	Total = Recency+Frequency+Monetary
	where RFMMain.RFMKey = @rfmKey

drop table #tmpTrans	
drop table #tmpRanking

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_CreateSalesHistory]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_CreateSalesHistory]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_CreateSalesHistory]
@amount decimal(18,4),
@transDate datetime,
@sourceCodeKey uniqueidentifier,
@orderTypeKey uniqueidentifier,
@orderNumber nvarchar(50),
@responseMediaCode nvarchar(20),
@priceSheetKey uniqueidentifier,
@extendedCost decimal(18,4),
@warehouseKey uniqueidentifier,
@invType char(1),
@billToContactKey uniqueidentifier,
@shipToContactKey uniqueidentifier,
@soldToContactKey uniqueidentifier,
@orderDate datetime,
@productKey uniqueidentifier,
@qtySold decimal(18,4),
@undiscountedExtendedPrice decimal(18,4),
@uomKey uniqueidentifier,
@userKey uniqueidentifier,
@systemKey uniqueidentifier,
@accessKey uniqueidentifier,
@commissionPlanKey uniqueidentifier,
@salesTeamGroupKey uniqueidentifier,
@salesLocationKey uniqueidentifier,        /* 11/30/04 - pjr */
@isPledge bit,
@invoiceLineNumber int,
@invoiceNumber nvarchar(50)
AS
DECLARE @salesHistoryKey uniqueidentifier
DECLARE @glTypeDistribution int

SET @salesHistoryKey = NEWID()
INSERT SalesHistory(SalesHistoryKey, TransactionDate, OrderNumber, OrderTypeKey, OrderDate, 
  InvoiceTypeCode, BillToContactKey, ShipToContactKey, SoldToContactKey, ProductKey, WarehouseKey, 
  QuantitySold, ExtendedPrice, UndiscountedExtendedPrice, ExtendedCost, UomKey, SourceCodeKey, 
  ResponseMediaCode, PriceSheetKey, CommissionPlanKey, SalesTeamGroupKey, SalesLocationKey,
  AccessKey, CreatedOn, CreatedByUserKey, SystemEntityKey, IsPledge, InvoiceLineNumber, InvoiceNumber)
VALUES(@salesHistoryKey, @transDate, @orderNumber, @orderTypeKey, @orderDate, 
  @invType, @billToContactKey, @shipToContactKey, @soldToContactKey, @productKey, @warehouseKey, 
  @qtySold, -1 * @amount, @undiscountedExtendedPrice, @extendedCost, @uomKey, @sourceCodeKey,  
  @responseMediaCode, @priceSheetKey, @commissionPlanKey, @salesTeamGroupKey, @salesLocationKey,
  @accessKey, GETDATE(), @userKey, @systemKey, @isPledge, @invoiceLineNumber, @invoiceNumber)

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_CreateTempGL]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_CreateTempGL]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_CreateTempGL]
@accountKey uniqueidentifier,
@amount decimal(18,4),
@invoiceKey uniqueidentifier,
@paymentKey uniqueidentifier,
@productKey uniqueidentifier,
@finEntityKey uniqueidentifier,
@transDate datetime,
@journalType int,
@fiscalPeriod int,
@glEntryType nvarchar(50),
@description nvarchar(20),
@invoiceLineKey uniqueidentifier,
@defTermsKey uniqueidentifier,
@targetAcctKey uniqueidentifier,
@sequenceNumber int,
@originatingBatchNumber nvarchar(50),
@finalBatchNumber nvarchar(50),
@billToContactKey uniqueidentifier, 
@journalEntryDescription nvarchar(50),
@invoiceLineNumber int
AS
DECLARE @salesHistoryKey uniqueidentifier
DECLARE @glTypeDistribution int
SET @glTypeDistribution = 1
INSERT #tmpTransLine(AccountKey, Amount, InvoiceKey, PaymentKey, Description, ProductKey, 
FinEntityKey, TransDate, GLEntryType, JournalEntryTypeCode, FiscalPeriod,
InvoiceLineKey, DeferralTermsKey, TargetGLAccountKey, TransactionSequenceNumber, OriginatingBatchNumber,
FinalBatchNumber, BillToContactKey, JournalEntryDescription, InvoiceLineNumber) 
VALUES (@accountKey, @amount, @invoiceKey, @paymentKey, @description , @productKey,
@finEntityKey, @transDate, @glEntryType, @journalType, @fiscalPeriod, 
@invoiceLineKey, @defTermsKey, @targetAcctKey, @sequenceNumber,
@originatingBatchNumber, @finalBatchNumber, @billToContactKey, @journalEntryDescription, @invoiceLineNumber)

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_CreateUpdateAppealParticipation]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_CreateUpdateAppealParticipation]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_CreateUpdateAppealParticipation    Script Date: 7/3/2003 4:58:02 PM ******/
-- Create or update AppealParticipation records for each contact in the input list
--
CREATE PROCEDURE [dbo].[asi_CreateUpdateAppealParticipation]
@listKey uniqueidentifier,
@appealKey uniqueidentifier,
@solicitationKey uniqueidentifier,
@sourceCodeKey uniqueidentifier,
@responseTypeCode int,
@userKey uniqueidentifier
AS
BEGIN

BEGIN TRAN

declare @returnCount int
set @returnCount = 0

-- Update AppealParticipation for source code + contacts combos
-- that are already in appeal
UPDATE vBoAppealParticipation
 SET	SolicitationKey=@solicitationKey,
	UpdatedByUserKey=@userKey,
	UpdatedOn=getdate()
 FROM	vBoAppealParticipation ap INNER JOIN vBoListElement le
	ON ap.RespondentUserKey = le.ObjectKey
 WHERE
	ap.AppealKey = @appealKey
	AND le.ListKey = @listKey
    AND ap.SourceCodeKey=@sourceCodeKey

set @returnCount = @returnCount + @@ROWCOUNT

-- Insert into AppealParticipation for contacts entering appeal
-- for a particular source code
INSERT vBoAppealParticipation( 
	AppealParticipationKey, 
	AppealKey, 
	SolicitationKey, 
	SourceCodeKey,
	ResponseTypeCode, 
	CreatedByUserKey, 
	CreatedOn, 
	UpdatedByUserKey, 
	UpdatedOn, 
	RespondentUserKey) 
 SELECT newid(), 
	@appealKey, 
	@solicitationKey, 
	@sourceCodeKey,
	@responseTypeCode, 
	@userKey, 
	getdate(), 
	@userKey, 
	getdate(), 
	le.ObjectKey
 FROM 	vBoListElement le
 WHERE 
	le.ListKey = @listKey 
	AND NOT EXISTS (SELECT 1
			 FROM vBoAppealParticipation ap
			 WHERE ap.AppealKey = @appealKey
			 AND ap.RespondentUserKey = le.ObjectKey
			 AND ap.SourceCodeKey=@sourceCodeKey)

set @returnCount = @returnCount + @@ROWCOUNT

select @returnCount as ReturnCount

COMMIT TRAN

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetOrderResponseStart]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetOrderResponseStart]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_GetOrderResponseStart    ******/

CREATE  PROCEDURE [dbo].[asi_GetOrderResponseStart]

@userKey uniqueidentifier,
@rangeBegin float output,
@rangeEnd float output
AS
DECLARE @newGuid as uniqueidentifier 
declare @EveryoneFullControlAccessKey uniqueidentifier
select @EveryoneFullControlAccessKey = ParameterValue from SystemConfig 
	where ParameterName = 'Security.Token.EveryoneFullControlAccessKey'
set @rangeBegin = 0
set @rangeEnd = 0
BEGIN TRAN 
-- Get the ending value
SELECT	@rangeEnd =  max(ORDER_NUMBER)
 FROM	Orders
-- Check to make sure the counter exists - create it if not
IF NOT EXISTS(SELECT 1 FROM SystemConfig WHERE ParameterName='OrderResponseRangeStart')
BEGIN
	SELECT @newGuid = newid()
	INSERT SystemConfig (SystemConfigKey, ParameterName, ParameterValue, Description)
	VALUES(	@newGuid, 
		'OrderResponseRangeStart', 
		CAST(@rangeEnd As nvarchar(100)), 
		'Ending point in the Orders table already processed by response acquisition.')
END
-- Get the beginning value
SELECT	@rangeBegin = CAST(ParameterValue As float)
 FROM	SystemConfig
 WHERE	ParameterName = 'OrderResponseRangeStart'
 IF @rangeBegin is NULL
	SET @rangeBegin = 0
-- Set the ending value
UPDATE	SystemConfig
 SET	ParameterValue = CAST(@rangeEnd As nvarchar(100))
 WHERE	ParameterName = 'OrderResponseRangeStart'
COMMIT TRAN

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetTransResponseStart]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetTransResponseStart]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_GetTransResponseStart    Script Date: 7/3/2003 4:58:03 PM ******/

CREATE  PROCEDURE [dbo].[asi_GetTransResponseStart] 

@userKey uniqueidentifier,
@rangeBegin int output,
@rangeEnd int output

AS

DECLARE @newGuid as uniqueidentifier 
declare @EveryoneFullControlAccessKey uniqueidentifier
select @EveryoneFullControlAccessKey = ParameterValue from SystemConfig 
	where ParameterName = 'Security.Token.EveryoneFullControlAccessKey'

set @rangeBegin = 0
set @rangeEnd = 0

BEGIN TRAN 

-- Get the ending value
SELECT	@rangeEnd =  max(TRANS_NUMBER)
 FROM	Trans

-- Check to make sure the counter exists - create it if not
IF NOT EXISTS(SELECT 1 FROM SystemConfig WHERE ParameterName='TransResponseRangeStart')
BEGIN
	SELECT @newGuid = newid()
	INSERT SystemConfig (SystemConfigKey, ParameterName, ParameterValue, Description, 
		OrganizationKey, SystemEntityKey, CreatedByUserKey, CreatedOn)
	VALUES(	@newGuid, 
		'TransResponseRangeStart', 
		CAST(@rangeEnd As nvarchar(100)), 
		'Ending point in the Trans table already processed by response acquisition.',
		'00000000-0000-0000-0000-000000000000',
		NULL,
		@userKey, 
		getdate())
END

-- Get the beginning value
SELECT	@rangeBegin = CAST(ParameterValue As int)
 FROM	SystemConfig
 WHERE	ParameterName = 'TransResponseRangeStart'

-- Set the ending value
UPDATE	SystemConfig
 SET	ParameterValue = CAST(@rangeEnd As nvarchar(100))
 WHERE	ParameterName = 'TransResponseRangeStart'

COMMIT TRAN

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_CsUpdateCampaignResponses]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_CsUpdateCampaignResponses]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_UpdateCampaignResponses    Script Date: 11/15/2005 3:00 PM ******/
CREATE    PROCEDURE [dbo].[asi_CsUpdateCampaignResponses]
 
@useImplicit bit, 
@userKey uniqueidentifier
AS
--The following values were used during testing
--set @useImplicit = 1 
--set @userKey = '00000000-0000-0000-0000-000000000001' 
-- updated 15 Feb 2007 RRK to add some Seco stuff; ServiceCentral in particular.
-- updated 16 Feb 2007 RRK DT19614 -- fix problem with auto-mapped Dues
declare @firstTransNumber int
declare @lastTransNumber int
declare @firstOrderNumber float
declare @lastOrderNumber float
declare @now datetime
declare @debug bit
set @debug = 1
--Get the last TRANS row used in a response update and update the number to the current max
if @debug = 1
	print 'Get the last TRANS row used in a response update and update the number to the current max'
execute asi_GetTransResponseStart @userKey, @firstTransNumber output, @lastTransNumber output
if @debug = 1
	print 'First Trans Number:' + convert(varchar(10),@firstTransNumber) +'; Last Tans Number ' + convert(varchar(10),@lastTransNumber)
--Get the last ORDERS row used in a response update and update the number to the current max
if @debug = 1
	print 'Get the last ORDERS row used in a response update and update the number to the current max'
execute asi_GetOrderResponseStart @userKey, @firstOrderNumber output, @lastOrderNumber output
if @debug = 1
	print 'First Order: ' + convert(varchar(10),@firstOrderNumber) +'; Last Order:' + convert(varchar(10),@lastOrderNumber)

-- HACK-- this must be removed to prevent duplicate responses 
--select @firstOrderNumber = 0,@lastOrderNumber = 10000,@firstTransNumber=0,@lastTransNumber =100000
-- END HACK

set @now = getdate()
if exists (select * from tempdb..sysobjects where id = OBJECT_ID(N'tempdb..#tmpResponse'))
   drop table #tmpResponse
create table #tmpResponse(
 SourceTable char(1),
 TransNumber int, 
 LineSub decimal(18,4),
 TransDate datetime, 
 Id varchar(10), 
 UserKey uniqueidentifier,
 ProductCode varchar(31),
 SourceCode varchar(60), 
 TotalRevenue decimal(18,4),
 WasSolicited tinyint not null default 1,
 InvoiceReferenceNum int default -1)
 
-- Dues Trans records with matching source code
-- bp 6/6/05 - We want to recognize separate responses for separate source codes, even
-- 	if trans number is the same, so add t.SOURCE_CODE to 'group by' clause
if @debug = 1
	print 'Due Trans records with matching source code'
insert #tmpResponse(SourceTable, TransNumber, SourceCode, Id, TransDate)
select  'D', t.TRANS_NUMBER, min(t.SOURCE_CODE), max(t.BT_ID), min(t.TRANSACTION_DATE)
 from Trans t
  inner join SourceCode sg on t.SOURCE_CODE = sg.Code
 where t.TRANS_NUMBER > @firstTransNumber and t.TRANS_NUMBER <= @lastTransNumber
   and t.TRANSACTION_TYPE = 'DIST'
   and t.SOURCE_SYSTEM in ('DUES','SC')
   and t.JOURNAL_TYPE = 'PAY'
   and t.SOURCE_CODE > ' ' and t.SOURCE_CODE <> 'WEB'
   and sg.SourceCodeStatusCode = 0 -- 0 is Active
 group by t.TRANS_NUMBER, t.SOURCE_CODE
-- FR Trans records with matching source code
if @debug = 1
	print 'FR Trans records with matching source code'
insert #tmpResponse(SourceTable, TransNumber, SourceCode, Id, TransDate)
select  'T', t.TRANS_NUMBER, min(t.SOURCE_CODE), max(t.BT_ID), min(t.TRANSACTION_DATE)
 from Trans t
	inner join SourceCode sg on t.SOURCE_CODE = sg.Code
 where t.TRANS_NUMBER > @firstTransNumber and t.TRANS_NUMBER <= @lastTransNumber
   and t.TRANSACTION_TYPE = 'DIST'
   and t.SOURCE_SYSTEM = 'FR'
   and t.JOURNAL_TYPE = 'IN'
   and t.SOURCE_CODE > ' ' and t.SOURCE_CODE <> 'WEB'
   and sg.SourceCodeStatusCode = 0 -- 0 is Active
 group by t.TRANS_NUMBER
 if @debug = 1
	print'Meeting Trans records with matching source code'
-- Meeting Trans records with matching source code
-- DT16091 - Include INVOICE_REFERENCE_NUM in #tmpResponse. We'll need this to filter out
-- past responses to the same event, and to filter out duplicate responses to the same event.
insert #tmpResponse(SourceTable, TransNumber, SourceCode, Id, TransDate, InvoiceReferenceNum)
select  'T', t.TRANS_NUMBER, t.SOURCE_CODE, max(t.BT_ID), min(t.TRANSACTION_DATE), t.INVOICE_REFERENCE_NUM
 from Trans t
 inner join SourceCode sg on t.SOURCE_CODE = sg.Code
where t.TRANS_NUMBER > @firstTransNumber and t.TRANS_NUMBER <= @lastTransNumber
   and t.TRANSACTION_TYPE = 'DIST'
   and t.SOURCE_SYSTEM = 'MEETING'
   and t.JOURNAL_TYPE = 'IN'
   and t.SOURCE_CODE > ' ' and t.SOURCE_CODE <> 'WEB'
   and sg.SourceCodeStatusCode = 0 -- 0 is Active
 group by t.TRANS_NUMBER, t.SOURCE_CODE, t.INVOICE_REFERENCE_NUM
 if @debug = 1
	print 'Orders and Expo transactions with matching source code'
--Orders and Expo transactions with matching source code
insert #tmpResponse(SourceTable, TransNumber, SourceCode, Id, TransDate, TotalRevenue)
select  'O', o.ORDER_NUMBER, o.SOURCE_CODE, o.BT_ID, o.ORDER_DATE, o.LINE_TOTAL
 from Orders o
  inner join SourceCode sg on o.SOURCE_CODE = sg.Code 
where ORDER_NUMBER > @firstOrderNumber and ORDER_NUMBER <= @lastOrderNumber
   and o.SOURCE_CODE > ' ' and o.SOURCE_CODE <> 'WEB'
   and sg.SourceCodeStatusCode = 0 -- 0 is Active
   -- bp 6/6/05 - Meetings tranactions will be handled separately
   and o.SOURCE_SYSTEM <> 'MEETING'
   -- Don't include premium donation orders
   and not exists(select 1 from Donation_Premium where ORDER_NUMBER = o.ORDER_NUMBER)
   and (o.SOURCE_CODE IN (SELECT Code from SourceCode where SourceCodeStatusCode=0))	
if @useImplicit = 1
begin
if @debug = 1
	print 'Dues Trans records with matching product and no explicit source code'
--Dues Trans records with matching product and no explicit source code
insert #tmpResponse(SourceTable, TransNumber, LineSub, ProductCode, Id, TransDate)
select distinct 'D', t.TRANS_NUMBER, (t.LINE_NUMBER + t.SUB_LINE_NUMBER / 1000), t.PRODUCT_CODE, t.BT_ID, t.TRANSACTION_DATE
 from Trans t
  inner join AppealProduct ap on t.PRODUCT_CODE = ap.ProductCode
  inner join AppealMain am on ap.AppealKey = am.AppealKey
 where t.TRANS_NUMBER > @firstTransNumber and t.TRANS_NUMBER <= @lastTransNumber
   and t.TRANSACTION_TYPE = 'DIST'
   and t.SOURCE_SYSTEM in ('DUES','SC')
   and t.JOURNAL_TYPE = 'PAY'
   and (t.SOURCE_CODE = '' or t.SOURCE_CODE = 'WEB')
   and am.AppealStatusCode = 0 -- 0 is Active
   and not exists(select 1 from #tmpResponse where TransNumber = t.TRANS_NUMBER and LineSub is null and SourceTable = 'T')
--Keep only the lowest Line/SubLine for each transaction number
delete tr
 from #tmpResponse tr
 where (SourceTable = 'T' or SourceTable = 'D')
   and LineSub >  (select min(LineSub)
      from #tmpResponse
      where TransNumber = tr.TransNumber
        and (SourceTable = 'T' or SourceTable = 'D'))
--FR Trans records with matching product and no explicit source code
if @debug = 1
	print 'FR Trans records with matching product and no explicit source code'
insert #tmpResponse(SourceTable, TransNumber, LineSub, ProductCode, Id, TransDate)
select distinct 'T', t.TRANS_NUMBER, (t.LINE_NUMBER + t.SUB_LINE_NUMBER / 1000), t.PRODUCT_CODE, t.BT_ID, t.TRANSACTION_DATE
 from Trans t
  inner join AppealProduct ap on t.PRODUCT_CODE = ap.ProductCode
  inner join AppealMain am on ap.AppealKey = am.AppealKey
 where t.TRANS_NUMBER > @firstTransNumber and t.TRANS_NUMBER <= @lastTransNumber
   and t.TRANSACTION_TYPE = 'DIST'
   and t.SOURCE_SYSTEM = 'FR'
   and t.JOURNAL_TYPE = 'IN'
   and (t.SOURCE_CODE = '' or t.SOURCE_CODE = 'WEB')
   and am.AppealStatusCode = 0 -- 0 is Active
   and not exists(select 1 from #tmpResponse where TransNumber = t.TRANS_NUMBER and LineSub is null and SourceTable = 'T')
--Keep only the lowest Line/SubLine for each transaction number
delete tr
 from #tmpResponse tr
 where SourceTable = 'T'
   and LineSub >  (select min(LineSub)
      from #tmpResponse
      where TransNumber = tr.TransNumber
        and SourceTable = 'T')
 
--Meeting Trans records with matching product and no explicit source code
if @debug = 1
	print 'Meeting Trans records with matching product and no explicit source code'
insert #tmpResponse(SourceTable, TransNumber, LineSub, ProductCode, Id, TransDate, InvoiceReferenceNum)
select distinct 'T', t.TRANS_NUMBER, (t.LINE_NUMBER + t.SUB_LINE_NUMBER / 1000), t.PRODUCT_CODE, t.BT_ID, t.TRANSACTION_DATE,
	t.INVOICE_REFERENCE_NUM
 from Trans t
  inner join AppealProduct ap on t.PRODUCT_CODE = ap.ProductCode
  inner join AppealMain am on ap.AppealKey = am.AppealKey
 where t.TRANS_NUMBER > @firstTransNumber and t.TRANS_NUMBER <= @lastTransNumber
   and t.TRANSACTION_TYPE = 'DIST'
   and t.SOURCE_SYSTEM = 'MEETING'
   and t.JOURNAL_TYPE = 'IN'
   and (t.SOURCE_CODE = '' or t.SOURCE_CODE = 'WEB')
   and am.AppealStatusCode = 0 -- 0 is Active
   and not exists(select 1 from #tmpResponse where TransNumber = t.TRANS_NUMBER and LineSub is null and SourceTable = 'T')
--Keep only the lowest Line/SubLine for each transaction number
delete tr
 from #tmpResponse tr
 where SourceTable = 'T'
   and LineSub >  (select min(LineSub)
      from #tmpResponse
      where TransNumber = tr.TransNumber
        and SourceTable = 'T')
 if @debug = 1
	print 'Order and Expo transactions with matching products and no explicit source code'
--Order and Expo transactions with matching products and no explicit source code
insert #tmpResponse(SourceTable, TransNumber, LineSub, ProductCode, Id, TransDate, TotalRevenue)
select distinct 'O', ol.ORDER_NUMBER, ol.LINE_NUMBER, ol.PRODUCT_CODE, o.BT_ID, o.ORDER_DATE, o.LINE_TOTAL
 from Orders o
  inner join Order_Lines ol on o.ORDER_NUMBER = ol.ORDER_NUMBER
  inner join AppealProduct ap on ol.PRODUCT_CODE = ap.ProductCode
  inner join AppealMain am on ap.AppealKey = am.AppealKey
 where o.ORDER_NUMBER > @firstOrderNumber and o.ORDER_NUMBER <= @lastOrderNumber
   and (o.SOURCE_CODE = '' or o.SOURCE_CODE = 'WEB')
   and am.AppealStatusCode = 0 -- 0 is Active
   -- bp 6/6/05 - Meetings tranactions will be handled separately
   and o.SOURCE_SYSTEM <> 'MEETING'
   and not exists(select 1 from #tmpResponse where TransNumber = o.ORDER_NUMBER and LineSub is null and SourceTable = 'O')
   -- Don't include premium donation orders
   and not exists(select 1 from Donation_Premium where ORDER_NUMBER = o.ORDER_NUMBER)
--Keep only the lowest Line for each order number
delete tr
 from #tmpResponse tr
 where SourceTable = 'O'
   and LineSub >  (select min(LineSub)
      from #tmpResponse
      where TransNumber = tr.TransNumber
        and SourceTable = 'O')
end
if @debug = 1
	print 'Set the UserKey value'
--Set the UserKey value
-- EO 09-20-06 Unified Login changed this from UserMain to ContactMain
update tr
 set UserKey = cm.ContactKey
 from #tmpResponse tr
  inner join ContactMain cm on tr.Id = cm.SyncContactID

-- Treat 'WEB' SourceCode as we would if no SourceCode was entered
update #tmpResponse
 set SourceCode = null
 where SourceCode = 'WEB'
 
if @debug = 1
	print 'Attempt to find a match using the product and user'
--Attempt to find a match using the product and user
update tr
 set SourceCode =   (select top 1 sc.Code
       from AppealProduct ap
        inner join vBoSolicitation s on ap.AppealKey = s.AppealKey
        inner join vBoSourceCode sc on s.SolicitationKey = sc.SolicitationKey
       where ap.ProductCode = tr.ProductCode
         and exists( select 1
           from ListItem
           where ListKey = sc.SourceCodeKey
             and ObjectKey = tr.UserKey)
	 and sc.LastDropDate = (select max(sc2.LastDropDate)
		from 	AppealProduct ap2
		inner join vBoSolicitation s2 on ap2.AppealKey = s2.AppealKey
		inner join vBoSourceCode sc2 on s2.SolicitationKey = sc2.SolicitationKey
		where 	ap2.ProductCode = tr.ProductCode))
 from #tmpResponse tr
 where tr.SourceCode is null

if @debug = 1
	print 'Attempt to find a match just using the product'
--Attempt to find a match just using the product
-- use  the SourceCode with the Latest Drop Doate
update	tr
 set 	SourceCode =   (select 	top 1 sc.Code
 	from 	AppealProduct ap
	  inner join vBoSolicitation s on ap.AppealKey = s.AppealKey
	  inner join vBoSourceCode sc on s.SolicitationKey = sc.SolicitationKey
	where 	ap.ProductCode = tr.ProductCode
	 -- E0 09-21-06 
	 -- I'm not sure how the following ever worked      
	/*and  sc.LastDropDate = (select max(sc2.LastDropDate)
		from 	AppealProduct ap2
		inner join vBoSolicitation s2 on ap2.AppealKey = s2.AppealKey
		inner join vBoSourceCode sc2 on s2.SolicitationKey = sc2.SolicitationKey
		where 	ap2.ProductCode = tr.ProductCode)*/
	-- changing it to this
	order by sc.LastDropDate
),
	WasSolicited = 0
 from #tmpResponse tr
 where tr.SourceCode is null
if @debug = 1
	print 'Remove records without a source code'
--Remove records without a source code
delete #tmpResponse
 where SourceCode is null
 print 'Calculate revenue on records that originated from Trans (non-Dues)'
--Calculate revenue on records that originated from Trans (non-Dues)
update #tmpResponse
 set TotalRevenue = (select  sum(ISNULL(INVOICE_CHARGES, 0))
       from Trans
       -- DT16015 - If source code is explicitly associated with the Trans entry, make sure revenue
       --  is not attributed to another source code
       where TRANS_NUMBER = #tmpResponse.TransNumber and (SOURCE_CODE = #tmpResponse.SourceCode))
 where SourceTable = 'T'
if @debug = 1
	print 'Calculate revenue on records that originated from Trans (Dues)'
--Calculate revenue on records that originated from Trans (Dues)
-- BP 6/9/05 - When calculating revenue, group Trans lines based on
--	       TRANS_NUMBER and SOURCE_CODE 
-- BP 9/29/05 - DT 14640 - When calculating revenue, rather than using ABS(), multiply by -1, so negative payments are treated as negative revenue.
update #tmpResponse
 set TotalRevenue = (select  (sum(AMOUNT))*-1
       from Trans
       where TRANS_NUMBER = #tmpResponse.TransNumber and (SOURCE_CODE = #tmpResponse.SourceCode or SOURCE_CODE = '')
	 and TRANSACTION_TYPE='DIST' and SOURCE_SYSTEM in ('DUES','SC') and JOURNAL_TYPE='PAY')
 where SourceTable = 'D'

if exists (select * from tempdb..sysobjects where id = OBJECT_ID(N'tempdb..#bySourceCode'))
   drop table #bySourceCode
create table #bySourceCode(SourceCode nvarchar(60), TotalRevenue decimal(18,4), FirstResponse datetime, LastResponse datetime, LowResponse decimal(18,4), HighResponse decimal(18,4), TotalResponses int)
 
-- BP 9/30/05 Modify source code aggregation so negative revenue rows are handled properly

--Aggregate the responses by source code

-- When calculating TotalRevenue we want to include negative revenue responses
if @debug = 1
	print 'Aggregate the responses by source code'
insert #bySourceCode
select SourceCode, 
	sum(ISNULL(TotalRevenue, 0)), -- TotalRevenue
	null, -- FirstResponse
	null, -- LastResponse
	null, -- LowResponse
	null, -- HighResponse
	0  -- TotalResponses
 from #tmpResponse 
 group by SourceCode

-- BP 9/30/05 Remove negative revenue responses so that they aren't seen as responses
-- when calculating FirstResponse, LastResponse, LowResponse HighResponse, and TotalResponses
-- and creating/updating campaign and appeal participation records
if @debug = 1
	print 'Remove negative revenue responses so that they aren''t seen as responses'
delete #tmpResponse where TotalRevenue<0

update #bySourceCode 
	set 
	FirstResponse = 
		(select min(TransDate) 
			from #tmpResponse 
			where #tmpResponse.SourceCode=#bySourceCode.SourceCode),
	LastResponse = 
		(select max(TransDate) 
			from #tmpResponse 
			where #tmpResponse.SourceCode=#bySourceCode.SourceCode),
	LowResponse = 
		(select min(TotalRevenue) 
			from #tmpResponse 
			where #tmpResponse.SourceCode=#bySourceCode.SourceCode),
	HighResponse = 
		(select max(TotalRevenue) 
			from #tmpResponse 
			where #tmpResponse.SourceCode=#bySourceCode.SourceCode)
		from #bySourceCode, #tmpResponse

-- BP 11/14/05 DT 16091
-- When calculating TotalResponses we don't want to include past responses to 
-- the same event by the same contact for the same SourceCode. Also, for multiple registrations to the same
-- event by the same contact for the same SourceCode, we want to count as one response.
--
-- Remove past responses
if @debug = 1
	print 'Remove past responses'
delete #tmpResponse where 
	exists (
		select * from Trans where INVOICE_REFERENCE_NUM = #tmpResponse.InvoiceReferenceNum and
			SOURCE_CODE = #tmpResponse.SourceCode and
			TRANS_NUMBER <= @firstTransNumber)
-- Calculate TotalResponses. Entries with the same InvoiceReferenceNum should
-- be grouped together and only count as one response. Entries with 
-- InvoiceReferenceNum = -1 are each counted as a response.
update #bySourceCode 
	set 
	TotalResponses = 
		(select count(distinct InvoiceReferenceNum)
			from #tmpResponse 
			where #tmpResponse.SourceCode=#bySourceCode.SourceCode and InvoiceReferenceNum<>-1)
		 +
		 (select count(*)
			from #tmpResponse 
			where #tmpResponse.SourceCode=#bySourceCode.SourceCode and InvoiceReferenceNum=-1)
	from #bySourceCode, #tmpResponse

if exists (select * from tempdb..sysobjects where id = OBJECT_ID(N'tempdb..#byAppeal'))
   drop table #byAppeal
create table #byAppeal(CampaignKey uniqueidentifier, AppealKey uniqueidentifier, SolicitationKey uniqueidentifier, SolicitationGroupKey uniqueidentifier, UserKey uniqueidentifier, WasSolicited tinyint)
 if @debug = 1
	print 'Aggregate the responses by appeal and user'
--Aggregate the responses by appeal and user
insert #byAppeal
select distinct c.CampaignKey, a.AppealKey, s.SolicitationKey, sc.SourceCodeKey,  tr.UserKey, tr.WasSolicited
 from #tmpResponse tr
  inner join vBoSourceCode sc on tr.SourceCode = sc.Code
  inner join vBoSolicitation s on sc.SolicitationKey = s.SolicitationKey
  inner join vBoAppeal a on s.AppealKey = a.AppealKey
  inner join vBoCampaign c on a.CampaignKey = c.CampaignKey
 
--Allow only one record per Appeal and User combination
set rowcount 1
 
declare @appealKey uniqueidentifier
declare @campaignKey uniqueidentifier
declare @respondentUserKey uniqueidentifier
 
select @appealKey = AppealKey, @campaignKey = CampaignKey, @respondentUserKey = UserKey
 from #byAppeal
 group by CampaignKey, AppealKey, UserKey
 having count(*) > 1
while @@ROWCOUNT > 0
begin
 delete #byAppeal
  where AppealKey = @appealKey
    and CampaignKey = @campaignKey
    and UserKey = @respondentUserKey
 select @appealKey = AppealKey, @campaignKey = CampaignKey, @respondentUserKey = UserKey
  from #byAppeal
  group by CampaignKey, AppealKey, UserKey
  having count(*) > 1
end
 
set rowcount 0
 
begin transaction
 
--Update SourceCode
if @debug = 1
	print 'Update SourceCOde'

update sg
 set TotalRevenue = sg.TotalRevenue + bsc.TotalRevenue,
  FirstResponseDate = 	case
  				when sg.FirstResponseDate is NULL then bsc.FirstResponse 
				when bsc.FirstResponse is NULL then sg.FirstResponseDate
  				when bsc.FirstResponse < sg.FirstResponseDate then bsc.FirstResponse 
  				else sg.FirstResponseDate end,
  LastResponseDate = 	case
  				when sg.LastResponseDate is NULL then bsc.LastResponse 
				when bsc.LastResponse is NULL then sg.LastResponseDate
  				when bsc.LastResponse > sg.LastResponseDate then bsc.LastResponse 
  				else sg.LastResponseDate end,
  LowResponseAmount = 	case
  				when sg.LowResponseAmount < 0 then bsc.LowResponse 
				when bsc.LowResponse < 0 then sg.LowResponseAmount
  				when bsc.LowResponse < sg.LowResponseAmount then bsc.LowResponse   							
				else sg.LowResponseAmount end,
  HighResponseAmount = case 
				when bsc.HighResponse > sg.HighResponseAmount then bsc.HighResponse 
				else sg.HighResponseAmount end,
  TotalPositiveResponse = sg.TotalPositiveResponse + bsc.TotalResponses, 
  ResponsesTotalledOn = @now,
  UpdatedOn = @now,
  UpdatedByUserKey = @userKey
 from SourceCode sg
  inner join #bySourceCode bsc on sg.Code = bsc.SourceCode

-- DT 16091 - Don't attempt to create appeal or campaign participation entries if the User is unknown. This can happen when a new contact
-- is registered for an event and is not added to the db.
delete from #byAppeal where UserKey is null
--Create campaign opt-in
if @debug = 1
	print 'Create campaign opt-in'
insert CampaignParticipation(CampaignParticipationKey, CampaignKey, RespondentUserKey, ResponseTypeCode, CreatedByUserKey, CreatedOn, UpdatedByUserKey, UpdatedOn)
select newid(), CampaignKey, UserKey, 1, @userKey, @now, @userKey, @now -- UnsolicitedResponse = Opt-In = ResponseStatus of one (1)
 from #byAppeal ba
 where not exists(select 1 from CampaignParticipation where CampaignKey = ba.CampaignKey and RespondentUserKey = ba.UserKey)
 
if @debug = 1
	print 'Update appeal participation'
--Update appeal participation
update ap
 set SolicitationKey = ba.SolicitationKey,
  AppealKey = ba.AppealKey,
  ResponseTypeCode = case when WasSolicited = 1 then 0 else 1 end,
  UpdatedOn = @now,
  UpdatedByUserKey = @userKey
 from AppealParticipation ap
  inner join #byAppeal ba on ap.AppealKey = ba.AppealKey and ap.RespondentUserKey = ba.UserKey
if @debug = 1
	print 'Create appeal participation'    
--Create appeal participation
insert AppealParticipation(AppealParticipationKey, AppealKey, RespondentUserKey, SolicitationKey, ResponseTypeCode, CreatedByUserKey, CreatedOn, UpdatedByUserKey, UpdatedOn,SourceCodeKey)
select newid(), ba.AppealKey, ba.UserKey, ba.SolicitationKey, case when WasSolicited = 1 then 0 else 1 end, @userKey, @now, @userKey, @now,SolicitationGroupKey --SolicitedResponse = Responded = ResponseStatus of zero (0)
 from #byAppeal ba
 --INNER JOIN SourceCode SC ON SC.Code = ba.SourceCode
 where not exists(select 1 from AppealParticipation where AppealKey = ba.AppealKey and RespondentUserKey = ba.UserKey)
 
commit transaction

if exists (select * from tempdb..sysobjects where id = OBJECT_ID(N'tempdb..#byAppeal'))
   drop table #byAppeal
if exists (select * from tempdb..sysobjects where id = OBJECT_ID(N'tempdb..#bySourceCode'))
   drop table #bySourceCode
if exists (select * from tempdb..sysobjects where id = OBJECT_ID(N'tempdb..#tmpResponse'))
   drop table #tmpResponse

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentGetLatestKey]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentGetLatestKey]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- gets the "latest" document key given a DocumentKey or a DocumentVersionKey.  If key is DocumentKey
-- that same DocumentKey is returned.  If key is a DocumentVersionKey, returns the DocumentKey of the
-- document with the lowest status (e.g., prefers working over published, published over archived, etc.)
-- and the most recent date
CREATE PROCEDURE [dbo].[asi_DocumentGetLatestKey] 
    @key uniqueidentifier, 
    @documentKey uniqueidentifier OUT 
AS
BEGIN
   SELECT TOP 1 @documentKey = DocumentKey
     FROM DocumentMain
    WHERE DocumentKey = @key OR DocumentVersionKey = @key
    ORDER BY DocumentStatusCode ASC, UpdatedOn DESC
END


GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_HierarchyResort2]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_HierarchyResort2]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- Resets the SortOrder column on all records within a given Root Hierarchy so that each is a multiple
-- of 2048.  This allows for 12 worst case inserts before a resort is needed.
CREATE PROCEDURE [dbo].[asi_HierarchyResort2] @rootHierarchyKey uniqueidentifier 
AS
BEGIN
    DECLARE @NewSortOrder int
    DECLARE @RootHierarchyKeyVal uniqueidentifier

    SET NOCOUNT ON

    DECLARE @hierarchy TABLE (HierarchyKey uniqueidentifier, OldSortOrder int, NewSortOrder int IDENTITY(2048, 2048))

    INSERT INTO @hierarchy (HierarchyKey, OldSortOrder)
        SELECT HierarchyKey, SortOrder
          FROM Hierarchy
         WHERE RootHierarchyKey = @rootHierarchyKey
      ORDER BY SortOrder

    UPDATE h
       SET h.[SortOrder] = h2.[NewSortOrder]
      FROM [dbo].[Hierarchy] h INNER JOIN @hierarchy h2 ON h.[HierarchyKey] = h2.[HierarchyKey]
     WHERE h.[SortOrder] = h2.[OldSortOrder]
        

    SET NOCOUNT OFF
END
GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_HierarchyGetFolderSortOut]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_HierarchyGetFolderSortOut]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


-- Given the HierarchyKey of the parent folder, gets a sort order that will put the new folder in alphabetical order.
-- if the parent folder does not exist in the db (i.e., it is only in memory at this point) rootHierarchyKey and
-- parentFolderSortOrder will be used to determine the new sort order.
CREATE PROCEDURE [dbo].[asi_HierarchyGetFolderSortOut] 
   @parentFolderHierarchyKey uniqueidentifier, 
   @rootHierarchyKey uniqueidentifier, 
   @parentFolderSortOrder int, 
   @parentFolderDepth int,
   @newFolderName nvarchar(100), 
   @newSort int OUTPUT 
AS
BEGIN
    DECLARE @lowSort int
    DECLARE @highSort int
    DECLARE @lowDocumentName nvarchar(100)
    DECLARE @Run int

    SET @Run = 0
    WHILE @Run < 2
    BEGIN
        -- find the top end of the sort range.  Which is from the next folder up in the tree from where we want to be
        SELECT @highSort = Min(SortOrder)
          FROM Hierarchy a INNER JOIN DocumentMain b
            ON a.UniformKey = b.DocumentVersionKey AND b.DocumentStatusCode = 40
         WHERE (a.ParentHierarchyKey = @parentFolderHierarchyKey
           AND b.DocumentName > @newFolderName
           AND b.DocumentTypeCode = 'FOL')
            OR (a.ParentHierarchyKey = @parentFolderHierarchyKey
           AND a.SortOrder > @parentFolderSortOrder
           AND a.Depth <= @parentFolderDepth)

        -- if there is nothing higher (i.e., this is at the very end of the tree), just get the tree's max + 2048
        IF @highSort IS NULL
            SELECT @highSort = IsNull(Max(SortOrder),0) + 2048
              FROM Hierarchy
             WHERE RootHierarchyKey = @rootHierarchyKey

        -- find the highest sort order below our high.  That will be the low
        SELECT @lowSort = IsNull(Max(SortOrder),0)
          FROM Hierarchy
         WHERE RootHierarchyKey = @rootHierarchyKey
           AND SortOrder < @highSort

        IF @lowSort < @parentFolderSortOrder
        BEGIN
            IF @Run = 0
                SET @lowSort = @parentFolderSortOrder
            ELSE
            BEGIN
                SET @lowSort = @parentFolderSortOrder
                IF @highSort - @lowSort < 2
                    SET @highSort = @lowSort + 2
            END
        END

        -- if there is no room between the low and the high, need to redo the sort order for this root
        IF @highSort - @lowSort < 2
        BEGIN
            EXEC asi_HierarchyResort2 @rootHierarchyKey

            -- get the sort again in case it has changed
            SELECT @parentFolderSortOrder = SortOrder FROM Hierarchy WHERE HierarchyKey = @parentFolderHierarchyKey
            SET @Run = @Run + 1
        END
        ELSE
            SET @Run = 2
    END
    SET @newSort = ((@highSort - @lowSort) / 2) + @lowSort
END



GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentLinkDocumentOut]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentLinkDocumentOut]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- links a document into a folder using the hierarchy.  The FolderHierarchyKey points to the parent folder
CREATE PROCEDURE [dbo].[asi_DocumentLinkDocumentOut]
   @folderHierarchyKey uniqueidentifier,
   @documentVersionKey uniqueidentifier,
   @hierarchyKey uniqueidentifier OUTPUT
AS
DECLARE 
   @sortOrder int,
   @documentTypeCode nvarchar(3),
   @documentName nvarchar(100),
   @rootHierarchyKey uniqueidentifier,
   @parentFolderSortOrder int,
   @parentFolderDepth int
BEGIN
   -- first check to see if such a link already exists, if not, then build it
   SELECT @hierarchyKey = HierarchyKey
     FROM Hierarchy
    WHERE ParentHierarchyKey = @folderHierarchyKey
      AND UniformKey = @documentVersionKey

   IF @hierarchyKey IS NULL
   BEGIN
      SET @sortOrder = null
      SET @hierarchyKey = NewID()

      -- see if the doc to be linked is a folder.  If so, it needs a new sort order
      SELECT TOP 1 @documentTypeCode = DocumentTypeCode,
             @documentName = DocumentName
        FROM DocumentMain
       WHERE DocumentVersionKey = @documentVersionKey
       ORDER BY UpdatedOn DESC

      IF @documentTypeCode IN ('FOL','CFL','NAV')
      BEGIN
         SELECT @rootHierarchyKey = RootHierarchyKey,
                @parentFolderSortOrder = SortOrder,
                @parentFolderDepth = Depth
           FROM Hierarchy
          WHERE HierarchyKey = @folderHierarchyKey

          exec asi_HierarchyGetFolderSortOut @folderHierarchyKey, @rootHierarchyKey, @parentFolderSortOrder, @parentFolderDepth, @documentName, @sortOrder OUT
      END

      INSERT INTO Hierarchy (
             HierarchyKey, 
             RootHierarchyKey, 
             ParentHierarchyKey, 
             SortOrder, 
             Depth, 
             UniformType,
             UniformKey,
             IsChildAMemberOfParent)
      SELECT @hierarchyKey,
             RootHierarchyKey,
             HierarchyKey, 
             ISNULL(@sortOrder,SortOrder), 
             Depth + 1, 
             UniformType,
             @documentVersionKey,
             IsChildAMemberOfParent
        FROM Hierarchy
       WHERE HierarchyKey = @folderHierarchyKey

      IF @@ROWCOUNT = 0
         SET @hierarchyKey = NULL
   END
END


GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentLinkDocument]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentLinkDocument]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- links a document into a folder using the hierarchy.  The FolderHierarchyKey points to the parent folder
CREATE PROCEDURE [dbo].[asi_DocumentLinkDocument]
   @folderHierarchyKey uniqueidentifier,
   @documentVersionKey uniqueidentifier
AS
DECLARE 
   @hierarchyKey uniqueidentifier
BEGIN
   exec asi_DocumentLinkDocumentOut @folderHierarchyKey, @documentVersionKey, @hierarchyKey output
   -- return the key found or created
   SELECT @hierarchyKey AS HierarchyKey
END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentCreateCopy]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentCreateCopy]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- creates a copy of the document given by key in the folder given by FolderHierarchyKey
-- Key can be either a DocumentKey or a DocumentVersionKey.  If the latter, copies the 
-- latest version available
-- IsSystem is defaulted to false when creating a copy even if copying an IsSystem=true item.
CREATE PROCEDURE [dbo].[asi_DocumentCreateCopy]
    @folderHierarchyKey uniqueidentifier,
    @key uniqueidentifier,
    @userKey uniqueidentifier,
    @loggedInUserGroupKey uniqueidentifier = '00000000-0000-0000-0000-000000000000', -- if this is empty, we assume the user is not logged in
    @documentName nvarchar(100) = null
AS
BEGIN
    DECLARE @newDocumentKey uniqueidentifier;
    DECLARE @newDocumentVersionKey uniqueidentifier;
    DECLARE @newAccessKey uniqueidentifier;
    DECLARE @documentKey uniqueidentifier
    DECLARE @accessKey uniqueidentifier;
    DECLARE @now datetime;

    SET @now = GETDATE();
    SET @newDocumentKey = NEWID();
    SET @newDocumentVersionKey = NEWID();

    -- create the UniformRegistry entry first
    INSERT INTO UniformRegistry (UniformKey, ComponentKey)
        SELECT @newDocumentKey, ComponentKey
          FROM ComponentRegistry
         WHERE Name = N'Document'
           AND InterfaceName = N'BusinessController';

    -- then the UniformRegistry entry for the version key
    INSERT INTO UniformRegistry (UniformKey, ComponentKey)
        SELECT @newDocumentVersionKey, ComponentKey
          FROM ComponentRegistry
         WHERE Name = N'DocumentVersion'
           AND InterfaceName = N'BusinessController';

    -- get the latest document key
    EXEC dbo.asi_DocumentGetLatestKey @key, @documentKey OUT;

    -- copy the AccessKeys if necessary
    SELECT @accessKey = [AccessKey] FROM [dbo].[DocumentMain] WHERE [DocumentKey] = @documentKey;
    SET @newAccessKey = @accessKey;
    IF EXISTS (SELECT 1 FROM [dbo].[AccessMain] WHERE [AccessKey] = @accessKey AND [AccessScope] = N'Local') 
    BEGIN
        -- We have custom/local security, so we need to copy the access keys first before copying the document
        SET @newAccessKey = NEWID();
        -- Copy the AccessMain Row
        INSERT INTO [dbo].[AccessMain] (AccessKey, AccessScope, CreatedByUserKey, CreatedOn, UpdatedByUserKey, UpdatedOn)
            SELECT @newAccessKey, [AccessScope], @userKey, @now, @userKey, @now 
              FROM [dbo].[AccessMain] WHERE [AccessKey] = @accessKey;
        -- Copy all AccessItem Rows
        INSERT INTO [dbo].[AccessItem] (AccessKey, Grantee, Permission, GroupKey, RoleKey, UserKey)
            SELECT @newAccessKey, [Grantee], [Permission], [GroupKey], [RoleKey], [UserKey] 
              FROM [dbo].[AccessItem] WHERE [AccessKey] = @accessKey;
    END

    -- then create the copy
    INSERT INTO [dbo].[DocumentMain] (
          DocumentKey,
          DocumentTypeCode,
          DocumentName,
          DocumentVersionKey,
          DocumentStatusCode,
          DocumentCode,
          AlternateName,
          Blob,
          IsSystem,
          AccessKey,
          DefaultChildAccessKey,
          DocumentDescription,
          ContainsChildrenFlag,
          BranchedFromDocumentKey,
          RelatedDocumentVersionKey,
          StatusUpdatedByUserKey,
          StatusUpdatedOn,
          UpdatedByUserKey,
          UpdatedOn,
          CreatedByUserKey,
          CreatedOn)
    SELECT @newDocumentKey,
          a.DocumentTypeCode,
          ISNULL(@documentName, a.DocumentName),
          @newDocumentVersionKey,
          CASE b.TrackVersionsFlag WHEN 0 THEN 40 ELSE 10 END,
          a.DocumentCode,
          a.AlternateName,
          a.Blob,
          0, -- a.IsSystem, -- Creating a copy of a system item should not be automatically set to IsSystem=true
          @newAccessKey,
          a.DefaultChildAccessKey,
          a.DocumentDescription,
          a.ContainsChildrenFlag,
          a.DocumentKey,
          a.RelatedDocumentVersionKey,
          @userKey,
          @now,
          @userKey,
          @now,
          @userKey,
          @now
     FROM [dbo].[DocumentMain] a 
          INNER JOIN [dbo].[DocumentTypeRef] b ON a.[DocumentTypeCode] = b.[DocumentTypeCode]
    WHERE a.DocumentKey = @documentKey
      AND EXISTS(
          SELECT 1 
            FROM AccessItem INNER JOIN UserToken ON AccessItem.Grantee = UserToken.Grantee OR AccessItem.Grantee = @loggedInUserGroupKey
           WHERE AccessItem.AccessKey = a.AccessKey 
             AND UserToken.UserKey = @userKey 
             AND (AccessItem.Permission&3)>0)

    -- link the new copy into the specified folder
    EXEC dbo.asi_DocumentLinkDocument @folderHierarchyKey, @newDocumentVersionKey
END



GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentCreateCopyWithAlternateName]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentCreateCopyWithAlternateName]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- creates a copy of the document given by key in the folder given by FolderHierarchyKey
-- Key can be either a DocumentKey or a DocumentVersionKey.  If the latter, copies the 
-- latest version available
-- IsSystem is defaulted to false when creating a copy even if copying an IsSystem=true item.
CREATE PROCEDURE [dbo].[asi_DocumentCreateCopyWithAlternateName]
    @folderHierarchyKey uniqueidentifier,
    @key uniqueidentifier,
    @userKey uniqueidentifier,
    @loggedInUserGroupKey uniqueidentifier = '00000000-0000-0000-0000-000000000000', -- if this is empty, we assume the user is not logged in
    @documentName nvarchar(100) = null,
    @alternateName nvarchar(100) = null
AS
BEGIN
    DECLARE @newDocumentKey uniqueidentifier;
    DECLARE @newDocumentVersionKey uniqueidentifier;
    DECLARE @newAccessKey uniqueidentifier;
    DECLARE @documentKey uniqueidentifier;
    DECLARE @accessKey uniqueidentifier;
    DECLARE @now datetime;

    SET @now = GETDATE();
    SET @newDocumentKey = NEWID();
    SET @newDocumentVersionKey = NEWID();

    -- create the UniformRegistry entry first
    INSERT INTO UniformRegistry (UniformKey, ComponentKey)
        SELECT @newDocumentKey, ComponentKey
          FROM ComponentRegistry
         WHERE Name = N'Document'
           AND InterfaceName = N'BusinessController';

    -- then the UniformRegistry entry for the version key
    INSERT INTO UniformRegistry (UniformKey, ComponentKey)
        SELECT @newDocumentVersionKey, ComponentKey
          FROM ComponentRegistry
         WHERE Name = N'DocumentVersion'
           AND InterfaceName = N'BusinessController';
      
    -- get the latest document key
    EXEC dbo.asi_DocumentGetLatestKey @key, @documentKey OUT;

    -- copy the AccessKeys if necessary
    SELECT @accessKey = [AccessKey] FROM [dbo].[DocumentMain] WHERE [DocumentKey] = @documentKey;
    SET @newAccessKey = @accessKey;
    IF EXISTS (SELECT 1 FROM [dbo].[AccessMain] WHERE [AccessKey] = @accessKey AND [AccessScope] = N'Local') 
    BEGIN
        -- We have custom/local security, so we need to copy the access keys first before copying the document
        SET @newAccessKey = NEWID();
        -- Copy the AccessMain Row
        INSERT INTO [dbo].[AccessMain] (AccessKey, AccessScope, CreatedByUserKey, CreatedOn, UpdatedByUserKey, UpdatedOn)
            SELECT @newAccessKey, [AccessScope], @userKey, @now, @userKey, @now 
              FROM [dbo].[AccessMain] WHERE [AccessKey] = @accessKey;
        -- Copy all AccessItem Rows
        INSERT INTO [dbo].[AccessItem] (AccessKey, Grantee, Permission, GroupKey, RoleKey, UserKey)
            SELECT @newAccessKey, [Grantee], [Permission], [GroupKey], [RoleKey], [UserKey] 
              FROM [dbo].[AccessItem] WHERE [AccessKey] = @accessKey;
    END

    -- then create the copy
    INSERT INTO [dbo].[DocumentMain] (
          DocumentKey,
          DocumentTypeCode,
          DocumentName,
          DocumentVersionKey,
          DocumentStatusCode,
          DocumentCode,
          AlternateName,
          Blob,
          IsSystem,
          AccessKey,
          DefaultChildAccessKey,
          DocumentDescription,
          ContainsChildrenFlag,
          BranchedFromDocumentKey,
          RelatedDocumentVersionKey,
          StatusUpdatedByUserKey,
          StatusUpdatedOn,
          UpdatedByUserKey,
          UpdatedOn,
          CreatedByUserKey,
          CreatedOn)
    SELECT @newDocumentKey,
          a.DocumentTypeCode,
          ISNULL(@documentName, a.DocumentName),
          @newDocumentVersionKey,
          CASE b.TrackVersionsFlag WHEN 0 THEN 40 ELSE 10 END,
          a.DocumentCode,
          ISNULL(@alternateName, a.AlternateName),
          a.Blob,
          0, -- a.IsSystem, -- Creating a copy of a system item should not be automatically set to IsSystem=true
          @newAccessKey,
          a.DefaultChildAccessKey,
          a.DocumentDescription,
          a.ContainsChildrenFlag,
          a.DocumentKey,
          a.RelatedDocumentVersionKey,
          @userKey,
          @now,
          @userKey,
          @now,
          @userKey,
          @now
     FROM [dbo].[DocumentMain] a 
          INNER JOIN [dbo].[DocumentTypeRef] b ON a.[DocumentTypeCode] = b.[DocumentTypeCode]
    WHERE a.DocumentKey = @documentKey
      AND EXISTS(
          SELECT 1 
            FROM AccessItem INNER JOIN UserToken ON AccessItem.Grantee = UserToken.Grantee OR AccessItem.Grantee = @loggedInUserGroupKey
           WHERE AccessItem.AccessKey = a.AccessKey 
             AND UserToken.UserKey = @userKey 
             AND (AccessItem.Permission&3)>0)

    -- link the new copy into the specified folder
    EXEC dbo.asi_DocumentLinkDocument @folderHierarchyKey, @newDocumentVersionKey
END



GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentCreateShortcut]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentCreateShortcut]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- creates a shortcut to the document given by DocumentVersionKey
-- in the folder given by FolderHierarchyKey
CREATE PROCEDURE [dbo].[asi_DocumentCreateShortcut]
   @folderHierarchyKey uniqueidentifier,
   @documentVersionKey uniqueidentifier,
   @userKey uniqueidentifier
AS
BEGIN
   DECLARE @newDocumentKey uniqueidentifier, @newDocumentVersionKey uniqueidentifier, @documentKey uniqueidentifier

   SET @newDocumentKey = NewID()
   SET @newDocumentVersionKey = NewID()

   -- create the UniformRegistry entry first
   INSERT INTO UniformRegistry (UniformKey, ComponentKey)
   SELECT @newDocumentKey, ComponentKey
     FROM ComponentRegistry
    WHERE Name = 'Document'
      AND InterfaceName = 'BusinessController'

   -- then the UniformRegistry entry for the version key
   INSERT INTO UniformRegistry (UniformKey, ComponentKey)
   SELECT @newDocumentVersionKey, ComponentKey
     FROM ComponentRegistry
    WHERE Name = 'DocumentVersion'
      AND InterfaceName = 'BusinessController'

   -- make sure we get the latest one to shortcut to
   EXEC asi_DocumentGetLatestKey @documentVersionKey, @documentKey OUT

   -- then create the shortcut document
   INSERT INTO DocumentMain (
          DocumentKey,
          DocumentTypeCode,
          DocumentName,
          DocumentVersionKey,
          DocumentStatusCode,
          AlternateName,
          IsSystem,
          AccessKey,
          ContainsChildrenFlag,
          RelatedDocumentVersionKey,
          StatusUpdatedByUserKey,
          StatusUpdatedOn,
          UpdatedByUserKey,
          UpdatedOn,
          CreatedByUserKey,
          CreatedOn)
   SELECT @newDocumentKey,
          'SRT',
          DocumentName,
          @newDocumentVersionKey,
          40,
          AlternateName,
          0,
          AccessKey,
          0,
          @documentVersionKey,
          @userKey,
          GetDate(),
          @userKey,
          GetDate(),
          @userKey,
          GetDate()
     FROM DocumentMain
    WHERE DocumentKey = @documentKey

   -- if it worked, link it in.  If not, return null
   IF @@ROWCOUNT = 1
      exec asi_DocumentLinkDocument @folderHierarchyKey, @newDocumentVersionKey
   ELSE
      SELECT null
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentDeleteDocument]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentDeleteDocument]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- Deletes a document that is either a leaf node in a hierarchy, or a document not participating
-- in a hierarchy (a stand alone document).  This procedure takes into account any custom access
-- control, as well as whether the document is versioned or not.  This Stored Procedure should not
-- be called directly; it is called by asi_DocumentDelete or asi_DocumentDeleteHierarchy.
CREATE PROCEDURE [dbo].[asi_DocumentDeleteDocument] 
    @documentVersionKey uniqueidentifier,
    @purgeVersions bit = 0
AS
BEGIN
    SET NOCOUNT ON
    DECLARE @documentKey uniqueidentifier
    DECLARE @accessKey uniqueidentifier
    DECLARE @isVersioned bit
    DECLARE @publishedVersionExists bit

    SET @publishedVersionExists = 1
    SELECT @documentKey = d.[DocumentKey], @accessKey = d.[AccessKey], @isVersioned = t.[TrackVersionsFlag]
      FROM [dbo].[DocumentMain] d INNER JOIN [dbo].[DocumentTypeRef] t ON d.[DocumentTypeCode] = t.[DocumentTypeCode]
     WHERE d.[DocumentVersionKey] = @documentVersionKey AND d.[DocumentStatusCode] IN (40,60)

    IF @documentKey IS NULL -- Could not find a published version
    BEGIN
        SET @publishedVersionExists = 0
        IF EXISTS (SELECT 1 FROM [dbo].[DocumentMain] d WHERE d.[DocumentVersionKey] = @documentVersionKey)
        BEGIN
            SET @isVersioned = 1
        END
    END

    IF @isVersioned = 1
    BEGIN
        IF @purgeVersions = 0
        BEGIN
            -- Versioned document... just Recycle it
            UPDATE [dbo].[DocumentMain] 
               SET [DocumentStatusCode] = 80,
                   [StatusUpdatedOn] = GETDATE()
             WHERE [DocumentKey] = @documentKey
        END
        ELSE
        BEGIN
            -- Versioned document... purge all versions
            DECLARE @documents TABLE (DocumentKey uniqueidentifier NOT NULL)
            INSERT INTO @documents
                SELECT [DocumentKey] FROM [dbo].[DocumentMain] d WHERE d.[DocumentVersionKey] = @documentVersionKey
                
            DELETE FROM [dbo].[Hierarchy] WHERE [UniformKey] = @documentVersionKey
            DELETE prd FROM @documents d INNER JOIN [dbo].[PublishRequestDetail] prd ON d.[DocumentKey] = prd.[ContentDocumentKey]
            DELETE dm FROM @documents d INNER JOIN [dbo].[DocumentMain] dm ON d.[DocumentKey] = dm.[DocumentKey]
            EXEC [dbo].[asi_AccessKeyDelete] @accessKey
            DELETE FROM [dbo].[UniformTag] WHERE [UniformKey] = @documentVersionKey
            DELETE FROM [dbo].[UniformRegistry] WHERE [UniformKey] = @documentVersionKey
            DELETE u FROM @documents d INNER JOIN [dbo].[UniformRegistry] u ON d.[DocumentKey] = u.[UniformKey]
            DELETE FROM [dbo].[UniformLicense] WHERE [UniformKey] = @documentVersionKey
        END
    END
    ELSE IF @documentKey IS NOT NULL
    BEGIN
        -- Non-versioned document... delete all references
        DELETE FROM [dbo].[Hierarchy] WHERE [UniformKey] = @documentVersionKey
        EXEC [dbo].[asi_AccessKeyDelete] @accessKey
        DELETE FROM [dbo].[PublishRequestDetail] WHERE [ContentDocumentKey] = @documentKey
        DELETE FROM [dbo].[DocumentMain] WHERE [DocumentVersionKey] = @documentVersionKey
        DELETE FROM [dbo].[UniformTag] WHERE [UniformKey] = @documentVersionKey
        DELETE FROM [dbo].[UniformRegistry] WHERE [UniformKey] = @documentKey
        DELETE FROM [dbo].[UniformRegistry] WHERE [UniformKey] = @documentVersionKey
        DELETE FROM [dbo].[UniformLicense] WHERE [UniformKey] = @documentVersionKey
    END
    
    SET NOCOUNT OFF
END


GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentDeleteHierarchy]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentDeleteHierarchy]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- Recursively deletes all children of the specified hierarchy key.  After this function returns,
-- all child documents, along with all associated hierarchy keys, will be deleted, resulting
-- in just a leaf-node, which can then be deleted by asi_DocumentDeleteDocument.
CREATE PROCEDURE [dbo].[asi_DocumentDeleteHierarchy] 
    @hierarchyKey uniqueidentifier,
    @purgeVersions bit = 0
AS
BEGIN
    SET NOCOUNT ON
    DECLARE @ChildrenTable TABLE
    (
        [HierarchyKey] uniqueidentifier,
        [DocumentVersionKey] uniqueidentifier
    )

    INSERT INTO @ChildrenTable
        SELECT h.[HierarchyKey], d.[DocumentVersionKey]
          FROM [dbo].[Hierarchy] h 
               INNER JOIN [dbo].[DocumentMain] d ON h.UniformKey = d.[DocumentVersionKey] 
         WHERE h.[ParentHierarchyKey] = @hierarchyKey

    DECLARE @childHierarchyKey uniqueidentifier
    DECLARE @documentVersionKey uniqueidentifier

    WHILE EXISTS (SELECT 1 FROM @ChildrenTable)
    BEGIN
        SELECT TOP 1 @childHierarchyKey = HierarchyKey, @documentVersionKey = DocumentVersionKey FROM @ChildrenTable
        EXEC [asi_DocumentDeleteHierarchy] @childHierarchyKey, @purgeVersions
        EXEC [asi_DocumentDeleteDocument] @documentVersionKey, @purgeVersions
        DELETE FROM @ChildrenTable WHERE HierarchyKey = @childHierarchyKey
    END
    SET NOCOUNT OFF
END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- Deletes the specified document (and potentially all child documents if the document is involved
-- in a hierarchy).  
CREATE PROCEDURE [dbo].[asi_DocumentDelete] 
    @documentVersionKey uniqueidentifier, 
    @purgeVersions bit = 0
AS
BEGIN
    SET NOCOUNT ON
    DECLARE @hierarchyKey uniqueidentifier

    -- Get the hierarchy key
    SELECT @hierarchyKey = HierarchyKey FROM [dbo].[Hierarchy] 
     WHERE UniformKey = @documentVersionKey

    IF (@hierarchyKey IS NOT NULL)
        EXEC [dbo].[asi_DocumentDeleteHierarchy] @hierarchyKey, @purgeVersions
    EXEC [dbo].[asi_DocumentDeleteDocument] @documentVersionKey, @purgeVersions
    SET NOCOUNT OFF
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentDescendantKeys]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentDescendantKeys]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

/*
Retrieves a list of all of the DocumentVersionKeys for all documents that are descendants of the provided folder key (i.e. its children, children's children, etc).
*/
CREATE PROCEDURE [dbo].[asi_DocumentDescendantKeys]
(
      @hierarchyKey uniqueidentifier,
      @userKey uniqueidentifier,
      @loggedInUserGroupKey uniqueidentifier = '00000000-0000-0000-0000-000000000000', -- if this is empty, we assume the user is not logged in
      @publishedOnly bit = 1,
      @ignoreLicensing bit = 0
)
AS
BEGIN
      DECLARE @descendants TABLE
      (
            [RootHierarchyKey] uniqueidentifier,
            [HierarchyKey] uniqueidentifier,
            [DocumentVersionKey] uniqueidentifier,
            [DocumentKey] uniqueidentifier,
            [AccessKey] uniqueidentifier
      )

      INSERT INTO @descendants
      SELECT h.[RootHierarchyKey], h.[HierarchyKey], d.[DocumentVersionKey], d.[DocumentKey], d.[AccessKey]
      FROM [Hierarchy] h
            INNER JOIN [DocumentMain] d ON h.[UniformKey] = d.[DocumentVersionKey]
      WHERE h.[ParentHierarchyKey] = @hierarchyKey
            AND ((@publishedOnly = 1 AND d.[DocumentStatusCode] IN (40,60)) OR
                     (@publishedOnly = 0 AND d.DocumentKey IN (SELECT TOP 1 [DocumentKey] FROM [DocumentMain] WHERE [DocumentVersionKey] = d.[DocumentVersionKey] AND [DocumentStatusCode] IN (10,20,30,40,60) ORDER BY [DocumentStatusCode])))

      WHILE (@@ROWCOUNT > 0)
      BEGIN
            INSERT INTO @descendants
            SELECT h.[RootHierarchyKey], h.[HierarchyKey], d.[DocumentVersionKey], d.[DocumentKey], d.[AccessKey]
            FROM [Hierarchy] h
                  INNER JOIN [DocumentMain] d ON h.[UniformKey] = d.[DocumentVersionKey]
                  INNER JOIN @descendants d1 ON h.[ParentHierarchyKey] = d1.HierarchyKey
                  LEFT OUTER JOIN @descendants d2 ON h.[HierarchyKey] = d2.[HierarchyKey]
            WHERE d2.[HierarchyKey] IS NULL
                  AND ((@publishedOnly = 1 AND d.[DocumentStatusCode] IN (40,60)) OR
                         (@publishedOnly = 0 AND d.DocumentKey IN (SELECT TOP 1 [DocumentKey] FROM [DocumentMain] WHERE [DocumentVersionKey] = d.[DocumentVersionKey] AND [DocumentStatusCode] IN (10,20,30,40,60) ORDER BY [DocumentStatusCode])))
      END
      SELECT [RootHierarchyKey], [HierarchyKey], [DocumentVersionKey], [DocumentKey]
        FROM @descendants d
        INNER JOIN [dbo].[AccessItem] ai ON d.[AccessKey] = ai.[AccessKey]
        INNER JOIN [dbo].[UserToken] ut ON (ai.[Grantee] = ut.[Grantee] OR ai.Grantee = @loggedInUserGroupKey) AND ut.[UserKey] = @userKey
        LEFT OUTER JOIN [dbo].[UniformLicense] ul ON d.[DocumentVersionKey] = ul.[UniformKey]
        LEFT OUTER JOIN [dbo].[LicenseLegacyList] ll ON ul.[LicenseKey] = ll.[LicenseLegacyKey] 
        WHERE (@ignoreLicensing = 1 OR (ul.[LicenseKey] IS NULL OR ll.[LicenseLegacyKey] IS NOT NULL))   
        GROUP BY [RootHierarchyKey], [HierarchyKey], [DocumentVersionKey], [DocumentKey]
      END



GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentDescendantKeysByType]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentDescendantKeysByType]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


/*
Retrieves a list of all of the DocumentVersionKeys for all documents with a DocumentTypeCode = @documentTypeCode
that are descendants of the provided folder key (i.e. its children, children's children, etc).
*/
CREATE PROCEDURE [dbo].[asi_DocumentDescendantKeysByType]
(
      @hierarchyKey uniqueidentifier,
      @userKey uniqueidentifier,
      @loggedInUserGroupKey uniqueidentifier = '00000000-0000-0000-0000-000000000000', -- if this is empty, we assume the user is not logged in
      @publishedOnly bit = 1,
      @ignoreLicensing bit = 0,
      @documentTypeCode nvarchar(6)
)
AS
BEGIN
      DECLARE @descendants TABLE
      (
            [DocumentName] nvarchar(200),
            [DocumentTypeCode] varchar(6),
            [RootHierarchyKey] uniqueidentifier,
            [HierarchyKey] uniqueidentifier,
            [DocumentVersionKey] uniqueidentifier,
            [DocumentKey] uniqueidentifier,
            [AccessKey] uniqueidentifier
      )

      INSERT INTO @descendants
      SELECT d.[DocumentName], d.[DocumentTypeCode], h.[RootHierarchyKey], h.[HierarchyKey], d.[DocumentVersionKey], d.[DocumentKey], d.[AccessKey]
      FROM [Hierarchy] h
            INNER JOIN [DocumentMain] d ON h.[UniformKey] = d.[DocumentVersionKey]
      WHERE h.[ParentHierarchyKey] = @hierarchyKey
            AND ((@publishedOnly = 1 AND d.[DocumentStatusCode] IN (40,60)) OR
                     (@publishedOnly = 0 AND d.DocumentKey IN (SELECT TOP 1 [DocumentKey] FROM [DocumentMain] WHERE [DocumentVersionKey] = d.[DocumentVersionKey] AND [DocumentStatusCode] IN (10,20,30,40,60) ORDER BY [DocumentStatusCode])))

      WHILE (@@ROWCOUNT > 0)
      BEGIN
            INSERT INTO @descendants
            SELECT d.[DocumentName], d.[DocumentTypeCode], h.[RootHierarchyKey], h.[HierarchyKey], d.[DocumentVersionKey], d.[DocumentKey], d.[AccessKey]
            FROM [Hierarchy] h
                  INNER JOIN [DocumentMain] d ON h.[UniformKey] = d.[DocumentVersionKey]
                  INNER JOIN @descendants d1 ON h.[ParentHierarchyKey] = d1.HierarchyKey
                  LEFT OUTER JOIN @descendants d2 ON h.[HierarchyKey] = d2.[HierarchyKey]
            WHERE d2.[HierarchyKey] IS NULL
                  AND ((@publishedOnly = 1 AND d.[DocumentStatusCode] IN (40,60)) OR
                         (@publishedOnly = 0 AND d.DocumentKey IN (SELECT TOP 1 [DocumentKey] FROM [DocumentMain] WHERE [DocumentVersionKey] = d.[DocumentVersionKey] AND [DocumentStatusCode] IN (10,20,30,40,60) ORDER BY [DocumentStatusCode])))
      END
      
      SELECT [DocumentName], [DocumentTypeCode], [RootHierarchyKey], [HierarchyKey], [DocumentVersionKey], [DocumentKey]
        FROM @descendants d
        INNER JOIN [dbo].[AccessItem] ai ON d.[AccessKey] = ai.[AccessKey]
        INNER JOIN [dbo].[UserToken] ut ON (ai.[Grantee] = ut.[Grantee] OR ai.Grantee = @loggedInUserGroupKey) AND ut.[UserKey] = @userKey
        LEFT OUTER JOIN [dbo].[UniformLicense] ul ON d.[DocumentVersionKey] = ul.[UniformKey]
        LEFT OUTER JOIN [dbo].[LicenseLegacyList] ll ON ul.[LicenseKey] = ll.[LicenseLegacyKey] 
        WHERE (@ignoreLicensing = 1 OR (ul.[LicenseKey] IS NULL OR ll.[LicenseLegacyKey] IS NOT NULL))
        AND [DocumentTypeCode] = @documentTypeCode
        GROUP BY [DocumentName], [DocumentTypeCode], [RootHierarchyKey], [HierarchyKey], [DocumentVersionKey], [DocumentKey]
      END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentEnsureFolder]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentEnsureFolder]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

/*
Given a document tree path containing only folders, starting with the root, makes sure the folder path exists by
creating any folder in the path that does not.  If all goes well, the HierarchyKey of the end folder is returned.
Null is returned if the root does not exist (it won't ALTER  roots) or if the user does not have ALTER  permission
anywhere along the way. The parts of the path must be separated by the forward slash (/) 
*/
CREATE PROC [dbo].[asi_DocumentEnsureFolder]
   @documentPath nvarchar(2000),
   @organizationKey uniqueidentifier,
   @userKey uniqueidentifier,
   @loggedInUserGroupKey uniqueidentifier = '00000000-0000-0000-0000-000000000000', -- if this is empty, we assume the user is not logged in
   @rootHierarchyKey uniqueidentifier = null
AS
BEGIN
   DECLARE 
      @parent uniqueidentifier,
      @documentRootName nvarchar(100),
      @documentName nvarchar(100),
      @ptr int,
      @newSort int,
      @documentKey uniqueidentifier,
      @documentVersionKey uniqueidentifier,
      @accessKey uniqueidentifier,
      @hierarchyKey uniqueidentifier,
      @parentFolderDepth int,
      @parentFolderSortOrder int,
      @tmp int

   -- default accesskey to everyone full control
   SELECT @accessKey = Convert(uniqueidentifier,ParameterValue)
     FROM SystemConfig
    WHERE ParameterName = 'Security.Token.EveryoneFullControlAccessKey'
      AND OrganizationKey = @organizationKey

   SET @ptr = CHARINDEX(N'/', @documentPath)
   IF @ptr > 0
   BEGIN
      --First segment contains the root name, the rest is the path
      SET @documentRootName = SUBSTRING(@documentPath, 1, @ptr - 1)
      SET @documentPath = SUBSTRING(@documentPath, @ptr + 1, LEN(@documentPath) - @ptr)
   END
   ELSE
   BEGIN
      --No root specified so use absolute root name
      SET @documentRootName = N'$'
      IF @documentPath = N'$'
         SET @documentPath = ''
   END
   -- check to make sure the root exists and the user has rights to it
   IF @rootHierarchyKey IS NULL
   BEGIN
	   SELECT @rootHierarchyKey = RootHierarchyKey
		 FROM HierarchyRoot
		WHERE HierarchyRootName = @documentRootName
		  AND HierarchyRoot.OrganizationKey = @organizationKey
		  AND EXISTS(
			  SELECT 1 
				FROM AccessItem INNER JOIN UserToken ON AccessItem.Grantee = UserToken.Grantee OR AccessItem.Grantee = @loggedInUserGroupKey
			   WHERE AccessItem.AccessKey = HierarchyRoot.AccessKey 
				 AND UserToken.UserKey = @userKey 
				 AND (AccessItem.Permission&3)>0)
   END
   ELSE
   BEGIN
	   SELECT @rootHierarchyKey = RootHierarchyKey
		 FROM HierarchyRoot
		WHERE RootHierarchyKey = @rootHierarchyKey
		  AND HierarchyRoot.OrganizationKey = @organizationKey
		  AND EXISTS(
			  SELECT 1 
				FROM AccessItem INNER JOIN UserToken ON AccessItem.Grantee = UserToken.Grantee OR AccessItem.Grantee = @loggedInUserGroupKey
			   WHERE AccessItem.AccessKey = HierarchyRoot.AccessKey 
				 AND UserToken.UserKey = @userKey 
				 AND (AccessItem.Permission&3)>0)
   END
   -- if we can get to the root, lets go inside the path
   IF @rootHierarchyKey IS NOT NULL
   BEGIN
      SET @hierarchyKey = @rootHierarchyKey
      SET @parent = @rootHierarchyKey
      SET @parentFolderDepth = 0
      SET @parentFolderSortOrder = 0

      -- loop thru the path components
      WHILE LEN(@documentPath) > 0
      BEGIN
         -- separate the next part of the path from the rest
         SET @ptr = CHARINDEX(N'/', @documentPath)
         IF @ptr > 0
         BEGIN
            SET @documentName = SUBSTRING(@documentPath, 1, @ptr - 1)
            SET @documentPath = SUBSTRING(@documentPath, @ptr + 1, LEN(@documentPath) - @ptr)
         END
         ELSE
         BEGIN
            SET @documentName = @documentPath
            SET @documentPath = N''
         END

         -- if there is still path parts left, documentName contains a folder name. Get its HierarchyKey
         IF LEN(@documentPath) > 0
         BEGIN
            SET @documentKey = null

            SELECT @parent = Hierarchy.ParentHierarchyKey,
                   @hierarchyKey = Hierarchy.HierarchyKey,
                   @parentFolderDepth = Hierarchy.Depth,
                   @parentFolderSortOrder = Hierarchy.SortOrder,
                   @documentKey = DocumentMain.DocumentKey,
                   @accessKey = DocumentMain.AccessKey
              FROM Hierarchy INNER JOIN DocumentMain ON Hierarchy.UniformKey = DocumentMain.DocumentVersionKey AND DocumentMain.DocumentStatusCode IN (10,20,30,40,60)
             WHERE Hierarchy.RootHierarchyKey = @rootHierarchyKey
               AND Hierarchy.ParentHierarchyKey = @parent
               AND DocumentMain.DocumentName = @documentName
            IF @@ROWCOUNT = 0
            -- its not there.  Since we had control permission at the higher level, create it.
            BEGIN
               SET @documentKey = NewID()
               SET @documentVersionKey = NewID()

               -- create the UniformRegistry entry first
               INSERT INTO UniformRegistry (UniformKey, ComponentKey)
               SELECT @documentKey, ComponentKey
                 FROM ComponentRegistry
                WHERE Name = 'Document'
                  AND InterfaceName = 'BusinessController'

               -- then the UniformRegistry entry for the version key
               INSERT INTO UniformRegistry (UniformKey, ComponentKey)
               SELECT @documentVersionKey, ComponentKey
                 FROM ComponentRegistry
                WHERE Name = 'DocumentVersion'
                  AND InterfaceName = 'BusinessController'

               -- then create the folder document
               INSERT INTO DocumentMain (
                      DocumentKey,
                      DocumentTypeCode,
                      DocumentName,
                      DocumentVersionKey,
                      DocumentStatusCode,
                      AlternateName,
                      IsSystem,
                      AccessKey,
                      ContainsChildrenFlag,
                      StatusUpdatedByUserKey,
                      StatusUpdatedOn,
                      UpdatedByUserKey,
                      UpdatedOn,
                      CreatedByUserKey,
                      CreatedOn)
               VALUES (
                      @documentKey,
                      'FOL',
                      @documentName,
                      @documentVersionKey,
                      40,
                      @documentName,
                      0,
                      @accessKey,
                      0,
                      @userKey,
                      GetDate(),
                      @userKey,
                      GetDate(),
                      @userKey,
                      GetDate())

              -- then create the hierarchy element
              SET @hierarchyKey = NewID()
	    
              EXEC asi_HierarchyGetFolderSortOut @parent, @rootHierarchyKey, @parentFolderSortOrder, @parentFolderDepth, @documentName, @newSort OUTPUT

              INSERT INTO Hierarchy (HierarchyKey, RootHierarchyKey, ParentHierarchyKey, SortOrder, Depth, UniformType, UniformKey, IsChildAMemberOfParent)
              SELECT @hierarchyKey, RootHierarchyKey, HierarchyKey, @newSort, Depth + 1, UniformType, @documentVersionKey, IsChildAMemberOfParent
                FROM Hierarchy
               WHERE HierarchyKey = @parent
 
               SET @parent = @hierarchyKey
               SET @parentFolderSortOrder = @newSort
               SET @parentFolderDepth = @parentFolderDepth + 1
            END
            -- it is there, check the security
            ELSE
            BEGIN
               SELECT @tmp = count(*) 
                 FROM AccessItem INNER JOIN UserToken ON AccessItem.Grantee = UserToken.Grantee OR AccessItem.Grantee = @loggedInUserGroupKey
                WHERE AccessItem.AccessKey = @accessKey 
                  AND UserToken.UserKey = @userKey 
                  AND (AccessItem.Permission&3)>0
               IF @tmp > 0 AND @hierarchyKey IS NOT NULL
               BEGIN
                  SET @parent = @hierarchyKey
               END
               ELSE
               BEGIN
                  SET @parent = NULL
                  SET @documentPath = NULL
                  SET @hierarchyKey = NULL
               END
            END
         END
      END -- WHILE LEN(@documentPath) > 0
      SELECT @hierarchyKey
   END -- IF @rootHierarchyKey IS NOT NULL
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentGetLatestVersionDocumentKey]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentGetLatestVersionDocumentKey]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- gets the "latest" document key given a DocumentKey or a DocumentVersionKey.  If key is DocumentKey
-- it looks at all versions of that Document (same DocumentVersionKey)  If key is a DocumentVersionKey, 
-- returns the DocumentKey of the document with the lowest status (e.g., prefers working over published, 
-- published over archived, etc.) and the most recent date
CREATE PROCEDURE [dbo].[asi_DocumentGetLatestVersionDocumentKey] @key uniqueidentifier, @documentKey uniqueidentifier OUT AS
BEGIN
    SELECT @documentKey = a.DocumentKey
      FROM DocumentMain a 
           INNER JOIN DocumentMain b ON a.DocumentVersionKey = b.DocumentVersionKey
     WHERE (b.DocumentKey = @key OR b.DocumentVersionKey = @key)
       AND a.CreatedOn = (SELECT TOP 1 CreatedOn
                            FROM DocumentMain
                           WHERE DocumentVersionKey = a.DocumentVersionKey
                           ORDER BY DocumentStatusCode, UpdatedOn DESC)
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentHierarchyKeyByKey]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentHierarchyKeyByKey]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- Finds the first (should be only for documents) hierarchy key associated
-- with the DocumentKey or DocumentVersionKey sent in the key parameter.
-- We make sure that we do not include results from the UniformItem hierarchy
-- rooted at '.'
CREATE PROC [dbo].[asi_DocumentHierarchyKeyByKey] @key uniqueidentifier AS
BEGIN
   DECLARE @documentKey uniqueidentifier

   EXEC asi_DocumentGetLatestKey @key, @documentKey OUT

   SELECT TOP 1 h.HierarchyKey 
     FROM Hierarchy h 
          INNER JOIN DocumentMain d ON h.UniformKey = d.DocumentVersionKey 
          INNER JOIN HierarchyRoot r ON h.RootHierarchyKey = r.RootHierarchyKey
    WHERE d.DocumentKey = @documentKey AND r.HierarchyRootName <> N'.'
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentImport]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentImport]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/*
Creates or upates the document described by the parameters.  Since the import could be coming from a 
database that does not have the same key values for certain things, these keys may or may not be preserved.

The rules are:
1. If the document does not already exists in the target database, in any version, it will be created
2. If the document does already exist in the target database it may be imported or updated according to specific rules outlined below.

Preserving Keys (e.g., for Dev -> Test -> Production environments)

3. For Insert/Create only: if the user who created the document being imported does not exist in the import database, the default user key (that of the person doing the import) will be used.  Otherwise the CreatedByUserKey from the import record will be preserved.
4. If the user who last updated the document does not exist in the import database, the default user key (that of the person doing the import) will be used.  Otherwise the UpdatedByUserKey from the import record will be preserved.
5. If the user who last updated the status does not exist in the import database, the default user key (that of the person doing the import) will be used.  Otherwise the StatusUpdatedByUserKey from the import record will be preserved.
6. If the security AccessKey on the document being imported does not exist in the import database:
   a. and the document is only being imported into one folder and that folder has a DefaultChildAccessKey, the folders DefaultChildAccessKey will be used
   b. and the document is being imported into more than one folder or the only folder into which it is being imported has no DefaultChildAccessKey, the default access key (supplied at the start of the import process) will be used.  
Otherwise, the AccessKey from the import record will be preserved.
7. If the security DefaultChildAccessKey on the document being imported does not exist in the import database, NULL will be substituted.  Otherwise, the DefaultChildAccessKey from the import record will be preserved.
*/
CREATE PROCEDURE [dbo].[asi_DocumentImport]
   @DocumentKey uniqueidentifier,
   @DocumentName nvarchar(100),
   @DocumentDescription nvarchar(250),
   @DocumentVersionKey uniqueidentifier,
   @DocumentTypeCode nvarchar(3),
   @DocumentStatusCode int,
   @DocumentCode nvarchar(100),
   @AlternateName nvarchar(100),
   @IsSystem bit,
   @Blob image,
   @AccessKey uniqueidentifier,
   @DefaultChildAccessKey uniqueidentifier,
   @ContainsChildrenFlag bit,
   @BranchedFromDocumentKey uniqueidentifier,
   @RelatedDocumentVersionKey uniqueidentifier,
   @StatusUpdatedOn datetime,
   @StatusUpdatedByUserKey uniqueidentifier,
   @UpdatedOn datetime,
   @UpdatedByUserKey uniqueidentifier,
   @CreatedOn datetime,
   @CreatedByUserKey uniqueidentifier,
   @DefaultUserKey uniqueidentifier,
   @DefaultAccessKey uniqueidentifier,
   @Overwrite bit
AS
DECLARE
   @check int, @currentDocumentStatusCode int, @lockedOn datetime, @trackVersionsFlag bit
BEGIN
   -- some of the keys may not exist in the import database.  Check each and if they do not, use the default
   -- if the user who last updated the status does not exist in this database, use the default user key (person doing the import)
   SELECT @check = Count(*)
     FROM UserMain
    WHERE UserKey = @StatusUpdatedByUserKey

   IF @check = 0 SET @StatusUpdatedByUserKey = @DefaultUserKey
      
   -- if the user who last updated the document does not exist in this database, use the default user key (person doing the import)
   SELECT @check = Count(*)
     FROM UserMain
    WHERE UserKey = @UpdatedByUserKey

   IF @check = 0 SET @UpdatedByUserKey = @DefaultUserKey

   -- if the user who created the document does not exist in this database, use the default user key (person doing the import)
   SELECT @check = Count(*)
     FROM UserMain
    WHERE UserKey = @CreatedByUserKey

   IF @check = 0 SET @CreatedByUserKey = @DefaultUserKey

   -- if the AccessKey on the document does not exist, use the default access key
   SELECT @check = Count(*)
     FROM AccessMain
    WHERE AccessKey = @AccessKey

   IF @check = 0 SET @AccessKey = @DefaultAccessKey

   -- if the DefaultChildAccessKey on the document does not exist, set it to null
   IF @DefaultChildAccessKey IS NOT NULL
   BEGIN
      SELECT @check = Count(*)
        FROM AccessMain
       WHERE AccessKey = @DefaultChildAccessKey

      IF @check = 0 SET @DefaultChildAccessKey = null
   END

   -- if the RelatedDocumentVersionKey does not exists (it is a shortcut to nowhere)
   IF @RelatedDocumentVersionKey IS NOT NULL
   BEGIN
      SELECT @check = Count(*)
        FROM UniformRegistry
       WHERE UniformKey = @RelatedDocumentVersionKey

      IF @check = 0
      BEGIN
         RAISERROR ('Unable to import %s. Shortcut references a document that does not exist',11,1, @DocumentName)
         RETURN
      END
   END

   -- check to see if documents of this type track versions so we know if we need to follow any version tracking rules
   SELECT @trackVersionsFlag = TrackVersionsFlag
     FROM DocumentTypeRef
    WHERE DocumentTypeCode = @DocumentTypeCode

   -- next, check to see if this is an insert or an update and grab the DocumentStatusCode for later if update
   SELECT @currentDocumentStatusCode = DocumentStatusCode, @lockedOn = LockedOn
     FROM DocumentMain
    WHERE DocumentKey = @DocumentKey

   -- if there is not one there already, it is an insert
   IF @currentDocumentStatusCode IS NULL
   BEGIN
      INSERT INTO UniformRegistry (UniformKey, ComponentKey) 
      SELECT @DocumentKey, ComponentKey
        FROM ComponentRegistry
       WHERE Name = 'Document'
         AND InterfaceName = 'BusinessController'

      -- check to see if the version key is already there
      SELECT @check = Count(*)
        FROM UniformRegistry
       WHERE UniformKey = @DocumentVersionKey

      -- if the DocumentVersionKey does not exist, add it
      IF @check = 0
         INSERT INTO UniformRegistry (UniformKey, ComponentKey)
         SELECT @DocumentVersionKey, ComponentKey
           FROM ComponentRegistry
          WHERE Name = 'DocumentVersion'
            AND InterfaceName = 'BusinessController'
      -- if the DocumentVersionKey DOES exists, we need to make sure the status rules are applied
      ELSE
      BEGIN
         -- If the incoming document's status is Working, make sure that if there is another working version
         -- it gets archived.  If the incoming document's status is Published, make sure that if there is another
         -- Published version, it gets archived
         IF (@DocumentStatusCode = 10 OR @DocumentStatusCode = 40) AND @trackVersionsFlag = 1
            UPDATE DocumentMain
               SET DocumentStatusCode = 50
             WHERE DocumentVersionKey = @DocumentVersionKey
               AND DocumentStatusCode = @DocumentStatusCode
      END

      INSERT INTO DocumentMain (
             DocumentKey,
             DocumentName,
             DocumentDescription,
             DocumentVersionKey,
             DocumentTypeCode,
             DocumentStatusCode,
			 DocumentCode,
             AlternateName,
             IsSystem,
             Blob,
             AccessKey,
             DefaultChildAccessKey,
             ContainsChildrenFlag,
             BranchedFromDocumentKey,
             RelatedDocumentVersionKey,
             StatusUpdatedOn,
             StatusUpdatedByUserKey,
             UpdatedOn,
             UpdatedByUserKey,
             CreatedOn,
             CreatedByUserKey)
      VALUES (
             @DocumentKey,
             @DocumentName,
             @DocumentDescription,
             @DocumentVersionKey,
             @DocumentTypeCode,
             @DocumentStatusCode,
             @DocumentCode,
             @AlternateName,
             @IsSystem,
             @Blob,
             @AccessKey,
             @DefaultChildAccessKey,
             @ContainsChildrenFlag,
             @BranchedFromDocumentKey,
             @RelatedDocumentVersionKey,
             @StatusUpdatedOn,
             @StatusUpdatedByUserKey,
             @UpdatedOn,
             @UpdatedByUserKey,
             @CreatedOn,
             @CreatedByUserKey)
   END
   -- there is already one there, it is an update
   ELSE
   BEGIN
      IF @Overwrite = 1
      BEGIN
         -- if the existing document's status is Publish Requested, PublishPending, RecycleRequested, or RecyclePending
         -- or the document is Locked, we can't import.  Raise an error
         IF @currentDocumentStatusCode IN (20,30,60,70)
         BEGIN
            DECLARE @DocumentStatusDesc nvarchar(30)
            SELECT @DocumentStatusDesc = DocumentStatusDesc FROM DocumentStatusRef WHERE DocumentStatusCode = @currentDocumentStatusCode

            RAISERROR ('Unable to import %s. The exact version of the document already exists in the target database with a status of %s.',11,1, @DocumentName, @DocumentStatusDesc)
            RETURN
         END

         IF @lockedOn IS NOT NULL
         BEGIN
            RAISERROR ('Unable to import %s. The exact version of the document already exists in the target database and is Locked for editing.',11,1, @DocumentName)
            RETURN
         END

         -- if the status of the doc being imported does not match the one that exists, we need to apply
         -- some special rules.
         IF @currentDocumentStatusCode <> @DocumentStatusCode AND @trackVersionsFlag = 1
         BEGIN
            -- if source is Published and Target is Working, need to archive existing published version first
            IF @DocumentStatusCode = 40 AND @currentDocumentStatusCode = 10
               UPDATE DocumentMain
                  SET DocumentStatusCode = 50
                WHERE DocumentVersionKey = @DocumentVersionKey
                  AND DocumentStatusCode = @DocumentStatusCode

            -- for all other combinations we have not yet covered except Source is Archived, Target is Working
            -- leave the status unchanged
            IF (@DocumentStatusCode = 10 AND @currentDocumentStatusCode IN (40,50)) OR
               (@DocumentStatusCode = 40 AND @currentDocumentStatusCode = 50) OR
               (@DocumentStatusCode = 50 AND @currentDocumentStatusCode = 40)
               SET @DocumentStatusCode = @currentDocumentStatusCode
         END

         UPDATE DocumentMain 
            SET DocumentName = @DocumentName,
                DocumentDescription = @DocumentDescription,
                DocumentTypeCode = @DocumentTypeCode,
                DocumentStatusCode = @DocumentStatusCode,
				DocumentCode = @DocumentCode,
                AlternateName = @AlternateName,
                IsSystem = @IsSystem,
                Blob = @Blob,
                DefaultChildAccessKey = @DefaultChildAccessKey,
                ContainsChildrenFlag = @ContainsChildrenFlag,
                BranchedFromDocumentKey = @BranchedFromDocumentKey,
                RelatedDocumentVersionKey  = @RelatedDocumentVersionKey,
                StatusUpdatedOn = @StatusUpdatedOn,
                StatusUpdatedByUserKey = @StatusUpdatedByUserKey,
                UpdatedOn = @UpdatedOn,
                UpdatedByUserKey = @UpdatedByUserKey
          WHERE DocumentKey = @DocumentKey
      END
   END
   SELECT @DocumentKey
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentInheritLicenseRestrictions]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentInheritLicenseRestrictions]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
--  PARAMETER USAGE NOTES
--	@documentVersionKey: Required parameter. Needed to know which Document we're applying the license restrictions to
--	@parentHierarchyKey: Optional parameter. License restrictions can still be copied from parent folder before the hierarchy
--						 has been created if the parent hierarchy key is passes in

CREATE PROCEDURE dbo.asi_DocumentInheritLicenseRestrictions
	(@documentVersionKey uniqueidentifier,
	@parentHierarchyKey uniqueidentifier = '00000000-0000-0000-0000-000000000000')
AS
BEGIN

	DECLARE @parentDocumentVersionKey uniqueidentifier

	IF @parentHierarchyKey = '00000000-0000-0000-0000-000000000000'
	BEGIN

		SELECT @parentDocumentVersionKey = parent.[UniformKey]
		FROM [dbo].[Hierarchy] parent INNER JOIN [dbo].[Hierarchy] child ON parent.[HierarchyKey] = child.[ParentHierarchyKey]
		WHERE child.[UniformKey] = @documentVersionKey

	END
	ELSE
	BEGIN

		SELECT @parentDocumentVersionKey = [Hierarchy].[UniformKey]
		FROM [dbo].[Hierarchy]
		WHERE [Hierarchy].[HierarchyKey] = @parentHierarchyKey

	END

	INSERT INTO [dbo].[UniformLicense] ([LicenseKey], [UniformKey])
	SELECT [UniformLicense].[LicenseKey], @documentVersionKey
	FROM [dbo].[UniformLicense]
	WHERE [UniformLicense].[UniformKey] = @parentDocumentVersionKey
	AND [UniformLicense].[LicenseKey] NOT IN
		(SELECT [UniformLicense].[LicenseKey] FROM [dbo].[UniformLicense] WHERE [UniformLicense].[UniformKey] = @documentVersionKey)

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentKeysByCode]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentKeysByCode]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-----------------------------------------------------------------------
-- Given a document code and RootHierarchyKey returns the HierarchyKey, 
-- DocumentVersionKey and DocumentKey of the document if it is found 
-- within the given hierarchy. Security IS checked. 
-- NOTE: The documentKey returned will be that of the latest version
-----------------------------------------------------------------------
CREATE PROC [dbo].[asi_DocumentKeysByCode]
   @documentCode nvarchar(100),
   @rootHierarchyKey uniqueidentifier,
   @userKey uniqueidentifier,
   @loggedInUserGroupKey uniqueidentifier = '00000000-0000-0000-0000-000000000000' -- if this is empty, we assume the user is not logged in
AS
BEGIN
   SELECT h.HierarchyKey,
          d.DocumentVersionKey,
          d.DocumentKey
     FROM Hierarchy h 
          INNER JOIN DocumentMain d ON h.UniformKey = d.DocumentVersionKey AND d.DocumentStatusCode IN (10,20,30,40,60)
    WHERE h.RootHierarchyKey = @rootHierarchyKey
          AND d.DocumentCode = @documentCode
          AND EXISTS(
          SELECT 1 
            FROM AccessItem INNER JOIN UserToken ON AccessItem.Grantee = UserToken.Grantee OR AccessItem.Grantee = @loggedInUserGroupKey
           WHERE AccessItem.AccessKey = d.AccessKey 
             AND UserToken.UserKey = @userKey 
             AND (AccessItem.Permission&3)>0)
    ORDER BY d.DocumentStatusCode DESC
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentKeysByPath]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentKeysByPath]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


/*
Given a document tree path, starting with the root, returns the RootHierarchyKey, HierarchyKey and DocumentKey of the
end node as out parameters. Security IS checked. The parts of the path must be separated by the forward slash (/).
NOTE: The documentKey returned will be that of the latest version
*/
CREATE PROC [dbo].[asi_DocumentKeysByPath]
   @documentPath nvarchar(2000),
   @organizationKey uniqueidentifier,
   @userKey uniqueidentifier,
   @loggedInUserGroupKey uniqueidentifier = '00000000-0000-0000-0000-000000000000', -- if this is empty, we assume the user is not logged in
   @ignoreLicensing bit = 0,
   @rootHierarchyKey uniqueidentifier OUT,
   @hierarchyKey uniqueidentifier OUT,
   @documentVersionKey uniqueidentifier OUT,
   @documentKey uniqueidentifier OUT
AS
BEGIN
   DECLARE
      @parent uniqueidentifier,
      @relatedDocumentVersionKey uniqueidentifier,
      @relatedDocumentKey uniqueidentifier,
      @relatedHierarchyKey uniqueidentifier,
      @documentRootName nvarchar(100),
      @documentName nvarchar(100),
      @ptr int,
      @documentPathWorking nvarchar(2000)
      
   SET @ptr = CHARINDEX(N'/', @documentPath)
   IF @ptr > 0
   BEGIN
      --First segment contains the root name
      SET @documentRootName = SUBSTRING(@documentPath, 1, @ptr - 1)
      SET @documentPath = SUBSTRING(@documentPath, @ptr + 1, LEN(@documentPath) - @ptr)
   END
   ELSE
   BEGIN
        -- See if it's the name of a root; if not, default to $
        IF EXISTS (SELECT 1 FROM HierarchyRoot WHERE HierarchyRootName = @documentPath)
        BEGIN
              SET @documentRootName = @documentPath
              SET @documentPath = ''
        END
        ELSE
      BEGIN
              --No root specified so use absolute root name
              SET @documentRootName = N'$'
              IF @documentPath = N'$'
                   SET @documentPath = N''
        END
   END
   -- check to make sure the root exists and the user has rights to it
   -- Updated to handle multiple roots with the same name
   DECLARE @HierarchyRoots TABLE (
       RootHierarchyKey uniqueidentifier,
       HierarchyKey uniqueidentifier,
       UniformKey uniqueidentifier,
       DocumentKey uniqueidentifier,
       Checked bit
   )
   INSERT INTO @HierarchyRoots
   SELECT a.RootHierarchyKey,
          b.HierarchyKey,
          b.UniformKey,
          c.DocumentKey,
          0
     FROM HierarchyRoot a inner join Hierarchy b on a.RootHierarchyKey = b.HierarchyKey
          left join DocumentMain c ON b.UniformKey = c.DocumentVersionKey AND c.DocumentStatusCode IN (40,60)
    WHERE a.HierarchyRootName = @documentRootName
      AND a.OrganizationKey = @organizationKey
        AND (@rootHierarchyKey IS NULL OR @rootHierarchyKey = '00000000-0000-0000-0000-000000000000' OR a.RootHierarchyKey = @rootHierarchyKey)
      AND EXISTS(
          SELECT 1
            FROM AccessItem INNER JOIN UserToken ON AccessItem.Grantee = UserToken.Grantee OR AccessItem.Grantee = @loggedInUserGroupKey
           WHERE AccessItem.AccessKey = a.AccessKey
             AND UserToken.UserKey = @userKey
             AND (AccessItem.Permission&3)>0)

   WHILE @hierarchyKey IS NULL AND @documentVersionKey IS NULL AND @documentKey IS NULL AND EXISTS (SELECT 1 FROM @HierarchyRoots WHERE Checked = 0)
   BEGIN
       SET @documentPathWorking = @documentPath

         SELECT @rootHierarchyKey = RootHierarchyKey,
                    @hierarchyKey = HierarchyKey,
                    @documentVersionKey = UniformKey,
                    @documentKey = DocumentKey
             FROM @HierarchyRoots
            WHERE Checked = 0

         -- if we can get to the root, lets go inside the path
         IF @rootHierarchyKey IS NOT NULL
         BEGIN
          UPDATE @HierarchyRoots SET Checked = 1 WHERE RootHierarchyKey = @rootHierarchyKey

              SET @hierarchyKey = @rootHierarchyKey
              SET @parent = @rootHierarchyKey
              -- loop thru the path components
              WHILE LEN(@documentPathWorking) > 0
              BEGIN
                   -- separate the next part of the path from the rest
                   SET @ptr = CHARINDEX(N'/', @documentPathWorking)
                   IF @ptr > 0
                   BEGIN
                        SET @documentName = SUBSTRING(@documentPathWorking, 1, @ptr - 1)
                        SET @documentPathWorking = SUBSTRING(@documentPathWorking, @ptr + 1, LEN(@documentPathWorking) - @ptr)
                   END
                   ELSE
                   BEGIN
                        SET @documentName = @documentPathWorking
                        SET @documentPathWorking = N''
                   END

                   -- if there is still path parts left, documentName contains a folder name. Get its HierarchyKey
                   IF LEN(@documentName) > 0
                   BEGIN
                        SET @documentKey = null
                        SET @documentVersionKey = null
                        SET @hierarchyKey = null

                        DECLARE @t1 TABLE (
                              ParentHierarchyKey uniqueidentifier,
                              HierarchyKey uniqueidentifier,
                              DocumentVersionKey uniqueidentifier,
                              DocumentKey uniqueidentifier,
                              RelatedDocumentVersionKey uniqueidentifier,
                              AccessKey uniqueidentifier,
                              UpdatedOn datetime,
                              DocumentStatusCode int
                        )
                        DELETE FROM @t1
                        INSERT INTO @t1 (ParentHierarchyKey, HierarchyKey, DocumentVersionKey, DocumentKey, RelatedDocumentVersionKey, AccessKey, UpdatedOn, DocumentStatusCode)
                        SELECT
                                 Hierarchy.ParentHierarchyKey,
                                 Hierarchy.HierarchyKey,
                                 DocumentMain.DocumentVersionKey,
                                 DocumentMain.DocumentKey,
                                 DocumentMain.RelatedDocumentVersionKey,
                                 DocumentMain.AccessKey,
                                 DocumentMain.UpdatedOn,
                                 DocumentMain.DocumentStatusCode
                          FROM Hierarchy INNER JOIN DocumentMain ON Hierarchy.UniformKey = DocumentMain.DocumentVersionKey
                         WHERE Hierarchy.RootHierarchyKey = @rootHierarchyKey
                           AND Hierarchy.ParentHierarchyKey = @parent
                           AND DocumentMain.DocumentName = @documentName
                         ORDER BY DocumentMain.DocumentStatusCode ASC, DocumentMain.UpdatedOn DESC

                        SELECT TOP 1 @parent = a.ParentHierarchyKey,
                              @hierarchyKey = a.HierarchyKey,
                              @documentVersionKey = a.DocumentVersionKey,
                              @documentKey = a.DocumentKey,
                              @relatedDocumentVersionKey = a.RelatedDocumentVersionKey
                        FROM @t1 AS a
                           WHERE EXISTS(
                                 SELECT 1
                                     FROM AccessItem INNER JOIN UserToken ON AccessItem.Grantee = UserToken.Grantee OR AccessItem.Grantee = @loggedInUserGroupKey
                                    WHERE AccessItem.AccessKey = a.AccessKey
                                      AND UserToken.UserKey = @userKey
                                      AND (AccessItem.Permission&3)>0)
                              AND (@ignoreLicensing = 1
                                 OR NOT EXISTS (SELECT 1 FROM UniformLicense WHERE UniformKey = a.DocumentVersionKey)
                                     OR EXISTS(
                                      SELECT 1
                                          FROM [dbo].[UniformLicense] INNER JOIN [dbo].[LicenseLegacyList] l ON UniformLicense.LicenseKey = l.LicenseLegacyKey
                                       WHERE UniformLicense.UniformKey = a.DocumentVersionKey))
                         ORDER BY a.DocumentStatusCode ASC, a.UpdatedOn DESC

                        IF @@ROWCOUNT = 0
                        BEGIN
                           SET @parent = NULL
                           SET @documentPathWorking = NULL
                        END
                        ELSE
                        BEGIN
                           IF (@hierarchyKey IS NOT NULL)
                                SET @parent = @hierarchyKey
                           -- get related document info if there
                           IF (@relatedDocumentVersionKey IS NOT NULL)
                           BEGIN
                                SELECT top 1 @relatedHierarchyKey = HierarchyKey, @relatedDocumentKey = DocumentMain.DocumentKey
                                    FROM Hierarchy INNER JOIN DocumentMain ON Hierarchy.UniformKey = DocumentMain.DocumentVersionKey
                                 WHERE Hierarchy.RootHierarchyKey = @rootHierarchyKey
                                     AND DocumentMain.DocumentVersionKey = @relatedDocumentVersionKey
                                     AND EXISTS(
                                           SELECT 1
                                             FROM AccessItem INNER JOIN UserToken ON AccessItem.Grantee = UserToken.Grantee OR AccessItem.Grantee = @loggedInUserGroupKey
                                            WHERE AccessItem.AccessKey = DocumentMain.AccessKey
                                                AND UserToken.UserKey = @userKey
                                                AND (AccessItem.Permission&3)>0)
                                    AND (@ignoreLicensing = 1
                                       OR NOT EXISTS (SELECT 1 FROM UniformLicense WHERE UniformKey = DocumentMain.DocumentVersionKey)
                                           OR EXISTS(
                                            SELECT 1
                                              FROM [dbo].[UniformLicense] 
                                                   INNER JOIN [dbo].[LicenseLegacyList] l ON UniformLicense.LicenseKey = l.LicenseLegacyKey
                                             WHERE UniformLicense.UniformKey = DocumentMain.DocumentVersionKey))
                                 ORDER BY DocumentMain.DocumentStatusCode ASC, DocumentMain.UpdatedOn DESC

                                IF @@ROWCOUNT = 1 AND @relatedHierarchyKey IS NOT NULL
                                BEGIN
                                     SET @parent = @relatedHierarchyKey
                                     SET @documentKey = @relatedDocumentKey
                                END
                           END
                        END
                   END
              END -- WHILE LEN(@documentPathWorking) > 0
         END -- IF @rootHierarchyKey IS NOT NULL
   END -- WHILE Checked = 0END
END



GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentMainByHierarchyKey]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentMainByHierarchyKey]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/*
Given a hierarchy key, returns everything from DocumentMain except the blob (for security and performance reasons)
for the Document associated with that Hierarchy element.  Also includes the DocumentTypeName, DocumentTypeDesc, 
and DocumentIconURL from the associated DocumentTypeRef record.

If publishedOnly = 1 it will only get published documents.  Otherwise, it gets the latest version, published or working.
It won't get documents with any other status

NOTE: Security is bypassed since the call requires the key (e.g., a reference from an object to which the user
has access) and the sensitive part, the blob, is not returned.
*/
CREATE PROC [dbo].[asi_DocumentMainByHierarchyKey]
   @hierarchyKey uniqueidentifier,
   @publishedOnly bit = 0
AS
BEGIN
   SELECT a.DocumentKey,
          a.DocumentVersionKey,
          a.DocumentStatusCode,
          a.DocumentName,
          a.AlternateName,
          a.DocumentDescription,
          a.DocumentTypeCode,
          a.IsSystem,
          a.ContainsChildrenFlag,
          a.AccessKey,
          a.DefaultChildAccessKey,
          a.StatusUpdatedOn,
          a.StatusUpdatedByUserKey,
          a.CreatedOn,
          a.CreatedByUserKey,
          a.UpdatedOn,
          a.UpdatedByUserKey,
          b.DocumentTypeName, 
          b.DocumentTypeDesc,
          b.DocumentIconURL
     FROM [dbo].[DocumentMain] a INNER JOIN [dbo].[DocumentTypeRef] b on a.DocumentTypeCode = b.DocumentTypeCode
          INNER JOIN [dbo].[Hierarchy] c ON a.DocumentVersionKey = c.UniformKey
    WHERE c.HierarchyKey = @hierarchyKey
      AND ((a.DocumentStatusCode IN (10,20,30,70) AND @publishedOnly = 0)
       OR (a.DocumentStatusCode IN (40,60) 
      AND (@publishedOnly = 1
       OR NOT EXISTS (
          SELECT 1
            FROM [dbo].[DocumentMain] d
           WHERE d.DocumentVersionKey = a.DocumentVersionKey
             AND d.DocumentStatusCode IN (10,20,30,70)))))
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentMainByKey]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentMainByKey]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/*
Given the document key, returns everything from DocumentMain except the blob (for security and performance reasons)
plus DocumentTypeName, DocumentTypeDesc, and DocumentIconURL from the associated DocumentTypeRef record.

NOTE: Security is bypassed since the call requires the key (e.g., a reference from an object to which the user
has access) and the sensitive part, the blob, is not returned.
*/
CREATE PROC [dbo].[asi_DocumentMainByKey]
   @key uniqueidentifier
AS
BEGIN
   DECLARE @documentKey uniqueidentifier

   EXEC asi_DocumentGetLatestKey @key, @documentKey OUT

   SELECT a.DocumentKey,
          a.DocumentVersionKey,
          a.DocumentStatusCode,
          a.DocumentName,
          a.AlternateName,
          a.DocumentDescription,
          a.DocumentTypeCode,
          a.IsSystem,
          a.ContainsChildrenFlag,
          a.RelatedDocumentVersionKey,
          a.AccessKey,
          a.DefaultChildAccessKey,
          a.StatusUpdatedOn,
          a.StatusUpdatedByUserKey,
          a.CreatedOn,
          a.CreatedByUserKey,
          a.UpdatedOn,
          a.UpdatedByUserKey,
          b.DocumentTypeName, 
          b.DocumentTypeDesc,
          b.DocumentIconURL,
          c.DocumentKey AS RelatedDocumentKey,
          c.DocumentTypeCode AS RelatedDocumentTypeCode,
          c.DocumentStatusCode AS RelatedDocumentStatusCode,
          c.DocumentName AS RelatedDocumentName,
          c.AlternateName AS RelatedAlternateName,
          c.DocumentDescription AS RelatedDocumentDescription,
          c.CreatedOn AS RelatedCreatedOn,
          c.CreatedByUserKey AS RelatedCreatedByUserKey,
          c.UpdatedOn AS RelatedUpdatedOn,
          c.UpdatedByUserKey AS RelatedUpdatedByUserKey,
          d.DocumentTypeName AS RelatedDocumentTypeName, 
          d.DocumentTypeDesc AS RelatedDocumentTypeDesc,
          d.DocumentIconURL AS RelatedDocumentIconURL,
          d.ShortcutIconURL AS RelatedShortcutIconURL
     FROM DocumentMain a INNER JOIN DocumentTypeRef b ON a.DocumentTypeCode = b.DocumentTypeCode
          LEFT OUTER JOIN DocumentMain c ON a.RelatedDocumentVersionKey = c.DocumentVersionKey AND c.DocumentStatusCode IN (40,60)
          LEFT OUTER JOIN DocumentTypeRef d ON c.DocumentTypeCode = d.DocumentTypeCode
    WHERE a.DocumentKey = @documentKey
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentMainByPath]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentMainByPath]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

/*
Gets the document data for the document at the given path INCLUDING the blob. Security IS checked. The first 
segment of the documentPath should be the DocumentRoot name. The last segment should be the DocumentName
Individual segments are separated by the forward slash (/) 
*/
CREATE PROC [dbo].[asi_DocumentMainByPath]
   @documentPath nvarchar(2000),
   @organizationKey uniqueidentifier,
   @userKey uniqueidentifier,
   @loggedInUserGroupKey uniqueidentifier = '00000000-0000-0000-0000-000000000000', -- if this is empty, we assume the user is not logged in
   @publishedOnly bit = 0,
   @ignoreLicensing bit = 0
AS
BEGIN
   DECLARE 
      @rootHierarchyKey uniqueidentifier,
      @hierarchyKey uniqueidentifier,
      @documentVersionKey uniqueidentifier,
      @documentKey uniqueidentifier

   EXEC asi_DocumentKeysByPath @documentPath, @organizationKey, @userKey, @loggedInUserGroupKey, @ignoreLicensing, @rootHierarchyKey out, @hierarchyKey out, @documentVersionKey out, @documentKey out

   IF @documentVersionKey IS NOT NULL
      SELECT TOP 1
             a.Blob,
             a.DocumentKey,
             a.DocumentVersionKey,
             a.DocumentStatusCode,
             a.DocumentName,
             a.AlternateName,
             a.DocumentDescription,
             a.DocumentTypeCode,
             a.IsSystem,
             a.ContainsChildrenFlag,
             a.AccessKey,
             a.DefaultChildAccessKey,
             a.StatusUpdatedOn,
             a.StatusUpdatedByUserKey,
             a.CreatedOn,
             a.CreatedByUserKey,
             a.UpdatedOn,
             a.UpdatedByUserKey,
             b.DocumentTypeName, 
             b.DocumentTypeDesc,
             b.DocumentIconURL,
             @hierarchyKey AS HierarchyKey
        FROM DocumentMain a 
             INNER JOIN DocumentTypeRef b on a.DocumentTypeCode = b.DocumentTypeCode
       WHERE a.DocumentVersionKey = @documentVersionKey
         AND (a.DocumentStatusCode IN (40,60) OR @publishedOnly = 0)
         AND EXISTS(
             SELECT 1 
               FROM AccessItem INNER JOIN UserToken ON AccessItem.Grantee = UserToken.Grantee OR AccessItem.Grantee = @loggedInUserGroupKey
              WHERE AccessItem.AccessKey = a.AccessKey 
                AND UserToken.UserKey = @userKey)
       ORDER BY a.UpdatedOn DESC, a.DocumentStatusCode ASC
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentMainGetPublishedWebsites]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentMainGetPublishedWebsites]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_DocumentMainGetPublishedWebsites]
AS
BEGIN
    SELECT [AlternateName], [DocumentVersionKey]
    FROM [dbo].[DocumentMain]
    WHERE [DocumentTypeCode] = N'WEB'
    AND [DocumentStatusCode] = 40
    ORDER BY [AlternateName]
END
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentMainListByParentHierarchyKey]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentMainListByParentHierarchyKey]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

/*
Retrieves a list of Documents under a particular folder by the folder's HierarchyKey. Security IS enforced.

Returns:
Everything from the DocumentMain table except the blob. Also includes DocumentTypeName, DocumentTypeDesc, 
and DocumentIconURL from DocumentTypeRef and HierarchyKey from the Hierarchy element representing the document.
*/
CREATE PROC [dbo].[asi_DocumentMainListByParentHierarchyKey]
   @parentHierarchyKey uniqueidentifier,
   @userKey uniqueidentifier,
   @loggedInUserGroupKey uniqueidentifier = '00000000-0000-0000-0000-000000000000', -- if this is empty, we assume the user is not logged in
   @publishedOnly bit = 0,
   @ignoreLicensing bit = 0
AS
BEGIN
   DECLARE @parentHierarchyKeyCopy uniqueidentifier;
   SET @parentHierarchyKeyCopy = @parentHierarchyKey
  
   DECLARE @t1 TABLE(
          HierarchyKey uniqueidentifier,
          DocumentKey uniqueidentifier,
          DocumentVersionKey uniqueidentifier,
          DocumentStatusCode int,
          DocumentName nvarchar(100),
          AlternateName nvarchar(100),
          DocumentDescription nvarchar(250),
          DocumentTypeCode nvarchar(3),
          IsSystem bit,
          ContainsChildrenFlag bit,
          RelatedDocumentVersionKey uniqueidentifier,
          AccessKey uniqueidentifier,
          DefaultChildAccessKey uniqueidentifier,
          StatusUpdatedOn datetime,
          StatusUpdatedByUserKey uniqueidentifier,
          CreatedOn datetime,
          CreatedByUserKey uniqueidentifier,
          UpdatedOn datetime,
          UpdatedByUserKey uniqueidentifier,
          DocumentTypeName nvarchar(255), 
          DocumentTypeDesc nvarchar(100),
          DocumentIconURL nvarchar(256),
          RelatedDocumentKey uniqueidentifier,
          RelatedDocumentTypeCode nvarchar(3),
          RelatedDocumentName nvarchar(100),
          RelatedAlternateName nvarchar(100),
          RelatedDocumentDescription nvarchar(250),
          RelatedDocumentTypeName nvarchar(255), 
          RelatedDocumentTypeDesc nvarchar(100),
          RelatedDocumentIconURL nvarchar(256),
          RelatedShortcutIconURL nvarchar(256),
          RelatedDocumentStatusCode int,
          SortOrder int
   )
   
   INSERT INTO @t1
   SELECT a.HierarchyKey,
          b.DocumentKey,
          b.DocumentVersionKey,
          b.DocumentStatusCode,
          b.DocumentName,
          b.AlternateName,
          b.DocumentDescription,
          b.DocumentTypeCode,
          b.IsSystem,
          b.ContainsChildrenFlag,
          b.RelatedDocumentVersionKey,
          b.AccessKey,
          b.DefaultChildAccessKey,
          b.StatusUpdatedOn,
          b.StatusUpdatedByUserKey,
          b.CreatedOn,
          b.CreatedByUserKey,
          b.UpdatedOn,
          b.UpdatedByUserKey,
          c.DocumentTypeName, 
          c.DocumentTypeDesc,
          c.DocumentIconURL,
          d.DocumentKey AS RelatedDocumentKey,
          d.DocumentTypeCode AS RelatedDocumentTypeCode,
          d.DocumentName AS RelatedDocumentName,
          d.AlternateName AS RelatedAlternateName,
          d.DocumentDescription AS RelatedDocumentDescription,
          e.DocumentTypeName AS RelatedDocumentTypeName, 
          e.DocumentTypeDesc AS RelatedDocumentTypeDesc,
          e.DocumentIconURL AS RelatedDocumentIconURL,
          e.ShortcutIconURL AS RelatedShortcutIconURL,
          d.DocumentStatusCode AS RelatedDocumentStatusCode,
          a.SortOrder
     FROM [dbo].[Hierarchy] a INNER JOIN [dbo].[DocumentMain] b ON a.UniformKey = b.DocumentVersionKey
      INNER JOIN [dbo].[DocumentTypeRef] c ON b.DocumentTypeCode = c.DocumentTypeCode
          LEFT OUTER JOIN [dbo].[DocumentMain] d ON b.RelatedDocumentVersionKey = d.DocumentVersionKey
          LEFT OUTER JOIN [dbo].[DocumentTypeRef] e ON d.DocumentTypeCode = e.DocumentTypeCode
    WHERE a.ParentHierarchyKey = @parentHierarchyKeyCopy
    
    SELECT  
          HierarchyKey,
          DocumentKey,
          DocumentVersionKey,
          DocumentStatusCode,
          DocumentName,
          AlternateName,
          DocumentDescription,
          DocumentTypeCode,
          IsSystem,
          ContainsChildrenFlag,
          RelatedDocumentVersionKey,
          AccessKey,
          DefaultChildAccessKey,
          StatusUpdatedOn,
          StatusUpdatedByUserKey,
          CreatedOn,
          CreatedByUserKey,
          UpdatedOn,
          UpdatedByUserKey,
          DocumentTypeName, 
          DocumentTypeDesc,
          DocumentIconURL,
          RelatedDocumentKey,
          RelatedDocumentTypeCode,
          RelatedDocumentName,
          RelatedAlternateName,
          RelatedDocumentDescription,
          RelatedDocumentTypeName, 
          RelatedDocumentTypeDesc,
          RelatedDocumentIconURL,
          RelatedShortcutIconURL
     FROM @t1 t
    WHERE ((t.DocumentStatusCode IN (10,20,30,70) AND @publishedOnly = 0)
       OR (t.DocumentStatusCode IN (40,60) 
      AND (@publishedOnly = 1
       OR NOT EXISTS (
          SELECT 1
            FROM [dbo].[DocumentMain] f
           WHERE f.DocumentVersionKey = t.DocumentVersionKey
             AND f.DocumentStatusCode IN (10,20,30,70)))))
      AND ((t.RelatedDocumentStatusCode IN (10,20,30,70) AND @publishedOnly = 0)
       OR t.RelatedDocumentStatusCode IS NULL
       OR (t.RelatedDocumentStatusCode IN (40,60) 
      AND (@publishedOnly = 1
       OR NOT EXISTS (
          SELECT 1
            FROM [dbo].[DocumentMain] g
           WHERE g.DocumentVersionKey = t.RelatedDocumentVersionKey
             AND g.DocumentStatusCode IN (10,20,30,70)))))
      AND EXISTS(
          SELECT 1 
            FROM [dbo].[AccessItem] INNER JOIN [dbo].[UserToken] ON AccessItem.Grantee = UserToken.Grantee OR AccessItem.Grantee = @loggedInUserGroupKey
           WHERE AccessItem.AccessKey = t.AccessKey 
             AND UserToken.UserKey=@userKey 
             AND (AccessItem.Permission&3)>0)
      AND (@ignoreLicensing = 1
       OR NOT EXISTS (SELECT 1 FROM UniformLicense WHERE UniformKey = DocumentVersionKey)
         OR EXISTS(
          SELECT 1 
            FROM [dbo].[UniformLicense] INNER JOIN [dbo].[LicenseLegacyList] l ON UniformLicense.LicenseKey = l.LicenseLegacyKey
           WHERE UniformLicense.UniformKey = DocumentVersionKey))
    ORDER BY SortOrder, DocumentName
END



GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentMainListByParentPath]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentMainListByParentPath]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

/*
Given a path to a folder, returns all documents in that folder. Security IS checked. The first 
segment of the documentPath should be the DocumentRoot name. The last segment should be the DocumentName of the folder
for which contents are desired. Individual segments are separated by the forward slash (/) 

Returns:
Everything from the DocumentMain table except the blob. Also includes DocumentTypeName, DocumentTypeDesc, 
and DocumentIconURL from DocumentTypeRef and HierarchyKey from the Hierarchy element representing the document.
*/
CREATE PROC [dbo].[asi_DocumentMainListByParentPath]
   @documentPath nvarchar(2000),
   @organizationKey uniqueidentifier,
   @userKey uniqueidentifier,
   @loggedInUserGroupKey uniqueidentifier = '00000000-0000-0000-0000-000000000000', -- if this is empty, we assume the user is not logged in
   @publishedOnly bit = 0,
   @ignoreLicensing bit = 0
AS
BEGIN
   DECLARE
      @rootHierarchyKey uniqueidentifier,
      @hierarchyKey uniqueidentifier,
      @documentVersionKey uniqueidentifier,
      @documentKey uniqueidentifier

   EXEC asi_DocumentKeysByPath @documentPath, @organizationKey, @userKey, @loggedInUserGroupKey, @ignoreLicensing, @rootHierarchyKey out, @hierarchyKey out, @documentVersionKey out, @documentKey out

   EXEC asi_DocumentMainListByParentHierarchyKey @hierarchyKey, @userKey, @loggedInUserGroupKey, @publishedOnly, @ignoreLicensing
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentMove]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentMove]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- moves the document given by key into the folder given by FolderHierarchyKey
-- Key is either a documentVersionKey for documents, or a HierarchyKey for folders.
CREATE PROCEDURE [dbo].[asi_DocumentMove]
   @folderHierarchyKey uniqueidentifier,
   @key uniqueidentifier
AS
BEGIN
   DECLARE 
      @documentVersionKey uniqueidentifier,
      @newHierarchyKey uniqueidentifier,
      @oldHierarchyKey uniqueidentifier,
      @childDocumentVersionKey uniqueidentifier,
      @documentTypeCode nchar(3)

   -- get the HierarchyKey to where it is currently linked, should be only one.  Also grab
   -- document type.  For folders, the key sent will be a hierarchy key
   SELECT TOP 1
          @oldHierarchyKey = a.HierarchyKey, 
          @documentTypeCode = b.DocumentTypeCode, 
          @documentVersionKey = b.DocumentVersionKey
     FROM Hierarchy a INNER JOIN DocumentMain b ON a.UniformKey = b.DocumentVersionKey
    WHERE b.DocumentVersionKey = @key
       OR a.HierarchyKey = @key
    ORDER BY b.UpdatedOn DESC, b.DocumentStatusCode ASC

   -- link the document into its new position
   exec asi_DocumentLinkDocumentOut @folderHierarchyKey, @documentVersionKey,@newHierarchyKey OUTPUT

   -- put out the new HierarchyKey so caller can get it
   SELECT @newHierarchyKey AS HierarchyKey

   -- if it is a folder, loop thru all of the children and move them as well, recursively
   IF @documentTypeCode = 'FOL'
   BEGIN
      SET ROWCOUNT 1
      SELECT @childDocumentVersionKey = UniformKey FROM Hierarchy WHERE ParentHierarchyKey = @oldHierarchyKey
      WHILE @@ROWCOUNT = 1
      BEGIN
         SET ROWCOUNT 0
         exec asi_DocumentMove @newHierarchyKey, @childDocumentVersionKey

         SET ROWCOUNT 1
         SELECT @childDocumentVersionKey = UniformKey FROM Hierarchy WHERE ParentHierarchyKey = @oldHierarchyKey
      END
      SET ROWCOUNT 0
   END

   -- remove the link to where is used to be
   DELETE FROM Hierarchy WHERE HierarchyKey = @oldHierarchyKey
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentPathByHierarchyKeyOut]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentPathByHierarchyKeyOut]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- Given a HierarchyKey returns the full path to the document starting with the root name.  The path is in
-- slash notation.  Like $/Common/Business Objects/DocumentType
CREATE PROCEDURE [dbo].[asi_DocumentPathByHierarchyKeyOut]
   @hierarchyKey uniqueidentifier,
   @path nvarchar(4000) OUT,
   @excludeDocument bit = 0,
   @publishedOnly bit = 0
AS
BEGIN
DECLARE 
   @rootHierarchyKey uniqueidentifier,
   @documentFound bit,
   @continue int

   SET NOCOUNT ON

   SET @path = ''
   SET @documentFound = 0
   SET @continue = 1

   SELECT @rootHierarchyKey = RootHierarchyKey
     FROM Hierarchy
    WHERE HierarchyKey = @hierarchyKey

   WHILE @hierarchyKey is not null AND @hierarchyKey <> @rootHierarchyKey AND @continue > 0
   BEGIN
      SELECT TOP 1
             @path = DocumentMain.DocumentName + CASE WHEN LEN(@path) > 0 THEN '/' + @path ELSE '' END,
             @hierarchyKey = Hierarchy.ParentHierarchyKey,
             @rootHierarchyKey = Hierarchy.RootHierarchyKey
        FROM Hierarchy INNER JOIN DocumentMain on Hierarchy.UniformKey = DocumentMain.DocumentVersionKey
       WHERE Hierarchy.HierarchyKey = @hierarchyKey
         AND (DocumentMain.DocumentStatusCode IN (40,60) OR @publishedOnly = 0)
       ORDER BY DocumentMain.DocumentStatusCode ASC, DocumentMain.UpdatedOn DESC

      SET @continue = @@ROWCOUNT

      IF @documentFound = 0 AND @excludeDocument = 1
      BEGIN
         SET @documentFound = 1
         SET @path = ''
      END
   END

   SET NOCOUNT OFF

   SELECT @path = HierarchyRootName + CASE WHEN LEN(@path) > 0 THEN '/' + @path ELSE '' END
     FROM HierarchyRoot
    WHERE RootHierarchyKey = @rootHierarchyKey
END


GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentPathByHierarchyKey]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentPathByHierarchyKey]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- Given a HierarchyKey returns the full path to the document starting with the root name.  The path is in
-- slash notation.  Like $/Common/Business Objects/DocumentType
CREATE PROCEDURE [dbo].[asi_DocumentPathByHierarchyKey]
   @hierarchyKey uniqueidentifier,
   @publishedOnly bit = 0
AS
BEGIN
DECLARE 
   @path nvarchar(4000)

   EXEC asi_DocumentPathByHierarchyKeyOut @hierarchyKey, @path OUT, 0, @publishedOnly

   SELECT @path AS Path
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentPathByKey]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentPathByKey]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_DocumentPathByKey]
   @key uniqueidentifier,
   @organizationKey uniqueidentifier OUT,
   @publishedOnly bit = 0
AS
BEGIN
   DECLARE @hierarchyKey uniqueidentifier, @rootHierarchyKey uniqueidentifier, @documentName nvarchar(100), @path nvarchar(4000)

   SELECT TOP 1 @hierarchyKey = HierarchyKey, @organizationKey = OrganizationKey,
          @documentName = DocumentName, @rootHierarchyKey = RootHierarchyKey
     FROM (
     SELECT Hierarchy.HierarchyKey, HierarchyRoot.OrganizationKey, HierarchyRoot.HierarchyRootName, DocumentMain.DocumentName,
            Hierarchy.RootHierarchyKey, DocumentMain.DocumentStatusCode, DocumentMain.UpdatedOn
     FROM Hierarchy 
          INNER JOIN HierarchyRoot on Hierarchy.RootHierarchyKey = HierarchyRoot.RootHierarchyKey
          INNER JOIN DocumentMain on Hierarchy.UniformKey = DocumentMain.DocumentVersionKey
          WHERE DocumentMain.DocumentKey = @key
     UNION
     SELECT Hierarchy.HierarchyKey, HierarchyRoot.OrganizationKey, HierarchyRoot.HierarchyRootName, DocumentMain.DocumentName,
          Hierarchy.RootHierarchyKey, DocumentMain.DocumentStatusCode, DocumentMain.UpdatedOn
     FROM Hierarchy inner join HierarchyRoot on Hierarchy.RootHierarchyKey = HierarchyRoot.RootHierarchyKey
          inner join DocumentMain on Hierarchy.UniformKey = DocumentMain.DocumentVersionKey
          WHERE Hierarchy.UniformKey = @key
     ) a
    WHERE (DocumentStatusCode IN (40,60) OR @publishedOnly = 0)
          AND HierarchyRootName <> '.'
    ORDER BY UpdatedOn DESC, DocumentStatusCode ASC

   IF @@ROWCOUNT > 0
   BEGIN
      exec asi_DocumentPathByHierarchyKeyOut @hierarchyKey, @path OUT, 1, @publishedOnly
      IF @hierarchyKey <> @rootHierarchyKey
         SET @path = @path + '/' + @documentName     
   END

   SELECT @path AS Path
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DocumentPurgeArchivedVersions]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DocumentPurgeArchivedVersions]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


-- Purge all archived versions of a specified document (or of all documents)
CREATE PROCEDURE [dbo].[asi_DocumentPurgeArchivedVersions] 
    @documentVersionKey uniqueidentifier,
    @allDocuments bit = 0 -- Pass any GUID if this is set to 1, as the document version key is ignored
AS
BEGIN
    SET NOCOUNT ON
    DECLARE @documentsToDelete TABLE (DocumentKey uniqueidentifier, 
                                      DocumentVersionKey uniqueidentifier, 
                                      AccessKey uniqueidentifier, 
                                      PublishedVersionExists bit)
    INSERT INTO @documentsToDelete
    SELECT d.DocumentKey, d.DocumentVersionKey, d.AccessKey, 0
      FROM DocumentMain d
     WHERE DocumentStatusCode IN (50, 80)
           AND NOT EXISTS (SELECT 1 FROM DocumentTypeRef WHERE PublishWorkflowDocumentKey = d.DocumentKey)
           AND NOT EXISTS (SELECT 1 FROM DocumentTypeRef WHERE RecycleWorkflowDocumentKey = d.DocumentKey)
           AND NOT EXISTS (SELECT 1 FROM GroupTypeRef WHERE MemberQueryFolderKey = d.DocumentKey)
           AND NOT EXISTS (SELECT 1 FROM PackageQueue WHERE QueueReleaseWorkflowKey = d.DocumentKey)
           AND NOT EXISTS (SELECT 1 FROM RFMDefinition WHERE TransactionDocumentKey = d.DocumentKey)
           AND NOT EXISTS (SELECT 1 FROM RFMDefinition WHERE UserDocumentKey = d.DocumentKey)
           AND NOT EXISTS (SELECT 1 FROM WorkItem WHERE ProcessEngineKey = d.DocumentKey)
           AND NOT EXISTS (SELECT 1 FROM WorkItem WHERE WorkflowDefinitionKey = d.DocumentKey)
    AND (@allDocuments = 1 OR d.DocumentVersionKey = @documentVersionKey)

    UPDATE d
       SET PublishedVersionExists = 1
      FROM @documentsToDelete d
    WHERE EXISTS (SELECT 1 FROM DocumentMain x WHERE d.DocumentVersionKey = x.DocumentVersionKey AND x.DocumentStatusCode = 40)

    -- Delete unpublished documents from the PublishRequest and PublishRequestDetail tables
    DELETE p 
      FROM PublishRequest p
           INNER JOIN @documentsToDelete dtd ON p.DocumentKey = dtd.DocumentKey
    DELETE p 
      FROM PublishRequestDetail p
           INNER JOIN @documentsToDelete dtd ON p.ContentDocumentKey = dtd.DocumentKey 

    -- Delete the unpublished documents
    DELETE d
      FROM [dbo].[DocumentMain] d
           INNER JOIN @documentsToDelete dtd ON d.DocumentKey = dtd.DocumentKey
           
    -- Delete any unused hierarchy and access keys
    DELETE h
      FROM Hierarchy h 
           INNER JOIN @documentsToDelete dtd ON h.UniformKey = dtd.DocumentVersionKey AND h.UniformType = 'DocumentVersion'
    WHERE h.UniformKey NOT IN (SELECT DocumentVersionKey FROM DocumentMain) 
           AND h.HierarchyKey NOT IN (SELECT ParentHierarchyKey FROM Hierarchy)
    DELETE ai
      FROM [dbo].[AccessItem] ai
           INNER JOIN [dbo].[AccessMain] am ON ai.AccessKey = am.AccessKey 
           INNER JOIN @documentsToDelete dtd ON ai.AccessKey = dtd.AccessKey 
     WHERE dtd.PublishedVersionExists = 0 AND am.AccessScope = 'Local'
           AND NOT EXISTS (SELECT 1 FROM DocumentMain WHERE AccessKey = am.AccessKey AND DocumentKey != dtd.DocumentKey)
    DELETE am
      FROM [dbo].[AccessMain] am
           INNER JOIN @documentsToDelete dtd ON am.AccessKey = dtd.AccessKey 
     WHERE dtd.PublishedVersionExists = 0 AND am.AccessScope = 'Local'
           AND NOT EXISTS (SELECT 1 FROM DocumentMain WHERE AccessKey = am.AccessKey AND DocumentKey != dtd.DocumentKey)
END



GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_DropNameAllView]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_DropNameAllView]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- Author:		Paul Bradshaw
-- Create date: Jan 30th, 2007
-- Description:	Drop the Name_All View
-- =============================================
CREATE PROCEDURE asi_DropNameAllView 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	IF EXISTS (SELECT 1 FROM sysobjects WHERE name = 'Name_All' AND type = 'V')
		DROP VIEW Name_All
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_EnsurePublishQueueAndServiceBroker]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_EnsurePublishQueueAndServiceBroker]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


-----------------------------------------------
-- Create Publish Queue and enable the Broker
-----------------------------------------------
CREATE PROCEDURE [dbo].[asi_EnsurePublishQueueAndServiceBroker]
AS
BEGIN
    DECLARE @dbname sysname;
    DECLARE @sql nvarchar(500);
    SELECT @dbname = DB_NAME();
    IF (SELECT is_broker_enabled FROM sys.databases WHERE name = @dbname) <> 1
    BEGIN
        BEGIN TRY
            SET @sql = N'ALTER DATABASE ' + @dbname + N' SET ENABLE_BROKER WITH ROLLBACK IMMEDIATE';
            EXEC sp_executesql @sql;
        END TRY
        BEGIN CATCH
            SET @sql = N'ALTER DATABASE ' + @dbname + N' SET NEW_BROKER WITH ROLLBACK IMMEDIATE';
            EXEC sp_executesql @sql;
        END CATCH;
    END

    IF NOT EXISTS (SELECT * FROM sys.services WHERE name = N'iMISPublishService')
    BEGIN
        CREATE QUEUE iMISPublishQueue;
    END

    IF NOT EXISTS (SELECT * FROM sys.service_queues WHERE name = N'iMISPublishQueue')
    BEGIN
        CREATE SERVICE iMISPublishService 
            ON QUEUE iMISPublishQueue ([http://schemas.microsoft.com/SQL/Notifications/PostQueryNotification]);
    END
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_eSeriesInitialSettings]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_eSeriesInitialSettings]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_eSeriesInitialSettings] 
      @RootPath varchar(100),
      @VirtualDirectory varchar(100),
      @EmailAddress varchar(100),
      @OrganizationName varchar(100),
      @OrganizationAbbrev varchar(100),
      @WebCustomerType varchar(5)
AS
BEGIN
   UPDATE System_Variable
      SET Value = @VirtualDirectory
    WHERE Name = 'VirtualDirectoryPath'

   UPDATE System_Variable
      SET Value = @RootPath
    WHERE Name in ('RootPath', 'SecurePath')
   
   UPDATE Website
      SET DefaultSectionURL = REPLACE(DefaultSectionURL,WebsiteRootURL,@RootPath)
    WHERE IsiMISWebsite = 0
 
   UPDATE Website
      SET WebsiteRootURL = @RootPath,
          SecureWebsiteRootURL = @RootPath
    WHERE IsiMISWebsite = 0

          
   UPDATE SystemConfig
      SET ParameterValue = @EmailAddress
    WHERE ParameterName in (
			'CompanySearchCreateAccountNotification',
			'SendToEmailOnAccountUpdate',
			'ContactUsEmailFrom',
			'ContactUsEmailTo',
			'Webmaster',
			'CreateAccountEmailFrom',
			'BasicFormEmailTo',
			'NoReplyOrganizationEmailAddress',
			'NewUserAddedFromEventRegistrationEmailTo',
			'EmailToSubmitComments',
			'OrderWebmaster',
			'BillingMembershipContactEmailAddress',
			'LogonChangesEmailFrom',
			'EmailFrom',
			'ProductSaleEmailTo')

   UPDATE SystemConfig
      SET ParameterValue = @OrganizationName
    WHERE ParameterName = 'OrganizationName'

   UPDATE SystemConfig
      SET ParameterValue = @OrganizationAbbrev
    WHERE ParameterName = 'OrganizationAbbrev'

   UPDATE SystemConfig
      SET ParameterValue = @VirtualDirectory + '/Images/'
    WHERE ParameterName = 'ImagesPath'

   UPDATE System_Params
      SET ShortValue = @WebCustomerType
    WHERE ParameterName = 'Member_Control.AnonymousSignUpMemberType'

   IF @@ROWCOUNT = 0
      INSERT INTO System_Params(ParameterName, ShortValue) VALUES ('Member_Control.AnonymousSignUpMemberType', @WebCustomerType)

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ExportTypeByKey]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ExportTypeByKey]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_ExportTypeByKey    Script Date: 7/3/2003 4:58:03 PM ******/
CREATE   PROC [dbo].[asi_ExportTypeByKey]
	@typeKey uniqueidentifier
	AS
BEGIN
	SET ROWCOUNT 1
	SELECT	e.Name as ExportTypeName ,e.ExportType, e.NavMarker, e.ProcessEngineTypeKey, p.Name

	 FROM	ExportType e, ProcessEngineType p
			
	 WHERE	e.ExportTypeKey = @typeKey 
		and e.ProcessEngineTypeKey = p.ProcessEngineTypeKey
	SET ROWCOUNT 0
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ExportTypes]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ExportTypes]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_ExportTypes    Script Date: 7/3/2003 4:58:03 PM ******/
CREATE   PROC asi_ExportTypes
	AS
BEGIN
	select ExportTypeKey, ExportType, Name, NavMarker, ProcessEngineTypeKey from ExportType
	
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_FindLastReceiptDateForContact]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_FindLastReceiptDateForContact]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_FindLastReceiptDateForContact]
@contactKey uniqueidentifier

 AS

SELECT TOP 1 r.IssuedOn FROM ReceiptMain r
 WHERE r.IssuedToContactKey = @contactKey
 ORDER BY r.IssuedOn DESC

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_FindUnreceiptedPayments]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_FindUnreceiptedPayments]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_FindUnreceiptedPayments]
@contactKey uniqueidentifier

 AS

SELECT * FROM PaymentMain p
 LEFT OUTER JOIN ReceiptLine rl on p.PaymentKey = rl.PaymentKey
 WHERE p.PayorContactKey = @contactKey
 AND  rl.ReceiptLineKey is null

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_FixDuplicateIndividualRows]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_FixDuplicateIndividualRows]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_FixDuplicateIndividualRows]
AS
BEGIN
    BEGIN TRANSACTION
    -- Fix up the problem caused by converting a "CM" record with two ContactMain records
    -- to a "M" record, which leaves two Individual records associated with the same Name record
    DECLARE @cleanupTable TABLE (ContactKey uniqueidentifier)
    DECLARE @udpateTable TABLE (ContactKey uniqueidentifier)

    INSERT INTO @cleanupTable  -- Get a list of extraneous individual records
    SELECT a.ContactKey FROM ContactMain a INNER JOIN ContactMain b ON a.SyncContactID = b.SyncContactID
    WHERE a.ContactKey != b.ContactKey AND a.IsInstitute = 0 AND b.IsInstitute = 0 AND a.SyncContactID != b.ID

    INSERT INTO @udpateTable  -- Get a list of individual record IDs that need to be updated
    SELECT a.ContactKey FROM ContactMain a INNER JOIN ContactMain b ON a.SyncContactID = b.SyncContactID
    WHERE a.ContactKey != b.ContactKey AND a.IsInstitute = 0 AND b.IsInstitute = 0 AND a.ID != b.SyncContactID

     -- Delete extraneous Individual record
    IF EXISTS (SELECT 1 FROM @cleanupTable)
    BEGIN
        UPDATE a
           SET ContactStatusCode = d.ContactStatusCode,
               UpdatedByUserKey = c.UserKey,
               UpdatedOn = GETDATE(),
               SyncContactID = NULL, 
               ID = NULL
          FROM ContactMain a INNER JOIN @cleanupTable b ON a.ContactKey = b.ContactKey
                             INNER JOIN UserMain c ON c.UserId = 'MANAGER'
                             INNER JOIN ContactStatusRef d ON d.ContactStatusDesc = 'Delete' AND d.IsSystem = 1
    END

    -- Correct the ID on the remaining Individual record
    IF EXISTS (SELECT 1 FROM @udpateTable)
    BEGIN
        UPDATE a
           SET a.ID = a.SyncContactID
          FROM ContactMain a INNER JOIN @udpateTable b ON a.ContactKey = b.ContactKey
    END

    COMMIT TRANSACTION
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_FixDuplicateIndividualRowsById]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_FixDuplicateIndividualRowsById]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_FixDuplicateIndividualRowsById]
	@id varchar(10)
AS
BEGIN
    BEGIN TRANSACTION
    -- Fix up the problem caused by converting a "CM" record with two ContactMain records
    -- to a "M" record, which leaves two Individual records associated with the same Name record
    DECLARE @cleanupTable TABLE (ContactKey uniqueidentifier)
    DECLARE @udpateTable TABLE (ContactKey uniqueidentifier)

    INSERT INTO @cleanupTable  -- Get a list of extraneous individual records
        SELECT a.ContactKey FROM ContactMain a INNER JOIN ContactMain b ON a.SyncContactID = b.SyncContactID
         WHERE a.ContactKey != b.ContactKey AND a.IsInstitute = 0 AND b.IsInstitute = 0 AND a.SyncContactID != b.ID
               AND (a.SyncContactID = @id OR a.ID = @id)

    INSERT INTO @udpateTable  -- Get a list of individual record IDs that need to be updated
        SELECT a.ContactKey FROM ContactMain a INNER JOIN ContactMain b ON a.SyncContactID = b.SyncContactID
         WHERE a.ContactKey != b.ContactKey AND a.IsInstitute = 0 AND b.IsInstitute = 0 AND a.ID != b.SyncContactID 
               AND (a.SyncContactID = @id OR a.ID = @id)

     -- Delete extraneous Individual record
    IF EXISTS (SELECT 1 FROM @cleanupTable)
    BEGIN
        UPDATE a
           SET ContactStatusCode = d.ContactStatusCode,
               UpdatedByUserKey = c.UserKey,
               UpdatedOn = GETDATE(),
               SyncContactID = NULL, 
               ID = NULL
          FROM ContactMain a INNER JOIN @cleanupTable b ON a.ContactKey = b.ContactKey
                             INNER JOIN UserMain c ON c.UserId = 'MANAGER'
                             INNER JOIN ContactStatusRef d ON d.ContactStatusDesc = 'Delete' AND d.IsSystem = 1
    END

    -- Correct the ID on the remaining Individual record
    IF EXISTS (SELECT 1 FROM @udpateTable)
    BEGIN
        UPDATE a
           SET a.ID = a.SyncContactID
          FROM ContactMain a INNER JOIN @udpateTable b ON a.ContactKey = b.ContactKey
    END

    COMMIT TRANSACTION
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GenerateContactSalutation]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GenerateContactSalutation]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROC [dbo].[asi_GenerateContactSalutation] (@salutationKey uniqueidentifier)
AS
BEGIN

SET NOCOUNT ON

DECLARE @sql nvarchar(2000)
DECLARE @contactKey uniqueidentifier
DECLARE @IndividualFormula nvarchar(2000)
DECLARE @InstituteFormula nvarchar(2000)

DECLARE @calcFormula nvarchar(2000) 

DECLARE @tempKey uniqueidentifier
DECLARE @tempValue nvarchar(1000)


SELECT @IndividualFormula = IndividualFormula, @InstituteFormula = InstituteFormula
	FROM SalutationRef
	WHERE SalutationRef.SalutationKey=@salutationKey AND AutoCreateFlag = 1

IF @@ROWCOUNT = 0
    RETURN

DECLARE theContactCursor CURSOR FAST_FORWARD FOR 
	SELECT ContactKey
		FROM vBoContact

OPEN theContactCursor
FETCH NEXT FROM theContactCursor INTO @contactKey

WHILE @@FETCH_STATUS = 0 -- spin through Contact entries
BEGIN

	SET @tempKey = newid()

	SELECT @sql =  
		CASE 
		WHEN IsInstitute = 1 THEN
			' asi_ProcessFormulaOutput ' 
				+ '''' + convert (nvarchar(100), @tempKey) + ''', '
				+ '''' + @InstituteFormula + ''', '
				+ '''Institute'', ''ContactKey'', ' 
				+ '''' + convert (nvarchar(50), @contactKey) 
				+ ''''

		WHEN IsInstitute = 0 THEN
			' asi_ProcessFormulaOutput ' 
				+ '''' + convert (nvarchar(100), @tempKey) + ''', '
				+ '''' + @IndividualFormula + ''', '
				+ '''Individual'', ''ContactKey'', ' 
				+ '''' + convert (nvarchar(50), @contactKey) 
				+ ''''
		END
	FROM ContactMain WHERE ContactKey = @contactKey

	EXEC (@sql)

	SELECT @tempValue = tempValue 
		FROM tempFormula
		WHERE tempKey = @tempKey

	IF @tempValue IS NOT NULL AND datalength (@tempValue) > 0 
	BEGIN
		IF not exists (SELECT 1 FROM vBoContactSalutation 
				WHERE ContactKey = @contactKey and SalutationKey = @salutationKey)
		BEGIN
			INSERT vBoContactSalutation
				(ContactSalutationKey, IsOverridden, SalutationText, ContactKey, SalutationKey, IsDeletable)
			VALUES (@tempKey, 0, @tempValue, @contactKey, @salutationKey, 1)
		END
		ELSE
		BEGIN
			UPDATE vBoContactSalutation set IsDeletable = 1 WHERE ContactKey = @contactKey and SalutationKey = @salutationKey
		END
	END

	DELETE FROM tempFormula WHERE tempKey = @tempKey

	FETCH NEXT FROM theContactCursor INTO @contactKey
END  -- spin through Contact entries

CLOSE theContactCursor
deallocate theContactCursor

UPDATE SalutationRef SET NeedsGenerationFlag = 0 WHERE SalutationKey = @salutationKey

SET NOCOUNT OFF

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GenerateContactSalutations]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GenerateContactSalutations]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROC [dbo].[asi_GenerateContactSalutations]
AS
BEGIN

SET NOCOUNT ON

DECLARE @sql nvarchar(2000)
DECLARE @contactKey uniqueidentifier
DECLARE @salutationKey uniqueidentifier
DECLARE @IndividualFormula nvarchar(2000)
DECLARE @InstituteFormula nvarchar(2000)

DECLARE @calcFormula nvarchar(2000) 

DECLARE @tempKey uniqueidentifier
DECLARE @tempValue nvarchar(1000)


DECLARE theSalutationRefCursor CURSOR FAST_FORWARD FOR 
	SELECT SalutationKey, IndividualFormula, InstituteFormula
		FROM SalutationRef
		WHERE AutoCreateFlag = 1

OPEN theSalutationRefCursor
FETCH NEXT FROM theSalutationRefCursor INTO @salutationKey, @IndividualFormula, @InstituteFormula

WHILE @@FETCH_STATUS = 0 -- spin through SalutationRef entries
BEGIN

	DECLARE theContactCursor CURSOR FAST_FORWARD FOR 
		SELECT ContactKey FROM ContactMain

	OPEN theContactCursor
	FETCH NEXT FROM theContactCursor INTO @contactKey

	WHILE @@FETCH_STATUS = 0 -- spin through Contact entries
	BEGIN

		SET @tempKey = newid()

		SELECT @sql =  
			CASE 
			WHEN IsInstitute = 1 THEN
					' asi_ProcessContactFormulaOutput ' 
						+ '''' + convert (nvarchar(100), @tempKey) + ''', '
						+ '''' + @InstituteFormula + ''', '
						+ '''Institute'', ''ContactKey'', ' 
						+ '''' + convert (nvarchar(50), @contactKey) 
						+ ''''

			WHEN IsInstitute = 0 THEN
					' asi_ProcessContactFormulaOutput ' 
						+ '''' + convert (nvarchar(100), @tempKey) + ''', '
						+ '''' + @IndividualFormula + ''', '
						+ '''Individual'', ''ContactKey'', ' 
						+ '''' + convert (nvarchar(50), @contactKey) 
						+ ''''
			END
		FROM ContactMain WHERE ContactKey = @contactKey

		EXEC (@sql)

		SELECT @tempValue = tempValue FROM tempFormula
			WHERE tempKey = @tempKey

		IF datalength(@tempValue) > 0 AND @tempValue IS NOT NULL
		BEGIN
			IF NOT EXISTS (SELECT 1 FROM ContactSalutation 
						   WHERE ContactKey = @contactKey AND SalutationKey = @salutationKey)
			BEGIN
				INSERT ContactSalutation (ContactSalutationKey, IsOverridden, SalutationText, ContactKey, SalutationKey)
				VALUES (newid(), 0, @tempValue, @contactKey, @salutationKey)
			END
		END

		DELETE FROM tempFormula WHERE tempKey = @tempKey

		FETCH NEXT FROM theContactCursor INTO @contactKey
	END  -- spin through Contact entries

	CLOSE theContactCursor
	DEALLOCATE theContactCursor


	FETCH NEXT FROM theSalutationRefCursor INTO @salutationKey, @IndividualFormula, @InstituteFormula
END  -- spin through SalutationRef entries

CLOSE theSalutationRefCursor
DEALLOCATE theSalutationRefCursor

SET NOCOUNT OFF

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GenerateExpectedPaymentSet]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GenerateExpectedPaymentSet]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_GenerateExpectedPaymentSet]
    (@newExpectedPaymentSetKey uniqueidentifier, -- used if no existing row
     @monthYear datetime, -- Month/Year to generate payments for
     @userKey uniqueidentifier, -- user to log as CreateBy UpdatedBy
     @batchSize integer, -- number of payments to set at a time
     @doNotLoop bit, -- if set to 1 will process the first batch and exit
     @clearExistingValues bit,  -- set to 1 to clear existing values
     @updateHeaderFlag bit -- set to 1 if the procedure should update the header
     )
AS
BEGIN
    DECLARE @expectedPaymentSetKey uniqueidentifier
    DECLARE @foundExistingExpectedPaymentSet bit
    DECLARE @monthDay integer
    DECLARE @paymentMonth integer
    DECLARE @paymentYear integer
    DECLARE @monthYearEnd datetime
    DECLARE @setStatusComplete smallint
    DECLARE @setStatusGenerating smallint
    DECLARE @setStatusCompleteWithError smallint
    DECLARE @paymentStatusPending smallint
    DECLARE @paymentStatusAwaiting smallint
    DECLARE @paymentStatusProcessed smallint
    DECLARE @errorMessage NVARCHAR(4000);
    DECLARE @errorSeverity INT;
    DECLARE @errorState INT;
    
    -- turn row(s) affected messages off
    SET NOCOUNT ON

    -- VALIDATE - MonthYear must be at the start of the month
    SET @monthDay = DATEPART(DAY,@monthYear)
    
    IF @monthDay<>1
    BEGIN
        RAISERROR ( N'MonthYear Date must have day set to 1',16,1);
        RETURN
    END

    -- Get the date part values	
    SET @paymentMonth = DATEPART(MONTH,@monthYear)
    SET @paymentYear = DATEPART(YEAR,@monthYear)
    
    SET @monthYearEnd = DATEADD(MONTH,1,@monthYear)
    SET @monthYearEnd = DATEADD(DAY,-1,@monthYearEnd)
    
    -- variables for the expected set status values
    SET @setStatusComplete = 1
    SET @setStatusGenerating = 2
    SET @setStatusCompleteWithError = 3

    -- set the payment status values
    SET @paymentStatusPending = 1
    SET @paymentStatusAwaiting = 2
    SET @paymentStatusProcessed = 3
    
    -- Check value of Batch Size
    IF @batchSize <=0
        SET @batchSize = 50

    -- do we already have a row for this month/year
    IF EXISTS (SELECT 1	FROM RecurringDonationExpectedPaymentSet WHERE ExpectedPaymentDate=@monthYear)
    BEGIN
        SET @foundExistingExpectedPaymentSet = 1
        SELECT @expectedPaymentSetKey=[RecurringDonationExpectedPaymentSetKey]
          FROM [RecurringDonationExpectedPaymentSet]
         WHERE [ExpectedPaymentDate]=@monthYear
            
        -- if this isn't the GUID passed in raise an error
        IF @newExpectedPaymentSetKey <> @expectedPaymentSetKey
        BEGIN
            RAISERROR ( N'The ExpectedPaymentSetKey value passed into the Procedure does not match the existing ExpectedPaymentSetKey',16,1);
            RETURN
        END
    END
    ELSE
    BEGIN
        -- doesn't already exist so use the new key passed in
        SET @foundExistingExpectedPaymentSet = 0
        IF @newExpectedPaymentSetKey IS NOT NULL
            SET @expectedPaymentSetKey = @newExpectedPaymentSetKey
        ELSE
            SET @expectedPaymentSetKey = NEWID()
    END
    
    -- DROP THE EXISTING VALUES	
    IF @clearExistingValues = 1 AND @foundExistingExpectedPaymentSet = 1
    BEGIN

        BEGIN TRANSACTION
        
        DELETE 
          FROM [RecurringDonationExpectedPayment] 
         WHERE [RecurringDonationExpectedPaymentSetKey] = @expectedPaymentSetKey
               AND [RecurringDonationExpectedPaymentStatusCode] <> @paymentStatusProcessed
        
        COMMIT TRANSACTION
    END

    -- Identify the donations for this month/year            
    DECLARE @recurringDonationTable TABLE (
        [StartDate] datetime NOT NULL,
        [EndDate] datetime NULL,
        [RecurringDonationFrequencyCode] integer NOT NULL,
        [RecurringDonationCommitmentKey] uniqueidentifier NOT NULL
    )
     
    ;WITH RecurringDonationTable AS (     
        SELECT StartDate, EndDate, RecurringDonationFrequencyCode, RecurringDonationCommitmentKey 
          FROM RecurringDonationCommitment 
         WHERE CommitmentStatusInd='A' AND
               StartDate<=@monthYearEnd AND 
               (
                   EndDate IS NULL
               OR
                   EndDate>=@monthYear
               )
        UNION ALL      
        SELECT DATEADD(m, 12/RecurringDonationFrequencyCode, StartDate), EndDate, RecurringDonationFrequencyCode, RecurringDonationCommitmentKey 
          FROM RecurringDonationTable a
         WHERE DATEADD(m, 12/RecurringDonationFrequencyCode, StartDate) <= ISNULL(EndDate,@monthYearEnd)
               AND DATEADD(m, 12/RecurringDonationFrequencyCode, StartDate)<=@monthYearEnd 
    )
    INSERT INTO @recurringDonationTable (StartDate, EndDate, RecurringDonationFrequencyCode, RecurringDonationCommitmentKey)
    SELECT StartDate, EndDate, RecurringDonationFrequencyCode, RecurringDonationCommitmentKey 
      FROM RecurringDonationTable 
     WHERE StartDate<=@monthYearEnd AND StartDate>=@monthYear 
    OPTION (maxrecursion 0);

    -- Insert Header - we do this in a separate transaction so if the detail fails we can
    -- update the header with a completedWithError status
    BEGIN TRANSACTION

    BEGIN TRY

        IF @foundExistingExpectedPaymentSet = 0
        BEGIN
            INSERT INTO [dbo].[RecurringDonationExpectedPaymentSet] ([RecurringDonationExpectedPaymentSetKey], [ExpectedPaymentDate],
                                                                     [RecurringDonationExpectedPaymentSetStatusCode], [CreatedByUserKey], 
                                                                     [CreatedOn], [UpdatedByUserKey], [UpdatedOn])
             VALUES (@expectedPaymentSetKey, @monthYear, @setStatusGenerating, @userKey, GETDATE(), @userKey, GETDATE())
        END
        ELSE
        BEGIN
            UPDATE [dbo].[RecurringDonationExpectedPaymentSet] 
               SET [UpdatedByUserKey] = @userKey, [UpdatedOn] = GETDATE(), [RecurringDonationExpectedPaymentSetStatusCode] = @setStatusGenerating
             WHERE [RecurringDonationExpectedPaymentSetKey] = @expectedPaymentSetKey
        END
        
        IF @@TRANCOUNT > 0
            COMMIT TRANSACTION

    END TRY
    BEGIN CATCH
    
        IF @@TRANCOUNT > 0
            ROLLBACK TRANSACTION
        SELECT 
            @errorMessage = ERROR_MESSAGE(),
            @errorSeverity = ERROR_SEVERITY(),
            @errorState = ERROR_STATE();
        
        RAISERROR (@errorMessage, -- Message text.
               @errorSeverity, -- Severity.
               @errorState -- State.
               );
        
    END CATCH
    
    -- Now insert the expected payments rows
    BEGIN TRANSACTION
        
    BEGIN TRY
                
        DECLARE @isDone bit
        SET @isDone = 0
        WHILE (@isDone = 0)
        BEGIN

            INSERT INTO [dbo].[RecurringDonationExpectedPayment]([RecurringDonationExpectedPaymentKey], [RecurringDonationExpectedPaymentSetKey], 
                                                                 [RecurringDonationCommitmentKey], [OpportunityKey], [DonationAmount], [PaymentMethod], 
                                                                 [Distribution], [Appeal], [Campaign], [Fund], [Narrative], [MatchReference], [BranchSortCode],
                                                                 [BankAccountNumber], [BankAccountName], [ResultingTransNum], [ResultingTransLineNum],
                                                                 [RecurringDonationExpectedPaymentStatusCode], [CreatedByUserKey], [CreatedOn], [UpdatedByUserKey], [UpdatedOn])
             SELECT TOP (@batchSize) NEWID(), @expectedPaymentSetKey, c.RecurringDonationCommitmentKey, NULL, c.DonationAmount, c.PaymentMethod,
                  c.Distribution, c.Appeal, c.Campaign, c.Fund, N'', c.MatchReference, c.BranchSortCode, c.BankAccountNumber,
                                     c.BankAccountName, 0, 0, @paymentStatusAwaiting, @userKey, GETDATE(), @userKey, GETDATE()
               FROM RecurringDonationCommitment c
                    INNER JOIN @recurringDonationTable r ON c.RecurringDonationCommitmentKey = r.RecurringDonationCommitmentKey
                    LEFT OUTER JOIN RecurringDonationExpectedPayment e ON c.RecurringDonationCommitmentKey=e.RecurringDonationCommitmentKey 
                         AND e.[RecurringDonationExpectedPaymentSetKey] = @expectedPaymentSetKey				   
              WHERE e.RecurringDonationCommitmentKey IS NULL -- filter out the existing expected payments
             
             IF @@ROWCOUNT = 0
                 SET @isDone = 1

             IF @@TRANCOUNT > 0
                 COMMIT TRANSACTION
            
             IF @doNotLoop = 1
                 BREAK
        END -- WHILE
        
        -- Update the header to say the processing is complete
        IF @isDone = 1 AND @updateHeaderFlag=1
        BEGIN
            BEGIN TRANSACTION
            
            -- Update the header row to say we have finished generating
            UPDATE [dbo].[RecurringDonationExpectedPaymentSet] 
               SET [UpdatedByUserKey] = @userKey, [UpdatedOn] = GETDATE(), 
                   [RecurringDonationExpectedPaymentSetStatusCode] = @setStatusComplete
             WHERE [RecurringDonationExpectedPaymentSetKey] = @expectedPaymentSetKey
             IF @@TRANCOUNT > 0
                 COMMIT TRANSACTION

        END
        
    END TRY
    BEGIN CATCH
    
        IF @@TRANCOUNT > 0
            ROLLBACK TRANSACTION
   
        SELECT 
            @errorMessage = ERROR_MESSAGE(),
            @errorSeverity = ERROR_SEVERITY(),
            @errorState = ERROR_STATE();

        IF @updateHeaderFlag = 1
        BEGIN
            BEGIN TRANSACTION
            
            -- Update the header row to say we have finished with errors
            UPDATE [dbo].[RecurringDonationExpectedPaymentSet] 
               SET [UpdatedByUserKey] = @userKey, [UpdatedOn] = GETDATE(), 
                   [RecurringDonationExpectedPaymentSetStatusCode] = @setStatusCompleteWithError
             WHERE [RecurringDonationExpectedPaymentSetKey] = @expectedPaymentSetKey
             IF @@TRANCOUNT > 0
                 COMMIT TRANSACTION
        END
                
        RAISERROR (@errorMessage, -- Message text.
               @errorSeverity, -- Severity.
               @errorState -- State.
               );
        
    END CATCH
    
END




GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GenTableByTableNameAndValue]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GenTableByTableNameAndValue]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_GenTableByTableNameAndValue    Script Date: 7/3/2003 4:58:03 PM ******/
CREATE   PROC asi_GenTableByTableNameAndValue
@Code varchar(60),
@TableName varchar(30)

AS
BEGIN
	select * from Gen_Tables where TABLE_NAME = @TableName and ((CODE = @Code) or (SUBSTITUTE = @Code) or (UPPER_CODE = @Code))
	
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetAccessArea]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetAccessArea]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_GetAccessArea    Script Date: 7/3/2003 4:58:03 PM ******/
CREATE PROCEDURE dbo.asi_GetAccessArea
	@navmarker varchar(36),
	@pageset varchar(36) = null
AS

select AccessAreaKey
from NavigationMain
where Marker = @navmarker
and PageSet = ISNULL(@pageset, ' ')

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetAccessKeyReferences]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetAccessKeyReferences]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_GetAccessKeyReferences]
    @accessKey uniqueidentifier
AS
BEGIN
	DECLARE @tableName nvarchar(255)
	DECLARE @columnName nvarchar(255)
	DECLARE @sql nvarchar(4000)
	DECLARE @results table (UserKey uniqueidentifier, TableName nvarchar(255), ColumnName nvarchar(255))
	DECLARE @exists bit
	DECLARE theCursor CURSOR FAST_FORWARD FOR
		SELECT isc.TABLE_NAME, isc.COLUMN_NAME from INFORMATION_SCHEMA.COLUMNS isc INNER JOIN INFORMATION_SCHEMA.TABLES ist ON isc.TABLE_NAME = ist.TABLE_NAME
		WHERE isc.COLUMN_NAME like '%AccessKey' AND isc.DATA_TYPE = 'uniqueidentifier' AND ist.TABLE_TYPE = 'BASE TABLE' AND ist.TABLE_SCHEMA = 'dbo'
	OPEN theCursor
	FETCH NEXT from theCursor INTO @tableName, @columnName
	WHILE (@@FETCH_STATUS =0)
	BEGIN
		SET @sql = N'IF EXISTS (SELECT 1 FROM ' + @tableName + N' WHERE ' + @columnName + N' = @aKey) BEGIN SET @e = 1 END ELSE BEGIN SET @e = 0 END';
		EXEC sp_executesql @sql, N'@e bit out, @aKey uniqueidentifier', @exists out, @accessKey
		IF (@exists = 1) INSERT INTO @results VALUES (@accessKey, @tableName, @columnName)
		FETCH NEXT from theCursor INTO @tableName, @columnName
	END
	CLOSE theCursor
	DEALLOCATE theCursor
	SELECT * from @results
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetAddressByEmail]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetAddressByEmail]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_GetAddressByEmail] 
    @email nvarchar (300)
AS
BEGIN

SELECT AddressKey FROM AddressMain WHERE AddressCategoryCode=4 AND FormattedAddress = @email

END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetAssignableChildTagKey]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetAssignableChildTagKey]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- This stored procedure retrieves records from vBoTagHierarchy records
-- that are child records of @ParentHierarchyKey and @UserKey has access to assign.
-- =============================================
CREATE PROCEDURE [dbo].[asi_GetAssignableChildTagKey]
	@ParentHierarchyKey uniqueidentifier,
    @UserKey uniqueidentifier
AS
BEGIN
	SELECT HierarchyKey FROM vBoTagHierarchy
	 WHERE ParentHierarchyKey = @ParentHierarchyKey
       AND EXISTS (SELECT 1
 	 FROM AccessItem INNER JOIN UserToken
  	   ON AccessItem.Grantee = UserToken.Grantee
	WHERE AccessItem.AccessKey = vBoTagHierarchy.AssignAccessKey
	  AND UserToken.UserKey = @UserKey
-- At least one of Control/Read/Add/Edit/Delete
	  AND (AccessItem.Permission&31)>0)
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetBlogArchiveMonths]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetBlogArchiveMonths]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


CREATE PROCEDURE [dbo].[asi_GetBlogArchiveMonths]
       @parentHierarchyKey uniqueidentifier,
       @userKey uniqueidentifier,
       @loggedInUserGroupKey uniqueidentifier = '00000000-0000-0000-0000-000000000000' -- if this is empty, we assume the user is not logged in
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @publishedOnly bit
    DECLARE @ignoreLicensing bit

    SET @publishedOnly = 1
    SET @ignoreLicensing = 0;

    IF OBJECT_ID('tempdb..#ChildDocuments') IS NOT NULL
        DROP TABLE #ChildDocuments
        
    CREATE TABLE #ChildDocuments (HierarchyKey uniqueidentifier PRIMARY KEY, DocumentKey uniqueidentifier, DocumentVersionKey uniqueidentifier,
                                  DocumentStatusCode nvarchar(6), DocumentName nvarchar(100), AlternateName nvarchar(100),
                                  DocumentDescription nvarchar(250), DocumentTypeCode nvarchar(6), IsSystem bit, 
                                  ContainsChildrenFlag bit, RelatedDocumentVersionKey uniqueidentifier, AccessKey uniqueidentifier,
                                  DefaultChildAccessKey uniqueidentifier, StatusUpdatedOn datetime, StatusUpdatedByUserKey uniqueidentifier,
                                  CreatedOn datetime, CreatedByUserKey uniqueidentifier, UpdatedOn datetime, UpdatedByUserKey uniqueidentifier,
                                  DocumentTypeName nvarchar(255), DocumentTypeDesc nvarchar(100), DocuemntIconUrl nvarchar(256),
                                  RelatedDocumentKey uniqueidentifier, RelatedDocumentTypeCode nvarchar(6), RelatedDocumentName nvarchar(100),
                                  RealtedAlternateName nvarchar(100), RelatedDocumentDescription nvarchar(250), relatedDocumentTypeName nvarchar(255),
                                  RelatedDocumentTypeDesc nvarchar(100), RelatedDocumentIconURL nvarchar(256), RelatedShortcutIconURL nvarchar(256));

    INSERT INTO #ChildDocuments
       EXECUTE [dbo].[asi_DocumentMainListByParentHierarchyKey] @parentHierarchyKey, @userKey, @loggedInUserGroupKey, @publishedOnly, @ignoreLicensing

    IF OBJECT_ID('tempdb..#SortedMonths') IS NOT NULL
        DROP TABLE #SortedMonths
        
    CREATE TABLE #SortedMonths (ArchiveDateSorted datetime PRIMARY KEY);
    
    -- Now create a second table of dates that will only contain a single instance for the year and month 
    INSERT INTO #SortedMonths (ArchiveDateSorted)
        SELECT CAST(RIGHT('0' + RTRIM(MONTH(d.CreatedOn)),2) + '/1/' + RTRIM(YEAR(d.CreatedOn)) AS datetime) AS ArchiveDateSorted 
          FROM #ChildDocuments cd 
                  INNER JOIN Hierarchy h ON cd.HierarchyKey = h.ParentHierarchyKey 
                  INNER JOIN DocumentMain d ON h.UniformKey = d.DocumentVersionKey AND d.DocumentTypeCode = 'CTY'
         GROUP BY  CAST(RIGHT('0' + RTRIM(MONTH(d.CreatedOn)),2) + '/1/' + RTRIM(YEAR(d.CreatedOn)) AS datetime)

    -- Return the month/year literal properly ordered in desc order
    SELECT RIGHT('0' + RTRIM(MONTH(ArchiveDateSorted)),2) + '/' + RTRIM(YEAR(ArchiveDateSorted)) AS ArchiveDate 
      FROM #SortedMonths
     ORDER BY ArchiveDateSorted DESC
    
    IF OBJECT_ID('tempdb..#ChildDocuments') IS NOT NULL
        DROP TABLE #ChildDocuments
    IF OBJECT_ID('tempdb..#SortedMonths') IS NOT NULL
        DROP TABLE #SortedMonths
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetCMNotificationsDue]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetCMNotificationsDue]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/*
This will retrieve all warning and expiration notices due for Content Management (CON and NAV items)

After retrieving the notices due, it will update the workflow tables to show that the notices have been sent
*/

CREATE PROC [dbo].[asi_GetCMNotificationsDue]
AS
BEGIN

	declare
	@navWarningDays1 int,
	@navWarningDays2 int,
	@navFinalNoticeDays int,
	@conWarningDays1 int,
	@conWarningDays2 int,
	@conFinalNoticeDays int,
	@conAddNoticeDays int,
	@navUseWarning1 bit,
	@navUseWarning2 bit,
	@navUseFinalNotice bit,
	@conUseWarning1 bit,
	@conUseWarning2 bit,
	@conUseFinalNotice bit,
	@conUseAddNotice bit

	SELECT @navWarningDays1 = CONVERT(int, [ParameterValue]) FROM [dbo].[SystemConfig] WHERE [ParameterName] = 'ND.ExpirationWarningDays1'
	SELECT @navWarningDays2 = CONVERT(int, [ParameterValue]) FROM [dbo].[SystemConfig] WHERE [ParameterName] = 'ND.ExpirationWarningDays2'
	SELECT @navFinalNoticeDays = CONVERT(int, [ParameterValue]) FROM [dbo].[SystemConfig] WHERE [ParameterName] = 'ND.FinalExpirationNoticeDays'
	SELECT @conWarningDays1 = CONVERT(int, [ParameterValue]) FROM [dbo].[SystemConfig] WHERE [ParameterName] = 'CM.ExpirationWarningDays1'
	SELECT @conWarningDays2 = CONVERT(int, [ParameterValue]) FROM [dbo].[SystemConfig] WHERE [ParameterName] = 'CM.ExpirationWarningDays2'
	SELECT @conFinalNoticeDays = CONVERT(int, [ParameterValue]) FROM [dbo].[SystemConfig] WHERE [ParameterName] = 'CM.FinalExpirationNoticeDays'
	SELECT @conAddNoticeDays = CONVERT(int, [ParameterValue]) FROM [dbo].[SystemConfig] WHERE [ParameterName] = 'CM.ExpAdditionalDays'

	SET @navUseWarning1 = 1
	SET @navUseWarning2 = 1
	SET @navUseFinalNotice = 1
	SET @conUseWarning1 = 1
	SET @conUseWarning2 = 1
	SET @conUseFinalNotice = 1
	SET @conUseAddNotice = 1

	IF @navWarningDays1 <= 0 BEGIN SET @navUseWarning1 = 0 END
	IF @navWarningDays2 <= 0 BEGIN SET @navUseWarning2 = 0 END
	IF @navWarningDays1 = @navWarningDays2 BEGIN SET @navUseWarning2 = 0 END
	IF @navFinalNoticeDays <= 0 BEGIN SET @navUseFinalNotice = 0 END
	IF @conWarningDays1 <= 0 BEGIN SET @conUseWarning1 = 0 END
	IF @conWarningDays2 <= 0 BEGIN SET @conUseWarning2 = 0 END
	IF @conWarningDays1 = @conWarningDays2 BEGIN SET @conUseWarning2 = 0 END
	IF @conFinalNoticeDays <= 0 BEGIN SET @conUseFinalNotice = 0 END
	IF @conAddNoticeDays <= 0 BEGIN SET @conUseAddNotice = 0 END

	DECLARE @warnings TABLE (
		DocumentVersionKey uniqueidentifier,
		DocumentTypeCode nvarchar(3),
		ContactKey uniqueidentifier,
		Email nvarchar(100),
		WarningNumber int,
		NoticeNumber int
	)

	IF @navUseWarning1 = 1 
	BEGIN

		-- Get navigations that need 1st warning
		INSERT @warnings (
			[DocumentVersionKey], 
			[DocumentTypeCode], 
			[ContactKey], 
			[WarningNumber], 
			[NoticeNumber])
		SELECT 
			nav.[DocumentVersionKey],
			'NAV',
			nav.[NotifyContactKey],
			1,
			0
		FROM [dbo].[NavigationWorkflowParameters] nav 
			INNER JOIN [dbo].[DocumentMain] doc ON nav.[DocumentVersionKey] = doc.[DocumentVersionKey]
		WHERE 
			nav.[RemoveAfterDays] > 0
			AND doc.[DocumentStatusCode] = 40
			AND nav.[FirstWarningSentOn] IS NULL
			AND DATEADD(day, nav.[RemoveAfterDays] - @navWarningDays1, CONVERT(datetime, CONVERT(char, doc.[StatusUpdatedOn], 103), 103)) 
				<= CONVERT(datetime, CONVERT(char, GETDATE(), 103), 103)

	END

	IF @navUseWarning2 = 1
	BEGIN

		-- Get navigations that need 2nd warning
		INSERT @warnings (
			[DocumentVersionKey], 
			[DocumentTypeCode], 
			[ContactKey], 
			[WarningNumber], 
			[NoticeNumber])
		SELECT 
			nav.[DocumentVersionKey],
			'NAV',
			nav.[NotifyContactKey],
			2,
			0
		FROM [dbo].[NavigationWorkflowParameters] nav 
			INNER JOIN [dbo].[DocumentMain] doc ON nav.[DocumentVersionKey] = doc.[DocumentVersionKey]
		WHERE 
			nav.[RemoveAfterDays] > 0
			AND doc.[DocumentStatusCode] = 40
			AND nav.[SecondWarningSentOn] IS NULL
			AND DATEDIFF(hour, nav.[FirstWarningSentOn], GETDATE()) >= 20
			AND DATEADD(day, nav.[RemoveAfterDays] - @navWarningDays2, CONVERT(datetime, CONVERT(char, doc.[StatusUpdatedOn], 103), 103)) 
				<= CONVERT(datetime, CONVERT(char, GETDATE(), 103), 103)


	END

		-- Get navigation to inactivate and send first notice
		INSERT @warnings (
			[DocumentVersionKey], 
			[DocumentTypeCode], 
			[ContactKey], 
			[WarningNumber], 
			[NoticeNumber])
		SELECT 
			nav.[DocumentVersionKey],
			'NAV',
			nav.[NotifyContactKey],
			0,
			1
		FROM [dbo].[NavigationWorkflowParameters] nav 
			INNER JOIN [dbo].[DocumentMain] doc ON nav.[DocumentVersionKey] = doc.[DocumentVersionKey]
		WHERE 
			nav.[RemoveAfterDays] > 0
			AND doc.[DocumentStatusCode] = 40
			AND nav.[FirstNotificationSentOn] IS NULL
			AND ((@navUseWarning2 = 1 AND DATEDIFF(hour, nav.[SecondWarningSentOn], GETDATE()) >= 20) 
				OR (@navUseWarning2 = 0 and DATEDIFF(hour, nav.[FirstWarningSentOn], GETDATE()) >= 20))
			AND DATEADD(day, nav.[RemoveAfterDays], CONVERT(datetime, CONVERT(char, doc.[StatusUpdatedOn], 103), 103)) 
				<= CONVERT(datetime, CONVERT(char, GETDATE(), 103), 103)

	IF @navUseFinalNotice = 1
	BEGIN
		-- Get navigation to send second notice
		INSERT @warnings (
			[DocumentVersionKey], 
			[DocumentTypeCode], 
			[ContactKey], 
			[WarningNumber], 
			[NoticeNumber])
		SELECT 
			nav.[DocumentVersionKey],
			'NAV',
			nav.[NotifyContactKey],
			0,
			2
		FROM [dbo].[NavigationWorkflowParameters] nav 
			INNER JOIN [dbo].[DocumentMain] doc ON nav.[DocumentVersionKey] = doc.[DocumentVersionKey]
		WHERE 
			nav.[RemoveAfterDays] > 0
			AND doc.[DocumentStatusCode] = 40
			AND nav.[SecondNotificationSentOn] IS NULL
			AND DATEDIFF(hour, nav.[FirstNotificationSentOn], GETDATE()) >= 20
			AND DATEADD(day, nav.[RemoveAfterDays] + @navFinalNoticeDays, CONVERT(datetime, CONVERT(char, doc.[StatusUpdatedOn], 103), 103)) 
				<= CONVERT(datetime, CONVERT(char, GETDATE(), 103), 103)
	END

	IF @conUseWarning1 = 1 
	BEGIN

		-- Get content that need 1st warning
		INSERT @warnings (
			[DocumentVersionKey], 
			[DocumentTypeCode], 
			[ContactKey], 
			[WarningNumber], 
			[NoticeNumber])
		SELECT 
			con.[DocumentVersionKey],
			'CON',
			gm.[MemberContactKey],
			1,
			0
		FROM [dbo].[ContentWorkflowParameters] con 
			INNER JOIN [dbo].[DocumentMain] doc ON con.[DocumentVersionKey] = doc.[DocumentVersionKey]
			INNER JOIN [dbo].[GroupMember] gm ON con.[OwnerGroupMemberKey] = gm.[GroupMemberKey]
		WHERE 
			doc.[DocumentTypeCode] = 'CON'
			AND doc.[DocumentStatusCode] IN (40,60)
			AND con.[PublishedVersion] = 1
			AND con.[FirstWarningSentOn] IS NULL
			AND DATEADD(day, - @conWarningDays1, CONVERT(datetime, CONVERT(char, con.[ExpirationDate], 103), 103)) 
				<= CONVERT(datetime, CONVERT(char, GETDATE(), 103), 103)

	END

	IF @conUseWarning2 = 1
	BEGIN

		-- Get content that need 2nd warning
		INSERT @warnings (
			[DocumentVersionKey], 
			[DocumentTypeCode], 
			[ContactKey], 
			[WarningNumber], 
			[NoticeNumber])
		SELECT 
			con.[DocumentVersionKey],
			'CON',
			gm.[MemberContactKey],
			2,
			0
		FROM [dbo].[ContentWorkflowParameters] con 
			INNER JOIN [dbo].[DocumentMain] doc ON con.[DocumentVersionKey] = doc.[DocumentVersionKey]
			INNER JOIN [dbo].[GroupMember] gm ON con.[OwnerGroupMemberKey] = gm.[GroupMemberKey]
		WHERE 
			doc.[DocumentTypeCode] = 'CON'
			AND doc.[DocumentStatusCode] IN (40,60)
			AND con.[PublishedVersion] = 1
			AND con.[SecondWarningSentOn] IS NULL
			AND DATEDIFF(hour, con.[FirstWarningSentOn], GETDATE()) >= 20
			AND DATEADD(day, - @conWarningDays2, CONVERT(datetime, CONVERT(char, con.[ExpirationDate], 103), 103)) 
				<= CONVERT(datetime, CONVERT(char, GETDATE(), 103), 103)


	END

		-- Get content to inactivate and send first notice
		INSERT @warnings (
			[DocumentVersionKey], 
			[DocumentTypeCode], 
			[ContactKey], 
			[WarningNumber], 
			[NoticeNumber])
		SELECT 
			con.[DocumentVersionKey],
			'CON',
			gm.[MemberContactKey],
			0,
			1
		FROM [dbo].[ContentWorkflowParameters] con 
			INNER JOIN [dbo].[DocumentMain] doc ON con.[DocumentVersionKey] = doc.[DocumentVersionKey]
			INNER JOIN [dbo].[GroupMember] gm ON con.[OwnerGroupMemberKey] = gm.[GroupMemberKey]
		WHERE 
			doc.[DocumentTypeCode] = 'CON'
			AND doc.[DocumentStatusCode] IN (40,60)
			AND con.[PublishedVersion] = 1
			AND con.[FirstNotificationSentOn] IS NULL
			AND ((@conUseWarning2 = 1 AND DATEDIFF(hour, con.[SecondWarningSentOn], GETDATE()) >= 20) 
				OR (@conUseWarning2 = 0 and DATEDIFF(hour, con.[FirstWarningSentOn], GETDATE()) >= 20))
			AND CONVERT(datetime, CONVERT(char, con.[ExpirationDate], 103), 103)
				<= CONVERT(datetime, CONVERT(char, GETDATE(), 103), 103)

	IF @conUseFinalNotice = 1
	BEGIN
		-- Get content to send second notice
		INSERT @warnings (
			[DocumentVersionKey], 
			[DocumentTypeCode], 
			[ContactKey], 
			[WarningNumber], 
			[NoticeNumber])
		SELECT 
			con.[DocumentVersionKey],
			'CON',
			gm.[MemberContactKey],
			0,
			2
		FROM [dbo].[ContentWorkflowParameters] con 
			INNER JOIN [dbo].[DocumentMain] doc ON con.[DocumentVersionKey] = doc.[DocumentVersionKey]
			INNER JOIN [dbo].[GroupMember] gm ON con.[OwnerGroupMemberKey] = gm.[GroupMemberKey]
		WHERE 
			doc.[DocumentTypeCode] = 'CON'
			AND doc.[DocumentStatusCode] IN (40,60)
			AND con.[PublishedVersion] = 1
			AND con.[SecondNotificationSentOn] IS NULL
			AND DATEDIFF(hour, con.[FirstNotificationSentOn], GETDATE()) >= 20
			AND DATEADD(day, @conFinalNoticeDays, CONVERT(datetime, CONVERT(char, con.[ExpirationDate], 103), 103)) 
				<= CONVERT(datetime, CONVERT(char, GETDATE(), 103), 103)
	END

	IF @conUseAddNotice = 1
	BEGIN

		-- Get content to send additional notice
		INSERT @warnings (
			[DocumentVersionKey], 
			[DocumentTypeCode], 
			[ContactKey], 
			[WarningNumber], 
			[NoticeNumber])
		SELECT 
			con.[DocumentVersionKey],
			'CON',
			gm.[MemberContactKey],
			0,
			3
		FROM [dbo].[ContentWorkflowParameters] con 
			INNER JOIN [dbo].[DocumentMain] doc ON con.[DocumentVersionKey] = doc.[DocumentVersionKey]
			INNER JOIN [dbo].[GroupMember] gm ON con.[OwnerGroupMemberKey] = gm.[GroupMemberKey]
		WHERE 
			doc.[DocumentTypeCode] = 'CON'
			AND doc.[DocumentStatusCode] IN (40,60)
			AND con.[PublishedVersion] = 1
			AND con.[AdditionalNoticeSentOn] IS NULL
			AND ((@conUseFinalNotice = 1 AND DATEDIFF(hour, con.[SecondNotificationSentOn], GETDATE()) >= 20) 
				OR (@conUseFinalNotice = 0 and DATEDIFF(hour, con.[FirstNotificationSentOn], GETDATE()) >= 20))
			AND DATEADD(day, @conAddNoticeDays, CONVERT(datetime, CONVERT(char, con.[ExpirationDate], 103), 103)) 
				<= CONVERT(datetime, CONVERT(char, GETDATE(), 103), 103)

	END

	-- Get email addresses
	UPDATE @warnings
	SET
		[Email] = n.[EMAIL]
	FROM (@warnings temp INNER JOIN [dbo].[ContactMain] c
			ON temp.[ContactKey] = c.[ContactKey])
		INNER JOIN [dbo].[Name] n ON c.[SyncContactID] = n.[ID]

	----------------------------------
	-- Begin Update Workflow Tables --
	----------------------------------

	UPDATE [dbo].[NavigationWorkflowParameters]
	SET [FirstWarningSentOn] = GETDATE()
	WHERE [DocumentVersionKey] in (
		Select [DocumentVersionKey]
		FROM @warnings 
		WHERE [WarningNumber] = 1
			AND [DocumentTypeCode] = 'NAV'
			AND ISNULL([Email],'') != '')

	UPDATE [dbo].[NavigationWorkflowParameters]
	SET [SecondWarningSentOn] = GETDATE()
	WHERE [DocumentVersionKey] in (
		Select [DocumentVersionKey]
		FROM @warnings 
		WHERE [WarningNumber] = 2
			AND [DocumentTypeCode] = 'NAV'
			AND ISNULL([Email],'') != '')

	UPDATE [dbo].[NavigationWorkflowParameters]
	SET [FirstNotificationSentOn] = GETDATE()
	WHERE [DocumentVersionKey] in (
		Select [DocumentVersionKey]
		FROM @warnings 
		WHERE [NoticeNumber] = 1
			AND [DocumentTypeCode] = 'NAV'
			AND ISNULL([Email],'') != '')

	UPDATE [dbo].[NavigationWorkflowParameters]
	SET [SecondNotificationSentOn] = GETDATE()
	WHERE [DocumentVersionKey] in (
		Select [DocumentVersionKey]
		FROM @warnings 
		WHERE [NoticeNumber] = 2
			AND [DocumentTypeCode] = 'NAV'
			AND ISNULL([Email],'') != '')

	UPDATE [dbo].[ContentWorkflowParameters]
	SET [FirstWarningSentOn] = GETDATE()
	WHERE [DocumentVersionKey] in (
		Select [DocumentVersionKey]
		FROM @warnings 
		WHERE [WarningNumber] = 1
			AND [DocumentTypeCode] = 'CON'
			AND ISNULL([Email],'') != '')

	UPDATE [dbo].[ContentWorkflowParameters]
	SET [SecondWarningSentOn] = GETDATE()
	WHERE [DocumentVersionKey] in (
		Select [DocumentVersionKey]
		FROM @warnings 
		WHERE [WarningNumber] = 2
			AND [DocumentTypeCode] = 'CON'
			AND ISNULL([Email],'') != '')

	UPDATE [dbo].[ContentWorkflowParameters]
	SET [FirstNotificationSentOn] = GETDATE()
	WHERE [DocumentVersionKey] in (
		Select [DocumentVersionKey]
		FROM @warnings 
		WHERE [NoticeNumber] = 1
			AND [DocumentTypeCode] = 'CON'
			AND ISNULL([Email],'') != '')

	UPDATE [dbo].[ContentWorkflowParameters]
	SET [SecondNotificationSentOn] = GETDATE()
	WHERE [DocumentVersionKey] in (
		Select [DocumentVersionKey]
		FROM @warnings 
		WHERE [NoticeNumber] = 2
			AND [DocumentTypeCode] = 'CON'
			AND ISNULL([Email],'') != '')

	UPDATE [dbo].[ContentWorkflowParameters]
	SET [AdditionalNoticeSentOn] = GETDATE()
	WHERE [DocumentVersionKey] in (
		Select [DocumentVersionKey]
		FROM @warnings 
		WHERE [NoticeNumber] = 3
			AND [DocumentTypeCode] = 'CON'
			AND ISNULL([Email],'') != '')

	--------------------------------
	-- End Update Workflow Tables --
	--------------------------------


	SELECT temp.*, h.[HierarchyKey] FROM @warnings temp INNER JOIN [dbo].[Hierarchy] h
		ON temp.[DocumentVersionKey] = h.[UniformKey]
	ORDER BY
		temp.[DocumentTypeCode],
		temp.[ContactKey],
		temp.[NoticeNumber],
		temp.[WarningNumber]
		

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetCommunityRoster]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetCommunityRoster]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


CREATE PROCEDURE [dbo].[asi_GetCommunityRoster] (
      @communityDocumentKey uniqueidentifier
)
AS
BEGIN
    -- Get ParentHierarchyKey
    DECLARE @parentHierarchyKey uniqueidentifier
    SELECT @parentHierarchyKey = h.[ParentHierarchyKey]
      FROM [dbo].[DocumentMain] d
           INNER JOIN [dbo].[Hierarchy] h ON d.[DocumentVersionKey] = h.[UniformKey]
     WHERE d.[DocumentVersionKey] = @communityDocumentKey 
           AND d.DocumentTypeCode = 'CTY' 
           AND d.DocumentStatusCode = 40

    -- Get the list of all community documents underneath the parent of the specified community document
    DECLARE @communityDocument table
    (
        [DocumentVersionKey] uniqueidentifier PRIMARY KEY,
        [Title] nvarchar(100),
        [CreatedOn] datetime,
        [CreatedByUserKey] uniqueidentifier
    )

    INSERT INTO @communityDocument
        SELECT [DocumentVersionKey], [Title], [CreatedOn], [CreatedByUserKey] 
          FROM [dbo].[asi_PublishedCommunitiesByDocumentKey](@communityDocumentKey)
         WHERE [DocumentTypeCode] = 'CTY'

    -- Get all subscribers to all groups for all documents
    DECLARE @subscriber table
    (
       [ContactKey] uniqueidentifier,
        [JoinDate] datetime
    )
             
    DECLARE @groupTypeKey uniqueidentifier
    DECLARE @subscriberRoleKey uniqueidentifier
    DECLARE @adminRoleKey uniqueidentifier
    DECLARE @wikiAuthorRoleKey uniqueidentifier
    DECLARE @communityModeratorRoleKey uniqueidentifier

    SET @groupTypeKey = '44B62E6D-CB59-4113-B3B9-D85E52F176BF'
    SET @subscriberRoleKey = '5BF5FE7A-BF40-4072-B7E7-FD250635BF95'
    SET @adminRoleKey = '13FE69F0-19B3-4F47-805C-64FF8E836469'
    SET @wikiAuthorRoleKey = '62FF03ED-8C63-4CA3-A83B-8E6349FC15B2'
    SET @communityModeratorRoleKey = '4789BA6A-674A-4917-A02A-398236F95D14'
    
    INSERT INTO @subscriber
        SELECT [MemberContactKey], MIN(m.[JoinDate])
          FROM @communityDocument cd
               INNER JOIN [dbo].[GroupMain] g ON g.[GroupTypeKey] = @groupTypeKey AND g.[Name] = LOWER(CAST(cd.[DocumentVersionKey] AS nvarchar(36)))
               INNER JOIN [dbo].[GroupMember] m ON g.[GroupKey] = m.[GroupKey] AND m.[IsActive] = 1
               INNER JOIN [dbo].[GroupMemberDetail] d ON m.[GroupMemberKey] = d.[GroupMemberKey] 
                                                  AND d.[GroupRoleKey] IN (@subscriberRoleKey, @adminRoleKey, @wikiAuthorRoleKey, @communityModeratorRoleKey)
                                                  AND d.[IsActive] = 1
         GROUP BY [MemberContactKey]

    -- Return each subscriber's roster info
    SELECT s.[ContactKey], i.[FirstName], i.[LastName], c.[FullName], i.[PrimaryInstituteName], ii.[InstituteName], s.[JoinDate], [Title] AS [MostRecentPostTitle], [DocumentVersionKey] AS [MostRecentPostKey], d.[CreatedOn] AS [MostRecentPostOn]
      FROM @subscriber s
           INNER JOIN [dbo].[ContactMain] c ON s.[ContactKey] = c.[ContactKey]
           LEFT OUTER JOIN [dbo].[Individual] i ON s.[ContactKey] = i.[ContactKey]
           LEFT OUTER JOIN [dbo].[Institute] ii ON s.[ContactKey] = ii.[ContactKey]
           LEFT OUTER JOIN @communityDocument d ON s.[ContactKey] = d.[CreatedByUserKey]
     WHERE [DocumentVersionKey] IS NULL 
           OR [DocumentVersionKey] = (SELECT TOP 1 [DocumentVersionKey] 
                                        FROM @communityDocument cd 
                                       WHERE cd.[CreatedByUserKey] = d.[CreatedByUserKey] 
                                       ORDER BY cd.[CreatedOn] DESC)
END





GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetCommunitySubscriptions]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetCommunitySubscriptions]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_GetCommunitySubscriptions] (
    @groupRoleKey uniqueidentifier,
    @groupTypeKey uniqueidentifier,
    @contactKey uniqueidentifier,
    @communityDocumentKey uniqueidentifier
)
AS
BEGIN

    -- Get the list of all community documents underneath the parent of the specified community document
    DECLARE @communityDocument table
    (
        [DocumentVersionKeyString] nvarchar(40) PRIMARY KEY
    )

    INSERT INTO @communityDocument
        SELECT LOWER(CAST([DocumentVersionKey] AS nvarchar(40))) 
          FROM [dbo].[asi_PublishedCommunitiesByDocumentKey](@communityDocumentKey)
         WHERE [DocumentTypeCode] = 'CTY'

    -- Return the subscription information
    SELECT CAST(NULL AS NVARCHAR(100)) AS [Community], 
           CAST(NULL AS NVARCHAR(100)) AS [Type], 
           CAST(NULL AS NVARCHAR(100)) AS [Title], 
           [g].[Name] AS [CommunityDocumentKey], 
           [c].[FullName]
      FROM [dbo].[GroupMember] AS [m]
           INNER JOIN [dbo].[GroupMemberDetail] AS [d] ON [m].[GroupMemberKey] = [d].[GroupMemberKey] AND 
                                                          [d].[GroupRoleKey] = @groupRoleKey AND [d].[IsActive] = 1 AND 
                                                          [d].[GroupMemberStatusCode] = 'A' AND 
                                                         ([d].[EffectiveDate] IS NULL OR [d].[EffectiveDate] < GETDATE()) AND 
                                                         ([d].[ExpirationDate] IS NULL OR [d].[ExpirationDate] > GETDATE())
           INNER JOIN [dbo].[GroupMain] AS [g] on [m].[GroupKey] = [g].[GroupKey] AND [g].[GroupTypeKey] = @groupTypeKey
           INNER JOIN [dbo].[ContactMain] AS [c] on [m].[MemberContactKey] = [c].[ContactKey]
           INNER JOIN @communityDocument cd ON g.[Name] = cd.[DocumentVersionKeyString]
     WHERE [m].[MemberContactKey] = @contactKey 
END 


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetDatabaseVersion]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetDatabaseVersion]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- Author:		Paul Bradshaw
-- Create date: Sept 19, 2006
-- Description:	Get DB Version string
-- =============================================
CREATE PROCEDURE [dbo].[asi_GetDatabaseVersion] 
	@p1 nvarchar(20) = '' -- Specify which version part, or nothing for full version
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @version nvarchar(24)
	DECLARE @major nvarchar(10)
	DECLARE @minor nvarchar(10)
	DECLARE @patch nvarchar(10)
	DECLARE @build nvarchar(10)
	DECLARE @systemEntity uniqueidentifier
	DECLARE @type nvarchar(20)

	SET @type = UPPER(@p1)

	SELECT @systemEntity = SystemEntityKey FROM SystemEntity WHERE SystemKeyword = 'Organization'

	SELECT @major = ParameterValue FROM SystemConfig WHERE ParameterName = 'System.Database.Version.Major'
		AND OrganizationKey = '00000000-0000-0000-0000-000000000000' AND SystemEntityKey = @systemEntity
	SELECT @minor = ParameterValue FROM SystemConfig WHERE ParameterName = 'System.Database.Version.Minor'
		AND OrganizationKey = '00000000-0000-0000-0000-000000000000' AND SystemEntityKey = @systemEntity
	SELECT @patch = ParameterValue FROM SystemConfig WHERE ParameterName = 'System.Database.Version.Patch'
		AND OrganizationKey = '00000000-0000-0000-0000-000000000000' AND SystemEntityKey = @systemEntity
	SELECT @build = ParameterValue FROM SystemConfig WHERE ParameterName = 'System.Database.Version.Build'
		AND OrganizationKey = '00000000-0000-0000-0000-000000000000' AND SystemEntityKey = @systemEntity

	IF @major IS NOT NULL AND @minor IS NOT NULL AND @patch IS NOT NULL AND @build IS NOT NULL
	BEGIN
		IF @type = ''
		BEGIN
			SET @version = @major + '.' + @minor + '.' + @patch + '.' + @build
		END
		ELSE IF @type = 'NOBUILD'
		BEGIN
			SET @version = @major + '.' + @minor + '.' + @patch
		END
		ELSE IF @type = 'MAJORMINOR'
		BEGIN
			SET @version = @major + '.' + @minor
		END
		ELSE IF @type = 'MAJOR'
		BEGIN
			SET @version = @major
		END
		ELSE IF @type = 'MINOR'
		BEGIN
			SET @version = @minor
		END
		ELSE IF @type = 'PATCH'
		BEGIN
			SET @version = @patch
		END
		ELSE IF @type = 'BUILD'
		BEGIN
			SET @version = @build
		END
		
	END
	ELSE
	BEGIN
		SET @version = NULL
	END

	SELECT @version

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetPublishRequestDetails]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetPublishRequestDetails]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_GetPublishRequestDetails]
	@PublishRequestKey uniqueidentifier,
	@PublishServerCode nchar(1)
AS
BEGIN
	SELECT PublishRequestDetailKey
      FROM PublishRequestDetail prd, DocumentMain dm
     WHERE prd.PublishServerCode = @PublishServerCode
       AND prd.PublishRequestKey = @PublishRequestKey
	   AND prd.ContentDocumentKey = dm.DocumentKey
       AND ((dm.DocumentStatusCode IN (30,40) AND prd.IsDelete = 0)
		     OR (dm.DocumentStatusCode IN (70,80) AND prd.IsDelete = 1))
	   AND ((PublishRequestStatusCode = 0 AND (PublishedDateTime IS NULL OR PublishedDateTime <= GetDate()))
			OR
			(PublishRequestStatusCode = 1 AND prd.IsDelete = 0 AND
			(DATEADD(second, prd.Frequency, prd.PublishedDateTime) <= GetDate())
               AND (prd.Frequency <> 0))
			)
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetPublishRequests]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetPublishRequests]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_GetPublishRequests]
    @PublishServerCode nchar(1) AS
BEGIN
    DECLARE @now datetime
    SET @now = GETDATE();
    SELECT [PublishRequestKey] 
      FROM [dbo].[PublishRequest] pr
     WHERE EXISTS (SELECT 1 
                     FROM [dbo].[PublishRequestDetail] prd
                          INNER JOIN [dbo].[DocumentMain] dm ON prd.[ContentDocumentKey] = dm.[DocumentKey]
                    WHERE prd.[PublishRequestKey] = pr.[PublishRequestKey]
                      AND prd.[PublishServerCode] = @PublishServerCode
                      AND (    (dm.[DocumentStatusCode] IN (30,40) AND prd.[IsDelete] = 0)
                            OR (dm.[DocumentStatusCode] IN (70,80) AND prd.[IsDelete] = 1)
                           )
                      AND (    (prd.[PublishRequestStatusCode] = 0 
                                AND (prd.[PublishedDateTime] IS NULL OR prd.[PublishedDateTime] <= @now)
                                )
                            OR (prd.[PublishRequestStatusCode] = 1 AND prd.[IsDelete] = 0 
                                AND (DATEADD(second, prd.[Frequency], prd.[PublishedDateTime]) <= @now)
                                AND (prd.[Frequency] <> 0)
                                )
                          )
                   )
     ORDER BY pr.[PublishPriorityCode], pr.[RequestDateTime]
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetPublishRequestStatus]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetPublishRequestStatus]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_GetPublishRequestStatus]
	@PublishRequestKey uniqueidentifier,
	@PublishServerCode nchar(1) AS
BEGIN

SELECT 
(SELECT Count(*) FROM PublishRequestDetail 
  WHERE PublishRequestKey = a.PublishRequestKey
	AND PublishServerCode = @PublishServerCode 
    AND PublishRequestStatusCode = 0) AS PendingCount,
(SELECT Count(*) FROM PublishRequestDetail 
  WHERE PublishRequestKey = a.PublishRequestKey
    AND PublishServerCode = @PublishServerCode 
    AND PublishRequestStatusCode = 1) AS PublishedCount,
(SELECT Count(*) FROM PublishRequestDetail 
  WHERE PublishRequestKey = a.PublishRequestKey
	AND PublishServerCode = @PublishServerCode
   AND PublishRequestStatusCode = 2) AS CanceledCount,
(SELECT Count(*) FROM PublishRequestDetail 
  WHERE PublishRequestKey = a.PublishRequestKey
	AND PublishServerCode = @PublishServerCode
	AND PublishRequestStatusCode = 3)  AS FailedCount
FROM PublishRequest a
WHERE PublishRequestKey = @PublishRequestKey
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetRecentCompletePublishRequests]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetRecentCompletePublishRequests]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_GetRecentCompletePublishRequests]
	@PublishServerCode nchar(1),
	@NumberOfRequests int = 20
AS
BEGIN
	DECLARE @recentRequests TABLE (
		ID int identity (1,1),
		PublishRequestKey uniqueidentifier
	)

	INSERT INTO @recentRequests (PublishRequestKey)
	SELECT PublishRequestKey FROM PublishRequest
    WHERE Exists (SELECT 1 FROM PublishRequestDetail prd, DocumentMain dm
                          WHERE prd.PublishRequestKey = PublishRequest.PublishRequestKey
							AND prd.PublishServerCode = @PublishServerCode
							AND prd.ContentDocumentKey = dm.DocumentKey
						    AND ((dm.DocumentStatusCode IN (30,40) AND prd.IsDelete = 0)
									OR (dm.DocumentStatusCode IN (70,80) AND prd.IsDelete = 1))
						   AND prd.PublishRequestStatusCode <> 0
				   )
    ORDER BY RequestDateTime DESC

	SELECT PublishRequestKey FROM @recentRequests WHERE ID <= @NumberOfRequests
END


SET ANSI_NULLS ON

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetRolesAccess]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetRolesAccess]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_GetRolesAccess    Script Date: 7/3/2003 4:58:03 PM ******/
CREATE PROCEDURE [dbo].[asi_GetRolesAccess]
	@accessArea uniqueidentifier
AS

select ai.AccessKey, ai.Grantee, ai.Permission, 
ai.RoleKey, ai.UserKey, ai.GroupKey
from AccessItem ai, AccessArea aa
where ai.AccessKey = aa.ProtectedAccessKey
and aa.AccessAreaKey = @accessArea

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetSalesHistoryResponseStart]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetSalesHistoryResponseStart]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_GetSalesHistoryResponseStart    ******/

CREATE       PROCEDURE [dbo].[asi_GetSalesHistoryResponseStart]

@userKey 	uniqueidentifier,
@rangeBegin 	datetime OUTPUT,
@rangeEnd 	datetime OUTPUT

AS

DECLARE @newGuid 			uniqueidentifier 
DECLARE @EveryoneFullControlAccessKey 	uniqueidentifier
DECLARE @now 				datetime
DECLARE @defaultDate			datetime

SET @defaultDate = '1/1/1980'
SET @rangeBegin = @defaultDate
SET @rangeEnd = @defaultDate

BEGIN TRAN 

-- Get the ending value
SELECT	@rangeEnd =  ISNULL(MAX(CreatedOn), @defaultDate)
 FROM	SalesHistory

-- Check to make sure the counter exists - create it if not
IF NOT EXISTS(SELECT 1 FROM SystemConfig WHERE ParameterName='SalesHistoryResponseRangeStart')
BEGIN
	SELECT @newGuid = newid()
	SELECT @now = getdate()

	INSERT SystemConfig (SystemConfigKey, ParameterName, ParameterValue, [Description], 
	       OrganizationKey, SystemEntityKey, CreatedByUserKey, CreatedOn, UpdatedByUserKey, UpdatedOn)
	VALUES(	@newGuid, 
		'SalesHistoryResponseRangeStart', 
		CAST(@rangeEnd As nvarchar(100)), 
		'Ending point in the SalesHistory table already processed by response acquisition.',
		'00000000-0000-0000-0000-000000000000',
		NULL,
		@userKey, 
		@now, 
		@userKey, 
		@now)
END

-- Get the beginning value
SELECT	@rangeBegin = ISNULL(CAST(ParameterValue AS datetime), @defaultDate)
  FROM	SystemConfig
 WHERE	ParameterName = 'SalesHistoryResponseRangeStart'

-- Set the ending value
UPDATE	SystemConfig
   SET	ParameterValue = CAST(@rangeEnd AS nvarchar(100))
 WHERE	ParameterName = 'SalesHistoryResponseRangeStart'

COMMIT TRAN

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetSeasonalFullAddressKeysByFullAddressKey]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetSeasonalFullAddressKeysByFullAddressKey]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE  PROCEDURE [dbo].[asi_GetSeasonalFullAddressKeysByFullAddressKey] (@fullAddressKey uniqueidentifier, @now datetime) 
AS
BEGIN

SELECT SeasonalFullAddressKey FROM SeasonalFullAddress 
 WHERE FullAddressKey = @fullAddressKey 
   AND BeginDate < @now
   AND (EndDate IS NULL OR EndDate > @now  OR IsSeasonalAnnually = 1) 
ORDER BY BeginDate

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetSystemEntityKeyForSourceCode]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetSystemEntityKeyForSourceCode]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE Procedure asi_GetSystemEntityKeyForSourceCode
@SourceCodeKey uniqueidentifier
AS
SELECT TOP 1 SystemEntityKey FROM CampaignMain C
INNER JOIN AppealMain A ON C.CampaignKey = A.CampaignKey
INNER JOIN SolicitationMain S ON S.AppealKey = A.AppealKey
INNER JOIN SourceCode SC on SC.SolicitationKey = S.SolicitationKey
WHERE SourceCodeKey = @SourceCodeKey

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetUserKeyReferences]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetUserKeyReferences]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_GetUserKeyReferences]
    @userKey uniqueidentifier
AS
BEGIN
	DECLARE @tableName nvarchar(255)
	DECLARE @columnName nvarchar(255)
	DECLARE @sql nvarchar(4000)
	DECLARE @results table (UserKey uniqueidentifier, TableName nvarchar(255), ColumnName nvarchar(255))
	DECLARE @exists bit
	DECLARE theCursor CURSOR FAST_FORWARD FOR
		SELECT isc.TABLE_NAME, isc.COLUMN_NAME from INFORMATION_SCHEMA.COLUMNS isc INNER JOIN INFORMATION_SCHEMA.TABLES ist ON isc.TABLE_NAME = ist.TABLE_NAME
		WHERE isc.COLUMN_NAME like '%UserKey' AND isc.DATA_TYPE = 'uniqueidentifier' AND ist.TABLE_TYPE = 'BASE TABLE' AND ist.TABLE_SCHEMA = 'dbo'
	OPEN theCursor
	FETCH NEXT from theCursor INTO @tableName, @columnName
	WHILE (@@FETCH_STATUS =0)
	BEGIN
		SET @sql = N'IF EXISTS (SELECT 1 FROM ' + @tableName + N' WHERE ' + @columnName + N' = @uKey) BEGIN SET @e = 1 END ELSE BEGIN SET @e = 0 END';
		EXEC sp_executesql @sql, N'@e bit out, @uKey uniqueidentifier', @exists out, @userKey
		IF (@exists = 1) INSERT INTO @results VALUES (@userKey, @tableName, @columnName)
		FETCH NEXT from theCursor INTO @tableName, @columnName
	END
	CLOSE theCursor
	DEALLOCATE theCursor
	SELECT * from @results
END

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetAccessKeyReferences]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[asi_GetAccessKeyReferences]

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GetVatCountryForTaxByLocation]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GetVatCountryForTaxByLocation]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


-- Calculate the vat country to use for taxing a "Tax by location" product
-- PARAMETERS
-- @orgCode             The financial entity (org) for the order.
--                      If passed empty/null the default org is assumed.
-- @billToId            Bill to contact Id.
-- @shipToCountry       The currently selected ship to country code. Accepts either a country name or country code.
--                      This may not necessarily be the ship to contacts ship to country. It may have been manually changed on the order.
-- @vatCountryCode OUT  Returns the country code that VAT is being charged based on.
--                      Could legitimately be empty if the determined country does not have a VAT_COUNTRY_CODE
--                      Will always be empty in a non VAT environment.

-- The procedure also returns  a single row resultset containing the value returned by @vatCountryCode OUT

CREATE PROCEDURE [dbo].[asi_GetVatCountryForTaxByLocation]
    @orgCode varchar(5),
    @billToID varchar(10),
    @shipToCountry varchar(25),
    @vatCountryCode varchar(2) = NULL OUT
AS
BEGIN

    -- Declare variables    
    DECLARE @taxOnShipTo bit
    DECLARE @orgVatCountryCode varchar(2)
    DECLARE @billCountry varchar(25)
    DECLARE @billVatCountryCode varchar(2)
    DECLARE @contactVatCountryCode varchar(2)
        
    -- Default the return value
    SET @vatCountryCode = ''

    -- Check we are licensed for VAT
    IF NOT EXISTS (SELECT 1 
                     FROM [dbo].[LicenseLegacyList] 
                    WHERE [LegacyLicenseCode]='VAT') 
    BEGIN
        GOTO ReturnValue
    END

    -- Get the org's VAT country code
    -- As part of this we check that it is a vat org and it has a vat country defined
    -- If no org was specified, then assume the default org
    IF LEN(COALESCE(@orgCode, ''))=0
    BEGIN
        SELECT @orgCode = o.[OrgCode], @orgVatCountryCode = o.[VATCountry]
          FROM [dbo].[Org_Control] o 
         WHERE o.[DefaultFlag]=1 AND o.[UseVATTaxation]=1 AND LEN(o.[VATCountry])>0
    END
    ELSE
    BEGIN
        SELECT @orgVatCountryCode = o.[VATCountry]
          FROM [dbo].[Org_Control] o 
         WHERE o.[OrgCode]=@orgCode AND o.[UseVATTaxation]=1 AND LEN(o.[VATCountry])>0
    END
    IF @@ROWCOUNT=0
    BEGIN
        -- Not a properly configured VAT org
        GOTO ReturnValue
    END

    -- Default to the org vat country code
    SET @vatCountryCode = @orgVatCountryCode

    -- Determine whether to use TaxOnShipTo option
    -- If the setting cannot be found, default to false
    SELECT @taxOnShipTo = CASE WHEN [ShortValue]='YES' THEN 1 ELSE 0 END
      FROM [dbo].[System_Params]
     WHERE [ParameterName] = 'AR_Control.TaxOnShipTo'  
    IF @@ROWCOUNT=0
    BEGIN
        SET @taxOnShipTo = 0
    END     
 
    -- Process based on the taxation method
    IF @taxOnShipTo = 1
    BEGIN
        
        -- Establish the vat country code of the ship to country 
        IF LEN(COALESCE(@shipToCountry,''))>0
        BEGIN
            -- Check the ship to country exists
            -- We could have been supplied either a country code or a country name    
            IF LEN(@shipToCountry)<=2
            BEGIN
                            SELECT @vatCountryCode = c.[VAT_COUNTRY_CODE]
                              FROM [dbo].[Country_Names] c
                            WHERE c.[COUNTRY_CODE] = @shipToCountry
            END
            ELSE
            BEGIN
                            SELECT @vatCountryCode = c.[VAT_COUNTRY_CODE]
                              FROM [dbo].[Country_Names] c
                            WHERE c.[COUNTRY] = @shipToCountry
            END
            -- @vatCountryCode remains unchanged if the country cannot be located
            -- If the country exists but the VAT_COUNTRY_CODE is empty, then we DO want that empty value
        END
        
    END
    ELSE
    BEGIN
        
        -- Do we have a bill to id
        IF LEN(COALESCE(@billToID, ''))=0
        BEGIN
            GOTO ReturnValue
        END
        
        -- Retrieve the various vat country codes from the contact
        SELECT @contactVatCountryCode = COALESCE(nf.[VAT_COUNTRY],''),
               @billCountry = COALESCE(na.[COUNTRY],''),
               @billVatCountryCode = COALESCE(c.[VAT_COUNTRY_CODE],'')
          FROM [dbo].[Name] n
               LEFT OUTER JOIN [dbo].[Name_Address] na ON n.[ID] = na.[ID] AND na.[PREFERRED_BILL] = 1
               LEFT OUTER JOIN [dbo].[Country_Names] c ON na.[COUNTRY] = c.[COUNTRY]
               LEFT OUTER JOIN [dbo].[Name_Fin] nf ON n.[ID] = nf.[ID]
         WHERE n.[ID] = @billToID
         
        -- We prioritize countries in a specific order
        -- 1. VAT Country code from the VAT tab in CP
        -- 2. VAT Country code of the primary billing address
        -- 3. VAT Country from the Org (already set as the default)
        IF LEN(@contactVatCountryCode)>0
        BEGIN
            -- The VAT Country from the VAT tab in CP  (Name_Fin.VAT_COUNTRY)
            SET @vatCountryCode = @contactVatCountryCode
        END
        ELSE
        BEGIN
            IF LEN(@billCountry)>0
            BEGIN
                -- The country of the contacts primary billing address
                -- @billVatCountryCode may be empty, thats OK
                -- If there was a bill to country then we want its VAT country code, even if its empty
                SET @vatCountryCode = @billVatCountryCode
            END
        END
        
    END

ReturnValue:    
 
    -- Return the values as a resultset for desktop
    SELECT @vatCountryCode AS [VatCountryCode]

END



GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GroupActiveMemberKeyByGroupRole]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GroupActiveMemberKeyByGroupRole]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_GroupActiveMemberKeyByGroupRole] (@groupKey uniqueidentifier, @roleKey uniqueidentifier) 
AS
BEGIN

SELECT gm.GroupMemberKey, gm.MemberContactKey
FROM GroupMember gm INNER JOIN GroupMemberDetail gmd ON gm.GroupMemberKey = gmd.GroupMemberKey
WHERE gm.GroupKey=@groupKey AND gmd.GroupRoleKey=@roleKey AND gmd.IsActive = 1
ORDER BY gmd.EffectiveDate

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GroupActiveMembershipCount]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GroupActiveMembershipCount]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_GroupActiveMembershipCount]
	@groupkey uniqueidentifier
	AS
BEGIN
	SELECT COUNT(1) AS MemberCount 
	FROM GroupMember 
	WHERE GroupKey=@groupkey AND IsActive=1
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GroupCopyDetailMembership]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GroupCopyDetailMembership]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_GroupCopyDetailMembership] (@srcGroupKey uniqueidentifier, @destGroupKey uniqueidentifier, @userKey uniqueidentifier, @now datetime) 
AS
BEGIN

-- Create temporary table to hold the results of a join of GroupMember and GroupMemberDetail
CREATE TABLE #tmpTable (GroupMemberKey uniqueidentifier, GroupKey uniqueidentifier, MemberContactKey uniqueidentifier, MemberIsActive bit, CreatedByUserKey uniqueidentifier, CreatedOn datetime, 
				UpdatedByUserKey uniqueidentifier, UpdatedOn datetime, DropDate datetime, JoinDate datetime,
				GroupRoleKey uniqueidentifier, EffectiveDate datetime, ExpirationDate datetime, TypeSpecificData nvarchar(250), TypeSpecificKey uniqueidentifier, TypeSpecificFlag bit, TypeSpecificInt int, 
				DetailGroupMemberStatusCode nvarchar(4), DetailIsActive bit, GroupMemberDetailKey uniqueidentifier)

-- Fill the temporary table with the results of the join, creating new ids for the GroupMemberKey and GroupMemberDetailKey, and setting other columns to specified values
INSERT INTO #tmpTable (GroupMemberKey, GroupKey, MemberContactKey, MemberIsActive, CreatedByUserKey, CreatedOn, UpdatedByUserKey,UpdatedOn, 
				DropDate, JoinDate,
				GroupRoleKey, EffectiveDate, ExpirationDate, TypeSpecificData, TypeSpecificKey, TypeSpecificFlag, TypeSpecificInt, 
				DetailGroupMemberStatusCode, DetailIsActive, GroupMemberDetailKey)
	SELECT newid(), @destGroupKey, gm.MemberContactKey, gm.IsActive, @userKey, @now, @userKey, @now, gm.DropDate, gm.JoinDate,
			gmd.GroupRoleKey, gmd.EffectiveDate, gmd.ExpirationDate, gmd.TypeSpecificData, gmd.TypeSpecificKey, gmd.TypeSpecificFlag, gmd.TypeSpecificInt, 
			gmd.GroupMemberStatusCode, gmd.IsActive, newid()
	FROM GroupMember gm INNER JOIN GroupMemberDetail gmd ON gm.GroupMemberKey = gmd.GroupMemberKey
	WHERE gm.GroupKey = @srcGroupKey

-- Fill the GroupMember table from the temporary table, selecting distinct GroupMemberKey rows
INSERT INTO GroupMember (GroupMemberKey, GroupKey, MemberContactKey, IsActive, CreatedByUserKey, CreatedOn, UpdatedByUserKey, UpdatedOn, DropDate, JoinDate)
	SELECT DISTINCT GroupMemberKey, GroupKey, MemberContactKey, MemberIsActive, CreatedByUserKey, CreatedOn, UpdatedByUserKey, UpdatedOn, DropDate, JoinDate
		FROM #tmpTable

-- Fill the GroupMemberDetail table from the temporary table, using all the rows
INSERT INTO GroupMemberDetail (GroupMemberKey, GroupRoleKey, EffectiveDate, ExpirationDate, TypeSpecificData, TypeSpecificKey, TypeSpecificFlag, CreatedOn, CreatedByUserKey, UpdatedOn, UpdatedByUserKey,
					TypeSpecificInt, GroupMemberStatusCode, IsActive, GroupMemberDetailKey, GroupKey)
	SELECT GroupMemberKey, GroupRoleKey, EffectiveDate, ExpirationDate, TypeSpecificData, TypeSpecificKey, TypeSpecificFlag, CreatedOn, CreatedByUserKey, UpdatedOn, UpdatedByUserKey,
			TypeSpecificInt, DetailGroupMemberStatusCode, DetailIsActive, GroupMemberDetailKey, GroupKey
		FROM #tmpTable

DROP TABLE #tmpTable

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GroupCopySimpleMembership]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GroupCopySimpleMembership]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_GroupCopySimpleMembership] (@srcGroupKey uniqueidentifier, @destGroupKey uniqueidentifier, @userKey uniqueidentifier, @now datetime) 
AS
BEGIN

INSERT INTO GroupMember (GroupMemberKey, GroupKey, MemberContactKey, IsActive, CreatedByUserKey, CreatedOn, UpdatedByUserKey, UpdatedOn, DropDate, JoinDate)
	SELECT newid(), @destGroupKey, MemberContactKey, IsActive, @userKey, @now, @userKey, @now, DropDate, JoinDate 
		FROM GroupMember
		WHERE GroupMember.GroupKey=@srcGroupKey
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GroupMainDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GroupMainDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create proc [dbo].[asi_GroupMainDelete]
       @groupKey uniqueidentifier As
begin
	if not exists(select 1 from GroupMember where GroupKey = @groupKey) and
	   not exists(select 1 from AccessItem where GroupKey = @groupKey)
	begin
		begin transaction
		delete GroupMemberDetail where GroupKey = @groupKey
		delete GroupMember where GroupKey = @groupKey
		delete AccessItem where GroupKey = @groupKey
		delete GroupMain where GroupKey = @groupKey 
		commit transaction
	end
	else
	begin
		RAISERROR('Cannot delete group while child items exist.', 16, 1)
	end
end

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GroupMemberKeyByGroupRole]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GroupMemberKeyByGroupRole]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_GroupMemberKeyByGroupRole] (@groupKey uniqueidentifier, @roleKey uniqueidentifier) 
AS
BEGIN

SELECT gm.GroupMemberKey, gm.MemberContactKey
FROM GroupMember gm INNER JOIN GroupMemberDetail gmd ON gm.GroupMemberKey = gmd.GroupMemberKey
WHERE gm.GroupKey=@groupKey AND gmd.GroupRoleKey=@roleKey
ORDER BY gmd.EffectiveDate DESC

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GroupMembership]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GroupMembership]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_GroupMembership] (@contactKey uniqueidentifier) 
AS
BEGIN

SELECT DISTINCT GroupMain.GroupKey
FROM	GroupMember INNER JOIN
	GroupMain ON GroupMember.GroupKey = GroupMain.GroupKey 
WHERE     (GroupMember.MemberContactKey = @contactKey)
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GroupMembershipByGroup]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GroupMembershipByGroup]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_GroupMembershipByGroup    Script Date: 7/3/2003 4:58:03 PM ******/

CREATE PROCEDURE [dbo].[asi_GroupMembershipByGroup]
	@causeGroupKey uniqueidentifier,
	@effectGroupKey uniqueidentifier AS

BEGIN
	PRINT 'This SP is obsolete'
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GroupMembershipByMember]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GroupMembershipByMember]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_GroupMembershipByMember    Script Date: 7/3/2003 4:58:04 PM ******/

CREATE   PROCEDURE [dbo].[asi_GroupMembershipByMember]
	@effectGroupKey uniqueidentifier,
	@userKey uniqueidentifier AS

BEGIN
	PRINT 'This SP is obsolete'
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GroupMembershipByType]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GroupMembershipByType]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_GroupMembershipByType] (@contactKey uniqueidentifier, @groupTypeKey uniqueidentifier) 
AS
BEGIN

SELECT DISTINCT GroupMain.GroupKey, GroupMain.Name
FROM	GroupMember INNER JOIN
	GroupMain ON GroupMember.GroupKey = GroupMain.GroupKey 
WHERE     (GroupMember.MemberContactKey = @contactKey) AND
	     (GroupMain.GroupTypeKey = @groupTypeKey)
ORDER BY GroupMain.Name
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GroupMembershipCount]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GroupMembershipCount]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_GroupMembershipCount]
	@groupkey uniqueidentifier
	AS
BEGIN
	SELECT COUNT(1) AS MemberCount 
	FROM GroupMember 
	WHERE GroupKey=@groupkey
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GroupRoleCountByType]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GroupRoleCountByType]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_GroupRoleCountByType]
	@groupTypeKey uniqueidentifier,
	@groupRoleKey uniqueidentifier
	AS
BEGIN
	SELECT COUNT(1) AS RoleCount 
	FROM GroupMain INNER JOIN  GroupMemberDetail ON GroupMain.GroupKey = GroupMemberDetail.GroupKey
	WHERE GroupMain.GroupTypeKey = @groupTypeKey AND GroupRoleKey=@groupRoleKey AND GroupMemberDetail.IsActive = 1
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GroupRoleInstanceCountByType]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GroupRoleInstanceCountByType]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_GroupRoleInstanceCountByType]
	@groupTypeKey uniqueidentifier,
	@groupRoleKey uniqueidentifier
	AS
BEGIN
	SELECT COUNT(1) AS RoleCount 
	FROM GroupMain INNER JOIN GroupInstanceRole on GroupMain.GroupKey = GroupInstanceRole.GroupKey
	WHERE GroupMain.GroupTypeKey = @groupTypeKey AND GroupInstanceRole.GroupRoleKey=@groupRoleKey
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_GroupTypeMembershipByContact]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_GroupTypeMembershipByContact]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_GroupTypeMembershipByContact] (@contactKey uniqueidentifier) 
AS
BEGIN

SELECT DISTINCT GroupMain.GroupTypeKey, GroupTypeRef.GroupTypeName
FROM	GroupMember INNER JOIN
	GroupMain ON GroupMember.GroupKey = GroupMain.GroupKey INNER JOIN
	GroupTypeRef ON GroupMain.GroupTypeKey = GroupTypeRef.GroupTypeKey
WHERE     (GroupMember.MemberContactKey = @contactKey)
ORDER BY GroupTypeRef.GroupTypeName

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_HierarchyResortChildren]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_HierarchyResortChildren]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_HierarchyResortChildren] 
    @parentHierarchyKey uniqueidentifier,
    @parentDepth int = -1 
AS
BEGIN
	SET NOCOUNT ON
	IF (@parentDepth < 0)
	   SELECT @parentDepth = Depth FROM [dbo].[Hierarchy] WHERE [HierarchyKey] = @parentHierarchyKey

	INSERT INTO #Reorder (HierarchyKey, NewDepth) VALUES (@parentHierarchyKey, @parentDepth)

	DECLARE @ChildrenTable TABLE
	(
		[HierarchyKey] uniqueidentifier,
		[SortOrder] int,
		[Depth] int
	)

	INSERT INTO @ChildrenTable
	    SELECT HierarchyKey, SortOrder, @parentDepth + 1 
	      FROM Hierarchy 
	     WHERE ParentHierarchyKey = @parentHierarchyKey

	DECLARE @childHierarchyKey uniqueidentifier
    DECLARE @childDepth int
	
	WHILE EXISTS (SELECT 1 FROM @ChildrenTable)
	BEGIN
		SELECT TOP 1 @childHierarchyKey = HierarchyKey, @childDepth = Depth FROM @ChildrenTable ORDER BY SortOrder
		EXEC asi_HierarchyResortChildren @childHierarchyKey, @childDepth
		DELETE FROM @ChildrenTable WHERE HierarchyKey = @childHierarchyKey
	END

	SET NOCOUNT OFF
END


GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_HierarchyAlphaResortChildren]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_HierarchyAlphaResortChildren]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- Recursively sorts hierarchy into alpha order.
-- Called by asi_HierarchyAlphaResort.
CREATE PROCEDURE [dbo].[asi_HierarchyAlphaResortChildren] 
    @parentHierarchyKey uniqueidentifier, 
    @parentDepth int = -1 
AS
BEGIN
	SET NOCOUNT ON
	
	IF (@parentDepth < 0)
	   SELECT @parentDepth = Depth FROM [dbo].[Hierarchy] WHERE [HierarchyKey] = @parentHierarchyKey


	INSERT INTO #Reorder (HierarchyKey, NewDepth) VALUES (@parentHierarchyKey, @parentDepth)

	DECLARE @ChildrenTable TABLE
	(
		[HierarchyKey] uniqueidentifier,
        [DocumentName] nvarchar(100),
        [DocumentTypeCode] nvarchar(3),
        [Depth] int
	)

	INSERT INTO @ChildrenTable
	    SELECT h.[HierarchyKey], d.[DocumentName], d.[DocumentTypeCode], @parentDepth + 1
          FROM [dbo].[Hierarchy] h 
               INNER JOIN [dbo].[DocumentMain] d ON h.UniformKey = d.DocumentVersionKey 
         WHERE h.[ParentHierarchyKey] = @parentHierarchyKey

	DECLARE @childHierarchyKey uniqueidentifier
    DECLARE @childDocumentType nvarchar(3)
    DECLARE @childDepth int
	
	WHILE EXISTS (SELECT 1 FROM @ChildrenTable)
	BEGIN
		SELECT TOP 1 @childHierarchyKey = [HierarchyKey], @childDocumentType = [DocumentTypeCode], @childDepth = [Depth]
          FROM @ChildrenTable ORDER BY [DocumentName]
        IF (@childDocumentType != 'NAV')
		    EXEC asi_HierarchyAlphaResortChildren @childHierarchyKey, @childDepth
        ELSE
            EXEC asi_HierarchyResortChildren @childHierarchyKey, @childDepth
		DELETE FROM @ChildrenTable WHERE [HierarchyKey] = @childHierarchyKey
	END

	SET NOCOUNT OFF
END


GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_HierarchyAlphaResort]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_HierarchyAlphaResort]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- Resets the SortOrder column on all records within a given Root Hierarchy so that
-- documents refered to are in alphanumeric order
CREATE PROCEDURE [dbo].[asi_HierarchyAlphaResort] 
    @rootHierarchyKey uniqueidentifier 
AS
BEGIN
   SET NOCOUNT ON

   CREATE TABLE #Reorder (
      NewSortOrder int IDENTITY (0,2048),
      HierarchyKey uniqueidentifier,
      NewDepth int)

   DECLARE @rootDepth int
   SELECT @rootDepth = Depth FROM [dbo].[Hierarchy] WHERE [HierarchyKey] = @rootHierarchyKey
   EXEC asi_HierarchyAlphaResortChildren @rootHierarchyKey, @rootDepth

   UPDATE h
      SET h.SortOrder = r.NewSortOrder,
          h.Depth = r.NewDepth
     FROM [dbo].[Hierarchy] h 
          INNER JOIN #Reorder r ON h.HierarchyKey = r.HierarchyKey

   DROP TABLE #Reorder

   SET NOCOUNT OFF
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_HierarchyDeleteBranch]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_HierarchyDeleteBranch]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- Deletes the hierarchy branched rooted at the hierarchyKey sent in.  This includes all descendants
CREATE PROCEDURE [dbo].[asi_HierarchyDeleteBranch] @hierarchyKey uniqueidentifier AS
DECLARE
	@LowSort int, @HighSort int, @RootHierarchyKey uniqueidentifier
BEGIN
	-- first, find the high (if it is there) as the lowest sort order that is higher than the one sent in
	-- and with a depth equal or shallower
	SELECT @RootHierarchyKey = a.RootHierarchyKey, @LowSort = a.SortOrder, @HighSort = Min(b.SortOrder)
	  FROM Hierarchy a LEFT OUTER JOIN Hierarchy b
	    ON a.RootHierarchyKey = b.RootHierarchyKey
	   AND a.SortOrder < b.SortOrder
	   AND a.Depth >= b.Depth
	 WHERE a.HierarchyKey = @hierarchyKey
	 GROUP BY a.RootHierarchyKey, a.SortOrder
	
	-- if we found the high sort, delete everything in between
	IF @HighSort IS NOT NULL
	BEGIN
		DELETE 
		  FROM Hierarchy 
		 WHERE RootHierarchyKey = @RootHierarchyKey
		   AND SortOrder >= @LowSort 
		   AND SortOrder < @HighSort
	END
	-- if we didn't, delete everything beyond this one
	ELSE
	BEGIN
		DELETE 
		  FROM Hierarchy 
		 WHERE RootHierarchyKey = @RootHierarchyKey
		   AND SortOrder >= @LowSort 
	END
	
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_HierarchyDemoteBranch]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_HierarchyDemoteBranch]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- Demotes the hierarchy branch rooted at the hierarchyKey sent in to be the last child of
-- its older sibling. Since it is already in the right place as far as sort order goes, this
-- just means incrementing the depth on all descendants and changing the parent of the one sent
CREATE PROCEDURE [dbo].[asi_HierarchyDemoteBranch] @hierarchyKey uniqueidentifier AS
DECLARE
	@NewParentSort int, @Depth int, @LowSort int, @HighSort int, @RootHierarchyKey uniqueidentifier
BEGIN
	-- find the prior sibling that will become the parent
	SELECT @RootHierarchyKey = a.RootHierarchyKey, @Depth=a.Depth, @LowSort = a.SortOrder, @NewParentSort = ISNULL(Max(b.SortOrder),0)
	  FROM Hierarchy a LEFT OUTER JOIN Hierarchy b
            ON a.RootHierarchyKey = b.RootHierarchyKey
           AND a.SortOrder > b.SortOrder
	   AND a.Depth = b.Depth
	   AND a.ParentHierarchyKey = b.ParentHierarchyKey
	 WHERE a.HierarchyKey = @hierarchyKey
	 GROUP BY a.RootHierarchyKey, a.Depth, a.SortOrder

	-- if we didn't get one (shouldn't happen) throw an exception
	if @NewParentSort IS NULL
		RAISERROR ('Cannot Demote. No older sibling available',16,1)
	
	-- find the high sortorder to move (if it is there) as the lowest sort order that is higher than the one sent in
	-- and with a depth equal or shallower
	SELECT @HighSort = Min(SortOrder)
	  FROM Hierarchy
	 WHERE RootHierarchyKey = RootHierarchyKey
	   AND SortOrder > @LowSort
	   AND Depth <= @Depth
	
	-- if we found the high sort, update everything in between
	IF @HighSort IS NOT NULL
	BEGIN
		UPDATE Hierarchy 
		   SET Depth = Depth + 1
		 WHERE RootHierarchyKey = @RootHierarchyKey
		   AND SortOrder >= @LowSort 
		   AND SortOrder < @HighSort
	END
	-- if we didn't, update everything beyond this one
	ELSE
	BEGIN
		UPDATE Hierarchy 
		   SET Depth = Depth + 1
		 WHERE RootHierarchyKey = @RootHierarchyKey
		   AND SortOrder >= @LowSort 
	END

	-- move to the new parent
	UPDATE Hierarchy
	   SET ParentHierarchyKey = (
		SELECT HierarchyKey
		  FROM Hierarchy
		 WHERE RootHierarchyKey = @RootHierarchyKey
		   AND SortOrder = @NewParentSort)
	 WHERE HierarchyKey = @hierarchyKey
	
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_HierarchyGetAdjacentSortOut]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_HierarchyGetAdjacentSortOut]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- Given the HierarchyKey of the Hierarchy element near which the new (or moved) one needs to go, and where, in relation
-- to this near one it needs to be, this procedure returns a SortOrder that will place the new (or moved) record
-- in the right place.  If there is no space to put it there (i.e., there is no integer between the record just prior
-- and the record just after) the entire hierarchy, from the root, will be resorted so all SortOrders are divisible by 2048
-- Values for addType parameter:
--    0 - Before the adjacent Hierarchy record, as a sibling
--    1 - After the adjacent Hierarchy record, as a sibling
--    2 - As the first child of the adjacent Hierarchy record
--    3 - As the last child of the adjacent Hierarchy record
--    4 - With the same sort order as that of the adjacent Hierarchy record (for use when sorting after the fact, e.g., alpha)
-- TO DO: implement locking later so sort order can't come up twice with highly concurrent work
-- TO DO: Resort has deadlocking issues - fix!
CREATE PROCEDURE [dbo].[asi_HierarchyGetAdjacentSortOut] @adjacentHierarchyKey uniqueidentifier, @addType smallint = 3, @NewSort int OUTPUT AS
DECLARE
      @LowSort int, @HighSort int, @SortOrder int, @RootHierarchyKey uniqueidentifier, @Run bit
BEGIN
      SET @Run = 1
      WHILE @Run = 1
      BEGIN
            -- BeforeAsSibling - SortOrder is between that of the adjacentHierarchyKey and the max SortOrder lower than that (or 0 if none)
            IF @addType = 0
            BEGIN
                  SELECT @RootHierarchyKey = a.RootHierarchyKey, @HighSort = a.SortOrder, @LowSort = ISNULL(Max(b.SortOrder),0)
                   FROM Hierarchy a LEFT OUTER JOIN Hierarchy b
                          ON a.RootHierarchyKey = b.RootHierarchyKey
                         AND a.SortOrder > b.SortOrder
                  WHERE a.HierarchyKey = @adjacentHierarchyKey
                  GROUP BY a.SortOrder, a.RootHierarchyKey
            END
      
            -- AfterAsSibling or AsLastChild - The SortOrder for both is the same but parent and depth will be different.
            -- SortOrder is between the min SortOrder on an element with a higher SortOrder and an equal or higher depth 
            -- (lower depth number) than that of the adjacentHierarchyKey and the max sort order lower than that.
            ELSE IF @addType = 1 OR @addType = 3
            BEGIN
                  -- first, find the high (if it is there) as the lowest sort order that is higher than the adjacent one
                  -- and with a depth equal or shallower than the adjacent one
                  SELECT @RootHierarchyKey = a.RootHierarchyKey, @HighSort = Min(b.SortOrder)
                   FROM Hierarchy a LEFT OUTER JOIN Hierarchy b
                          ON a.RootHierarchyKey = b.RootHierarchyKey
                         AND a.SortOrder < b.SortOrder
                     AND a.Depth >= b.Depth
                  WHERE a.HierarchyKey = @adjacentHierarchyKey
                  GROUP BY a.RootHierarchyKey
      
                  -- if we found the high sort, then the low is the one just lower
                  IF @HighSort IS NOT NULL
                  BEGIN
                        SELECT @LowSort = Max(a.SortOrder)
                         FROM Hierarchy a
                        WHERE a.RootHierarchyKey = @RootHierarchyKey
                           AND a.SortOrder < @HighSort 
                  END
                  -- if we didn't find one, the Low is the last sort order for the root and the max is that + 4096
                  ELSE
                  BEGIN
                        SELECT @LowSort = Max(a.SortOrder)
                         FROM Hierarchy a
                        WHERE a.RootHierarchyKey = @RootHierarchyKey
      
                        SET @HighSort = @LowSort + 4096
                  END
      
            END
      
            -- AsFirstChild  - SortOrder is between that of the adjacentHierarchyKey and the min SortOrder higher than that
            ELSE IF @addType = 2
            BEGIN
                  SELECT @RootHierarchyKey = a.RootHierarchyKey, @LowSort = a.SortOrder, @HighSort = ISNULL(Min(b.SortOrder), a.SortOrder + 4096)
                   FROM Hierarchy a LEFT OUTER JOIN Hierarchy b
                          ON a.RootHierarchyKey = b.RootHierarchyKey
                     AND a.SortOrder < b.SortOrder
                  WHERE a.HierarchyKey = @adjacentHierarchyKey
                  GROUP BY a.SortOrder, a.RootHierarchyKey
            END
            -- Same  - SortOrder is the same as the adjecent one (presumably the parent or a sibling)
            ELSE IF @addType = 4
            BEGIN
                  SELECT @RootHierarchyKey = a.RootHierarchyKey, @LowSort = a.SortOrder, @HighSort = a.SortOrder
                   FROM Hierarchy a
                  WHERE a.HierarchyKey = @adjacentHierarchyKey
            END
      
            -- if there is no room between the low and the high, need to redo the sort order for this root
            IF @HighSort - @LowSort < 2  AND @addType != 4
                  EXEC asi_HierarchyResort2 @RootHierarchyKey
            ELSE
                  SET @Run = 0
      END

      SET @NewSort = ISNULL(((@HighSort - @LowSort) / 2) + @LowSort, 0)
END


GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_HierarchyGetAdjacentSort]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_HierarchyGetAdjacentSort]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- Calls asi_HierarchyGetAdjacentSortOut using an OUTPUT Variable but returning the answer in a result set
CREATE PROCEDURE [dbo].[asi_HierarchyGetAdjacentSort] @adjacentHierarchyKey uniqueidentifier, @addType smallint = 3 AS
DECLARE @NewSort int
BEGIN
  EXEC asi_HierarchyGetAdjacentSortOut @adjacentHierarchyKey, @addType, @NewSort OUTPUT

  SELECT @NewSort AS NewSort
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_HierarchyMoveBranch]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_HierarchyMoveBranch]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- Moves the hierarchy branch rooted at the moveHierarchyKey sent in to be the next youngest sibling
-- of the targetHierarchyKey. The item can be moved as the oldest child of the targetHierarchyKey by
-- passing moveAsChild. All descendents are also moved.  Moving means changeing sort order on
-- all to be moved, changing the parent of the one sent in moveHierarchyKey, and possibly changing the depth
-- on all to be moved.
CREATE PROCEDURE [dbo].[asi_HierarchyMoveBranch] @moveHierarchyKey uniqueidentifier, @targetHierarchyKey uniqueidentifier, @addType smallint = 1 AS
DECLARE
	@MoveRootHierarchyKey uniqueidentifier, @MoveDepth int, @MoveLowSort int, @MoveHighSort int, 
	@TargetDepth int, @TargetLowSort int, @TargetHighSort int, @TargetRootHierarchyKey uniqueidentifier,
	@TargetParentHierarchyKey uniqueidentifier, @Adjustment int, @MoveAdjustment int, @DepthAdjustment int
BEGIN
	-- 1. Figure out the low and high sort order containing the branch to be moved
	SELECT @MoveRootHierarchyKey = a.RootHierarchyKey, @MoveDepth = a.Depth, @MoveLowSort = a.SortOrder, @MoveHighSort = Min(b.SortOrder) - 1
	  FROM Hierarchy a LEFT OUTER JOIN Hierarchy b
            ON a.RootHierarchyKey = b.RootHierarchyKey
           AND a.SortOrder < b.SortOrder
	   AND a.Depth >= b.Depth
	 WHERE a.HierarchyKey = @moveHierarchyKey
	 GROUP BY a.RootHierarchyKey, a.Depth, a.SortOrder

	IF @MoveHighSort IS NULL
		SELECT @MoveHighSort = Max(a.SortOrder)
 		  FROM Hierarchy a
		 WHERE a.RootHierarchyKey = @MoveRootHierarchyKey

	-- 2. Get the SortOrder, Depth and parent of the target and
	-- figure out the low and high sort order of the target area

	-- get the sort order of where the moved item itself should go
	EXEC asi_HierarchyGetAdjacentSortOut @targetHierarchyKey, @addType, @TargetLowSort OUTPUT

	-- then find the relavent keys and the top sort order in the target area
	SELECT @TargetRootHierarchyKey = a.RootHierarchyKey, @TargetDepth = a.Depth, 
	       @TargetParentHierarchyKey = a.ParentHierarchyKey, @TargetHighSort = Min(b.SortOrder)
	  FROM Hierarchy a LEFT OUTER JOIN Hierarchy b
            ON a.RootHierarchyKey = b.RootHierarchyKey
           AND b.SortOrder > @TargetLowSort
	 WHERE a.HierarchyKey = @targetHierarchyKey
	 GROUP BY a.RootHierarchyKey, a.Depth, a.ParentHierarchyKey
     
     --If we are moving the item as a child of the target, set depth and parent key.
     If @addType = 2 OR @addType = 3
     BEGIN
		SET @TargetParentHierarchyKey = @targetHierarchyKey
        SET @TargetDepth = @TargetDepth + 1
     END

	-- 3. Expand the target area by moving all higher ones back (unless we're moving to the end)
	SET @Adjustment = 0
	IF @TargetHighSort IS NOT NULL AND (@MoveLowSort <> @TargetLowSort OR @MoveRootHierarchyKey <> @TargetRootHierarchyKey)
	BEGIN
		SET @Adjustment = @MoveHighSort - @MoveLowSort + 2048
		UPDATE Hierarchy
		   SET SortOrder = SortOrder + @Adjustment
		 WHERE SortOrder >= @TargetHighSort
 		   AND RootHierarchyKey = @TargetRootHierarchyKey
	END

	-- 4. update the SortOrder of the items to be moved so they move into the target area.  Update depth as well
	IF @MoveLowSort <= @TargetLowSort
		SET @Adjustment = 0

	SET @MoveAdjustment = (@TargetLowSort + 2048) - (@MoveLowSort + @Adjustment)
	IF @MoveLowSort = @TargetLowSort
		SET @MoveAdjustment = 0

	SET @DepthAdjustment = @TargetDepth - @MoveDepth

	UPDATE Hierarchy
	   SET SortOrder = SortOrder + @MoveAdjustment,
	       RootHierarchyKey = @TargetRootHierarchyKey,
	       Depth = Depth + @DepthAdjustment
	 WHERE RootHierarchyKey = @MoveRootHierarchyKey
	   AND SortOrder >= @MoveLowSort + @Adjustment
	   AND SortOrder <= @MoveHighSort + @Adjustment

	-- 5. update the moved item to reflect its new parent
	UPDATE Hierarchy
	   SET ParentHierarchyKey = @TargetParentHierarchyKey
	 WHERE HierarchyKey = @moveHierarchyKey
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_HierarchyResort]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_HierarchyResort]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- Resets the SortOrder column on all records within a given Root Hierarchy so that each is a multiple
-- of 2048.  This allows for 12 worst case inserts before a resort is needed.
CREATE PROCEDURE [dbo].[asi_HierarchyResort] 
    @rootHierarchyKey uniqueidentifier 
AS
BEGIN
   SET NOCOUNT ON

   CREATE TABLE #Reorder (
      NewSortOrder int IDENTITY (0,2048),
      HierarchyKey uniqueidentifier,
      NewDepth int)

   DECLARE @rootDepth int
   SELECT @rootDepth = Depth FROM [dbo].[Hierarchy] WHERE [HierarchyKey] = @rootHierarchyKey

   EXEC asi_HierarchyResortChildren @rootHierarchyKey, @rootDepth

   UPDATE Hierarchy
      SET SortOrder = NewSortOrder,
          Depth = NewDepth
     FROM Hierarchy 
          INNER JOIN #Reorder ON Hierarchy.HierarchyKey = #Reorder.HierarchyKey

   SET NOCOUNT OFF
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_InsertChangeLog]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_InsertChangeLog]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_InsertChangeLog]

@logKey uniqueidentifier, 
@orgKey uniqueidentifier,
@objectTypeName nvarchar(100),
@objectKey uniqueidentifier,
@actionType tinyint, 
@desc nvarchar(250),
@createdOn datetime,
@createdByUserKey uniqueidentifier

AS

INSERT 
	ChangeLog (ChangeLogKey, OrganizationKey, ObjectTypeName, ObjectKey, ActionType, Description, CreatedOn, CreatedByUserKey)
	VALUES
	(@logKey, @orgKey, @objectTypeName, @objectKey, @actionType, @desc, @createdOn, @createdByUserKey)

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_InsertChangeProperty]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_InsertChangeProperty]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_InsertChangeProperty]

@logKey uniqueidentifier,
@propertyName nvarchar(100),
@originalValue nvarchar(250),
@originalDesc nvarchar(250),
@currentValue nvarchar(250),
@currentDesc nvarchar(250)

AS

INSERT 
	ChangeProperty (ChangeLogKey, PropertyName, OriginalValue, OriginalDescription, CurrentValue, CurrentDescription)
	VALUES
	(@logKey, @propertyName, @originalValue, @originalDesc, @currentValue, @currentDesc)

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_InsertSystemConfig]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_InsertSystemConfig]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


-- Creates the necessary entries in PropertyDefinition, SystemConfigParameterRef, (optionally) SystemConfig
-- and SystemConfigPageParameterRef in the correct in order to create working, UI editable
-- configuration parameters

CREATE PROCEDURE [dbo].[asi_InsertSystemConfig] 
      @systemKeyword nvarchar(25),
      @systemConfigPageName nvarchar(30),
      @userId nvarchar(60),
      @systemConfigKey uniqueidentifier,
      @parameterName nvarchar(255),
      @propertyDefinitionKey uniqueidentifier,
      @dataTypeCode int,
      @hiControlTypeCode int,
      @hiControlWidth int,
      @description nvarchar(500),
      @defaultParameterValue nvarchar(2500),
      @sortOrder int = -1,
      @createSystemConfigRow bit = 1    -- Specify 0 in call to utilize existing SystemConfig row
AS
BEGIN

      DECLARE @systemEntityKey uniqueidentifier
      DECLARE @systemConfigPageKey uniqueidentifier
      DECLARE @systemUserKey uniqueidentifier
      DECLARE @organizationKey uniqueidentifier

      -- gets the system entity key for the system (module)
      SELECT @systemEntityKey = [SystemEntityKey] FROM [dbo].[SystemEntity] WHERE [SystemKeyword] = @systemKeyword

      -- Get existing page key
      SELECT @systemConfigPageKey = [SystemConfigPageKey] FROM [dbo].[SystemConfigPageRef] WHERE [SystemConfigPageName] = @systemConfigPageName

      -- Get a user key to use for the System Config variable
      SELECT @systemUserKey = [UserKey] FROM [dbo].[UserMain] WHERE [UserId] = @userId
      -- Provide fall-back values if UserId is not found (rather than failing on insert with cannot insert NULL)
      IF @systemUserKey IS NULL
          SELECT @systemUserKey = [UserKey] FROM [dbo].[UserMain] WHERE [UserId] = 'SYSTEM'
      IF @systemUserKey IS NULL
          SELECT @systemUserKey = [UserKey] FROM [dbo].[UserMain] WHERE [UserId] = 'ADMINISTRATOR'
      IF @systemUserKey IS NULL
          SELECT @systemUserKey = [UserKey] FROM [dbo].[UserMain] WHERE [UserId] = 'MANAGER'

      -- Get the default organization for the system config variable
      SELECT @organizationKey = [OrganizationKey] FROM [dbo].[OrganizationMain] WHERE [IsDefault] = 1

      -- create the property definition for the new parameter
      IF NOT EXISTS (SELECT 1 FROM [dbo].[PropertyDefinition] WHERE [PropertyDefinitionKey] = @propertyDefinitionKey)
      BEGIN
            INSERT INTO [dbo].[PropertyDefinition] (
                  [PropertyDefinitionKey],
                  [Label],
                  [DataTypeCode],
                  [HIControlTypeCode],
                  [HIControlWidth]) 
            VALUES (
                  @propertyDefinitionKey, 
                  @parameterName, 
                  @dataTypeCode, 
                  @hiControlTypeCode, 
                  @hiControlWidth)
      END

      -- create the definition for the new parameter
      IF NOT EXISTS (SELECT 1 FROM [dbo].[SystemConfigParameterRef] WHERE [ParameterName] = @parameterName)
      BEGIN
            INSERT INTO [dbo].[SystemConfigParameterRef] (
                  [ParameterName],
                  [SystemKeyword],
                  [PropertyDefinitionKey],
                  [Description],
                  [DefaultParameterValue]) 
            VALUES (
                  @parameterName, 
                  @systemKeyword, 
                  @propertyDefinitionKey, 
                  @description, 
                  @defaultParameterValue)
      END

      -- Create the SystemConfig variable itself
      IF @createSystemConfigRow = 1 
         AND NOT EXISTS (SELECT 1 FROM [dbo].[SystemConfig] WHERE [SystemConfigKey] = @systemConfigKey)
      BEGIN
            INSERT INTO [dbo].[SystemConfig] (
                  [SystemConfigKey],
                  [ParameterName],
                  [ParameterValue],
                  [Description],
                  [CreatedByUserKey],
                  [CreatedOn],
                  [UpdatedByUserKey],
                  [UpdatedOn],
                  [OrganizationKey],
                  [SystemEntityKey]) 
            VALUES (
                  @systemConfigKey, 
                  @parameterName, 
                  @defaultParameterValue, 
                  @description, 
                  @systemUserKey, 
                  GETDATE(),
                  @systemUserKey, 
                  GETDATE(), 
                  @organizationKey, 
                  @systemEntityKey)
      END

      -- connect the parameter to the page
      IF NOT EXISTS (SELECT 1 FROM [dbo].[SystemConfigPageParameterRef] 
                           WHERE [SystemConfigPageKey] = @systemConfigPageKey AND [ParameterName] = @parameterName)
      BEGIN

            -- Validate the supplied sort order
            SET @sortOrder = ISNULL(@sortOrder,-1)
            IF @sortOrder != -1
            BEGIN
                -- Check if this sort location is already in use
                  IF EXISTS (SELECT 1 FROM [dbo].[SystemConfigPageParameterRef] WHERE [SystemConfigPageKey] = @systemConfigPageKey AND [SortOrder] = @sortOrder)
                  BEGIN
                      -- Sort location is already in use, so update the existing sort orders to create a space
                      UPDATE [dbo].[SystemConfigPageParameterRef]
                         SET [SortOrder] = ISNULL([SortOrder],0) + 1
                       WHERE [SystemConfigPageKey] = @systemConfigPageKey AND ISNULL([SortOrder],0) >= @sortOrder
                  END
            END
        ELSE
            BEGIN
                -- Place the sort order at the end
                  SELECT @sortOrder = ISNULL(MAX([SortOrder]),0) + 1 FROM [dbo].[SystemConfigPageParameterRef] WHERE [SystemConfigPageKey] = @systemConfigPageKey
            END


            INSERT INTO [dbo].[SystemConfigPageParameterRef] (
                  [SystemConfigPageKey],
                  [ParameterName],
                  [SortOrder]) 
            VALUES (
                  @systemConfigPageKey, 
                  @parameterName, 
                  @sortOrder)
      END

END





GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_InstitutesFromIndividual]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_InstitutesFromIndividual]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE  PROCEDURE [dbo].[asi_InstitutesFromIndividual]
	@individualkey uniqueidentifier
AS
BEGIN
select vBoInstitute.ContactKey from vBoInstitute
	where vBoInstitute.InstituteGroupKey in 
		(select	vBoGroup.GroupKey from vBoGroup inner join GroupMember 
			on vBoGroup.GroupKey = GroupMember.GroupKey 
			where GroupMember.MemberContactKey = @individualkey)
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_InstitutesFromIndividualByType]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_InstitutesFromIndividualByType]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE  PROCEDURE [dbo].[asi_InstitutesFromIndividualByType]
	@institutegrouptypekey uniqueidentifier,
	@individualkey uniqueidentifier
AS
BEGIN
select vBoInstitute.ContactKey from vBoInstitute
	where vBoInstitute.InstituteGroupKey in 
		(select	vBoGroup.GroupKey from vBoGroup inner join GroupMember 
			on vBoGroup.GroupKey = GroupMember.GroupKey 
			where GroupMember.MemberContactKey = @individualkey and
	           			vBoGroup.GroupTypeKey = @institutegrouptypekey)
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_IsVatTaxableOrder]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_IsVatTaxableOrder]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- For a given order or event, returns whether VAT should be charged
-- PARAMETERS
-- @orgCode             The financial entity (org) for the order.
--                      If passed empty the default org is assumed.
-- @billToId            Bill to contact Id.
-- @shipToId            Ship to contact Id.
-- @shipToCountry       The currently selected ship to country code. Accepts either a country name or country code.
--                      This may not necessarily be the ship to contacts ship to country. It may have been manually changed on the order.
-- @applyVat OUT        Returns a bit to indicate whether VAT should be charged for this order.
-- @vatCountryCode OUT  Returns the country code that VAT is being charged based on.
--                      Will always be empty unless @applyVat == 1
-- @taxCodeSub OUT      The substitute tax code to be used if VAT is not to be charged

-- The procedure also returns single row resultset containing the value returned by @applyVat OUT, @vatCountryCode OUT, @taxCodeSub OUT

CREATE PROCEDURE [dbo].[asi_IsVatTaxableOrder]
    @orgCode varchar(5),
    @billToID varchar(10),
    @shipToID varchar(10),
    @shipToCountry varchar(25),
    @applyVat bit = NULL OUT,
    @vatCountryCode varchar(2) = NULL OUT,
    @taxCodeSub varchar(15) = '' OUT    
AS
BEGIN

    -- declare variables    
    DECLARE @taxOnShipTo bit
    DECLARE @orgVatCountryCode varchar(2)
    DECLARE @contactIsVatExempt bit
    DECLARE @contactVatRegNumber varchar(25)
    DECLARE @contactVatCountryCode varchar(2)
    DECLARE @billToVatCountryCode varchar(2)
    DECLARE @shipToVatCountryCode varchar(2)
        
    DECLARE @vatZeroExempt as varchar(255)
    DECLARE @vatZeroOrderOtherEu as varchar(255)
    DECLARE @vatZeroOrderOutsideEu as varchar(255)

    -- retrieve substitute tax codes
    SELECT @vatZeroExempt=ShortValue FROM System_Params WHERE ParameterName='AR_Control.VatZeroExempt'
    SELECT @vatZeroOrderOtherEu=ShortValue FROM System_Params WHERE ParameterName='AR_Control.VatZeroOrderOtherEu'
    SELECT @vatZeroOrderOutsideEu=ShortValue FROM System_Params WHERE ParameterName='AR_Control.VatZeroOrderOutsideEu'
    SET @vatZeroExempt = ISNULL(@vatZeroExempt,'')
    SET @vatZeroOrderOtherEu = ISNULL(@vatZeroOrderOtherEu,'')
    SET @vatZeroOrderOutsideEu = ISNULL(@vatZeroOrderOutsideEu,'')
    
    -- default the return value to no vat
    SET @applyVat = 0
    SET @vatCountryCode = ''

    -- check we are licensed for VAT
    IF NOT EXISTS (SELECT 1 
                     FROM [dbo].[LicenseLegacyList] 
                    WHERE [LegacyLicenseCode]='VAT') 
    BEGIN
        GOTO ReturnValue
    END

    -- get the org's VAT country code
    -- as part of this we check that it is a vat org and it has a vat country defined
    -- if no org was specified, then assume the default org
    IF LEN(ISNULL(@orgCode, ''))=0
    BEGIN
        SELECT @orgCode = o.[OrgCode], @orgVatCountryCode = o.[VATCountry]
          FROM [dbo].[Org_Control] o 
         WHERE o.[DefaultFlag]=1 AND o.[UseVATTaxation]=1 AND LEN(o.[VATCountry])>0
    END
    ELSE
    BEGIN
        SELECT @orgVatCountryCode = o.[VATCountry]
          FROM [dbo].[Org_Control] o 
         WHERE o.[OrgCode]=@orgCode AND o.[UseVATTaxation]=1 AND LEN(o.[VATCountry])>0
    END
    IF @@ROWCOUNT=0
    BEGIN
        GOTO ReturnValue
    END
    
    -- now we have established the org is correctly configured for vat,
    -- assume we are going to charge vat
    SET @applyVat = 1
    SET @vatCountryCode = @orgVatCountryCode

    -- determine whether to use TaxOnShipTo option
    -- if the setting cannot be found, default to false
    SELECT @taxOnShipTo = CASE WHEN [ShortValue]='YES' THEN 1 ELSE 0 END
      FROM [dbo].[System_Params]
     WHERE [ParameterName] = 'AR_Control.TaxOnShipTo'  
    IF @@ROWCOUNT=0
    BEGIN
        SET @taxOnShipTo = 0
    END     
 
    -- process based on the taxation method
    IF @taxOnShipTo = 1
    BEGIN
        
        -- do we have a ship to id
        IF LEN(ISNULL(@shipToID, ''))=0
        BEGIN
            GOTO ReturnValue
        END
        
        -- load vat details from the ship to contact
        SELECT @contactIsVatExempt = ISNULL(nf.[USE_VAT_TAXATION],0),
               @contactVatRegNumber = ISNULL(nf.[VAT_REG_NUMBER],''),
               @contactVatCountryCode = ISNULL(nf.[VAT_COUNTRY],'')
          FROM [dbo].[Name] n 
               LEFT OUTER JOIN [dbo].[Name_Fin] nf ON n.[ID] = nf.[ID]
         WHERE n.[ID]=@shipToID
        IF @@ROWCOUNT=0
        BEGIN
            GOTO ReturnValue
        END
         
        -- if the contact is vat exempt, go no further
        IF @contactIsVatExempt=1
        BEGIN
            SET @applyVat = 0
            SET @taxCodeSub = @vatZeroExempt
            GOTO ReturnValue
        END
        
        -- establish the vat country code of the ship to country 
        -- if no country was specified, or we can't find a match, assume its the org vat country code
        SET @shipToVatCountryCode = @orgVatCountryCode
        IF LEN(ISNULL(@shipToCountry,''))>0
        BEGIN
                                                -- check the ship to country exists
                                                -- we could have been supplied either a country code or a country name    
                                                IF LEN(@shipToCountry)<=2
                                                BEGIN
                                                                SELECT @shipToVatCountryCode = c.[VAT_COUNTRY_CODE]
                                                                  FROM [dbo].[Country_Names] c
                                                                WHERE c.[COUNTRY_CODE] = @shipToCountry
                                                END
                                                ELSE
                                                BEGIN
                                                                SELECT @shipToVatCountryCode = c.[VAT_COUNTRY_CODE]
                                                                  FROM [dbo].[Country_Names] c
                                                                WHERE c.[COUNTRY] = @shipToCountry
                                                END
            -- if the above doesn't find anything, @shipToVatCountryCode remains unchanged
        END
        
        -- is the contact considered vat registered
        IF LEN(@contactVatRegNumber)>0 AND LEN(@contactVatCountryCode)>0 AND @contactVatCountryCode=@shipToVatCountryCode
        BEGIN
            -- not taxable if different EU country from org
            IF (@contactVatCountryCode != @orgVatCountryCode)
            BEGIN
                SET @applyVat = 0
                SET @taxCodeSub = @vatZeroOrderOtherEu
                GOTO ReturnValue
            END
        END
    
        -- if we have a ship to vat country code, then charge vat
        IF LEN(@shipToVatCountryCode)>0
        BEGIN
            SET @vatCountryCode = @shipToVatCountryCode
        END
        ELSE
        BEGIN
            SET @applyVat = 0
            SET @taxCodeSub = @vatZeroOrderOutsideEu
        END
         
    END
    ELSE
    BEGIN
        
        -- do we have a bill to id
        IF LEN(ISNULL(@billToID, ''))=0
        BEGIN
            GOTO ReturnValue
        END
        
        -- load vat details from the bill to contact
        SELECT @contactIsVatExempt = ISNULL(nf.[USE_VAT_TAXATION],0),
               @contactVatRegNumber = ISNULL(nf.[VAT_REG_NUMBER],''),
               @contactVatCountryCode = ISNULL(nf.[VAT_COUNTRY],'')
          FROM [dbo].[Name] n 
               LEFT OUTER JOIN [dbo].[Name_Fin] nf ON n.[ID] = nf.[ID]
         WHERE n.[ID]=@billToID
        IF @@ROWCOUNT=0
        BEGIN
            GOTO ReturnValue
        END
         
        -- if the contact is vat exempt, go no further
        IF @contactIsVatExempt=1
        BEGIN
            SET @applyVat = 0
            SET @taxCodeSub = @vatZeroExempt
            GOTO ReturnValue
        END

        -- establish the vat country code for the bill to contact
        -- if the contact has a specific vat country code defined, use that
        -- otherwise establish it from their billing address
        IF LEN(@contactVatCountryCode)>0
        BEGIN
            SET @billToVatCountryCode = @contactVatCountryCode
        END
        ELSE
        BEGIN
            -- get the vat country code from the contacts billing country
            -- if the contact has no billing country, assume the org vat country
            SELECT @billToVatCountryCode = c.[VAT_COUNTRY_CODE]
              FROM [dbo].[Name_Address] n
                   INNER JOIN [dbo].[Country_Names] c ON n.[COUNTRY] = c.[COUNTRY]
             WHERE n.[ID] = @billToID AND n.[PREFERRED_BILL]=1 AND LEN(ISNULL(n.[COUNTRY],''))>0
            IF @@ROWCOUNT=0
            BEGIN
                SET @billToVatCountryCode = @orgVatCountryCode
            END
        END
        
        -- is the contact considered vat registered
        IF LEN(@contactVatRegNumber)>0
        BEGIN
            -- not taxable if different EU country from org
            IF (@billToVatCountryCode != @orgVatCountryCode)
            BEGIN
                SET @applyVat = 0
                SET @taxCodeSub = @vatZeroOrderOtherEu
                GOTO ReturnValue
            END
        END

        -- if we have a bill to vat country code, then charge vat
        IF LEN(@billToVatCountryCode)>0
        BEGIN
            SET @vatCountryCode = @billToVatCountryCode
        END
        ELSE
        BEGIN
            SET @applyVat = 0
            SET @taxCodeSub = @vatZeroOrderOutsideEu
        END
        
    END

ReturnValue:    
 
    -- if we arent applying vat, then clear any country code
    IF @applyVat = 0
    BEGIN
        SET @vatCountryCode = ''
    END

    -- return the values as a resultset for desktop
    SELECT @applyVat AS [ApplyVat], @vatCountryCode AS [VatCountryCode], @taxCodeSub AS [TaxCodeSub]

END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_IsVatTaxableRegistration2]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_IsVatTaxableRegistration2]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_IsVatTaxableRegistration2]
    @eventCode varchar(10),
    @registrantCountry varchar(25),
    @registrantIsCompany bit,
    @registrantIsVatRegistered bit,
    @registrantVatCountry varchar(25)='',
    @applyVat bit = NULL OUT,
    @taxCodeSub varchar(15) = '' OUT   
AS
BEGIN

    -- declare variables    
    DECLARE @orgCode varchar(5)
    DECLARE @orgCountryCode varchar(2)
    DECLARE @registrantCountryCode varchar(2)
    DECLARE @ruleSet varchar(10)
    DECLARE @isEuCountry bit
    DECLARE @taxOnShipTo bit
    DECLARE @shipToVatCountryCode varchar(25)
     
    -- determine whether to use TaxOnShipTo option. defaults to false.
    SELECT @taxOnShipTo = CASE WHEN [ShortValue]='YES' THEN 1 ELSE 0 END
      FROM [dbo].[System_Params]
     WHERE [ParameterName] = 'AR_Control.TaxOnShipTo'  
 
    -- default the return value to true
    -- this effectively means, handle tax as you always did
    -- if we fail any validations we want the system to behave as it always did
    SET @applyVat = 1
    
    -- check we are licensed for VAT
    IF NOT EXISTS (SELECT 1 
                     FROM [dbo].[LicenseLegacyList] 
                    WHERE [LegacyLicenseCode]='VAT') 
    BEGIN
        GOTO ReturnValue
    END

    -- verify the event exists, and retrieve some basic details
    IF LEN(ISNULL(@eventCode, ''))=0
    BEGIN
        GOTO ReturnValue
    END
    SELECT @orgCode = [ORG_CODE], @ruleSet = [VAT_RULESET]
      FROM [dbo].[Meet_Master] 
     WHERE [MEETING] = @eventCode
    IF @@ROWCOUNT=0
    BEGIN
        GOTO ReturnValue
    END

    -- if the event has no vat ruleset assigned, we need go no further
    IF LEN(ISNULL(@ruleSet, ''))=0
    BEGIN
        GOTO ReturnValue
    END

    -- verify the event org code is configured for VAT, and that a VAT country has been specified for the org  
    -- if the event has no org code, assume the default org code
    IF LEN(ISNULL(@orgCode, ''))=0
    BEGIN
        SELECT @orgCode = o.[OrgCode], @orgCountryCode = c.[COUNTRY_CODE]
          FROM [dbo].[Org_Control] o 
               INNER JOIN [dbo].[Country_Names] c on o.[VATCountry]=c.[VAT_COUNTRY_CODE]
         WHERE o.[DefaultFlag]=1 AND o.[UseVATTaxation]=1 AND LEN(o.[VATCountry])>0
    END
    ELSE
    BEGIN
        SELECT @orgCountryCode = c.[COUNTRY_CODE]
          FROM [dbo].[Org_Control] o 
               INNER JOIN [dbo].[Country_Names] c on o.[VATCountry]=c.[VAT_COUNTRY_CODE]
         WHERE o.[OrgCode]=@orgCode AND o.[UseVATTaxation]=1 AND LEN(o.[VATCountry])>0
    END
    IF @@ROWCOUNT = 0
    BEGIN
        GOTO ReturnValue
    END
           
    -- verify the contact country exists
    -- if no country was supplied, establish the default
    SET @registrantCountryCode = NULL
    IF LEN(ISNULL(@registrantCountry, ''))=0
    BEGIN
        -- no country supplied, so assume the default
        -- use the VAT country code from the default org
        -- but only if the default org is configured for VAT
        SELECT @registrantCountryCode=c.[COUNTRY_CODE], @shipToVatCountryCode =  c.[VAT_COUNTRY_CODE] 
          FROM [dbo].[Org_Control] o 
               INNER JOIN [dbo].[Country_Names] c on o.[VATCountry]=c.[VAT_COUNTRY_CODE]
         WHERE o.[DefaultFlag]=1 AND o.[UseVATTaxation]=1 AND LEN(o.[VATCountry])>0
        -- if we still don't have a country code, assume US
        IF @@ROWCOUNT=0
        BEGIN
            SET @registrantCountryCode='US'        
            SET @shipToVatCountryCode=''
        END
    END
    ELSE
    BEGIN     
        -- check the supplied country exists    
        IF LEN(@registrantCountry)<=2
        BEGIN
            SELECT @registrantCountryCode = [COUNTRY_CODE], @shipToVatCountryCode =  [VAT_COUNTRY_CODE]  
              FROM [dbo].[Country_Names] 
             WHERE [COUNTRY_CODE]=@registrantCountry
        END
        ELSE
        BEGIN
            SELECT @registrantCountryCode = [COUNTRY_CODE], @shipToVatCountryCode =  [VAT_COUNTRY_CODE]  
              FROM [dbo].[Country_Names] 
             WHERE [COUNTRY]=@registrantCountry
        END
        IF @@ROWCOUNT=0
        BEGIN
            GOTO ReturnValue
        END
    END

    -- if taxing on ShipTo, then correct the @registrantIsVatRegistered flag, to ALSO check VatCountry
    IF @taxOnShipTo=1 AND @registrantIsVatRegistered = 1
    BEGIN
          SELECT @registrantIsVatRegistered = CASE WHEN LEN(ISNULL(@registrantVatCountry, ''))>0 AND @registrantVatCountry=@shipToVatCountryCode THEN 1 ELSE 0 END
    END
    
    -- now we have everything we need to start processing the rules
    
    -- determine whether the contact country is within the EU
    IF EXISTS (SELECT 1
                 FROM [dbo].[Country_Names]
                WHERE [COUNTRY_CODE]=@registrantCountryCode AND [MAIL_GROUP]='EU') 
    BEGIN
        SET @isEuCountry = 1
    END
    ELSE
    BEGIN
        SET @isEuCountry = 0
    END
    
    -- process the ruleset
    SELECT TOP 1 @applyVat = [VAT_APPLIES], @taxCodeSub = [TAX_CODE_SUB]
     FROM [dbo].[Vat_Rule]
     WHERE [VAT_RULESET]=@ruleSet
           AND ([VAT_REGISTERED]=CASE @registrantIsVatRegistered WHEN 1 THEN 'Y' ELSE 'N' END OR [VAT_REGISTERED]='')
           AND ([COMPANY_CONTACT]=CASE @registrantIsCompany WHEN 1 THEN 'Y' ELSE 'N' END OR [COMPANY_CONTACT]='')
           AND (([LOCATION]='Same' AND @registrantCountryCode=@orgCountryCode)
                  OR
                ([LOCATION]='EU' AND @isEuCountry=1 AND @registrantCountryCode<>@orgCountryCode)
                  OR
                ([LOCATION]='NonEU' AND @isEuCountry=0)
                  OR
                [LOCATION]=''
               )
     ORDER BY [RULE_ORDER]
        
    IF @@ROWCOUNT = 0
    BEGIN
        SET @applyVat = 1
    END     
 
ReturnValue:    
    
    -- output parameter has already been set
    -- also return the value as a resultset for desktop
    SELECT @applyVat AS [ApplyVat], @taxCodeSub AS [TaxCodeSub]
    
END


GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_IsVatTaxableRegistration]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_IsVatTaxableRegistration]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- For a given registration, returns whether VAT should be charged
-- @eventCode = The code of the event being registered for
-- @registrantId = The ID of the contact who is registering
-- @registrantCountry = The country the contact is registering from, either the country name or country code can be used
-- @applyVat OUT = Returns a bit to indicate whether VAT should or should not be charged in this registration scenario
-- @taxCodeSub OUT = Returns the substitute tax code to be used if VAT is not to be charged
-- The procedure also returns single row single column resultset containing the value returned by @applyVat OUT, taxCodeSub OUT

CREATE PROCEDURE [dbo].[asi_IsVatTaxableRegistration]
    @eventCode varchar(10),
    @registrantId varchar(10),
    @registrantCountry varchar(25),
    @applyVat bit = NULL OUT,
    @taxCodeSub varchar(15) = '' OUT 
AS
BEGIN

    -- declare variables    
    DECLARE @isVatRegistered bit
    DECLARE @isVatExempt bit
    DECLARE @isCompany bit
    DECLARE @registrantVatCountry varchar(25)
     
    DECLARE @vatZeroExempt as varchar(255)
    SELECT @vatZeroExempt=ShortValue FROM System_Params WHERE ParameterName='AR_Control.VatZeroExempt'
    SET @vatZeroExempt = ISNULL(@vatZeroExempt,'')

    -- default the return value to true
    -- this effectively means, handle tax as you always did
    -- if we fail any validations we want the system to behave as it always did
    SET @applyVat = 1

    -- verify the contact exists, and retrieve some basic details
    -- USE_VAT_TAXATION is confusing, if a contact is marked VAT Exempt, [USE_VAT_TAXATION] is actually 1
    IF LEN(ISNULL(@registrantId, ''))=0
    BEGIN
        GOTO ReturnValue
    END
    SELECT @isCompany = n.[COMPANY_RECORD],
           @isVatRegistered = CASE WHEN LEN(ISNULL(nf.[VAT_REG_NUMBER], ''))>0 THEN 1 ELSE 0 END,
           @isVatExempt = CASE WHEN ISNULL(nf.[USE_VAT_TAXATION], 0)=1 THEN 1 ELSE 0 END,
           @registrantVatCountry = ISNULL(nf.[VAT_COUNTRY],'')
      FROM [dbo].[Name] n 
           LEFT OUTER JOIN [dbo].[Name_Fin] nf ON n.[ID] = nf.[ID]
     WHERE n.[ID]=@registrantId
    IF @@ROWCOUNT=0
    BEGIN
        GOTO ReturnValue
    END

    -- if the contact is vat exempt, go no further
    IF @isVatExempt=1
    BEGIN
        SET @applyVat = 0 
        SET @taxCodeSub = @vatZeroExempt
        GOTO ReturnValue
    END
        
    -- see if parent record is a company record (if there is a parent)
    IF @isCompany=0
    BEGIN
        SELECT @isCompany = p.[COMPANY_RECORD]
          FROM [dbo].[Name] p 
               LEFT OUTER JOIN [dbo].[Name] c ON p.[ID] = c.[CO_ID]
         WHERE c.[ID]=@registrantId
    END
    
    EXEC [dbo].[asi_IsVatTaxableRegistration2] @eventCode, @registrantCountry, @isCompany, @isVatRegistered, @registrantVatCountry, @applyVat OUT, @taxCodeSub OUT
ReturnValue:    
    
    -- output parameter has already been set
    -- also return the value as a resultset for desktop
    SELECT @applyVat AS [ApplyVat], @taxCodeSub AS [TaxCodeSub]
    
END  

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_LoadPrinterList]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_LoadPrinterList]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_LoadPrinterList    Script Date: 7/3/2003 4:58:04 PM ******/
CREATE   PROC asi_LoadPrinterList
	AS
BEGIN
	select SystemConfigKey, ParameterName, ParameterValue, Description from SystemConfig
where ParameterName='Printer'
	
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_LoginTokenCleanup]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_LoginTokenCleanup]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- Cleanup old login tokens
CREATE PROCEDURE [dbo].[asi_LoginTokenCleanup]
AS
BEGIN

     -- Tokens are only valid for 60 seconds, so anything older than 5 minutes has long expired
     DELETE FROM [dbo].[LoginToken]
     WHERE [CreatedOn] <= DATEADD(minute,-5,GETUTCDATE())
        
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_LoginTokenCreate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_LoginTokenCreate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- Create a login token for a specific user
-- @username : The username of the user to create the token for
-- @token : Returns the token
CREATE PROCEDURE [dbo].[asi_LoginTokenCreate]
     @username nvarchar(256),
     @token nvarchar(50) = NULL OUT
AS
BEGIN

     -- Create the token
     SET @token = NEWID()
     INSERT INTO [dbo].[LoginToken] ([Token], [UserName], [CreatedOn], [Expired])
     VALUES (@token, @username, GETUTCDATE(), 0)

     EXEC [dbo].[asi_LoginTokenCleanup]

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_LoginTokenValidate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_LoginTokenValidate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- Validate a login token
-- @token : the token to validate
-- @username : Returns the username of the user it authenticates,
-- or null if the token is invalid or expired
CREATE PROCEDURE [dbo].[asi_LoginTokenValidate]
     @token nvarchar(50),
     @username nvarchar(256) = NULL OUT
AS
BEGIN

     DECLARE @valid BIT

     -- look for an active token created within the last 60 seconds
     SELECT @username = [UserName] 
       FROM [dbo].[LoginToken]
      WHERE [Token] = @token
            AND [CreatedOn] > DATEADD(second,-60,GETUTCDATE())
            AND [Expired] = 0
            
     -- update the token on the database
     IF @@ROWCOUNT > 0
     BEGIN
          -- we found a valid token
          -- we've now used it so mark it as expired, these are one time use only
          UPDATE [dbo].[LoginToken] 
             SET [Expired]=1 
           WHERE [Token] = @token
     END
     ELSE
     BEGIN
          -- we couldn't find a valid token
          -- delete any invalid matches
          DELETE FROM [dbo].[LoginToken] WHERE [Token] = @token
     END
      
     -- cleanup expired tokens
     EXEC [dbo].[asi_LoginTokenCleanup]
        
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_LogMerge]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_LogMerge]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- This will mark all properties as being merged.
-- Used by the merge process ahead of the actual merge.
-- =============================================
CREATE PROCEDURE [dbo].[asi_LogMerge] 
    @fromContactId varchar(10),
    @toContactId varchar(10),
    @userName varchar(60)
AS
BEGIN
    SET NOCOUNT ON;
    --change the existing "from" logs
    UPDATE [dbo].[Name_Log] 
       SET [LOG_TEXT] =  
           CASE WHEN [LOG_TEXT] NOT LIKE '%Merged' THEN [LOG_TEXT] + ' - Merged'
                ELSE [LOG_TEXT]
           END
     WHERE ID = @fromContactId;

     DECLARE @currentDate datetime;
     DECLARE @currentTS timestamp;
     DECLARE @text nvarchar(800);
     SET @currentDate = GETDATE();
     SET @text = 'Party.Merged: ID ' + @fromContactId + ' -> ID ' + @toContactId;

     --add to to-party
     INSERT INTO [dbo].[Name_Log] ([DATE_TIME], [LOG_TYPE], [SUB_TYPE], [USER_ID], [ID], [LOG_TEXT])
          VALUES(@currentDate, 'CHANGE', 'MERGE', @userName, @toContactId, @text);
END




GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_MergeCustomizerUDTables]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_MergeCustomizerUDTables]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


-- =============================================
-- This procedure will gather up all the custom UD Tables defined by the customer
-- and load them into a meta table.  We will use this temp table to merge records
-- in these tables similar to what we do for asi_MergeReferences
-- =============================================
CREATE PROCEDURE [dbo].[asi_MergeCustomizerUDTables] ( @fromContactId varchar(10), 
                                               @toContactId varchar(10))
AS
BEGIN
       SET NOCOUNT ON;
    --create a temp table to store our metadata 
    CREATE TABLE #UDMergeSchemaReference([TableName] nvarchar(128) COLLATE DATABASE_DEFAULT NOT NULL,
                                         [ColumnName] nvarchar(128) COLLATE DATABASE_DEFAULT NOT NULL,
                                         [ProcessingOrder] int NOT NULL,
                                         [ProcessingType] nvarchar(10) COLLATE DATABASE_DEFAULT,
                                         [DataColumnName] nvarchar(128) COLLATE DATABASE_DEFAULT
                                         );

    -- Insert the update type rows for each of the defined UD tables
    INSERT INTO #UDMergeSchemaReference([TableName],
                                        [ColumnName],
                                        [ProcessingOrder],
                                        [ProcessingType],
                                        [DataColumnName])
    SELECT ud1.ObjectName AS TableName,
            'ID' AS [ColumnName],
            ROW_NUMBER() OVER (ORDER BY ud1.[ObjectName] ASC, udf.[SEQ]) AS [ProcessingOrder],
            CASE
            WHEN ud1.[IsMultiInstance] = 1
                THEN 'UPDATE'
            WHEN (ud2.[REQUIRED] = 1 AND c.DATA_TYPE = 'text')
                THEN 'IGNORE'
            WHEN (ud2.[REQUIRED] = 1 AND c.DATA_TYPE <> 'text')
                THEN 'DATAUPDATE'
                ELSE 'NODUPEKEY'
            END AS [ProcessingType],
            udf.[FIELD_NAME] AS [DataColumnName]
    FROM [dbo].[vUserDefinedDynamicBusinessObjectSources] AS ud1
        INNER JOIN dbo.[UD_Table] AS ud2 ON ud1.[ObjectName] = ud2.[TABLE_NAME]
        LEFT OUTER JOIN dbo.[UD_Field] AS udf ON ud2.[TABLE_NAME] = udf.[TABLE_NAME] AND ud2.[REQUIRED] = 1
        LEFT OUTER JOIN INFORMATION_SCHEMA.COLUMNS c ON ud2.[TABLE_NAME] = c.TABLE_NAME AND c.COLUMN_NAME = udf.[FIELD_NAME]
    ORDER BY ud1.[ObjectName], udf.[SEQ];

    DECLARE @UpdateRows int
    SELECT @UpdateRows = MAX([ProcessingOrder]) FROM #UDMergeSchemaReference

    -- Then insert the delete type rows so that we delete them last
    INSERT INTO #UDMergeSchemaReference([TableName],
                                    [ColumnName],
                                    [ProcessingOrder],
                                    [ProcessingType],
                                    [DataColumnName])
        SELECT ud1.[ObjectName] AS [TableName],
            'ID' AS [ColumnName],
            ROW_NUMBER() OVER (ORDER BY ud1.[ObjectName] ASC) + @UpdateRows AS [ProcessingOrder],
            'DELETE' AS [ProcessingType],
            NULL AS [DataColumnName]
        FROM dbo.[vUserDefinedDynamicBusinessObjectSources] AS ud1
        INNER JOIN dbo.[UD_Table] AS ud2 ON ud1.ObjectName = ud2.TABLE_NAME
        WHERE ud1.[IsMultiInstance] = 0
        ORDER BY ud1.[ObjectName];

    -- The processing logic - very similar to that seen in asi_MergePartyReferences save we also deal with multi-instance sequences
    DECLARE @tempProcessingStatement nvarchar(max);
    DECLARE @errorMessage nvarchar(max);
    SET @errorMessage = '';
    DECLARE @tempReferencesRowCount int;
    DECLARE @currentTable sysname;
    DECLARE @currentColumn sysname;
    DECLARE @currentOperation nvarchar(10);

    SET @tempReferencesRowCount = (SELECT MAX([ProcessingOrder]) FROM #UDMergeSchemaReference);

    DECLARE @counter int;
    SET @counter = 0;

    WHILE (@counter < @tempReferencesRowCount)
    BEGIN
        SET @counter += 1;
        --The following processing types explained:
        -- DATAUPDATE - Replace to-party's data column value if NULL with from-party data column value.
        -- NODUPKEY - If previous to-party record exists, we keep it and delete from-party or else switch keys.  This prevents duplicate key errors in certain tables.
        -- UPDATE - Switched out the from-party's key with the to-party's key and increments the SEQN 
        -- DELETE - Deletes the from-part record so order of table in list is important
        BEGIN TRY
            SELECT
               @currentColumn = [ColumnName],
               @currentTable = [TableName],
               @currentOperation = [ProcessingType],
               @tempProcessingStatement = 
               CASE WHEN [ProcessingType] = N'NODUPEKEY' THEN N'IF NOT EXISTS (SELECT * FROM '
                        + QUOTENAME([TableName]) 
                        + N' WHERE '
                        + QUOTENAME([ColumnName]) + N' = ''' 
                        + @toContactId + N''''
                        + N') BEGIN UPDATE'
                        + N' [dbo].' + QUOTENAME([TableName]) 
                        + N' SET ' + QUOTENAME([ColumnName]) +  N' = ''' 
                        + @toContactId + N''' WHERE ' 
                        + QUOTENAME([ColumnName]) + N' = ''' 
                        + @fromContactId + ''''
                        + N' END ELSE BEGIN DELETE FROM [dbo].'
                        + QUOTENAME([TableName])
                        + N' WHERE '
                        + QUOTENAME([ColumnName]) + N' = ''' 
                        + @fromContactId + N''' END'
                   WHEN [ProcessingType] = N'UPDATE' THEN N'UPDATE'
                        + N' [dbo].' + QUOTENAME([TableName]) 
                        + N' SET [SEQN] = [SEQN] + (SELECT COALESCE(MAX([SEQN]),0) FROM '
                        + N' [dbo].' + QUOTENAME([TableName]) 
                        + N' WHERE ' + QUOTENAME([ColumnName]) + N' = ''' 
                        + @toContactId + N''') '
                        + N' WHERE ' + QUOTENAME([ColumnName]) + N' = ''' 
                        + @fromContactId + N''';'
                        + N'UPDATE' 
                        + N' [dbo].' + QUOTENAME([TableName]) 
                        + N' SET ' + QUOTENAME([ColumnName]) + N' = ''' 
                        + @toContactId + ''''
                        + N' WHERE ' + QUOTENAME([ColumnName]) + N' = ''' 
                        + @fromContactId + N''''
                   WHEN [ProcessingType] = N'DELETE' THEN N'DELETE'
                        + N' FROM [dbo].' + QUOTENAME([TableName]) 
                        + N' WHERE ' 
                        + QUOTENAME([ColumnName]) + N' = ''' 
                        + @fromContactId + N''''
                   WHEN [ProcessingType] = N'DATAUPDATE' THEN N'UPDATE toTable SET'
                        + N'' + QUOTENAME([DataColumnName]) + N' = fromTable.'
                        + QUOTENAME([DataColumnName])  
                        + N' FROM [dbo].' + QUOTENAME([TableName]) + N' fromTable,'
                        + N' [dbo].' + QUOTENAME([TableName]) + ' toTable'
                        + N' WHERE fromTable.' + QUOTENAME([ColumnName]) + N' = '''
                        + @fromContactId + N''''
                        + N' AND toTable.'+ QUOTENAME([ColumnName]) + N' = '''
                        + @toContactId + ''''
                        + N' AND (toTable.'+ QUOTENAME([DataColumnName]) + N' IS NULL OR' 
                        + ' DATALENGTH(toTable.'+ QUOTENAME([DataColumnName]) + ') = 0 OR'
                        + ' (ISNUMERIC(toTable.' + QUOTENAME([DataColumnName]) +') = 1 AND' 
                        + ' toTable.' + QUOTENAME([DataColumnName]) + ' = 0))'
              END 
              FROM #UDMergeSchemaReference 
             WHERE [ProcessingOrder] = @counter;
            --PRINT @tempProcessingStatement;
            EXEC (@tempProcessingStatement);
        END TRY
        BEGIN CATCH
           SET @errorMessage  += '**' + 'Number = ' + convert(nvarchar(4), ERROR_NUMBER())
                                + ', ' + 'Severity = ' + convert(nvarchar(4), ERROR_SEVERITY())
                               + ', ' + 'Message = ' + convert(nvarchar(max), ERROR_MESSAGE())
                               + ' : ' + @currentTable + ' - ' + @currentColumn + ' - ' + @currentOperation
                                + CHAR(13);
            
            CONTINUE;
        END CATCH
    END

    -- Drop the temp table
    DROP TABLE #UDMergeSchemaReference;

    IF (@errorMessage <> '')
      RAISERROR(@errorMessage, 16, 1);
END



GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_MergeFinancialGroups]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_MergeFinancialGroups]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO



CREATE PROCEDURE [dbo].[asi_MergeFinancialGroups] 
    @fromContactId varchar(10), 
    @toContactId varchar(10)
AS
BEGIN
       SET NOCOUNT ON;

    --collect existing groups (product codes) for toParty
     DECLARE @ToPartyExistingGroups TABLE  (
        [GroupId] varchar(31)
     );

     WITH ExistingGroups
        AS (
        SELECT [PRODUCT_CODE] AS [GroupId]
          FROM [dbo].[Subscriptions]
         WHERE [ID] = @toContactId
        )
     INSERT INTO @ToPartyExistingGroups ([GroupId]) SELECT [GroupId] FROM ExistingGroups;

   --merge records that are only in the fromContact
      UPDATE [dbo].[Subscriptions]
         SET [ID] = @toContactId
       WHERE [ID] = @fromContactId
         AND [PRODUCT_CODE] NOT IN (SELECT [GroupId] FROM  @ToPartyExistingGroups);

   --extend record dates where there are matching records
     UPDATE toPartySubscriptions
            SET [BEGIN_DATE] = CASE WHEN toPartySubscriptions.[BEGIN_DATE] IS NOT NULL
                                     AND fromPartySubscriptions.[BEGIN_DATE] IS NOT NULL
                                     AND fromPartySubscriptions.[BEGIN_DATE] < toPartySubscriptions.[BEGIN_DATE]
                                    THEN fromPartySubscriptions.[BEGIN_DATE]
                                    WHEN toPartySubscriptions.[BEGIN_DATE] IS NULL
                                     AND fromPartySubscriptions.[BEGIN_DATE] IS NOT NULL
                                    THEN fromPartySubscriptions.[BEGIN_DATE]
                                    ELSE toPartySubscriptions.[BEGIN_DATE]
                                     END,
                [CONTINUOUS_SINCE] = CASE WHEN toPartySubscriptions.[CONTINUOUS_SINCE] IS NOT NULL
                                       AND fromPartySubscriptions.[CONTINUOUS_SINCE] IS NOT NULL
                                       AND fromPartySubscriptions.[CONTINUOUS_SINCE] < toPartySubscriptions.[CONTINUOUS_SINCE]
                                      THEN fromPartySubscriptions.[CONTINUOUS_SINCE]
                                      WHEN toPartySubscriptions.[CONTINUOUS_SINCE] IS NULL
                                       AND fromPartySubscriptions.[CONTINUOUS_SINCE] IS NOT NULL
                                      THEN fromPartySubscriptions.[CONTINUOUS_SINCE]
                                      ELSE toPartySubscriptions.[CONTINUOUS_SINCE]
                                       END,
                [BILL_THRU] = CASE WHEN toPartySubscriptions.[BILL_THRU] IS NOT NULL
                                       AND fromPartySubscriptions.[BILL_THRU] IS NOT NULL
                                       AND fromPartySubscriptions.[BILL_THRU] < toPartySubscriptions.[BILL_THRU]
                                      THEN fromPartySubscriptions.[BILL_THRU]
                                      WHEN toPartySubscriptions.[BILL_THRU] IS NULL
                                       AND fromPartySubscriptions.[BILL_THRU] IS NOT NULL
                                      THEN fromPartySubscriptions.[BILL_THRU]
                                      ELSE toPartySubscriptions.[BILL_THRU]
                                       END,
                [PAID_THRU] = CASE WHEN toPartySubscriptions.[PAID_THRU] IS NOT NULL
                                       AND fromPartySubscriptions.[PAID_THRU] IS NOT NULL
                                       AND fromPartySubscriptions.[PAID_THRU] < toPartySubscriptions.[PAID_THRU]
                                      THEN fromPartySubscriptions.[PAID_THRU]
                                      WHEN toPartySubscriptions.[PAID_THRU] IS NULL
                                       AND fromPartySubscriptions.[PAID_THRU] IS NOT NULL
                                      THEN fromPartySubscriptions.[PAID_THRU]
                                      ELSE toPartySubscriptions.[PAID_THRU]
                                       END,
                [LAST_PAID_THRU] = CASE WHEN toPartySubscriptions.[LAST_PAID_THRU] IS NOT NULL
                                       AND fromPartySubscriptions.[LAST_PAID_THRU] IS NOT NULL
                                       AND fromPartySubscriptions.[LAST_PAID_THRU] < toPartySubscriptions.[LAST_PAID_THRU]
                                     THEN fromPartySubscriptions.[LAST_PAID_THRU]
                                      WHEN toPartySubscriptions.[LAST_PAID_THRU] IS NULL
                                       AND fromPartySubscriptions.[LAST_PAID_THRU] IS NOT NULL
                                      THEN fromPartySubscriptions.[LAST_PAID_THRU]
                                      ELSE toPartySubscriptions.[LAST_PAID_THRU]
                                       END,
                [FUTURE_CREDITS] = toPartySubscriptions.[FUTURE_CREDITS] + fromPartySubscriptions.[FUTURE_CREDITS]
           FROM [dbo].[Subscriptions] toPartySubscriptions
     INNER JOIN @ToPartyExistingGroups g ON g.[GroupId] = toPartySubscriptions.[PRODUCT_CODE]
     INNER JOIN [dbo].[Subscriptions] fromPartySubscriptions ON fromPartySubscriptions.[PRODUCT_CODE] = toPartySubscriptions.[PRODUCT_CODE]   
          WHERE toPartySubscriptions.[ID] = @toContactId
            AND fromPartySubscriptions.[ID] = @fromContactId
  
    --make sure the gaining party gets the highest billing date data in the Name_Fin table
    UPDATE toNameFinTable
      SET [RENEWED_THRU] = CASE WHEN fromNameFinTable.[RENEWED_THRU] IS NOT NULL
                               AND toNameFinTable.[RENEWED_THRU] IS NOT NULL
                               AND fromNameFinTable.[RENEWED_THRU] > toNameFinTable.[RENEWED_THRU]
                              THEN fromNameFinTable.[RENEWED_THRU]
                              WHEN toNameFinTable.[RENEWED_THRU] IS NULL
                               AND fromNameFinTable.[RENEWED_THRU] IS NOT NULL
                              THEN fromNameFinTable.[RENEWED_THRU]
                              ELSE toNameFinTable.[RENEWED_THRU]
                               END
     FROM [dbo].[Name_Fin] toNameFinTable, [dbo].[Name_Fin] fromNameFinTable
    WHERE toNameFinTable.[ID] = @toContactId
      AND fromNameFinTable.[ID] = @fromContactId;   

   --delete fromContact records
   DELETE [dbo].[Subscriptions] WHERE [ID] = @fromContactId

END



GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_MergeFullAddressesDeleteDuplicatePurposes]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_MergeFullAddressesDeleteDuplicatePurposes]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO



/*=========================================================================
This procedure will merge all addresses between parties, excepting that the
system-based purpose addresses (such as 'Address' or 'Home Address') will
only be moved if the gaining party doesn't already have an entry.  Then the
losing party's addresses will be deleted.
TODO: Individual fields not xferred if empty in gaining party's existing system-purpose addresses
=========================================================================*/
CREATE PROCEDURE [dbo].[asi_MergeFullAddressesDeleteDuplicatePurposes] 
       @fromContactId varchar(10), 
       @toContactId varchar(10)
AS
BEGIN
       SET NOCOUNT ON;

       DECLARE @fromAddress1Key int,
               @fromAddress2Key int,
               @fromAddress3Key int,
               @toAddress1Key int,
               @toAddress2Key int,
               @toAddress3Key int,
               @toAddressShipKey int;
      
       --retrieve the three system purpose address keys for both parties, guarding against data corruption (record doesn't exist)
       --note that we also guard against all three addresses ending up with same address key (default setting when creating party)
       SET @fromAddress1Key = COALESCE ((SELECT [ADDRESS_NUM_1] 
                                          FROM [dbo].[Name] n1
                                    INNER JOIN [dbo].[Name_Address] add1 ON add1.[ADDRESS_NUM] = n1.[ADDRESS_NUM_1]
                                         WHERE n1.[ID] = @fromContactId),0);

       SET @toAddress1Key = COALESCE ((SELECT [ADDRESS_NUM_1] 
                                          FROM [dbo].[Name] n1
                                    INNER JOIN [dbo].[Name_Address] add1 ON add1.[ADDRESS_NUM] = n1.[ADDRESS_NUM_1]
                                         WHERE n1.[ID] = @toContactId),0);

       SET @fromAddress2Key = COALESCE ((SELECT [ADDRESS_NUM_2] 
                                          FROM [dbo].[Name] n1
                                    INNER JOIN [dbo].[Name_Address] add1 ON add1.[ADDRESS_NUM] = n1.[ADDRESS_NUM_2]
                                         WHERE n1.[ID] = @fromContactId
                                           AND n1.[ADDRESS_NUM_2] != n1.[ADDRESS_NUM_1]),0);

       SET @toAddress2Key = COALESCE ((SELECT [ADDRESS_NUM_2] 
                                          FROM [dbo].[Name] n1
                                    INNER JOIN [dbo].[Name_Address] add1 ON add1.[ADDRESS_NUM] = n1.[ADDRESS_NUM_2]
                                         WHERE n1.[ID] = @toContactId
                                           AND n1.[ADDRESS_NUM_2] != n1.[ADDRESS_NUM_1]),0);

      SET @fromAddress3Key = COALESCE ((SELECT [ADDRESS_NUM_3] 
                                          FROM [dbo].[Name] n1
                                    INNER JOIN [dbo].[Name_Address] add1 ON add1.[ADDRESS_NUM] = n1.[ADDRESS_NUM_3]
                                         WHERE n1.[ID] = @fromContactId
                                           AND n1.[ADDRESS_NUM_3] != n1.[ADDRESS_NUM_1]),0);

       SET @toAddress3Key = COALESCE ((SELECT [ADDRESS_NUM_3] 
                                          FROM [dbo].[Name] n1
                                    INNER JOIN [dbo].[Name_Address] add1 ON add1.[ADDRESS_NUM] = n1.[ADDRESS_NUM_3]
                                         WHERE n1.[ID] = @toContactId
                                           AND n1.[ADDRESS_NUM_3] != n1.[ADDRESS_NUM_1]),0);
        
        SET @toAddressShipKey = COALESCE ((SELECT [SHIP_ADDRESS_NUM] 
                                          FROM [dbo].[Name] n1
                                    INNER JOIN [dbo].[Name_Address] add1 ON add1.[ADDRESS_NUM] = n1.[SHIP_ADDRESS_NUM]
                                         WHERE n1.[ID] = @toContactId),0);

       --clear the preferred settings for the fromParty 
       UPDATE [dbo].[Name_Address]
          SET [PREFERRED_MAIL] = 0,
              [PREFERRED_BILL] = 0,
              [PREFERRED_SHIP] = 0
        WHERE [ID] = @fromContactId
       
       --transfer any of the system purpose addresses that are missing from toParty and exist in fromParty
       IF @fromAddress1Key > 0 AND @toAddress1Key = 0
           BEGIN
                UPDATE [dbo].[Name]
                   SET [ADDRESS_NUM_1] = @fromAddress1Key
                WHERE [ID] = @toContactId;

                UPDATE [dbo].[Name_Address]
                   SET [ID] = @toContactId
                 WHERE [ID] = @fromContactId
                   AND [ADDRESS_NUM] = @fromAddress1Key
           END;

       IF @fromAddress2Key > 0 AND @toAddress2Key = 0
           BEGIN
                UPDATE [dbo].[Name]
                   SET [ADDRESS_NUM_2] = @fromAddress2Key
                WHERE [ID] = @toContactId;

                UPDATE [dbo].[Name_Address]
                   SET [ID] = @toContactId
                 WHERE [ID] = @fromContactId
                   AND [ADDRESS_NUM] = @fromAddress2Key
           END;

       IF @fromAddress3Key > 0 AND @toAddress3Key = 0
           BEGIN
                UPDATE [dbo].[Name]
                   SET [ADDRESS_NUM_3] = @fromAddress3Key
                WHERE [ID] = @toContactId;

                UPDATE [dbo].[Name_Address]
                   SET [ID] = @toContactId
                 WHERE [ID] = @fromContactId
                   AND [ADDRESS_NUM] = @fromAddress3Key
           END;

       -- selectively update values where the toParty does not have an address element that the fromParty does have
       IF @fromAddress1Key > 0 AND @toAddress1Key > 0
           BEGIN
                -- populate physical address values if they are blank
                UPDATE toAddress
                   SET toAddress.[ADDRESS_1] = fromAddress.[ADDRESS_1],
                       toAddress.[ADDRESS_2] = fromAddress.[ADDRESS_2],
                       toAddress.[ADDRESS_3] = fromAddress.[ADDRESS_3],
                       toAddress.[CITY] = fromAddress.[CITY],
                       toAddress.[STATE_PROVINCE] = fromAddress.[STATE_PROVINCE],
                       toAddress.[ZIP] = fromAddress.[ZIP],
                       toAddress.[COUNTRY] = fromAddress.[COUNTRY],
                       toAddress.[FULL_ADDRESS] = fromAddress.[FULL_ADDRESS]
                  FROM [dbo].[Name_Address] fromAddress 
                        CROSS JOIN [dbo].[Name_Address] toAddress
                WHERE fromAddress.[ADDRESS_NUM] = @fromAddress1Key
                  AND toAddress.[ADDRESS_NUM] = @toAddress1Key
                  AND  toAddress.[ADDRESS_1] = ''
                  AND  toAddress.[ADDRESS_2] = ''
                  AND  toAddress.[ADDRESS_3] = ''
                  AND  toAddress.[CITY] = ''
                  AND  toAddress.[STATE_PROVINCE] = ''
                  AND  toAddress.[ZIP] = ''
                  -- We're not checking that the toAddress's country is blank.
                  -- If the rest of the physical address is blank in the ToParty,
                  -- overwrite the ToParty's country.

                -- populate phone value if it is blank
                UPDATE toAddress
                   SET toAddress.[PHONE] = fromAddress.[PHONE]
                  FROM [dbo].[Name_Address] fromAddress 
                        CROSS JOIN [dbo].[Name_Address] toAddress
                WHERE fromAddress.[ADDRESS_NUM] = @fromAddress1Key
                  AND toAddress.[ADDRESS_NUM] = @toAddress1Key
                  AND  toAddress.[PHONE] = ''

                -- populate fax value if it is blank
                UPDATE toAddress
                   SET toAddress.[FAX] = fromAddress.[FAX]
                  FROM [dbo].[Name_Address] fromAddress 
                        CROSS JOIN [dbo].[Name_Address] toAddress
                WHERE fromAddress.[ADDRESS_NUM] = @fromAddress1Key
                  AND toAddress.[ADDRESS_NUM] = @toAddress1Key
                  AND  toAddress.[FAX] = ''

                -- populate toll_free value if it is blank
                UPDATE toAddress
                   SET toAddress.[TOLL_FREE] = fromAddress.[TOLL_FREE]
                  FROM [dbo].[Name_Address] fromAddress 
                        CROSS JOIN [dbo].[Name_Address] toAddress
                WHERE fromAddress.[ADDRESS_NUM] = @fromAddress1Key
                  AND toAddress.[ADDRESS_NUM] = @toAddress1Key
                  AND  toAddress.[TOLL_FREE] = ''

                -- populate email value if it is blank
                UPDATE toAddress
                   SET toAddress.[EMAIL] = fromAddress.[EMAIL]
                  FROM [dbo].[Name_Address] fromAddress 
                        CROSS JOIN [dbo].[Name_Address] toAddress
                WHERE fromAddress.[ADDRESS_NUM] = @fromAddress1Key
                  AND toAddress.[ADDRESS_NUM] = @toAddress1Key
                  AND  toAddress.[EMAIL] = ''
                  
                -- populate note value if it is blank
                UPDATE toAddress
                   SET toAddress.[NOTE] = fromAddress.[NOTE]
                  FROM [dbo].[Name_Address] fromAddress 
                        CROSS JOIN [dbo].[Name_Address] toAddress
                WHERE fromAddress.[ADDRESS_NUM] = @fromAddress1Key
                  AND toAddress.[ADDRESS_NUM] = @toAddress1Key
                  AND toAddress.[NOTE] IS NULL
 
       END

       --move over all remaining addresses that are not included in system purpose
       UPDATE [dbo].[Name_Address]
          SET ID = @toContactId
        WHERE [ID] = @fromContactId
          AND [ADDRESS_NUM] NOT IN ( @fromAddress1Key, @fromAddress2Key, @fromAddress3Key)
          
       --identify all addresses that are about to be deleted and ensure that any Orders, Order_Badge, or Name_PL_Pref entries using them are also updated
       DECLARE @fromAddressesToDelete TABLE(AddressKey int NOT NULL)
       
       INSERT @fromAddressesToDelete(AddressKey)
       SELECT na.[ADDRESS_NUM]  
         FROM dbo.[Name_Address] na
        WHERE na.[ID] = @fromContactId
        
       UPDATE o
          SET [ST_ADDRESS_NUM] = @toAddressShipKey
         FROM [dbo].[Orders] o INNER JOIN @fromAddressesToDelete a ON o.[ST_ADDRESS_NUM] = a.[AddressKey]
        
       UPDATE ob
          SET [ADDRESS_NUM] = @toAddressShipKey
         FROM [dbo].[Order_Badge] ob INNER JOIN @fromAddressesToDelete a ON ob.[ADDRESS_NUM] = a.[AddressKey]

        --now delete remaining system purpose addresses for from-party
        DELETE [dbo].[Name_Address]
         WHERE [ID] = @fromContactId
      
        --restore the full address required for legacy desktop and reports
          UPDATE n
          SET n.[FULL_ADDRESS] = na.[FULL_ADDRESS],
              n.[CITY] = na.[CITY],
              n.[STATE_PROVINCE] = na.[STATE_PROVINCE],
              n.[ZIP] = na.[ZIP],
              n.[COUNTRY] = na.[COUNTRY],
              n.[COUNTY] = na.[COUNTY],
              n.[CRRT] = na.[CRRT],
              n.[BAR_CODE] = na.[BAR_CODE]
         FROM [dbo].[Name] n
              INNER JOIN [dbo].[Name_Address] na ON n.[MAIL_ADDRESS_NUM] = na.[ADDRESS_NUM] AND n.[ID] = @toContactId;
       
END




GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_MergeGroups]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_MergeGroups]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO




CREATE PROCEDURE [dbo].[asi_MergeGroups] 
    @fromContactId varchar(10), 
    @toContactId varchar(10)
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @currentDate datetime
    DECLARE @fromContactKey uniqueidentifier;
    DECLARE @toContactKey uniqueidentifier;

    --need our guid keys
    SET @fromContactKey = (SELECT [ContactKey]
                         FROM [dbo].[ContactMain]
                         WHERE [SyncContactID] = @fromContactId);
    SET @toContactKey = (SELECT [ContactKey]
                        FROM [dbo].[ContactMain]
                       WHERE [SyncContactID] = @toContactId);

    SET @currentDate = GETDATE();

    --make sure the gaining party gets the group-related data in the Name table
    UPDATE toNameTable
      SET [JOIN_DATE] = CASE WHEN fromNameTable.[JOIN_DATE] IS NOT NULL
                              AND toNameTable.[JOIN_DATE] IS NOT NULL
                              AND fromNameTable.[JOIN_DATE] < toNameTable.[JOIN_DATE]
                             THEN fromNameTable.[JOIN_DATE]
                             WHEN toNameTable.[JOIN_DATE] IS NULL
                              AND fromNameTable.[JOIN_DATE] IS NOT NULL
                             THEN fromNameTable.[JOIN_DATE]
                             ELSE toNameTable.[JOIN_DATE]
                             END,
       -- Choose proper MEMBER_STATUS based on MEMBER_STATUS_DATE
       [MEMBER_STATUS] = CASE WHEN fromNameTable.[MEMBER_STATUS_DATE] IS NOT NULL
                               AND toNameTable.[MEMBER_STATUS_DATE] IS NOT NULL
                               AND fromNameTable.[MEMBER_STATUS_DATE] > toNameTable.[MEMBER_STATUS_DATE]
                              THEN fromNameTable.[MEMBER_STATUS]
                              WHEN toNameTable.[MEMBER_STATUS_DATE] IS NULL
                               AND fromNameTable.[MEMBER_STATUS_DATE] IS NOT NULL
                              THEN fromNameTable.[MEMBER_STATUS]
                              ELSE toNameTable.[MEMBER_STATUS]
                               END,
       [MEMBER_STATUS_DATE] = CASE WHEN fromNameTable.[MEMBER_STATUS_DATE] IS NOT NULL
                               AND toNameTable.[MEMBER_STATUS_DATE] IS NOT NULL
                               AND fromNameTable.[MEMBER_STATUS_DATE] > toNameTable.[MEMBER_STATUS_DATE]
                              THEN fromNameTable.[MEMBER_STATUS_DATE]
                              WHEN toNameTable.[MEMBER_STATUS_DATE] IS NULL
                               AND fromNameTable.[MEMBER_STATUS_DATE] IS NOT NULL
                              THEN fromNameTable.[MEMBER_STATUS_DATE]
                              ELSE toNameTable.[MEMBER_STATUS_DATE]
                               END,
       -- Choose proper PAID_THRU 
       [PAID_THRU] = CASE WHEN fromNameTable.[PAID_THRU] IS NOT NULL
                               AND toNameTable.[PAID_THRU] IS NOT NULL
                               AND fromNameTable.[PAID_THRU] > toNameTable.[PAID_THRU]
                              THEN fromNameTable.[PAID_THRU]
                              WHEN toNameTable.[PAID_THRU] IS NULL
                               AND fromNameTable.[PAID_THRU] IS NOT NULL
                              THEN fromNameTable.[PAID_THRU]
                              ELSE toNameTable.[PAID_THRU]
                               END
     FROM [dbo].[Name] toNameTable, [dbo].[Name] fromNameTable
    WHERE toNameTable.[ID] = @toContactId
      AND fromNameTable.[ID] = @fromContactId;

    --update group exipration dates where fromParty and toParty have matching groups and roles - favor the longer fromParty date
    --update group effective dates as well - favor the earlier date.  Also pass along the active flag if active
    --do not update dates where from party has already reached their expiration
    --do not update expiration dates where from-party's membership started after the to-party's membership 
    --do not update any historical data (either membership ended on or before current date)
    UPDATE toGroupMemberDetail
       SET [ExpirationDate] = CASE WHEN fromGroupMemberDetail.[ExpirationDate] IS NOT NULL
                                    AND toGroupMemberDetail.[ExpirationDate] IS NOT NULL
                                    AND fromGroupMemberDetail.[ExpirationDate] > toGroupMemberDetail.[ExpirationDate] 
                                    AND fromGroupMemberDetail.[EffectiveDate] < toGroupMemberDetail.[ExpirationDate] 
                                   THEN fromGroupMemberDetail.[ExpirationDate] 
                                   WHEN fromGroupMemberDetail.[ExpirationDate] IS NULL
                                    AND fromGroupMemberDetail.IsActive = 1
                                   THEN fromGroupMemberDetail.[ExpirationDate]  
                                   ELSE toGroupMemberDetail.[ExpirationDate]                                  
                                    END,
           [EffectiveDate] = CASE WHEN fromGroupMemberDetail.[EffectiveDate] IS NOT NULL
                                   AND toGroupMemberDetail.[EffectiveDate] IS NOT NULL
                                   AND fromGroupMemberDetail.[EffectiveDate] < toGroupMemberDetail.[EffectiveDate] 
                                  THEN fromGroupMemberDetail.[EffectiveDate]  
                                  ELSE toGroupMemberDetail.[EffectiveDate]                                  
                                   END,
           [IsActive] = CASE WHEN fromGroupMemberDetail.[IsActive] = 1
                             THEN 1
                             ELSE toGroupMemberDetail.[IsActive] END,
           [GroupMemberStatusCode] = CASE WHEN fromGroupMemberDetail.[IsActive] = 1 
                                           AND toGroupMemberDetail.[IsActive] = 0
                                          THEN fromGroupMemberDetail.[GroupMemberStatusCode]
                                          ELSE toGroupMemberDetail.[GroupMemberStatusCode] END
      FROM [dbo].[GroupMemberDetail] toGroupMemberDetail
            INNER JOIN [dbo].[GroupMemberDetail] fromGroupMemberDetail ON toGroupMemberDetail.[GroupKey] = fromGroupMemberDetail.[GroupKey] 
                   AND toGroupMemberDetail.[GroupRoleKey] = fromGroupMemberDetail.[GroupRoleKey]
            INNER JOIN [dbo].[GroupMember] toGroupMember ON toGroupMember.[GroupMemberKey] = toGroupMemberDetail.[GroupMemberKey]
            INNER JOIN [dbo].[GroupMember] fromGroupMember ON fromGroupMember.[GroupMemberKey] = fromGroupMemberDetail.[GroupMemberKey]
     WHERE toGroupMember.[MemberContactKey] = @toContactKey
       AND fromGroupMember.[MemberContactKey] = @fromContactKey
       AND (fromGroupMemberDetail.[ExpirationDate] IS NULL OR fromGroupMemberDetail.[ExpirationDate] > @currentDate)
       AND (toGroupMemberDetail.[ExpirationDate] IS NULL OR toGroupMemberDetail.[ExpirationDate] > @currentDate)
    
    --update group active flag where fromParty and toParty have matching groups  
    UPDATE toGroupMember
       SET [DropDate] = CASE WHEN FromGroupMember.[DropDate] IS NOT NULL
                              AND toGroupMember.[DropDate] IS NOT NULL
                              AND fromGroupMember.[DropDate] > toGroupMember.[DropDate] 
                             THEN fromGroupMember.[DropDate] 
                             WHEN fromGroupMember.[DropDate] IS NULL
                              AND fromGroupMember.IsActive = 1
                             THEN fromGroupMember.[DropDate]    
                             ELSE toGroupMember.[DropDate] END,
            [IsActive] = CASE WHEN fromGroupMember.[IsActive] = 1
                             THEN 1
                             ELSE toGroupMember.[IsActive] END                              
      FROM [dbo].[GroupMember] toGroupMember
            INNER JOIN [dbo].[GroupMember] fromGroupMember ON toGroupMember.[GroupKey] = fromGroupMember.[GroupKey]
     WHERE toGroupMember.[MemberContactKey] = @toContactKey
       AND fromGroupMember.[MemberContactKey] = @fromContactKey

    --add roles where fromParty and toParty share groups but fromParty has extra roles
    UPDATE fromGroupMemberDetail
       SET [GroupMemberKey] = toGroupMemberDetail.[GroupMemberKey]
    FROM [dbo].[GroupMemberDetail] fromGroupMemberDetail
        INNER JOIN [dbo].[GroupMemberDetail] toGroupMemberDetail ON fromGroupMemberDetail.[GroupKey] = toGroupMemberDetail.[GroupKey]
        INNER JOIN [dbo].[GroupMember] toGroupMember ON toGroupMember.[GroupMemberKey] = toGroupMemberDetail.[GroupMemberKey]
        INNER JOIN [dbo].[GroupMember] fromGroupMember ON fromGroupMember.[GroupMemberKey] = fromGroupMemberDetail.[GroupMemberKey]
    WHERE toGroupMember.[MemberContactKey] = @toContactKey
      AND fromGroupMember.[MemberContactKey] = @fromContactKey
      AND (fromGroupMemberDetail.[ExpirationDate] IS NULL OR fromGroupMemberDetail.[ExpirationDate] > @currentDate)
      AND (toGroupMemberDetail.[ExpirationDate] IS NULL OR toGroupMemberDetail.[ExpirationDate] > @currentDate)
      AND NOT EXISTS (SELECT TOP 1 [GroupRoleKey] 
                              FROM [dbo].[GroupMemberDetail] dd
                        INNER JOIN [dbo].[GroupMember] gm ON gm.[GroupMemberKey] =  dd.[GroupMemberKey]
                             WHERE gm.[MemberContactKey] = @toContactKey
                               AND dd.[GroupRoleKey] = fromGroupMemberDetail.[GroupRoleKey]
                     )

    --now transfer any historical memberships as is - even if duplicate
    --also transfer future memberships if the current membership has expired
   UPDATE fromGroupMemberDetail
       SET [GroupMemberKey] = toGroupMemberDetail.[GroupMemberKey]
    FROM [dbo].[GroupMemberDetail] fromGroupMemberDetail
        INNER JOIN [dbo].[GroupMemberDetail] toGroupMemberDetail ON fromGroupMemberDetail.[GroupKey] = toGroupMemberDetail.[GroupKey]
        INNER JOIN [dbo].[GroupMember] toGroupMember ON toGroupMember.[GroupMemberKey] = toGroupMemberDetail.[GroupMemberKey]
        INNER JOIN [dbo].[GroupMember] fromGroupMember ON fromGroupMember.[GroupMemberKey] = fromGroupMemberDetail.[GroupMemberKey]
    WHERE toGroupMember.[MemberContactKey] = @toContactKey
      AND fromGroupMember.[MemberContactKey] = @fromContactKey
      AND (
            ( --this picks up historical records
              fromGroupMemberDetail.[ExpirationDate] IS NOT NULL 
              AND fromGroupMemberDetail.[EffectiveDate] IS NOT NULL 
              AND fromGroupMemberDetail.[ExpirationDate] < = @currentDate
              AND fromGroupMemberDetail.[EffectiveDate] != toGroupMemberDetail.[EffectiveDate]
            )
            OR 
             ( --this brings over future records where existing role will expire
               toGroupMemberDetail.[ExpirationDate] IS NOT NULL
               AND fromGroupMemberDetail.[EffectiveDate] IS NOT NULL
               AND toGroupMemberDetail.[ExpirationDate] < = fromGroupMemberDetail.[EffectiveDate]  
               AND fromGroupMemberDetail.[EffectiveDate] > @currentDate
             )
          )

    --add the groups that the fromParty has but the toParty doesn't have
    UPDATE fromGroupMember
       SET [MemberContactKey] = @toContactKey
      FROM [dbo].[GroupMember] fromGroupMember
     WHERE fromGroupMember.[MemberContactKey] = @fromContactKey
       AND NOT EXISTS (SELECT [MemberContactKey] 
                         FROM [dbo].[GroupMember] 
                        WHERE [MemberContactKey] = @toContactKey
                          AND [GroupKey] = fromGroupMember.[GroupKey]);

    --delete the fromParty memberships
    DELETE FROM [dbo].[GroupMemberDetail]
          WHERE [GroupMemberKey] IN (SELECT [GroupMemberKey]
                                       FROM [dbo].[GroupMember]
                                      WHERE [MemberContactKey] = @fromContactKey)   
                                          
    DELETE FROM [dbo].[GroupMember] 
          WHERE [MemberContactKey] = @fromContactKey;
   
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_MergeMultiInstanceUserDefinedData]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_MergeMultiInstanceUserDefinedData]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


CREATE PROCEDURE [dbo].[asi_MergeMultiInstanceUserDefinedData] 
    @fromContactId varchar(10), 
    @toContactId varchar(10)
AS
BEGIN
    SET NOCOUNT ON;
    
    -- First move across multi-instance records the toParty doesn't have
    UPDATE fromParty
       SET fromParty.[RowID] = @toContactId
      FROM [dbo].[UserDefinedMultiInstanceProperty] fromParty
     WHERE fromParty.[RowID] = @fromContactId
       AND NOT EXISTS (SELECT 1 FROM [dbo].[UserDefinedMultiInstanceProperty] 
                        WHERE [RowID] = @toContactId 
                          AND [TableName] = fromParty.[TableName]
                          AND [PropertyName] = fromParty.[PropertyName])
                          
    -- Next, merge in common rows mindful of keeping the sequence numbers unique
    INSERT INTO dbo.UserDefinedMultiInstanceProperty (TableName, PropertyName, RowID, RowKey, RowSequence, PropertyIntValue,
                                                      PropertyDateTimeValue, PropertyGuidValue, PropertyDecimalValue,
                                                      PropertyBooleanValue, PropertyStringValue)
        SELECT udm.TableName, udm.PropertyName, @toContactId, udm.RowKey, 
               (SELECT MAX(RowSequence) FROM dbo.UserDefinedMultiInstanceProperty udm2
                 WHERE udm2.TableName = udm.TableName AND udm2.PropertyName = udm.PropertyName AND udm2.RowID = @toContactId
                ) + ROW_NUMBER() OVER (PARTITION BY RowID, TableName, PropertyName ORDER BY RowSequence), 
               udm.PropertyIntValue, udm.PropertyDateTimeValue, udm.PropertyGuidValue, 
               udm.PropertyDecimalValue, udm.PropertyBooleanValue, udm.PropertyStringValue
          FROM dbo.UserDefinedMultiInstanceProperty udm
         WHERE RowID = @fromContactId
         ORDER BY udm.TableName, udm.PropertyName, udm.RowSequence
      
    -- Now remove any remaining fromParty records
    DELETE FROM [dbo].[UserDefinedMultiInstanceProperty]
     WHERE [RowID] = @fromContactId
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_MergePartyReferences]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_MergePartyReferences]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO







CREATE PROCEDURE [dbo].[asi_MergePartyReferences]
       @fromContactId varchar(10), 
       @toContactId varchar(10)
AS
BEGIN
    DECLARE @tempProcessingStatement nvarchar(max);
    DECLARE @errorMessage nvarchar(max);
    SET @errorMessage = '';
    DECLARE @fromContactKey uniqueidentifier ;
    DECLARE @toContactKey uniqueidentifier;
    DECLARE @toKey nvarchar(50);
    DECLARE @fromKey nvarchar(50);
    DECLARE @tempReferencesRowCount int;
    DECLARE @currentTable sysname;
    DECLARE @currentColumn sysname;
    DECLARE @currentOperation nvarchar(10);

    SET @tempReferencesRowCount = (SELECT MAX([ProcessingOrder]) FROM [dbo].[PartyMergeSchemaReference]);
    SET @fromContactKey = (SELECT [ContactKey] FROM [dbo].[ContactMain] WHERE [SyncContactID] = @fromContactId AND [IsInstitute] = 0);
    SET @toContactKey = (SELECT [ContactKey] FROM [dbo].[ContactMain] WHERE [SyncContactID] = @toContactId AND [IsInstitute] = 0);


    DECLARE @counter int;
    SET @counter = 0;

    WHILE (@counter < @tempReferencesRowCount)
    BEGIN
        SET @counter += 1;
        --The following processing types explained:
        -- DATAUPDATE - Replace to-party's data column value if NULL with from-party data column value.
        -- NODUPEKEY - If previous to-party record exists, we keep it and delete from-party or else switch keys.  This prevents duplicate key errors in certain tables.
        -- NOCOMBOKEY - Similar to NODUPEKEY but the value of two columns is used to determine the key
        -- UPDATE - Switched out the from-party's key with the to-party's key without any checks
        -- DELETE - Deletes the from-part record so order of table in list is important
        BEGIN TRY
            SELECT
               @currentColumn = [ColumnName],
               @currentTable = [TableName],
               @currentOperation = [ProcessingType],
               @toKey = CASE WHEN [UseGuidKey] = 1 THEN  CONVERT(nvarchar(50), @toContactKey) ELSE @toContactId END,
               @fromKey = CASE WHEN [UseGuidKey] = 1 THEN  CONVERT(nvarchar(50), @fromContactKey) ELSE @fromContactId END,
               @tempProcessingStatement = 
               CASE WHEN [ProcessingType] = N'NODUPEKEY' THEN N'IF NOT EXISTS (SELECT * FROM '
                        + '[dbo].' + QUOTENAME([TableName]) 
                        + ' WHERE ' + QUOTENAME([ColumnName]) + ' = '''  
                        + @toKey + ''''
                        + ') BEGIN UPDATE'
                        + ' [dbo].' + QUOTENAME([TableName]) 
                        + ' SET ' + QUOTENAME([ColumnName]) + ' = ''' 
                        + @toKey + ''' WHERE ' 
                        + QUOTENAME([ColumnName]) + ' = ''' 
                        + @fromKey + ''''
                        + ' END ELSE BEGIN DELETE FROM [dbo].'
                        + QUOTENAME([TableName])
                        + ' WHERE ' + QUOTENAME([ColumnName]) + ' = ''' 
                        + @fromKey + ''' END'
                    WHEN [ProcessingType] = N'NOCOMBOKEY' THEN N'UPDATE '
                        + ' [dbo].' + QUOTENAME([TableName])
                        + ' SET ' + QUOTENAME([ColumnName]) + ' = ''' 
                        + @toKey + ''' WHERE ' 
                        + QUOTENAME([DataColumnName]) + ' NOT IN ( SELECT fromTable.'
                        + QUOTENAME([DataColumnName]) + ' FROM '
                        + ' [dbo].' + QUOTENAME([TableName]) + ' fromTable JOIN '
                        + ' [dbo].' + QUOTENAME([TableName]) +' toTable ON toTable.'
                        + QUOTENAME([DataColumnName]) + ' = fromTable.'
                        + QUOTENAME([DataColumnName]) + ' WHERE fromTable.'
                        + QUOTENAME([ColumnName]) + ' = ''' + @fromKey + ''' AND toTable.'
                        + QUOTENAME([ColumnName]) + ' = ''' + @toKey + ''') AND '
                        + QUOTENAME([ColumnName])  + ' = ''' + @fromKey + '''; DELETE '
                        + ' [dbo].' + QUOTENAME([TableName])
                        + ' WHERE ' + QUOTENAME([ColumnName]) + ' = '''  
                        + @fromKey + ''''
                    WHEN [ProcessingType] = N'UPDATE' THEN N'UPDATE' 
                        + ' [dbo].' + QUOTENAME([TableName]) 
                        + ' SET ' + QUOTENAME([ColumnName]) + ' = ''' 
                        + @toKey + ''' WHERE ' 
                        + QUOTENAME([ColumnName]) + ' = ''' 
                        + @fromKey + ''''
                   WHEN [ProcessingType] = N'DELETE' THEN N'DELETE'
                        + ' FROM [dbo].' + QUOTENAME([TableName]) + ' WHERE ' 
                        + QUOTENAME([ColumnName]) + ' = ''' + @fromKey + ''''
                   WHEN [ProcessingType] = N'DATAUPDATE' THEN N'UPDATE toTable SET '
                        + QUOTENAME([DataColumnName]) + ' = fromTable.'
                        + QUOTENAME([DataColumnName]) 
                        + ' FROM [dbo].' + QUOTENAME([TableName]) + ' fromTable,'
                        + ' [dbo].' + QUOTENAME([TableName]) + ' toTable'
                       + ' WHERE fromTable.' + QUOTENAME([ColumnName]) + ' = '''
                        + @fromKey + ''''
                        + ' AND toTable.'+ QUOTENAME([ColumnName]) + ' = '''
                        + @toKey + ''''
                        + ' AND (toTable.'+ QUOTENAME([DataColumnName]) + ' IS NULL OR' 
                        + ' DATALENGTH(toTable.'+ QUOTENAME([DataColumnName]) + ') = 0 OR'
                        + ' (ISNUMERIC(toTable.' + QUOTENAME([DataColumnName]) +') = 1 AND' 
                        + ' toTable.' + QUOTENAME([DataColumnName]) + ' = 0))'
              END 
              FROM [dbo].[PartyMergeSchemaReference] 
             WHERE [ProcessingOrder] = @counter;
            --PRINT @tempProcessingStatement;
            EXEC (@tempProcessingStatement);
        END TRY
        BEGIN CATCH
           SET @errorMessage  += '**' + 'Number = ' + convert(nvarchar(4), ERROR_NUMBER())
                                + ', ' + 'Severity = ' + convert(nvarchar(4), ERROR_SEVERITY())
                               + ', ' + 'Message = ' + convert(nvarchar(max), ERROR_MESSAGE())
                               + ' : ' + @currentTable + ' - ' + @currentColumn + ' - ' + @currentOperation
                                + CHAR(13);
            
            CONTINUE;
        END CATCH
    END

    IF (@errorMessage <> '')
        RAISERROR(@errorMessage, 16, 1);
END









GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_MergePartyReferencesCustom]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_MergePartyReferencesCustom]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO




--================================================
--This is a blank stored procedure for customer use when
--custom operations are required during the merge of
--two party records.  This stored procedure is called
--'from' contact record and after all references such
--as addresses have been assigned to the gaining contact
--(ToContactKey)
--
--This is an execute-only operation that must only
--hand back an exception if it fails.  The Party 
--Merge service will not handle returned data.
--================================================ 
CREATE PROCEDURE [dbo].[asi_MergePartyReferencesCustom] 
       @FromContactId varchar(10), 
       @ToContactId varchar(10)
AS
BEGIN
    -- placeholder for user-defined code
       SET NOCOUNT ON;

   
       
END;





GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_RecalculateGiftHistorySummary]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_RecalculateGiftHistorySummary]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_RecalculateGiftHistorySummary]
    @DonorId varchar(10) = NULL, @RebuildAll bit = 0
AS
BEGIN

    -- Just in case process was interrupted, ensure temp tables are deleted
    IF OBJECT_ID('tempdb..#TblGifts') IS NOT NULL
        DROP TABLE #TblGifts;
    IF OBJECT_ID('tempdb..#GiftHistory') IS NOT NULL
        DROP TABLE #GiftHistory;
    IF OBJECT_ID('tempdb..#Years') IS NOT NULL
        DROP TABLE #Years;
    IF OBJECT_ID('tempdb..#ConsecutiveYears') IS NOT NULL
        DROP TABLE #ConsecutiveYears;

    -- Declare a table variable to store a summarization of gift-related transaction information
    CREATE TABLE #TblGifts (DonorId varchar(10) COLLATE DATABASE_DEFAULT,
                            OriginalTransNum int,
                            Amount money,
                            TransactionDate datetime,
                            GiftCalendarYear int,
                            Appeal varchar(40) COLLATE DATABASE_DEFAULT,
                            PRIMARY KEY (DonorId, OriginalTransNum)
                            );

    -- Declare a table variable to store details about first gift transactions
    DECLARE @FirstTrans      TABLE ( DonorId varchar(10) NOT NULL,
                                     OriginalTransNum int NOT NULL,
                                     TransactionDate datetime NOT NULL,
                                     Amount money NOT NULL,
                                     Appeal varchar(40) NULL
                                    );
    -- Declare a table variable to store details about next-to-last gift transactions
    DECLARE @NextToLastTrans TABLE ( DonorId varchar(10) NOT NULL,
                                     OriginalTransNum int NOT NULL,
                                     TransactionDate datetime NOT NULL,
                                     Amount money NOT NULL,
                                     Appeal varchar(40) NULL
                                    );
    -- Declare a table variable to store details about last gift transactions
    DECLARE @LastTrans       TABLE ( DonorId varchar(10) NOT NULL,
                                     OriginalTransNum int NOT NULL,
                                     TransactionDate datetime NOT NULL,
                                     Amount money NOT NULL,
                                     Appeal varchar (40) NULL
                                    );

    -- Populate a table variable with one row summarizing gift-related transactions for the donor(s) being updated
    IF @DonorId IS NULL AND @RebuildAll = 1
    BEGIN
        INSERT #TblGifts(OriginalTransNum ,DonorId, Amount,TransactionDate ,GiftCalendarYear, Appeal)
        SELECT gr.OriginalTransaction,
               gr.ID,
               SUM(gr.Amount) AS Amount,
               MIN(gr.TransactionDate) AS MinTransDate,
               YEAR(MIN(gr.TransactionDate)) AS GiftCalendarYear,
               MAX(gr.AppealCode) AS AppealCode
          FROM [dbo].[GiftReport] gr 
         GROUP BY gr.OriginalTransaction, gr.ID
        HAVING SUM(gr.Amount) <> 0
    END
    ELSE
    BEGIN
        INSERT #TblGifts(OriginalTransNum ,DonorId, Amount,TransactionDate ,GiftCalendarYear, Appeal)
        SELECT gr.OriginalTransaction ,
               gr.ID ,
               SUM(gr.Amount) AS Amount,
               MIN(gr.TransactionDate) AS MinTransDate,
               YEAR(MIN (gr.TransactionDate)) AS GiftCalendarYear,
               MAX(gr.AppealCode) AS AppealCode
          FROM [dbo].[GiftReport] gr 
         WHERE gr.ID = @DonorId
         GROUP BY gr.OriginalTransaction, gr.ID
        HAVING SUM(gr.Amount) <> 0
    END

    -- Before proceeding, check to be sure that there is still at least one row of giving history for the specified Donor
    -- If there are no rows of giving history, then delete any existing rows from GiftHistorySummary for the specified Donor and exit
    IF (SELECT COUNT(1) FROM #TblGifts WHERE DonorId = @DonorId AND @RebuildAll = 0) = 0
    BEGIN
        DELETE FROM [dbo].[GiftHistorySummary]
         WHERE [DonorId] = @DonorId
        RETURN
    END
      

    -- Populate a table variable with one row of details about the first gift transaction for the donor(s) being updated
    IF @DonorId IS NULL
    BEGIN
        INSERT INTO @FirstTrans (DonorId ,OriginalTransNum, TransactionDate,Amount ,Appeal)
        SELECT g.DonorId,
               g.OriginalTransNum,
               g.TransactionDate,
               g.Amount,
               g.Appeal
          FROM #TblGifts g
         WHERE g.OriginalTransNum = (SELECT MIN (a.OriginalTransaction)
                                        FROM [dbo].[GiftReport] a
                                             INNER JOIN (SELECT MIN(r.DateReceived) AS DateReceived
                                                           FROM [dbo].[GiftReport] r
                                                          WHERE r.ID = g.DonorId AND r.DateReceived IS NOT NULL) b
                                             ON a.DateReceived = b.DateReceived AND a.ID = g.DonorId
                                       WHERE a.OriginalTransaction IS NOT NULL
                                      )
    END
    ELSE
    BEGIN
        INSERT INTO @FirstTrans (DonorId ,OriginalTransNum, TransactionDate,Amount ,Appeal)
        SELECT g.DonorId,
               g.OriginalTransNum,
               g.TransactionDate,
               g.Amount,
               g.Appeal
          FROM #TblGifts g
         WHERE (g.DonorId = @DonorId)
           AND g.OriginalTransNum = (SELECT MIN (a.OriginalTransaction)
                                        FROM [dbo].[GiftReport] a
                                            INNER JOIN (SELECT MIN(r.DateReceived) AS DateReceived
                                                          FROM [dbo].[GiftReport] r
                                                         WHERE r.ID = g.DonorId AND r.DateReceived IS NOT NULL) b
                                            ON a.DateReceived = b.DateReceived AND a.ID = g.DonorId
                                       WHERE a.OriginalTransaction IS NOT NULL
                                      )
    END

    -- Populate a table variable with one row of details about the most recent gift transaction for the donor(s) being updated
    IF @DonorId IS NULL
    BEGIN
        INSERT @LastTrans(DonorId, OriginalTransNum, TransactionDate, Amount, Appeal)
        SELECT g.DonorId,
               g.OriginalTransNum,
               g.TransactionDate,
               g.Amount,
               g.Appeal
          FROM #TblGifts g
         WHERE g.OriginalTransNum = (SELECT MAX(a.OriginalTransaction)
                                       FROM [dbo].[GiftReport] a
                                            INNER JOIN (SELECT MAX(r.DateReceived) AS DateReceived
                                                          FROM [dbo].[GiftReport] r
                                                         WHERE r.ID = g.DonorId AND r.DateReceived IS NOT NULL) b
                                            ON a.DateReceived = b.DateReceived AND a.ID = g.DonorId
                                      WHERE a.OriginalTransaction IS NOT NULL
                                     )
    END
    ELSE
    BEGIN
        INSERT @LastTrans(DonorId, OriginalTransNum, TransactionDate, Amount, Appeal)
        SELECT g.DonorId,
               g.OriginalTransNum,
               g.TransactionDate,
               g.Amount,
               g.Appeal
          FROM #TblGifts g
         WHERE (g.DonorId = @DonorId )
           AND g.OriginalTransNum = (SELECT MAX(a.OriginalTransaction)
                                       FROM [dbo].[GiftReport] a
                                            INNER JOIN (SELECT MAX(r.DateReceived) AS DateReceived
                                                          FROM [dbo].[GiftReport] r
                                                         WHERE r.ID = g.DonorId AND r.DateReceived IS NOT NULL) b
                                            ON a.DateReceived = b.DateReceived AND a.ID = g.DonorId
                                      WHERE a.OriginalTransaction IS NOT NULL
                                     )
    END
    
    -- Populate a table variable with one row of details about the next-to-last gift transaction for the donor(s) being updated
    IF @DonorId IS NULL
    BEGIN
        INSERT @NextToLastTrans(DonorId ,OriginalTransNum, TransactionDate,Amount ,Appeal)
            SELECT g.DonorId,
                   g.OriginalTransNum,
                   g.TransactionDate,
                   g.Amount,
                   g.Appeal
              FROM #TblGifts g
             WHERE g.OriginalTransNum = (SELECT MAX(g1.OriginalTransNum)
                                           FROM #TblGifts g1
                                                LEFT OUTER JOIN @LastTrans l ON g1.OriginalTransNum = l.OriginalTransNum
                                          WHERE g1.DonorId = g.DonorId AND l.OriginalTransNum IS NULL
                                        )
    END
    ELSE
    BEGIN
        INSERT @NextToLastTrans(DonorId ,OriginalTransNum, TransactionDate,Amount ,Appeal)
        SELECT g.DonorId ,
               g.OriginalTransNum ,
               g.TransactionDate ,
               g.Amount ,
               g.Appeal
          FROM #TblGifts g
         WHERE (g.DonorId = @DonorId)
           AND g.OriginalTransNum = (SELECT MAX (g1.OriginalTransNum)
                                       FROM #TblGifts g1
                                            LEFT OUTER JOIN @LastTrans l ON g1.OriginalTransNum = l.OriginalTransNum
                                      WHERE g1.DonorId = g.DonorId AND l.OriginalTransNum IS NULL
                                    )
    END

    -- Declare a table variable for identifying date ranges for evaluating consecutive years
    CREATE TABLE #Years ( DonorId varchar (10) COLLATE DATABASE_DEFAULT NOT NULL,
                          Seqn int NOT NULL,
                          CalendarYear int NOT NULL,
                          BeginDate datetime NOT NULL,
                          EndDate datetime NOT NULL,
                          PrevYr int NOT NULL,
                          NextYr int NOT NULL,
                          ConsecutiveYr bit,
                          PRIMARY KEY (DonorId, Seqn)
                         );
                                
    -- Populate a table variable for identifying date ranges for evaluating consecutive years
    INSERT INTO #Years(Seqn, DonorId, CalendarYear, BeginDate, EndDate, PrevYr, NextYr, ConsecutiveYr)
        SELECT ROW_NUMBER() OVER (ORDER BY g.DonorId asc, YEAR(g.TransactionDate) asc),
               g.DonorId ,
               YEAR(g.TransactionDate),
               CAST(CAST(YEAR(g.TransactionDate ) AS varchar(4)) + '0101' AS datetime),
               CAST(CAST(YEAR(g.TransactionDate ) AS varchar(4)) + '1231' AS datetime),
               YEAR(g.TransactionDate)- 1,
               YEAR(g.TransactionDate)+ 1,
               0
          FROM #TblGifts g
         GROUP BY g.DonorId, YEAR( g.TransactionDate )
   
    CREATE TABLE #ConsecutiveYears (DonorId varchar(10) COLLATE DATABASE_DEFAULT NOT NULL, 
                                    Amount int NOT NULL,
                                    PRIMARY KEY (DonorId)
                                    );

    -- Use a CTE to calculate the largest group of consecutive years
    ;WITH consecutiveYears AS
       (
        SELECT t1.DonorId,
               t1.CalendarYear AS startOfGroup,
               MIN(t2.CalendarYear) AS endOfGroup,
               MIN(t2.CalendarYear) - t1.CalendarYear + 1 AS sizeOfGroup
          FROM ( SELECT DonorId,
                        CalendarYear
                   FROM #Years tbl1
                  WHERE NOT EXISTS
                       (SELECT 1
                          FROM #Years tbl2
                         WHERE tbl1.DonorId = tbl2.DonorId
                           AND tbl1.CalendarYear = tbl2.CalendarYear + 1
                        )
                ) t1
            INNER JOIN
               ( SELECT DonorId,
                        CalendarYear
                   FROM #Years tbl1
                  WHERE NOT EXISTS
                       (SELECT 1
                          FROM #Years tbl2
                         WHERE tbl2.DonorId = tbl1.DonorId
                           AND tbl2.CalendarYear = tbl1.CalendarYear + 1
                        )
                ) t2
             ON t1.DonorId = t2.DonorId
            AND t1.CalendarYear <= t2.CalendarYear
        GROUP BY t1.DonorId, t1.CalendarYear
       )
    INSERT INTO #ConsecutiveYears (DonorId, Amount)
        SELECT DonorId, MAX(sizeOfGroup)
          FROM consecutiveYears c
         WHERE endOfGroup = (SELECT MAX(y.endOfGroup)          -- Added 20130311 by JHS to ensure ConsecutiveYear resets correctly
                               FROM consecutiveYears y
                              WHERE c.DonorId = y.DonorId)
        GROUP BY DonorId
        ORDER BY DonorId -- was ORDER BY CAST(DonorId AS int)

    -- Populate a table variable with one row of lifetime aggregate values for each of the donors being updated
    CREATE TABLE #GiftHistory(DonorId varchar(10) COLLATE DATABASE_DEFAULT NOT NULL,
                              LowestGiftAmount money NOT NULL,
                              HighestGiftAmount money NOT NULL,
                              AverageGiftAmount money NOT NULL,
                              LifetimeGiftAmount money NOT NULL,
                              LifetimeNumberOfGifts int NOT NULL,
                              ConsecutiveYearsOfGiving int NOT NULL,
                              LastTransProcessed int NOT NULL,
                              PRIMARY KEY (DonorId)
                              );
    INSERT INTO #GiftHistory(DonorId ,LowestGiftAmount, HighestGiftAmount, AverageGiftAmount, LifetimeGiftAmount,
                             LifetimeNumberOfGifts, ConsecutiveYearsOfGiving, LastTransProcessed)
        SELECT DISTINCT(g.DonorId),
               MIN(g.Amount), MAX(g.Amount), AVG(g.Amount), SUM(g.Amount), 
               COUNT(DISTINCT(g.OriginalTransNum)),
               (SELECT Amount FROM #ConsecutiveYears cy WHERE cy.DonorId = g.DonorId),
               (SELECT MAX(DISTINCT(gr.TransactionNumber)) FROM [dbo].[GiftReport] gr WHERE gr.ID = g.DonorId)
          FROM #TblGifts g
         GROUP BY g.DonorId
              
    -- Now we begin the process of updating the repository for Gift History Summary data
    -- Delete rows for any existing Donors who are about to be updated
    DELETE GiftHistorySummary
      FROM GiftHistorySummary ghs  
           LEFT OUTER JOIN #GiftHistory gh ON ghs.DonorId = gh.DonorId
     WHERE gh.DonorId IS NOT NULL;
     
SET ANSI_WARNINGS OFF; -- The following cte necessarily aggregates rows with NULL values to collapse rows to one;
                       -- The resulting row has no NULL values, yielding the correct results, so ignore the warning.

    DECLARE @now datetime;
    SET @now = GETDATE();

    ;WITH cteGiftHistorySummary AS (
        SELECT gh.DonorId AS DonorId,
               NULL AS FirstGiftDate,
               NULL AS FirstGiftAmount,
               NULL AS FirstGiftAppeal,
               NULL AS NextLastGiftDate,
               NULL AS NextLastGiftAmount,
               NULL AS NextLastGiftAppeal,
               NULL AS LastGiftDate,
               NULL AS LastGiftAmount,
               NULL AS LastGiftAppeal,
               gh.LowestGiftAmount AS LowestGiftAmount,
               gh.HighestGiftAmount AS HighestGiftAmount,
               gh.AverageGiftAmount AS AverageGiftValue,
               gh.LifetimeGiftAmount AS LifetimeGiftValue,
               gh.LifetimeNumberOfGifts AS NumberOfGifts,
               gh.ConsecutiveYearsOfGiving AS ConsecutiveYearsGiving,
               gh.LastTransProcessed AS HighestTransNumProcessed
          FROM #GiftHistory gh
       UNION
        SELECT ft.DonorId AS DonorId,
               ft.TransactionDate AS FirstGiftDate,
               ft.Amount AS FirstGiftAmount,
               ft.Appeal AS FirstGiftAppeal,
               NULL AS NextLastGiftDate,
               NULL AS NextLastGiftAmount,
               NULL AS NextLastGiftAppeal,
               NULL AS LastGiftDate,
               NULL AS LastGiftAmount,
               NULL AS LastGiftAppeal,
               NULL AS LowestGiftAmount,
               NULL AS HighestGiftAmount,
               NULL AS AverageGiftValue,
               NULL AS LifetimeGiftValue,
               NULL AS NumberOfGifts,
               NULL AS ConsecutiveYearsGiving,
               NULL AS HighestTransNumProcessed
          FROM @FirstTrans ft
       UNION
        SELECT nt.DonorId AS DonorId,
               NULL AS FirstGiftDate,
               NULL AS FirstGiftAmount,
               NULL AS FirstGiftAppeal,
               nt.TransactionDate AS NextLastGiftDate,
               nt.Amount AS NextLastGiftAmount,
               nt.Appeal AS NextLastGiftAppeal,
               NULL AS LastGiftDate,
               NULL AS LastGiftAmount,
               NULL AS LastGiftAppeal,
               NULL AS LowestGiftAmount,
               NULL AS HighestGiftAmount,
               NULL AS AverageGiftValue,
               NULL AS LifetimeGiftValue,
               NULL AS NumberOfGifts,
               NULL AS ConsecutiveYearsGiving,
               NULL AS HighestTransNumProcessed
          FROM @NextToLastTrans nt
       UNION
        SELECT lt.DonorId AS DonorId ,
               NULL AS FirstGiftDate,
               NULL AS FirstGiftAmount,
               NULL AS FirstGiftAppeal,
               NULL AS NextLastGiftDate,
               NULL AS NextLastGiftAmount,
               NULL AS NextLastGiftAppeal,
               lt.TransactionDate AS LastGiftDate,
               lt.Amount AS LastGiftAmount,
               lt.Appeal AS LastGiftAppeal,
               NULL AS LowestGiftAmount,
               NULL AS HighestGiftAmount,
               NULL AS AverageGiftValue,
               NULL AS LifetimeGiftValue,
               NULL AS NumberOfGifts,
               NULL AS ConsecutiveYearsGiving,
               NULL AS HighestTransNumProcessed
          FROM @LastTrans lt
        )
    -- Insert new rows for any Donors being updated
    INSERT GiftHistorySummary(DonorId,
                              FirstGiftDate,
                              FirstGiftAmount,
                              FirstGiftAppeal,
                              NextLastGiftDate,
                              NextLastGiftAmount,
                              NextLastGiftAppeal,
                              LastGiftDate,
                              LastGiftAmount,
                              LastGiftAppeal,
                              LowestGiftAmount,
                              HighestGiftAmount,
                              AverageGiftValue,
                              LifetimeGiftValue,
                              NumberOfGifts,
                              ConsecutiveYearsGiving,
                              HighestTransNumProcessed,
                              LastUpdatedOn
                             )
    SELECT DonorId,
           MAX(FirstGiftDate),
           MAX(FirstGiftAmount),
           MAX(FirstGiftAppeal),
           MAX(NextLastGiftDate),
           MAX(NextLastGiftAmount),
           MAX(NextLastGiftAppeal),
           MAX(LastGiftDate),
           MAX(LastGiftAmount),
           MAX(LastGiftAppeal),
           MAX(LowestGiftAmount),
           MAX(HighestGiftAmount),
           MAX(AverageGiftValue),
           MAX(LifetimeGiftValue),
           MAX(NumberOfGifts),
           MAX(ConsecutiveYearsGiving),
           MAX(HighestTransNumProcessed),
           @now
      FROM cteGiftHistorySummary
    GROUP BY DonorId
    
    SET ANSI_WARNINGS ON; -- Restore ANSI warnings now that we're done

    IF OBJECT_ID('tempdb..#TblGifts') IS NOT NULL
        DROP TABLE #TblGifts;
    IF OBJECT_ID('tempdb..#GiftHistory') IS NOT NULL
        DROP TABLE #GiftHistory;
    IF OBJECT_ID('tempdb..#Years') IS NOT NULL
        DROP TABLE #Years;
    IF OBJECT_ID('tempdb..#ConsecutiveYears') IS NOT NULL
        DROP TABLE #ConsecutiveYears;

END



GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_UpdateFundraisingViewTables_DUES]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_UpdateFundraisingViewTables_DUES]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_UpdateFundraisingViewTables_DUES] 
    @TransRangeBegin int = NULL, @TransRangeEnd int = NULL
AS
BEGIN

-- If No TransRange parameters are passed in and there is no #TransTemp table, then this is a complete rebuild
IF (@TransRangeBegin IS NULL AND @TransRangeEnd IS NULL AND (SELECT COUNT(*) FROM #TransTemp) = 0)
BEGIN
    RETURN  -- Not yet implemented. This will need to truncate the three Report tables. Very dangerous!
END

-- Cache related [dbo].[Activity] info
DECLARE @ActivityTemp TABLE (ID varchar(10) NOT NULL, SEQN int NOT NULL, ORIGINATING_TRANS_NUM int NOT NULL, 
                            SOURCE_SYSTEM varchar(10) NOT NULL, TRANSACTION_DATE datetime NULL, EFFECTIVE_DATE datetime NULL, 
                            AMOUNT money NOT NULL, TAXABLE_VALUE money NOT NULL, ORG_CODE varchar(5) NOT NULL, SOURCE_CODE varchar(40) NOT NULL, 
                            SOLICITOR_ID varchar(10) NOT NULL, CAMPAIGN_CODE varchar(10) NOT NULL, ACTION_CODES varchar(255) NOT NULL, 
                            UF_4 numeric(15,4) NOT NULL, ACTIVITY_TYPE varchar(10) NOT NULL, PRODUCT_CODE varchar(31) NOT NULL);
INSERT INTO @ActivityTemp 
SELECT ID, SEQN, ORIGINATING_TRANS_NUM, SOURCE_SYSTEM, TRANSACTION_DATE, EFFECTIVE_DATE, AMOUNT, TAXABLE_VALUE,
       ORG_CODE, SOURCE_CODE, SOLICITOR_ID, CAMPAIGN_CODE, ACTION_CODES, UF_4, ACTIVITY_TYPE, PRODUCT_CODE 
  FROM (
    SELECT a.ID, a.SEQN, a.ORIGINATING_TRANS_NUM, a.SOURCE_SYSTEM, a.TRANSACTION_DATE, a.EFFECTIVE_DATE, a.AMOUNT, a.TAXABLE_VALUE,
           a.ORG_CODE, a.SOURCE_CODE, a.SOLICITOR_ID, a.CAMPAIGN_CODE, a.ACTION_CODES, a.UF_4, a.ACTIVITY_TYPE, a.PRODUCT_CODE
      FROM #TransTemp tt
           INNER JOIN [dbo].[Activity] a ON a.ORIGINATING_TRANS_NUM = tt.TransNum
    UNION
    SELECT a.ID, a.SEQN, a.ORIGINATING_TRANS_NUM, a.SOURCE_SYSTEM, a.TRANSACTION_DATE, a.EFFECTIVE_DATE, a.AMOUNT, a.TAXABLE_VALUE,
           a.ORG_CODE, a.SOURCE_CODE, a.SOLICITOR_ID, a.CAMPAIGN_CODE, a.ACTION_CODES, a.UF_4, a.ACTIVITY_TYPE, a.PRODUCT_CODE
      FROM #TransTemp tt
           INNER JOIN [dbo].[Trans] t ON tt.TransNum = t.TRANS_NUMBER
           INNER JOIN [dbo].[Activity] a ON a.SEQN = t.ACTIVITY_SEQN
) subActivity;

-- BEGIN GiftReport
-- Delete any existing rows from the [dbo].[GiftReport] table for transactions being updated
DELETE gr
  FROM [dbo].[GiftReport] gr
       INNER JOIN #TransTemp t ON gr.[TransactionNumber] = t.[TransNum]
                              AND gr.[InvoiceReferenceNumber] = t.[InvoiceNum]
 WHERE gr.[SourceSystem] IN ('DUES','SC')

-- Insert new rows into the [dbo].[GiftReport] table for transactions being updated
INSERT INTO [dbo].[GiftReport] ( ID, 
                                 OriginalTransaction, 
                                 TransactionNumber, 
                                 SourceSystem, 
                                 TransactionDate, 
                                 DateReceived, 
                                 Amount, 
                                 FairMktValue, 
                                 Fund, 
                                 AppealCode, 
                                 SolicitorID, 
                                 CheckNumber, 
                                 PaymentType, 
                                 CampaignCode, 
                                 FiscalYear, 
                                 FiscalMonth, 
                                 GiftType, 
                                 InvoiceReferenceNumber, 
                                 ReceiptID, 
                                 MatchingTransaction, 
                                 IsMatchingGift, 
                                 MemorialID, 
                                 PledgeID, 
                                 ListAs, 
                                 RequestNumber, 
                                 InstallmentDate, 
                                 MemorialNameText
                               )
     -------------- Segment DUES1 -- CASH DUES PAYMENT/PMT ON CASH DUES RENEWAL (SOURCE SYSTEM = DUES OR SC)
     SELECT a.ID,
            a.ORIGINATING_TRANS_NUM,
            a.ORIGINATING_TRANS_NUM,
            MAX(a.SOURCE_SYSTEM),
            MAX(a.TRANSACTION_DATE),
            MAX(CASE WHEN a.SOURCE_SYSTEM = 'FR' THEN a.EFFECTIVE_DATE ELSE a.TRANSACTION_DATE END),
            SUM(a.AMOUNT) Amount,  
            SUM(a.TAXABLE_VALUE),
            MAX(a.ORG_CODE),
            MAX(a.SOURCE_CODE),
            MAX(a.SOLICITOR_ID),
            MAX(c.CHECK_NUMBER),
            CASE MAX(COALESCE(ca.ACCOUNT_TYPE, 99))
                WHEN 1 THEN 'Credit Card'
                WHEN 2 THEN 'In Kind' 
                WHEN 3 THEN 'Debit Card' 
                ELSE 'Cash' 
            END,
            MAX(a.CAMPAIGN_CODE),
            CONVERT(int,SUBSTRING(CONVERT(char(6),MAX(c.FISCAL_PERIOD)),1,4)),
            CONVERT(int,SUBSTRING(CONVERT(char(6),MAX(c.FISCAL_PERIOD)),5,2)),
            'GIFT',
            MAX(c.INVOICE_REFERENCE_NUM),
            MAX(c.RECEIPT_ID),
            MAX(c.MATCH_GIFT_TRANS_NUM),
            MAX(c.IS_MATCH_GIFT),
            MAX(c.MEM_TRIB_ID),
            '',
            MAX(a.ACTION_CODES),
            MAX(a.UF_4),
            NULL,
            MAX(c.MEM_TRIB_NAME_TEXT)
       FROM @ActivityTemp a
            INNER JOIN [dbo].[Trans] c on a.ORIGINATING_TRANS_NUM = c.TRANS_NUMBER
            INNER JOIN #TransTemp t ON c.TRANS_NUMBER = t.TransNum AND c.INVOICE_REFERENCE_NUM = t.InvoiceNum
            LEFT OUTER JOIN [dbo].[Cash_Accounts] ca ON c.CHECK_NUMBER = ca.CASH_ACCOUNT_CODE 
      WHERE a.ACTIVITY_TYPE = 'GIFT' AND a.ID = c.ST_ID 
        AND a.SOURCE_SYSTEM IN ('SC', 'DUES') 
        AND c.TRANSACTION_TYPE = 'DIST' 
        AND c.PRODUCT_CODE = a.PRODUCT_CODE
      GROUP BY a.ID, a.ORIGINATING_TRANS_NUM,  a.ORG_CODE, a.CAMPAIGN_CODE, a.SOURCE_CODE
   UNION
     -------------- Segment DUES2  -- PAYMENT ON ACCRUAL DUES BILING (SOURCE SYSTEM = DUES)
     SELECT CASE 
                WHEN il.ST_ID IS NULL THEN i.BT_ID 
                ELSE il.ST_ID 
            END,
            p.TRANS_NUMBER,
            c.TRANS_NUMBER,
            MAX(p.SOURCE_SYSTEM),
            MAX(c.TRANSACTION_DATE),
            MAX(c.TRANSACTION_DATE),
            CASE
                WHEN MAX(c.JOURNAL_TYPE) = 'IN' THEN SUM(c.AMOUNT) 
                ELSE -SUM(c.AMOUNT) 
            END,
            SUM(c.TAXABLE_VALUE),
            CASE
                WHEN MAX(c.JOURNAL_TYPE) = 'IN' THEN MAX(c.OWNER_ORG_CODE) 
                ELSE MAX(c.GL_ACCT_ORG_CODE) 
            END,
            MAX(p.SOURCE_CODE),
            MAX(p.SOLICITOR_ID),
            MAX(c.CHECK_NUMBER),
            CASE MAX(COALESCE(ca.ACCOUNT_TYPE, 99))
                WHEN 1 THEN 'Credit Card' 
                WHEN 2 THEN 'In Kind' 
                WHEN 3 THEN 'Debit Card' 
                ELSE 'Cash' 
            END,
            MAX(a.CAMPAIGN_CODE),
            CONVERT(int,SUBSTRING(CONVERT(char(6),MAX(c.FISCAL_PERIOD)),1,4)),
            CONVERT(int,SUBSTRING(CONVERT(char(6),MAX(c.FISCAL_PERIOD)),5,2)),
            'Pledge Payment',
            MAX(c.INVOICE_REFERENCE_NUM),
            MAX(c.RECEIPT_ID),
            MAX(p.MATCH_GIFT_TRANS_NUM),
            MAX(p.IS_MATCH_GIFT),
            MAX(p.MEM_TRIB_ID),
            CASE 
                WHEN MAX(c.BT_ID)= MAX(c.ST_ID) THEN '' 
                ELSE MAX(c.BT_ID) 
            END,
            MAX(a.ACTION_CODES),
            MAX(a.UF_4),
            MAX(i.INSTALL_BILL_DATE),
            MAX(p.MEM_TRIB_NAME_TEXT)
       FROM [dbo].[Invoice] i
            INNER JOIN [dbo].[Trans] p ON i.ORIGINATING_TRANS_NUM = p.TRANS_NUMBER
            INNER JOIN [dbo].[Activity] a ON p.ACTIVITY_SEQN = a.SEQN
            INNER JOIN [dbo].[Trans] c ON i.REFERENCE_NUM = c.INVOICE_REFERENCE_NUM
            INNER JOIN #TransTemp t ON c.TRANS_NUMBER = t.TransNum
                                   AND c.INVOICE_REFERENCE_NUM = t.InvoiceNum
            LEFT OUTER JOIN [dbo].[Cash_Accounts] ca ON c.CHECK_NUMBER = ca.CASH_ACCOUNT_CODE
            LEFT OUTER JOIN [dbo].[Invoice_Lines] il ON c.INVOICE_REFERENCE_NUM = il.REFERENCE_NUM 
                                                    AND c.INVOICE_LINE_NUM = il.LINE_NUM
      WHERE p.TRANSACTION_TYPE = 'DIST' 
        AND c.IS_FR_ITEM = 1 
        AND a.ACTIVITY_TYPE = 'PLEDGE' 
        AND i.SOURCE_SYSTEM = 'DUES' 
        AND p.PRODUCT_CODE = c.PRODUCT_CODE 
        AND c.JOURNAL_TYPE = 'PAY' 
        AND c.TRANSACTION_TYPE = 'AR' 
        AND p.INVOICE_LINE_NUM = c.INVOICE_LINE_NUM
        GROUP BY il.ST_ID, i.BT_ID, c.TRANS_NUMBER, c.INVOICE_REFERENCE_NUM, c.OWNER_ORG_CODE, c.GL_ACCT_ORG_CODE, a.CAMPAIGN_CODE, p.SOURCE_CODE, p.TRANS_NUMBER

-- BEGIN PledgeReport
-- Delete any existing rows from the PledgeReport table for transactions being updated
DELETE pr
  FROM PledgeReport pr
       INNER JOIN (SELECT DISTINCT InvoiceNum FROM #TransTemp) invoices
           ON pr.InvoiceReferenceNumber = invoices.InvoiceNum
 WHERE pr.[SourceSystem] IN ('DUES','SC') 

--Insert new rows into the PledgeReport table for transactions being updated
INSERT INTO PledgeReport( ID, 
                          TransactionType, 
                          TransactionNumber, 
                          InvoiceReferenceNumber, 
                          TransactionDate, 
                          DateReceived, 
                          FiscalYear, 
                          FiscalMonth, 
                          AppealCode, 
                          CampaignCode, 
                          Fund, 
                          SolicitorID, 
                          SourceSystem, 
                          MatchingTransaction, 
                          IsMatchingGift, 
                          MemorialID, 
                          ListAs, 
                          RequestNumber, 
                          InstallmentDate, 
                          LastPaymentDate, 
                          PledgeAmount, 
                          AdjustmentsAmount, 
                          PaymentsAmount, 
                          PledgeFairMarketValue, 
                          MemorialNameText
                        )
       SELECT pd.ID, 
              pd.TransactionType, 
              pd.TransactionNumber, 
              pd.InvoiceReferenceNumber, 
              pd.TransactionDate, 
              pd.DateReceived, 
              pd.FiscalYear, 
              pd.FiscalMonth, 
              pd.AppealCode, 
              pd.CampaignCode, 
              pd.Fund, 
              pd.SolicitorID, 
              pd.SourceSystem, 
              pd.MatchingTransaction, 
              pd.IsMatchingGift, 
              pd.MemorialID, 
              pd.ListAs, 
              pd.RequestNumber, 
              pd.InstallmentDate, 
              pd.LastPaymentDate, 
              pd.PledgeAmount, 
              pd.AdjustmentsAmount, 
              pd.PaymentsAmount, 
              pd.PledgeFairMarketValue, 
              pd.MemorialNameText
       FROM (
    --- Segment DUES3  -- ACCRUAL DUES BILLING (SOURCE SYSTEM = DUES)
             SELECT a.ID,
                    'Pledge' AS TransactionType,
                    MAX(p.TRANS_NUMBER) AS TransactionNumber,
                    MAX(p.INVOICE_REFERENCE_NUM) AS InvoiceReferenceNumber,
                    MAX(p.TRANSACTION_DATE) AS TransactionDate,
                    MAX(a.EFFECTIVE_DATE) AS DateReceived,
                    CONVERT(int,substring(CONVERT(char(6),MAX(p.FISCAL_PERIOD)),1,4)) AS FiscalYear,
                    CONVERT(int,substring(CONVERT(char(6),MAX(p.FISCAL_PERIOD)),5,2)) AS FiscalMonth,
                    MAX(a.SOURCE_CODE) AS AppealCode,
                    MAX(a.CAMPAIGN_CODE) AS CampaignCode,
                    MAX(a.ORG_CODE) AS Fund,
                    MAX(a.SOLICITOR_ID) AS SolicitorID,
                    MAX(p.SOURCE_SYSTEM) AS SourceSystem,
                    MAX(p.MATCH_GIFT_TRANS_NUM) AS MatchingTransaction,
                    MAX(p.IS_MATCH_GIFT) AS IsMatchingGift,
                    MAX(p.MEM_TRIB_ID) AS MemorialID,
                    MAX(a.ACTION_CODES) AS ListAs,
                    MAX(a.UF_4) AS RequestNumber,
                    MAX(p.INSTALL_BILL_DATE) AS InstallmentDate,
                    NULL AS LastPaymentDate,
                    SUM(p.AMOUNT) * -1 AS PledgeAmount,
                    0 AS AdjustmentsAmount,
                    0 AS PaymentsAmount,
                    SUM(p.TAXABLE_VALUE) AS PledgeFairMarketValue,
                    MAX(p.MEM_TRIB_NAME_TEXT) AS MemorialNameText
               FROM [dbo].[Trans] p 
                    INNER JOIN (SELECT DISTINCT TransNum FROM #TransTemp) t ON t.TransNum = p.TRANS_NUMBER
--                  INNER JOIN [dbo].[Invoice] i ON p.INVOICE_REFERENCE_NUM = i.REFERENCE_NUM
                    INNER JOIN [dbo].[Activity] a ON p.ACTIVITY_SEQN = a.SEQN
              WHERE p.TRANSACTION_TYPE = 'DIST' 
                AND p.JOURNAL_TYPE = 'IN' 
                AND p.POSTED >= 2 
--              AND i.ORIGINATING_TRANS_NUM = p.TRANS_NUMBER 
                AND p.SOURCE_SYSTEM = 'DUES' 
                AND a.ACTIVITY_TYPE = 'PLEDGE' 
              GROUP BY a.ID, p.INVOICE_REFERENCE_NUM, a.ORG_CODE,a.CAMPAIGN_CODE,a.SOURCE_CODE
       UNION ALL
    --- Segment DUES4  -- CM/DM ACCRUAL DUES (SOURCE SYSTEM = DUES)
             SELECT CASE 
                    WHEN il.ST_ID IS NULL THEN i.BT_ID 
                    ELSE il.ST_ID 
                    END,
                    'Adjustment',
                    0,
                    MAX(adj.INVOICE_REFERENCE_NUM),
                    NULL,
                    NULL,
                    0,
                    0,
                    MAX(P.SOURCE_CODE),
                    MAX(P.CAMPAIGN_CODE),
                    MAX(adj.OWNER_ORG_CODE),
                    '',
                    MAX(i.SOURCE_SYSTEM),
                    0,
                    0,
                    '',
                    '',
                    0,
                    NULL,
                    NULL,
                    0,
                    SUM(adj.AMOUNT) * -1,
                    0,
                    0,
                    ''
               FROM [dbo].[Trans] adj 
                    INNER JOIN (SELECT DISTINCT InvoiceNum FROM #TransTemp) t ON t.InvoiceNum = adj.INVOICE_REFERENCE_NUM
                    INNER JOIN [dbo].[Invoice] i ON adj.INVOICE_REFERENCE_NUM = i.REFERENCE_NUM
                    INNER JOIN [dbo].[Trans] p ON p.TRANS_NUMBER = i.ORIGINATING_TRANS_NUM
                    INNER JOIN [dbo].[Activity] a ON a.SEQN = p.ACTIVITY_SEQN
                    LEFT OUTER JOIN [dbo].[Invoice_Lines] il ON il.REFERENCE_NUM = adj.INVOICE_REFERENCE_NUM 
                                                            AND il.LINE_NUM = adj.INVOICE_LINE_NUM
              WHERE adj.TRANSACTION_TYPE = 'DIST' 
                AND adj.JOURNAL_TYPE IN ('CM','DM')
                AND adj.POSTED >= 2 
                AND i.SOURCE_SYSTEM='DUES' 
                AND P.PRODUCT_CODE = adj.PRODUCT_CODE 
                AND P.INVOICE_LINE_NUM = adj.INVOICE_LINE_NUM
              GROUP BY i.BT_ID, il.ST_ID, adj.INVOICE_REFERENCE_NUM, adj.OWNER_ORG_CODE,P.CAMPAIGN_CODE, P.SOURCE_CODE
       UNION ALL
    --- Segment DUES2  -- PAYMENT ON ACCRUAL DUES BILLLING (SOURCE SYSTEM = DUES)
             SELECT CASE 
                       WHEN il.ST_ID IS NULL THEN i.BT_ID 
                       ELSE il.ST_ID 
                    END,
                    'Payment',
                    0,
                    MAX(Pay.INVOICE_REFERENCE_NUM),
                    NULL,
                    NULL,
                    0,
                    0,
                    P.SOURCE_CODE,
                    P.CAMPAIGN_CODE,
                    CASE
                        WHEN MAX(Pay.TRANSACTION_TYPE) = 'AR' THEN MAX(Pay.GL_ACCT_ORG_CODE) 
                        ELSE MAX(Pay.OWNER_ORG_CODE) 
                    END,
                    '',
                    MAX(i.SOURCE_SYSTEM),
                    0,
                    0,
                    '',
                    '',
                    0,
                    NULL,
                    MAX(Pay.TRANSACTION_DATE),
                    0,
                    0,
                    SUM(Pay.INVOICE_CREDITS),
                    0,
                    '' 
               FROM [dbo].[Trans] Pay
                        INNER JOIN (SELECT DISTINCT InvoiceNum FROM #TransTemp) t ON t.InvoiceNum = Pay.INVOICE_REFERENCE_NUM
                        INNER JOIN [dbo].[Invoice] i ON i.REFERENCE_NUM = Pay.INVOICE_REFERENCE_NUM
                        INNER JOIN [dbo].[Trans] p ON P.TRANS_NUMBER = i.ORIGINATING_TRANS_NUM
                        INNER JOIN [dbo].[Activity] a ON a.SEQN = P.ACTIVITY_SEQN
                        LEFT OUTER JOIN [dbo].[Invoice_Lines] il ON il.REFERENCE_NUM = Pay.INVOICE_REFERENCE_NUM 
                                                     AND il.LINE_NUM = Pay.INVOICE_LINE_NUM
             WHERE P.TRANSACTION_TYPE = 'DIST' 
               AND Pay.POSTED >= 2 AND Pay.IS_FR_ITEM=1 
               AND a.ACTIVITY_TYPE='PLEDGE' 
               AND i.SOURCE_SYSTEM='DUES' 
               AND P.PRODUCT_CODE = Pay.PRODUCT_CODE 
               AND Pay.JOURNAL_TYPE = 'PAY' 
               AND Pay.TRANSACTION_TYPE = 'AR' 
               AND P.INVOICE_LINE_NUM = Pay.INVOICE_LINE_NUM
            GROUP BY i.BT_ID, il.ST_ID, Pay.INVOICE_REFERENCE_NUM, Pay.OWNER_ORG_CODE,Pay.GL_ACCT_ORG_CODE, P.CAMPAIGN_CODE, P.SOURCE_CODE
            ) pd  
            INNER JOIN (SELECT DISTINCT InvoiceNum FROM #TransTemp) invoices
                   ON pd.InvoiceReferenceNumber = invoices.InvoiceNum

-- BEGIN DonationReport 
-- Delete any existing rows from the DonationReport table for transactions being updated
DELETE FROM [dbo].[DonationReport]
 WHERE [OriginalTransaction] IN (SELECT t.TransNum FROM #TransTemp t )
   AND [SourceSystem] IN ('DUES','SC')

;WITH
TempPledgeData AS (
    SELECT v.ID, v.InvoiceReferenceNumber, v.Fund, v.Campaign, v.Appeal, 
           v.TransactionNumber   AS TransactionNumber, 
           v.TransactionDate     AS TransactionDate,
           v.DateReceived        AS DateReceived,
           v.SourceSystem        AS SourceSystem,
           v.SolicitorID         AS SolicitorID,
           v.FiscalMonth         AS FiscalMonth,
           v.FiscalYear          AS FiscalYear,
           v.MatchingTransaction AS MatchingTransaction,
           v.IsMatchingGift      AS IsMatchingGift,
           v.MemorialID          AS MemorialID,
           v.ListAs              AS ListAs,
           v.RequestNumber       AS RequestNumber,
           v.MemorialNameText    AS MemorialNameText, 
           v.PledgeAmount        AS PledgeAmount,  
                 v.AdjustmentsAmount   AS AdjustmentsAmount
      FROM vPledgeData v
     WHERE v.SourceSystem = 'DUES' AND
           v.TransactionNumber IN (SELECT DISTINCT TransNum FROM #TransTemp WHERE Transnum > 0)
     UNION
    SELECT v.ID, v.InvoiceReferenceNumber, v.Fund, v.Campaign, v.Appeal, 
           v.TransactionNumber   AS TransactionNumber, 
           v.TransactionDate     AS TransactionDate,
           v.DateReceived        AS DateReceived,
           v.SourceSystem        AS SourceSystem,
           v.SolicitorID         AS SolicitorID,
           v.FiscalMonth         AS FiscalMonth,
           v.FiscalYear          AS FiscalYear,
           v.MatchingTransaction AS MatchingTransaction,
           v.IsMatchingGift      AS IsMatchingGift,
           v.MemorialID          AS MemorialID,
           v.ListAs              AS ListAs,
           v.RequestNumber       AS RequestNumber,
           v.MemorialNameText    AS MemorialNameText, 
           v.PledgeAmount        AS PledgeAmount,  
                 v.AdjustmentsAmount   AS AdjustmentsAmount
      FROM vPledgeData v
     WHERE v.SourceSystem = 'DUES' AND
           v.ID IN (SELECT DISTINCT DonorId FROM #TransTemp)
),
NetPledgeInfo AS (
    SELECT v.ID, v.InvoiceReferenceNumber, v.Fund, v.Campaign, v.Appeal, 
           MAX(v.TransactionNumber)   AS TransactionNumber,
           MAX(v.TransactionDate)     AS TransactionDate,
           MAX(v.DateReceived)        AS DateReceived,
           MAX(v.FiscalYear)          AS FiscalYear,
           MAX(v.FiscalMonth)         AS FiscalMonth,
           MAX(v.SolicitorID)         AS SolicitorID,
           MAX(v.SourceSystem)        AS SourceSystem,
           MAX(v.MatchingTransaction) AS MatchingTransaction,
           MAX(v.IsMatchingGift)      AS IsMatchingGift,
           MAX(v.MemorialID)          AS MemorialID,
           MAX(v.ListAs)              AS ListAs,
           MAX(v.RequestNumber)       AS RequestNumber,
           MAX(v.MemorialNameText)    AS MemorialNameText, 
           SUM(v.PledgeAmount)  +  SUM(v.AdjustmentsAmount) AS NetPledgeAmount
      FROM TempPledgeData v
     GROUP BY v.ID, v.InvoiceReferenceNumber, v.Fund, v.Campaign, v.Appeal
)      -- Insert new rows into the DonationReport table for transactions being updated
INSERT INTO DonationReport( ID, 
                            OriginalTransaction, 
                            InvoiceRefNum, 
                            SourceSystem, 
                            TransactionDate, 
                            DateReceived, 
                            Amount, 
                            SolicitorID, 
                            CheckNumber, 
                            PaymentType, 
                            FiscalMonth, 
                            FiscalYear, 
                            GiftType, 
                            MatchingTransaction, 
                            IsMatchingGift, 
                            MemorialID, 
                            ListAs, 
                            RequestNumber, 
                            MemorialNameText
                          )
       --- Segment DUES3  -- ACCRUAL DUES BILLING (SOURCE SYSTEM = DUES)
       --- AMOUNT IS NET PLEDGE AFTER CM/DM
       SELECT MAX(npi.ID),
              MAX(npi.TransactionNumber),
              MAX(npi.InvoiceReferenceNumber),
              MAX(npi.SourceSystem),
              MAX(npi.TransactionDate),
              MAX(npi.DateReceived),
              SUM(npi.NetPledgeAmount),
              MAX(npi.SolicitorID),
              '',
              '',
              MAX(npi.FiscalMonth),
              MAX(npi.FiscalYear),
              'Pledge',
              MAX(npi.MatchingTransaction),
              MAX(npi.IsMatchingGift),
              MAX(npi.MemorialID),
              MAX(npi.ListAs),
              MAX(npi.RequestNumber),
              MAX(npi.MemorialNameText) 
         FROM NetPledgeInfo npi 
           WHERE npi.TransactionNumber IN (SELECT DISTINCT TransNum FROM #TransTemp)
        GROUP BY npi.ID, npi.TransactionNumber
    UNION 
       --- Segment DUES1 -- CASH DUES PAYMENT/PMT ON CASH DUES RENEWAL (SOURCE SYSTEM = DUES OR SC)
      SELECT MAX(g.ID),
             MAX(g.OriginalTransaction) ,
             0,
             MAX(g.SourceSystem),
             MAX(g.TransactionDate),
             MAX(g.DateReceived),
             SUM(g.Amount),
             '',
             '',
             MAX(g.PaymentType),
             MAX(g.FiscalMonth),
             MAX(g.FiscalYear),
             'Gift',
             0,
             0,
             '',
             '',
             0,
             ''
        FROM [dbo].GiftReport g
             INNER JOIN (SELECT DISTINCT TransNum FROM #TransTemp) t ON g.OriginalTransaction = t.TransNum 
       WHERE g.SourceSystem IN ('DUES','SC') AND g.GiftType = 'GIFT'
       GROUP BY g.ID, g.OriginalTransaction

END


GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_UpdateFundraisingViewTables_FR]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_UpdateFundraisingViewTables_FR]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_UpdateFundraisingViewTables_FR] 
    @TransRangeBegin int = NULL, @TransRangeEnd int = NULL
AS
BEGIN

-- If No TransRange parameters are passed in and there is no #TransTemp table, then this is a complete rebuild
IF (@TransRangeBegin IS NULL AND @TransRangeEnd IS NULL AND (SELECT COUNT(*) FROM #TransTemp) = 0)
BEGIN
    RETURN  -- Not yet implemented. This will need to truncate the three Report tables. Very dangerous!
END

-- Cache related [dbo].[Activity] info
DECLARE @ActivityTemp TABLE (ID varchar(10) NOT NULL, SEQN int NOT NULL, ORIGINATING_TRANS_NUM int NOT NULL, 
                            SOURCE_SYSTEM varchar(10) NOT NULL, TRANSACTION_DATE datetime NULL, EFFECTIVE_DATE datetime NULL, 
                            AMOUNT money NOT NULL, TAXABLE_VALUE money NOT NULL, ORG_CODE varchar(5) NOT NULL, SOURCE_CODE varchar(40) NOT NULL, 
                            SOLICITOR_ID varchar(10) NOT NULL, CAMPAIGN_CODE varchar(10) NOT NULL, ACTION_CODES varchar(255) NOT NULL, 
                            UF_4 numeric(15,4) NOT NULL, ACTIVITY_TYPE varchar(10) NOT NULL, PRODUCT_CODE varchar(31) NOT NULL);
INSERT INTO @ActivityTemp 
SELECT ID, SEQN, ORIGINATING_TRANS_NUM, SOURCE_SYSTEM, TRANSACTION_DATE, EFFECTIVE_DATE, AMOUNT, TAXABLE_VALUE,
       ORG_CODE, SOURCE_CODE, SOLICITOR_ID, CAMPAIGN_CODE, ACTION_CODES, UF_4, ACTIVITY_TYPE, PRODUCT_CODE 
  FROM (
    SELECT a.ID, a.SEQN, a.ORIGINATING_TRANS_NUM, a.SOURCE_SYSTEM, a.TRANSACTION_DATE, a.EFFECTIVE_DATE, a.AMOUNT, a.TAXABLE_VALUE,
           a.ORG_CODE, a.SOURCE_CODE, a.SOLICITOR_ID, a.CAMPAIGN_CODE, a.ACTION_CODES, a.UF_4, a.ACTIVITY_TYPE, a.PRODUCT_CODE
      FROM #TransTemp tt
           INNER JOIN [dbo].[Activity] a ON a.ORIGINATING_TRANS_NUM = tt.TransNum
    UNION
    SELECT a.ID, a.SEQN, a.ORIGINATING_TRANS_NUM, a.SOURCE_SYSTEM, a.TRANSACTION_DATE, a.EFFECTIVE_DATE, a.AMOUNT, a.TAXABLE_VALUE,
           a.ORG_CODE, a.SOURCE_CODE, a.SOLICITOR_ID, a.CAMPAIGN_CODE, a.ACTION_CODES, a.UF_4, a.ACTIVITY_TYPE, a.PRODUCT_CODE
      FROM #TransTemp tt
           INNER JOIN [dbo].[Trans] t ON tt.TransNum = t.TRANS_NUMBER
           INNER JOIN [dbo].[Activity] a ON a.SEQN = t.ACTIVITY_SEQN
) subActivity;

-- BEGIN GiftReport
-- Delete any existing rows from the [dbo].[GiftReport] table for transactions being updated
DELETE gr
  FROM [dbo].[GiftReport] gr
       INNER JOIN #TransTemp t ON gr.[TransactionNumber] = t.[TransNum]
                              AND gr.[InvoiceReferenceNumber] = t.[InvoiceNum]
 WHERE gr.[SourceSystem] = 'FR'
 
-- Insert new rows into the [dbo].[GiftReport] table for transactions being updated
INSERT INTO [dbo].[GiftReport] ( ID, 
                                 OriginalTransaction, 
                                 TransactionNumber, 
                                 SourceSystem, 
                                 TransactionDate, 
                                 DateReceived, 
                                 Amount, 
                                 FairMktValue, 
                                 Fund, 
                                 AppealCode, 
                                 SolicitorID, 
                                 CheckNumber, 
                                 PaymentType, 
                                 CampaignCode, 
                                 FiscalYear, 
                                 FiscalMonth, 
                                 GiftType, 
                                 InvoiceReferenceNumber, 
                                 ReceiptID, 
                                 MatchingTransaction, 
                                 IsMatchingGift, 
                                 MemorialID, 
                                 PledgeID, 
                                 ListAs, 
                                 RequestNumber, 
                                 InstallmentDate, 
                                 MemorialNameText
                         )
    -------------- Segment FR1 -- SINGLE GIFT (SOURCE SYSTEM = FR)
     SELECT a.ID,
            a.ORIGINATING_TRANS_NUM,
            a.ORIGINATING_TRANS_NUM,
            MAX(a.SOURCE_SYSTEM),
            MAX(a.TRANSACTION_DATE),
            MAX(CASE WHEN a.SOURCE_SYSTEM = 'FR' THEN a.EFFECTIVE_DATE ELSE a.TRANSACTION_DATE END),
            SUM(a.AMOUNT) Amount,  
            SUM(a.TAXABLE_VALUE),
            MAX(a.ORG_CODE),
            MAX(a.SOURCE_CODE),
            MAX(a.SOLICITOR_ID),
            MAX(c.CHECK_NUMBER),
            CASE MAX(COALESCE(ca.ACCOUNT_TYPE, 99))
                WHEN 1 THEN 'Credit Card'
                WHEN 2 THEN 'In Kind' 
                WHEN 3 THEN 'Debit Card' 
                ELSE 'Cash' 
            END,
            MAX(a.CAMPAIGN_CODE),
            CONVERT(int,SUBSTRING(CONVERT(char(6),MAX(c.FISCAL_PERIOD)),1,4)),
            CONVERT(int,SUBSTRING(CONVERT(char(6),MAX(c.FISCAL_PERIOD)),5,2)),
            'GIFT',
            MAX(c.INVOICE_REFERENCE_NUM),
            MAX(c.RECEIPT_ID),
            MAX(c.MATCH_GIFT_TRANS_NUM),
            MAX(c.IS_MATCH_GIFT),
            MAX(c.MEM_TRIB_ID),
            '',
            MAX(a.ACTION_CODES),
            MAX(a.UF_4),
            NULL,
            MAX(c.MEM_TRIB_NAME_TEXT)
       FROM @ActivityTemp a
            INNER JOIN [dbo].[Trans] c on a.ORIGINATING_TRANS_NUM = c.TRANS_NUMBER
            INNER JOIN #TransTemp t ON c.TRANS_NUMBER = t.TransNum AND c.INVOICE_REFERENCE_NUM = t.InvoiceNum
            LEFT OUTER JOIN [dbo].[Cash_Accounts] ca ON c.CHECK_NUMBER = ca.CASH_ACCOUNT_CODE 
      WHERE a.ACTIVITY_TYPE = 'GIFT' 
        AND a.ID = c.ST_ID 
        AND a.SOURCE_SYSTEM = 'FR' 
        AND c.TRANSACTION_TYPE = 'PAY' 
        AND c.JOURNAL_TYPE = 'IN' 
        AND c.SUB_LINE_NUMBER = 1
     GROUP BY a.ID, a.ORIGINATING_TRANS_NUM,  a.ORG_CODE, a.CAMPAIGN_CODE, a.SOURCE_CODE
   UNION
     -------------- Segment FR2  -- PAYMENT ON FR INSTALLMENT/PAYMENT ON SINGLE PLEDGE (SOURCE SYSTEM = FR)
     SELECT CASE 
                WHEN il.ST_ID IS NULL THEN i.BT_ID 
                ELSE il.ST_ID 
            END,
            p.TRANS_NUMBER,
            c.TRANS_NUMBER,
            MAX(p.SOURCE_SYSTEM),
            MAX(c.TRANSACTION_DATE),
            MAX(c.TRANSACTION_DATE),
            CASE
                WHEN MAX(c.JOURNAL_TYPE) = 'IN' THEN SUM(c.AMOUNT) 
                ELSE -SUM(c.AMOUNT) 
            END,
            SUM(c.TAXABLE_VALUE),
            CASE
                WHEN MAX(c.JOURNAL_TYPE) = 'IN' THEN MAX(c.OWNER_ORG_CODE) 
                ELSE MAX(c.GL_ACCT_ORG_CODE) 
            END,
            MAX(p.SOURCE_CODE),
            MAX(p.SOLICITOR_ID),
            MAX(c.CHECK_NUMBER),
            CASE MAX(COALESCE(ca.ACCOUNT_TYPE, 99))
                WHEN 1 THEN 'Credit Card' 
                WHEN 2 THEN 'In Kind' 
                WHEN 3 THEN 'Debit Card' 
                ELSE 'Cash' 
            END,
            MAX(a.CAMPAIGN_CODE),
            CONVERT(int,SUBSTRING(CONVERT(char(6),MAX(c.FISCAL_PERIOD)),1,4)),
            CONVERT(int,SUBSTRING(CONVERT(char(6),MAX(c.FISCAL_PERIOD)),5,2)),
            'Pledge Payment',
            MAX(c.INVOICE_REFERENCE_NUM),
            MAX(c.RECEIPT_ID),
            MAX(p.MATCH_GIFT_TRANS_NUM),
            MAX(p.IS_MATCH_GIFT),
            MAX(p.MEM_TRIB_ID),
            CASE 
                WHEN MAX(c.BT_ID)= MAX(c.ST_ID) THEN '' 
                ELSE MAX(c.BT_ID) 
            END,
            MAX(a.ACTION_CODES),
            MAX(a.UF_4),
            MAX(i.INSTALL_BILL_DATE),
            MAX(p.MEM_TRIB_NAME_TEXT)
       FROM [dbo].[Invoice] i
            INNER JOIN [dbo].[Trans] p ON i.ORIGINATING_TRANS_NUM = p.TRANS_NUMBER
            INNER JOIN [dbo].[Activity] a ON p.ACTIVITY_SEQN = a.SEQN
            INNER JOIN [dbo].[Trans] c ON i.REFERENCE_NUM = c.INVOICE_REFERENCE_NUM
            INNER JOIN #TransTemp t ON c.TRANS_NUMBER = t.TransNum
                                   AND c.INVOICE_REFERENCE_NUM = t.InvoiceNum
            LEFT OUTER JOIN [dbo].[Cash_Accounts] ca ON c.CHECK_NUMBER = ca.CASH_ACCOUNT_CODE
            LEFT OUTER JOIN [dbo].[Invoice_Lines] il ON c.INVOICE_REFERENCE_NUM = il.REFERENCE_NUM 
                                                    AND c.INVOICE_LINE_NUM = il.LINE_NUM
      WHERE p.TRANSACTION_TYPE = 'DIST' 
        AND c.IS_FR_ITEM = 1 
        AND a.ACTIVITY_TYPE = 'PLEDGE' 
        AND p.LINE_NUMBER = 1 
        AND p.SUB_LINE_NUMBER = 1 
        AND i.SOURCE_SYSTEM = 'FR' 
        AND c.JOURNAL_TYPE = 'PAY' 
        AND c.TRANSACTION_TYPE = 'AR'
        GROUP BY il.ST_ID, i.BT_ID, c.TRANS_NUMBER, c.INVOICE_REFERENCE_NUM, c.OWNER_ORG_CODE, c.GL_ACCT_ORG_CODE, a.CAMPAIGN_CODE, p.SOURCE_CODE, p.TRANS_NUMBER
   UNION
     -------------- Segment FR3  -- DOWNPAYMENT ON FR INSTALLMENT (SOURCE SYSTEM = FR)
     SELECT CASE 
                WHEN c.ST_ID IS NULL THEN c.BT_ID 
                ELSE c.ST_ID 
            END,
            p.TRANS_NUMBER,
            c.TRANS_NUMBER,
            MAX(p.SOURCE_SYSTEM),
            MAX(c.TRANSACTION_DATE),
            MAX(c.TRANSACTION_DATE),
            SUM(c.AMOUNT),
            SUM(c.TAXABLE_VALUE),
            MAX(c.OWNER_ORG_CODE),
            MAX(p.SOURCE_CODE),
            MAX(p.SOLICITOR_ID),
            MAX(c.CHECK_NUMBER),
            CASE MAX(COALESCE(ca.ACCOUNT_TYPE, 99))
                WHEN 1 THEN 'Credit Card' 
                WHEN 2 THEN 'In Kind' 
                WHEN 3 THEN 'Debit Card' 
                ELSE 'Cash' 
            END,
            MAX(a.CAMPAIGN_CODE),
            CONVERT(int,SUBSTRING(CONVERT(char(6),MAX(c.FISCAL_PERIOD)),1,4)),
            CONVERT(int,SUBSTRING(CONVERT(char(6),MAX(c.FISCAL_PERIOD)),5,2)),
            'Pledge Payment',
            MAX(c.INVOICE_REFERENCE_NUM),
            MAX(c.RECEIPT_ID),
            MAX(p.MATCH_GIFT_TRANS_NUM),
            MAX(p.IS_MATCH_GIFT),
            MAX(p.MEM_TRIB_ID),
            CASE 
                WHEN MAX(c.BT_ID)= MAX(c.ST_ID) THEN '' 
                ELSE MAX(c.BT_ID) 
            END,
            MAX(a.ACTION_CODES),
            MAX(a.UF_4),
            MAX(p.INSTALL_BILL_DATE),
            MAX(p.MEM_TRIB_NAME_TEXT)
       FROM [dbo].[Trans] p
            INNER JOIN [dbo].[Activity] a ON p.ACTIVITY_SEQN = a.SEQN
            INNER JOIN [dbo].[Trans] c ON p.TRANS_NUMBER = c.TRANS_NUMBER
            INNER JOIN #TransTemp t ON c.TRANS_NUMBER = t.TransNum
                                   AND c.INVOICE_REFERENCE_NUM = t.InvoiceNum
            LEFT OUTER JOIN [dbo].[Cash_Accounts] ca ON c.CHECK_NUMBER = ca.CASH_ACCOUNT_CODE

      WHERE p.TRANSACTION_TYPE = 'DIST' 
        AND c.IS_FR_ITEM = 1 
        AND a.ACTIVITY_TYPE = 'PLEDGE' 
        AND p.LINE_NUMBER = 1 
        AND p.SUB_LINE_NUMBER = 1 
        AND p.SOURCE_SYSTEM = 'FR' 
        AND c.JOURNAL_TYPE = 'IN' 
        AND c.TRANSACTION_TYPE = 'PAY'
        GROUP BY c.ST_ID, c.BT_ID, c.TRANS_NUMBER, c.INVOICE_REFERENCE_NUM, c.OWNER_ORG_CODE, c.GL_ACCT_ORG_CODE, a.CAMPAIGN_CODE, p.SOURCE_CODE, p.TRANS_NUMBER
   UNION
     -------------- Segment FR4  -- ANY PAYMENT (+/-) ON SINGLE GIFT THRU CASH RECEIPTS (SOURCE SYSTEM = FR)
     SELECT CASE 
                WHEN il.ST_ID IS NULL THEN i.BT_ID 
                ELSE il.ST_ID 
            END,
            p.TRANS_NUMBER,
            c.TRANS_NUMBER,
            MAX(p.SOURCE_SYSTEM),
            MAX(c.TRANSACTION_DATE),
            MAX(c.TRANSACTION_DATE),
            CASE
                WHEN MAX(c.JOURNAL_TYPE) = 'IN' THEN SUM(c.AMOUNT) 
                ELSE -SUM(c.AMOUNT) 
            END,
            SUM(c.TAXABLE_VALUE),
            CASE
                WHEN MAX(c.JOURNAL_TYPE) = 'IN' THEN MAX(c.OWNER_ORG_CODE) 
                ELSE MAX(c.GL_ACCT_ORG_CODE) 
            END,
          MAX(p.SOURCE_CODE),
            MAX(p.SOLICITOR_ID),
            MAX(c.CHECK_NUMBER),
            CASE MAX(COALESCE(ca.ACCOUNT_TYPE, 99))
                WHEN 1 THEN 'Credit Card' 
                WHEN 2 THEN 'In Kind' 
                WHEN 3 THEN 'Debit Card' 
                ELSE 'Cash' 
            END,
            MAX(a.CAMPAIGN_CODE),
            CONVERT(int,SUBSTRING(CONVERT(char(6),MAX(c.FISCAL_PERIOD)),1,4)),
            CONVERT(int,SUBSTRING(CONVERT(char(6),MAX(c.FISCAL_PERIOD)),5,2)),
            'Pledge Payment',
            MAX(c.INVOICE_REFERENCE_NUM),
            MAX(c.RECEIPT_ID),
            MAX(p.MATCH_GIFT_TRANS_NUM),
            MAX(p.IS_MATCH_GIFT),
            MAX(p.MEM_TRIB_ID),
            CASE 
                WHEN MAX(c.BT_ID)= MAX(c.ST_ID) THEN '' 
                ELSE MAX(c.BT_ID) 
            END,
            MAX(a.ACTION_CODES),
            MAX(a.UF_4),
            MAX(i.INSTALL_BILL_DATE),
            MAX(p.MEM_TRIB_NAME_TEXT)
       FROM [dbo].[Invoice] i
            INNER JOIN [dbo].[Trans] p ON i.ORIGINATING_TRANS_NUM = p.TRANS_NUMBER
            INNER JOIN [dbo].[Activity] a ON p.ACTIVITY_SEQN = a.SEQN
            INNER JOIN [dbo].[Trans] c ON i.REFERENCE_NUM = c.INVOICE_REFERENCE_NUM
            INNER JOIN #TransTemp t ON c.TRANS_NUMBER = t.TransNum
                                   AND c.INVOICE_REFERENCE_NUM = t.InvoiceNum
            LEFT OUTER JOIN [dbo].[Cash_Accounts] ca ON c.CHECK_NUMBER = ca.CASH_ACCOUNT_CODE
            LEFT OUTER JOIN [dbo].[Invoice_Lines] il ON c.INVOICE_REFERENCE_NUM = il.REFERENCE_NUM 
                                                    AND c.INVOICE_LINE_NUM = il.LINE_NUM
      WHERE p.TRANSACTION_TYPE = 'DIST' 
        AND c.IS_FR_ITEM = 1 
        AND a.ACTIVITY_TYPE = 'GIFT' 
        AND p.LINE_NUMBER = 1 AND p.SUB_LINE_NUMBER = 1 
        AND i.SOURCE_SYSTEM = 'FR' 
        AND c.JOURNAL_TYPE = 'PAY' AND c.TRANSACTION_TYPE = 'AR'
        GROUP BY il.ST_ID, i.BT_ID, c.TRANS_NUMBER, c.INVOICE_REFERENCE_NUM, c.OWNER_ORG_CODE, c.GL_ACCT_ORG_CODE, a.CAMPAIGN_CODE, p.SOURCE_CODE, p.TRANS_NUMBER
   UNION
     --- Segment *TAB1  -- OPEN CREDIT APPLICATION - IN/TR (SOURCE SYSTEM = FR)
     SELECT MAX(p.ST_ID),
            MAX(p.TRANS_NUMBER),
            MAX(c.TRANS_NUMBER),
            MAX(p.SOURCE_SYSTEM),
            MAX(c.TRANSACTION_DATE),
            MAX(c.TRANSACTION_DATE),
            -SUM(c.AMOUNT) Amount,
            SUM(p.TAXABLE_VALUE),
            CASE
                WHEN MAX(c.JOURNAL_TYPE) = 'IN' 
                THEN MAX(c.OWNER_ORG_CODE) 
                ELSE MAX(c.GL_ACCT_ORG_CODE)
            END,
            MAX(p.SOURCE_CODE),
            MAX(p.SOLICITOR_ID),
            MAX(c.CHECK_NUMBER),
            CASE MAX(ca.ACCOUNT_TYPE)
                WHEN 1 THEN 'Credit Card' 
                WHEN 2 THEN 'In Kind' 
                WHEN 3 THEN 'Debit Card' 
                ELSE 'Cash' 
            END,
            MAX(a.CAMPAIGN_CODE),
            CONVERT(int,SUBSTRING(CONVERT(char(6),MAX(c.FISCAL_PERIOD)),1,4)),
            CONVERT(int,SUBSTRING(CONVERT(char(6),MAX(c.FISCAL_PERIOD)),5,2)),
            'Asterisk Tab Adjustment',
            MAX(c.INVOICE_REFERENCE_NUM),
            MAX(c.RECEIPT_ID),
            MAX(p.MATCH_GIFT_TRANS_NUM),
            MAX(p.IS_MATCH_GIFT),
            MAX(p.MEM_TRIB_ID),
            CASE 
                WHEN MAX(c.BT_ID)= MAX(c.ST_ID) THEN '' 
                ELSE MAX(c.BT_ID)
            END,
            '',
            0,
            MAX(i.INSTALL_BILL_DATE),
            MAX(p.MEM_TRIB_NAME_TEXT)
       FROM [dbo].[Invoice] i
            INNER JOIN [dbo].[Trans] c ON i.REFERENCE_NUM = c.INVOICE_REFERENCE_NUM 
            INNER JOIN #TransTemp t ON c.TRANS_NUMBER = t.TransNum
                                   AND c.INVOICE_REFERENCE_NUM = t.InvoiceNum
            INNER JOIN [dbo].[Trans] p ON i.ORIGINATING_TRANS_NUM = p.TRANS_NUMBER
            INNER JOIN [dbo].[Activity] a on p.ACTIVITY_SEQN = a.SEQN
            LEFT OUTER JOIN [dbo].[Cash_Accounts] ca on c.CHECK_NUMBER = ca.CASH_ACCOUNT_CODE
      WHERE p.LINE_NUMBER = 1  
        AND p.SUB_LINE_NUMBER = 1 
        AND p.JOURNAL_TYPE = 'IN' 
        AND p.TRANSACTION_TYPE = 'DIST' 
        AND i.SOURCE_SYSTEM='FR' 
        AND c.JOURNAL_TYPE = 'IN' 
        AND c.TRANSACTION_TYPE = 'TR'
     GROUP BY p.ST_ID, c.TRANS_NUMBER, p.INVOICE_REFERENCE_NUM
   UNION 
     --- Segment *TAB2  -- OPEN CREDIT APPLICATION - PAY/PAY OR PAY/TR (SOURCE SYSTEM = FR)
     SELECT MAX(p.ST_ID),
            MAX(p.TRANS_NUMBER),
            MAX(c.TRANS_NUMBER),
            MAX(p.SOURCE_SYSTEM),
            MAX(c.TRANSACTION_DATE),
            MAX(c.TRANSACTION_DATE),
            -SUM(c.AMOUNT) Amount,
            SUM(p.TAXABLE_VALUE),
            CASE
                WHEN MAX(c.JOURNAL_TYPE) = 'IN' 
                THEN MAX(c.OWNER_ORG_CODE) 
                ELSE MAX(c.GL_ACCT_ORG_CODE)
            END,
            MAX(p.SOURCE_CODE),
            MAX(p.SOLICITOR_ID),
            MAX(c.CHECK_NUMBER),
            CASE MAX(COALESCE(ca.ACCOUNT_TYPE, 99))
                WHEN 1 THEN 'Credit Card' 
                WHEN 2 THEN 'In Kind' 
                WHEN 3 THEN 'Debit Card' 
                ELSE 'Cash' 
            END,
            MAX(a.CAMPAIGN_CODE),
            CONVERT(int,SUBSTRING(CONVERT(char(6),MAX(c.FISCAL_PERIOD)),1,4)),
            CONVERT(int,SUBSTRING(CONVERT(char(6),MAX(c.FISCAL_PERIOD)),5,2)),
            'Asterisk Tab Adjustment',
            MAX(c.INVOICE_REFERENCE_NUM),
            MAX(c.RECEIPT_ID),
            MAX(p.MATCH_GIFT_TRANS_NUM),
            MAX(p.IS_MATCH_GIFT),
            MAX(p.MEM_TRIB_ID),
            CASE 
                WHEN MAX(c.BT_ID)= MAX(c.ST_ID) THEN '' 
                ELSE MAX(c.BT_ID)
            END,
            '',
            0,
            MAX(i.INSTALL_BILL_DATE),
            MAX(p.MEM_TRIB_NAME_TEXT)
       FROM [dbo].[Invoice] i
            INNER JOIN [dbo].[Trans] c ON i.REFERENCE_NUM = c.INVOICE_REFERENCE_NUM 
            INNER JOIN #TransTemp t ON c.TRANS_NUMBER = t.TransNum
                                   AND c.INVOICE_REFERENCE_NUM = t.InvoiceNum
            INNER JOIN [dbo].[Trans] p ON i.ORIGINATING_TRANS_NUM = p.TRANS_NUMBER
            INNER JOIN [dbo].[Activity] a on p.ACTIVITY_SEQN = a.SEQN
            LEFT OUTER JOIN [dbo].[Cash_Accounts] ca on c.CHECK_NUMBER = ca.CASH_ACCOUNT_CODE
      WHERE p.LINE_NUMBER = 1  
        AND p.SUB_LINE_NUMBER = 1 
        AND p.JOURNAL_TYPE = 'IN' 
        AND p.TRANSACTION_TYPE = 'DIST' 
        AND i.SOURCE_SYSTEM='FR' 
        AND c.JOURNAL_TYPE = 'PAY' 
        AND c.TRANSACTION_TYPE IN ('PAY','TR')
     GROUP BY p.ST_ID, c.TRANS_NUMBER, p.INVOICE_REFERENCE_NUM

-- Update rows in [dbo].[GiftReport] with MemorialTribute details from Activity
UPDATE gr 
   SET [MemorialTributeType] = a.MEM_TRIB_CODE,
       [MemorialTributeMessage] = ISNULL(a.NOTE_2, ''), 
       [TributeNotificationContactID] = tn.NOTIFY_ID 
  FROM [dbo].[Activity] a
       INNER JOIN @ActivityTemp at ON a.SEQN = at.SEQN
       LEFT OUTER JOIN [dbo].[Trans_Notify] tn ON tn.TRANS_NUMBER = a.ORIGINATING_TRANS_NUM 
       LEFT OUTER JOIN [dbo].[GiftReport] gr ON gr.OriginalTransaction = a.ORIGINATING_TRANS_NUM 
  WHERE EXISTS (SELECT Trans_Notify.TRANS_NUMBER 
                  FROM Trans_Notify 
                 WHERE gr.OriginalTransaction IS NOT NULL 
                   AND Trans_Notify.TRANS_NUMBER = gr.OriginalTransaction )

-- BEGIN PledgeReport
-- Delete any existing rows from the PledgeReport table for transactions being updated
DELETE pr
  FROM PledgeReport pr
       INNER JOIN (SELECT DISTINCT InvoiceNum FROM #TransTemp) invoices
           ON pr.InvoiceReferenceNumber = invoices.InvoiceNum
 WHERE pr.[SourceSystem] = 'FR'
 
--Insert new rows into the PledgeReport table for transactions being updated
INSERT INTO PledgeReport( ID, 
                          TransactionType, 
                          TransactionNumber, 
                          InvoiceReferenceNumber, 
                          TransactionDate, 
                          DateReceived, 
                          FiscalYear, 
                          FiscalMonth, 
                          AppealCode, 
                          CampaignCode, 
                          Fund, 
                          SolicitorID, 
                          SourceSystem, 
                          MatchingTransaction, 
                          IsMatchingGift, 
                          MemorialID, 
                          ListAs, 
                          RequestNumber, 
                          InstallmentDate, 
                          LastPaymentDate, 
                          PledgeAmount, 
                          AdjustmentsAmount, 
                          PaymentsAmount, 
                          PledgeFairMarketValue, 
                          MemorialNameText
                        )
       SELECT pd.ID, 
              pd.TransactionType, 
              pd.TransactionNumber, 
              pd.InvoiceReferenceNumber, 
              pd.TransactionDate, 
              pd.DateReceived, 
              pd.FiscalYear, 
              pd.FiscalMonth, 
              pd.AppealCode, 
              pd.CampaignCode, 
              pd.Fund, 
              pd.SolicitorID, 
              pd.SourceSystem, 
              pd.MatchingTransaction, 
              pd.IsMatchingGift, 
              pd.MemorialID, 
              pd.ListAs, 
              pd.RequestNumber, 
              pd.InstallmentDate, 
              pd.LastPaymentDate, 
              pd.PledgeAmount, 
              pd.AdjustmentsAmount, 
              pd.PaymentsAmount, 
              pd.PledgeFairMarketValue, 
              pd.MemorialNameText
       FROM (
    --- Segment PLEDGE1  -- SINGLE PLEDGE OR INSTALLMENT (SOURCE SYSTEM = FR)
             SELECT a.ID,
                    'Pledge' AS TransactionType,
                    MAX(p.TRANS_NUMBER) AS TransactionNumber,
                    MAX(p.INVOICE_REFERENCE_NUM) AS InvoiceReferenceNumber,
                    MAX(p.TRANSACTION_DATE) AS TransactionDate,
                    MAX(a.EFFECTIVE_DATE) AS DateReceived,
                    CONVERT(int,substring(CONVERT(char(6),MAX(p.FISCAL_PERIOD)),1,4)) AS FiscalYear,
                    CONVERT(int,substring(CONVERT(char(6),MAX(p.FISCAL_PERIOD)),5,2)) AS FiscalMonth,
                    MAX(a.SOURCE_CODE) AS AppealCode,
                    MAX(a.CAMPAIGN_CODE) AS CampaignCode,
                    MAX(a.ORG_CODE) AS Fund,
                    MAX(a.SOLICITOR_ID) AS SolicitorID,
                    MAX(p.SOURCE_SYSTEM) AS SourceSystem,
                    MAX(p.MATCH_GIFT_TRANS_NUM) AS MatchingTransaction,
                    MAX(p.IS_MATCH_GIFT) AS IsMatchingGift,
                    MAX(p.MEM_TRIB_ID) AS MemorialID,
                    MAX(a.ACTION_CODES) AS ListAs,
                    MAX(a.UF_4) AS RequestNumber,
                    MAX(p.INSTALL_BILL_DATE) AS InstallmentDate,
                    NULL AS LastPaymentDate,
                    SUM(p.AMOUNT) * -1 AS PledgeAmount,
                    0 AS AdjustmentsAmount,
                    0 AS PaymentsAmount,
                    SUM(p.TAXABLE_VALUE) AS PledgeFairMarketValue,
                    MAX(p.MEM_TRIB_NAME_TEXT) AS MemorialNameText
               FROM [dbo].[Trans] p 
                    INNER JOIN (SELECT DISTINCT TransNum FROM #TransTemp) t ON t.TransNum = p.TRANS_NUMBER
                    INNER JOIN [dbo].[Activity] a ON p.ACTIVITY_SEQN = a.SEQN
              WHERE p.TRANSACTION_TYPE = 'DIST' 
                AND p.JOURNAL_TYPE = 'IN' 
                AND p.POSTED >= 2 
                AND p.SOURCE_SYSTEM = 'FR' 
                AND a.ACTIVITY_TYPE = 'PLEDGE' 
              GROUP BY a.ID, p.INVOICE_REFERENCE_NUM, a.ORG_CODE,a.CAMPAIGN_CODE,a.SOURCE_CODE
          UNION ALL  
    --- Segment *TAB2  -- OPEN CREDIT APPLICATION - PAY/PAY (SOURCE SYSTEM = FR)
             SELECT MAX(P.ST_ID) AS ID,
                    'Asterisk Tab Adjustment' AS TransactionType, 
                    0 AS TransactionNumber,
                    MAX(C.INVOICE_REFERENCE_NUM)   AS InvoiceReferenceNumber,
                    NULL AS asTransactionDate, 
                    NULL AS DateReceived, 
                    0 AS FiscalYear,
                    0 AS FiscalMonth, 
                    MAX(P.SOURCE_CODE)  AS Appeal, 
                    MAX(P.CAMPAIGN_CODE) AS Campaign, 
                    MAX(C.OWNER_ORG_CODE) AS Fund,
                    '' AS SolicitorID,
                    MAX(i.SOURCE_SYSTEM)  AS SourceSystem, 
                    0 AS MatchingTransaction,
                    0 AS IsMatchingGift, 
                    '' AS MemorialID,
                    '' AS ListAs, 
                    0 AS RequestNumber, 
                    NULL AS InstallmentDate,
                    NULL AS LastPaymentDate,
                    0 AS PledgeAmount, 
                    0 AS AdjustmentsAmount, 
                    SUM(C.AMOUNT) * - 1 AS PaymentsAmount, 
                    0 AS PledgeFairMarketValue, 
                    '' AS MemorialNameText
               FROM [dbo].[Trans] c 
                    INNER JOIN [dbo].[Invoice] i ON i.REFERENCE_NUM = c.INVOICE_REFERENCE_NUM
                    INNER JOIN [dbo].[Trans] p ON p.TRANS_NUMBER = i.ORIGINATING_TRANS_NUM
                    LEFT OUTER JOIN [dbo].[Cash_Accounts] ca ON ca.CASH_ACCOUNT_CODE = c.CHECK_NUMBER
                    INNER JOIN [dbo].[Activity] a ON a.SEQN = p.ACTIVITY_SEQN 
                    INNER JOIN (SELECT DISTINCT TransNum FROM #TransTemp) t ON t.TransNum = p.TRANS_NUMBER
              WHERE  p.LINE_NUMBER = 1 
                AND p.SUB_LINE_NUMBER = 1
                AND p.JOURNAL_TYPE = 'IN' 
                AND p.TRANSACTION_TYPE = 'DIST' 
                AND i.SOURCE_SYSTEM = 'FR' 
                AND c.JOURNAL_TYPE = 'PAY' 
                AND c.TRANSACTION_TYPE = 'PAY' 
              GROUP BY P.ST_ID, P.TRANS_NUMBER, P.INVOICE_REFERENCE_NUM
          UNION ALL  
    --- Segment *TAB1  -- OPEN CREDIT APPLICATION - IN/TR (SOURCE SYSTEM = FR)
             SELECT MAX(P.ST_ID) AS ID,
                    'Asterisk Tab Adjustment' AS TransactionType, 
                    0 AS TransactionNumber,
                    MAX(C.INVOICE_REFERENCE_NUM)   AS InvoiceReferenceNumber,
                    NULL AS asTransactionDate, 
                    NULL AS DateReceived, 
                    0 AS FiscalYear,
                    0 AS FiscalMonth, 
                    MAX(P.SOURCE_CODE)  AS Appeal, 
                    MAX(P.CAMPAIGN_CODE) AS Campaign, 
                    MAX(C.OWNER_ORG_CODE) AS Fund,
                    '' AS SolicitorID,
                    MAX(i.SOURCE_SYSTEM)  AS SourceSystem, 
                    0 AS MatchingTransaction,
                    0 AS IsMatchingGift, 
                    '' AS MemorialID,
                    '' AS ListAs, 
                    0 AS RequestNumber, 
                    NULL AS InstallmentDate,
                    NULL AS LastPaymentDate,
                    0 AS PledgeAmount, 
                    0 AS AdjustmentsAmount, 
                    SUM(C.AMOUNT) * - 1 AS PaymentsAmount, 
                    0 AS PledgeFairMarketValue, 
                    '' AS MemorialNameText
               FROM [dbo].[Trans] c 
                    INNER JOIN [dbo].[Invoice] i ON i.REFERENCE_NUM = c.INVOICE_REFERENCE_NUM
                    INNER JOIN [dbo].[Trans] p ON p.TRANS_NUMBER = i.ORIGINATING_TRANS_NUM
                    LEFT OUTER JOIN [dbo].[Cash_Accounts] ca ON ca.CASH_ACCOUNT_CODE = c.CHECK_NUMBER
                    INNER JOIN [dbo].[Activity] a ON a.SEQN = p.ACTIVITY_SEQN 
                    INNER JOIN (SELECT DISTINCT TransNum FROM #TransTemp) t ON t.TransNum = p.TRANS_NUMBER
              WHERE  p.LINE_NUMBER = 1 
                AND p.SUB_LINE_NUMBER = 1 
                AND p.JOURNAL_TYPE = 'IN' 
                AND p.TRANSACTION_TYPE = 'DIST' 
                AND i.SOURCE_SYSTEM = 'FR' 
                AND c.JOURNAL_TYPE = 'IN' 
                AND c.TRANSACTION_TYPE = 'TR'
              GROUP BY P.ST_ID, P.TRANS_NUMBER, P.INVOICE_REFERENCE_NUM
          UNION ALL
    --- Segment PLEDGE2  -- CM/DM PLEDGE (SOURCE SYSTEM = FR)
             SELECT CASE 
                       WHEN il.ST_ID IS NULL THEN i.BT_ID 
                       ELSE il.ST_ID 
                    END,
                    'Adjustment',
                    0,
                    MAX(adj.INVOICE_REFERENCE_NUM),
                    NULL,
                    NULL,
                    0,
                    0,
                    MAX(P.SOURCE_CODE),
                    MAX(P.CAMPAIGN_CODE),
                    MAX(adj.OWNER_ORG_CODE),
                    '',
                    MAX(i.SOURCE_SYSTEM),
                    0,
                    0,
                    '',
                    '',
                    0,
                    NULL,
                    NULL,
                    0,
                    SUM(adj.AMOUNT) * -1,
                    0,
                    0,
                    ''
               FROM [dbo].[Trans] adj 
                    INNER JOIN (SELECT DISTINCT InvoiceNum FROM #TransTemp) t ON t.InvoiceNum = adj.INVOICE_REFERENCE_NUM
                    INNER JOIN [dbo].[Invoice] i ON adj.INVOICE_REFERENCE_NUM = i.REFERENCE_NUM
                    INNER JOIN [dbo].[Trans] p ON p.TRANS_NUMBER = i.ORIGINATING_TRANS_NUM
                    INNER JOIN [dbo].[Activity] a ON a.SEQN = p.ACTIVITY_SEQN
                    LEFT OUTER JOIN [dbo].[Invoice_Lines] il ON il.REFERENCE_NUM = adj.INVOICE_REFERENCE_NUM 
                                                            AND il.LINE_NUM = adj.INVOICE_LINE_NUM
              WHERE adj.TRANSACTION_TYPE = 'DIST' 
                AND adj.JOURNAL_TYPE IN ('CM','DM')
                AND adj.POSTED >= 2 
                AND i.SOURCE_SYSTEM = 'FR' 
                AND i.INSTALL_BILL_DATE is not NULL 
                AND P.SUB_LINE_NUMBER = 1 
                AND a.ACTIVITY_TYPE='PLEDGE' 
                AND P.LINE_NUMBER = 1
              GROUP BY i.BT_ID, il.ST_ID, adj.INVOICE_REFERENCE_NUM, adj.OWNER_ORG_CODE,P.CAMPAIGN_CODE, P.SOURCE_CODE
       UNION ALL
     --- Segment FR2  -- PAYMENT ON FR INSTALLMENT/PAYMENT ON SINGLE PLEDGE (SOURCE SYSTEM = FR)
             SELECT CASE 
                       WHEN il.ST_ID IS NULL THEN i.BT_ID 
                       ELSE il.ST_ID 
                    END,
                    'Payment',
                    0,
                    MAX(Pay.INVOICE_REFERENCE_NUM),
                    NULL,
                    NULL,
                    0,
                    0,
                    P.SOURCE_CODE,
                    P.CAMPAIGN_CODE,
                    CASE
                        WHEN MAX(Pay.TRANSACTION_TYPE) = 'AR' THEN MAX(Pay.GL_ACCT_ORG_CODE) 
                        ELSE MAX(Pay.OWNER_ORG_CODE) 
                    END,
                    '',
                    MAX(i.SOURCE_SYSTEM),
                    0,
                    0,
                    '',
                    '',
                    0,
                    NULL,
                    MAX(Pay.TRANSACTION_DATE),
                    0,
                    0,
                    SUM(Pay.INVOICE_CREDITS),
                    0,
                    '' 
               FROM [dbo].[Trans] Pay
                        INNER JOIN (SELECT DISTINCT InvoiceNum FROM #TransTemp) t ON t.InvoiceNum = Pay.INVOICE_REFERENCE_NUM
                        INNER JOIN [dbo].[Invoice] i ON i.REFERENCE_NUM = Pay.INVOICE_REFERENCE_NUM
                        INNER JOIN [dbo].[Trans] p ON P.TRANS_NUMBER = i.ORIGINATING_TRANS_NUM
                        INNER JOIN [dbo].[Activity] a ON a.SEQN = P.ACTIVITY_SEQN
                        LEFT OUTER JOIN [dbo].[Invoice_Lines] il ON il.REFERENCE_NUM = Pay.INVOICE_REFERENCE_NUM 
                                                     AND il.LINE_NUM = Pay.INVOICE_LINE_NUM
             WHERE P.TRANSACTION_TYPE = 'DIST' 
               AND Pay.POSTED >= 2 and Pay.IS_FR_ITEM=1 
               AND a.ACTIVITY_TYPE='PLEDGE' 
               AND P.LINE_NUMBER = 1  
               AND P.SUB_LINE_NUMBER = 1 
               AND i.SOURCE_SYSTEM='FR' 
               AND Pay.JOURNAL_TYPE = 'PAY' 
               AND Pay.TRANSACTION_TYPE = 'AR'
            GROUP BY i.BT_ID, il.ST_ID, Pay.INVOICE_REFERENCE_NUM, Pay.OWNER_ORG_CODE,Pay.GL_ACCT_ORG_CODE, P.CAMPAIGN_CODE, P.SOURCE_CODE
       UNION ALL
     --- Segment FR3  -- DOWNPAYMENT ON FR INSTALLMENT (SOURCE SYSTEM = FR)
             SELECT CASE 
                       WHEN Pay.ST_ID IS NULL THEN Pay.BT_ID 
                       ELSE Pay.ST_ID 
                    END,
                    'Payment',
                    0,
                    MAX(Pay.INVOICE_REFERENCE_NUM),
                    NULL,
                    NULL,
                    0,
                    0,
                    P.SOURCE_CODE,
                    P.CAMPAIGN_CODE,
                    Max(Pay.OWNER_ORG_CODE),
                    '',
                    MAX(Pay.SOURCE_SYSTEM),
                    0,
                    0,
                    '',
                    '',
                    0,
                    NULL,
                    MAX(Pay.TRANSACTION_DATE),
                    0,
                    0,
                    SUM(Pay.INVOICE_CREDITS),
                    0,
                    '' 
               FROM [dbo].[Trans] Pay
                        INNER JOIN (SELECT DISTINCT InvoiceNum FROM #TransTemp) t ON t.InvoiceNum = Pay.INVOICE_REFERENCE_NUM
                        INNER JOIN [dbo].[Trans] p ON P.TRANS_NUMBER = Pay.TRANS_NUMBER
                        INNER JOIN [dbo].[Activity] a ON a.SEQN = P.ACTIVITY_SEQN
             WHERE P.TRANSACTION_TYPE = 'DIST' 
               AND Pay.POSTED >= 2 and Pay.IS_FR_ITEM=1 
               AND a.ACTIVITY_TYPE='PLEDGE' 
               AND P.LINE_NUMBER = 1  
               AND P.SUB_LINE_NUMBER = 1 
               AND Pay.SOURCE_SYSTEM='FR' 
               AND Pay.JOURNAL_TYPE = 'IN' 
               AND Pay.TRANSACTION_TYPE = 'PAY'
            GROUP BY Pay.BT_ID, Pay.ST_ID, Pay.INVOICE_REFERENCE_NUM, Pay.OWNER_ORG_CODE,Pay.GL_ACCT_ORG_CODE, P.CAMPAIGN_CODE, P.SOURCE_CODE
            ) pd  
            INNER JOIN (SELECT DISTINCT InvoiceNum FROM #TransTemp) invoices
                   ON pd.InvoiceReferenceNumber = invoices.InvoiceNum

-- BEGIN DonationReport 
-- Delete any existing rows from the DonationReport table for transactions being updated
DELETE FROM [dbo].[DonationReport]
 WHERE [OriginalTransaction] IN (SELECT t.TransNum FROM #TransTemp t )
   AND [SourceSystem] = 'FR'
   
-- Sum the amount of the negative single gift payment from GiftReport 
-- This will be used in DonationReport later
-- DonationReport will find all the GIFT type + it's corresponding Pledge payment (negative single gift) in the CollapsedNegGifts
;WITH CollapsedNegGifts AS (
    SELECT gr.OriginalTransaction, SUM(gr.Amount) AS Amount
      FROM GiftReport gr
           INNER JOIN (SELECT DISTINCT TransNum FROM #TransTemp) t ON gr.OriginalTransaction = t.TransNum
     WHERE gr.GiftType = 'Pledge Payment'
     GROUP BY gr.OriginalTransaction
),
TempPledgeData AS (
    SELECT v.ID, v.InvoiceReferenceNumber, v.Fund, v.Campaign, v.Appeal, 
           v.TransactionNumber   AS TransactionNumber, 
     v.TransactionDate     AS TransactionDate,
           v.DateReceived        AS DateReceived,
           v.SourceSystem        AS SourceSystem,
           v.SolicitorID         AS SolicitorID,
           v.FiscalMonth         AS FiscalMonth,
           v.FiscalYear          AS FiscalYear,
           v.MatchingTransaction AS MatchingTransaction,
           v.IsMatchingGift      AS IsMatchingGift,
           v.MemorialID          AS MemorialID,
           v.ListAs              AS ListAs,
           v.RequestNumber       AS RequestNumber,
           v.MemorialNameText    AS MemorialNameText, 
           v.PledgeAmount        AS PledgeAmount,  
		   v.AdjustmentsAmount   AS AdjustmentsAmount
      FROM vPledgeData v
     WHERE v.SourceSystem = 'FR' AND
           v.TransactionNumber IN (SELECT DISTINCT TransNum FROM #TransTemp WHERE Transnum > 0)
     UNION
    SELECT v.ID, v.InvoiceReferenceNumber, v.Fund, v.Campaign, v.Appeal, 
           v.TransactionNumber   AS TransactionNumber, 
           v.TransactionDate     AS TransactionDate,
           v.DateReceived        AS DateReceived,
           v.SourceSystem        AS SourceSystem,
           v.SolicitorID         AS SolicitorID,
           v.FiscalMonth         AS FiscalMonth,
           v.FiscalYear          AS FiscalYear,
           v.MatchingTransaction AS MatchingTransaction,
           v.IsMatchingGift      AS IsMatchingGift,
           v.MemorialID          AS MemorialID,
           v.ListAs              AS ListAs,
           v.RequestNumber       AS RequestNumber,
           v.MemorialNameText    AS MemorialNameText, 
           v.PledgeAmount        AS PledgeAmount,  
		   v.AdjustmentsAmount   AS AdjustmentsAmount
      FROM vPledgeData v
     WHERE v.SourceSystem = 'FR' AND
           v.ID IN (SELECT DISTINCT DonorId FROM #TransTemp)
),
NetPledgeInfo AS (
    SELECT v.ID, v.InvoiceReferenceNumber, v.Fund, v.Campaign, v.Appeal, 
	       MAX(v.TransactionNumber)   AS TransactionNumber,
           MAX(v.TransactionDate)     AS TransactionDate,
           MAX(v.DateReceived)        AS DateReceived,
           MAX(v.FiscalYear)          AS FiscalYear,
           MAX(v.FiscalMonth)         AS FiscalMonth,
           MAX(v.SolicitorID)         AS SolicitorID,
           MAX(v.SourceSystem)        AS SourceSystem,
           MAX(v.MatchingTransaction) AS MatchingTransaction,
           MAX(v.IsMatchingGift)      AS IsMatchingGift,
           MAX(v.MemorialID)          AS MemorialID,
           MAX(v.ListAs)              AS ListAs,
           MAX(v.RequestNumber)       AS RequestNumber,
           MAX(v.MemorialNameText)    AS MemorialNameText, 
           SUM(v.PledgeAmount)  +  SUM(v.AdjustmentsAmount) AS NetPledgeAmount
      FROM TempPledgeData v
     GROUP BY v.ID, v.InvoiceReferenceNumber, v.Fund, v.Campaign, v.Appeal
)          
-- Insert new rows into the DonationReport table for transactions being updated
INSERT INTO DonationReport( ID, 
                            OriginalTransaction, 
                            InvoiceRefNum, 
                            SourceSystem, 
                            TransactionDate, 
                            DateReceived, 
                            Amount, 
                            SolicitorID, 
                            CheckNumber, 
                            PaymentType, 
                            FiscalMonth, 
                            FiscalYear, 
                            GiftType, 
                            MatchingTransaction, 
                            IsMatchingGift, 
                            MemorialID, 
                            ListAs, 
                            RequestNumber, 
                            MemorialNameText
                          )
       --- Segment PLEDGE3  -- SINGLE PLEDGE OR INSTALLMENT (SOURCE SYSTEM = FR)
       --- AMOUNT IS NET PLEDGE AFTER CM/DM 
        SELECT npi.ID, npi.TransactionNumber, MAX(npi.InvoiceReferenceNumber), MAX(npi.SourceSystem), MAX(npi.TransactionDate), MAX(npi.DateReceived), 
               SUM(npi.NetPledgeAmount), MAX(npi.SolicitorID), '', '', MAX(npi.FiscalMonth), MAX(npi.FiscalYear), 'Pledge',
               MAX(npi.MatchingTransaction), MAX(npi.IsMatchingGift), MAX(npi.MemorialID), MAX(npi.ListAs), MAX(npi.RequestNumber), MAX(npi.MemorialNameText)
          FROM NetPledgeInfo npi
		 WHERE npi.TransactionNumber IN (SELECT DISTINCT TransNum FROM #TransTemp)
         GROUP BY ID, TransactionNumber
    UNION
       --- Segment FR1  -- SINGLE GIFT (SOURCE SYSTEM = FR)
       --- INCLUDES ANY NEGATIVE SINGLE GIFT PAYMENT. 
       SELECT MAX(g.ID),
             g.OriginalTransaction,
             MAX(g.InvoiceReferenceNumber),
             MAX(g.SourceSystem),
             MAX(g.TransactionDate),
             MAX(g.DateReceived),
             (SUM(g.Amount)+ ISNULL(MAX(cg.Amount),0)) AS Amount,
             MAX(g.SolicitorID),
             MAX(g.CheckNumber),
             MAX(g.PaymentType),
             MAX(g.FiscalMonth),
             MAX(g.FiscalYear),
             'Gift',
             MAX(g.MatchingTransaction),
             MAX(g.IsMatchingGift),
             MAX(g.MemorialID),
             MAX(g.ListAs),
             MAX(g.RequestNumber),
             MAX(g.MemorialNameText) 
      FROM [dbo].GiftReport g
             INNER JOIN (SELECT DISTINCT TransNum FROM #TransTemp) t ON g.OriginalTransaction = t.TransNum
             LEFT OUTER JOIN CollapsedNegGifts cg ON g.OriginalTransaction = cg.OriginalTransaction
      WHERE g.SourceSystem = 'FR' AND g.GiftType = 'GIFT'
      GROUP BY g.ID, g.OriginalTransaction

END


GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_UpdateFundraisingViewTables_MEET]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_UpdateFundraisingViewTables_MEET]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_UpdateFundraisingViewTables_MEET] 
    @TransRangeBegin int = NULL, @TransRangeEnd int = NULL
AS
BEGIN

-- If No TransRange parameters are passed in and there is no #TransTemp table, then this is a complete rebuild
IF (@TransRangeBegin IS NULL AND @TransRangeEnd IS NULL AND (SELECT COUNT(*) FROM #TransTemp) = 0)
BEGIN
    RETURN  -- Not yet implemented. This will need to truncate the three Report tables. Very dangerous!
END

-- PBI36911 Create a new temp table and add value from #TransTemp to this table.
-- The first attempt was to use local variable instead of the new temp table, but performance is still very slow
IF OBJECT_ID('TempDB..#MeetTemp') IS NOT NULL DROP TABLE #MeetTemp
CREATE TABLE #MeetTemp (InvoiceNum int NOT NULL PRIMARY KEY)
INSERT #MeetTemp (InvoiceNum) (SELECT MAX(InvoiceNum) FROM #TransTemp 
                                WHERE InvoiceNum IS NOT NULL AND InvoiceNum != 0 HAVING MAX(InvoiceNum) IS NOT NULL)

-- BEGIN GiftReport
-- Delete any existing rows from the [dbo].[GiftReport] table for transactions being updated
DELETE gr
  FROM [dbo].[GiftReport] gr
       INNER JOIN #TransTemp t ON gr.[TransactionNumber] = t.[TransNum]
                              AND gr.[InvoiceReferenceNumber] = t.[InvoiceNum]
 WHERE gr.[SourceSystem] = 'MEETING';
 
DELETE gr
  FROM [dbo].[GiftReport] gr
       INNER JOIN #TransTemp t ON gr.[InvoiceReferenceNumber] = t.[InvoiceNum]
 WHERE gr.[SourceSystem] = 'MEETING';

-- Insert new rows into the [dbo].[GiftReport] table for transactions being updated
INSERT INTO [dbo].[GiftReport] ( ID, 
                                 OriginalTransaction, 
                                 TransactionNumber, 
                                 SourceSystem, 
                                 TransactionDate, 
                                 DateReceived, 
                                 Amount, 
                                 FairMktValue, 
                                 Fund, 
                                 AppealCode, 
                                 SolicitorID, 
                                 CheckNumber, 
                                 PaymentType, 
                                 CampaignCode, 
                                 FiscalYear, 
                                 FiscalMonth, 
                                 GiftType, 
                                 InvoiceReferenceNumber, 
                                 ReceiptID, 
                                 MatchingTransaction, 
                                 IsMatchingGift, 
                                 MemorialID, 
                                 PledgeID, 
                                 ListAs, 
                                 RequestNumber, 
                                 InstallmentDate, 
                                 MemorialNameText
                               )
     -------------- Segment MEET1 -- GIFT FROM EVENT REGISTRATION (SOURCE SYSTEM = MEETING)
     SELECT a.ID,
            ISNULL(MAX(i.ORIGINATING_TRANS_NUM),MIN(c.TRANS_NUMBER)),
            0,
            MAX(a.SOURCE_SYSTEM),
            MAX(a.TRANSACTION_DATE),
            MAX(COALESCE(a.EFFECTIVE_DATE,a.TRANSACTION_DATE)),
            SUM(a.AMOUNT),
            SUM(c.TAXABLE_VALUE),
            MAX(a.ORG_CODE),
            MAX(a.SOURCE_CODE),
            '',
            '',
            '',
            MAX(a.CAMPAIGN_CODE),
            CONVERT(int,SUBSTRING(CONVERT(char(6),MAX(c.FISCAL_PERIOD)),1,4)),
            CONVERT(int,SUBSTRING(CONVERT(char(6),MAX(c.FISCAL_PERIOD)),5,2)),
            'GIFT',
            MAX(c.INVOICE_REFERENCE_NUM),
            0,
            0,
            0,
            '',
            '',
            '',
            0,
            NULL,
            ''
       FROM [dbo].[Activity] a
            INNER JOIN [dbo].[Trans] c on a.ORIGINATING_TRANS_NUM = c.TRANS_NUMBER
            INNER JOIN #MeetTemp t on c.INVOICE_REFERENCE_NUM = t.InvoiceNum
            LEFT OUTER JOIN [dbo].[Invoice] i on i.REFERENCE_NUM = c.INVOICE_REFERENCE_NUM
      WHERE a.ACTIVITY_TYPE = 'GIFT' 
        AND c.TRANSACTION_TYPE = 'DIST' 
        AND (c.PRODUCT_CODE = a.PRODUCT_CODE OR c.PRODUCT_CODE LIKE a.PRODUCT_CODE +'/%') 
        AND a.SOURCE_SYSTEM = 'MEETING'
        --AND c.INVOICE_REFERENCE_NUM IN (SELECT MIN(t.InvoiceNum) FROM #TransTemp t)
     GROUP BY a.ID, c.INVOICE_REFERENCE_NUM, a.ORG_CODE, a.CAMPAIGN_CODE, a.SOURCE_CODE

-- BEGIN DonationReport 
-- Delete any existing rows from the DonationReport table for transactions being updated
DELETE FROM [dbo].[DonationReport]
 WHERE [OriginalTransaction] IN (SELECT t.TransNum FROM #TransTemp t )
   AND SourceSystem = 'MEETING';
   
DELETE FROM [dbo].[DonationReport]
 WHERE [InvoiceRefNum] IN (SELECT MAX(t.InvoiceNum) FROM #TransTemp t)
        AND SourceSystem = 'MEETING';
        
-- Insert new rows into the DonationReport table for transactions being updated
INSERT INTO DonationReport( ID, 
                            OriginalTransaction, 
                            InvoiceRefNum, 
                            SourceSystem, 
                            TransactionDate, 
                            DateReceived, 
                            Amount, 
                            SolicitorID, 
                            CheckNumber, 
                            PaymentType, 
                            FiscalMonth, 
                            FiscalYear, 
                            GiftType, 
                            MatchingTransaction, 
                            IsMatchingGift, 
                            MemorialID, 
                            ListAs, 
                            RequestNumber, 
                            MemorialNameText
                          )
       --- Segment MEET1 -- GIFT FROM EVENT REGISTRATION (SOURCE SYSTEM = MEETING)
             SELECT MAX(g.ID),
             MAX(g.OriginalTransaction),
             MAX(g.InvoiceReferenceNumber),
             MAX(g.SourceSystem),
             MAX(g.TransactionDate),
             MAX(g.DateReceived),
             SUM(g.Amount),
             '',
             '',
             '',
             MAX(g.FiscalMonth),
             MAX(g.FiscalYear),
             'Gift',
             0,
             0,
             '',
             '',
             0,
             ''
        FROM [dbo].GiftReport g
        INNER JOIN #MeetTemp t on g.InvoiceReferenceNumber = t.InvoiceNum
        WHERE g.SourceSystem = 'MEETING'
        GROUP BY g.ID, g.InvoiceReferenceNumber

DROP TABLE #MeetTemp 

END


GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_MergeRebuildGiftHistory]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_MergeRebuildGiftHistory]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


-- This script rebuilds the gift history after a merge,
-- preventing a bug where gift amounts can be doubled after a merge
CREATE PROCEDURE [dbo].[asi_MergeRebuildGiftHistory]
@toDonorId varchar(10)
AS
BEGIN
    -- Clean up Temp Tables if they're still lying around
    IF OBJECT_ID('tempdb..#FRTransNums') IS NOT NULL
        DROP TABLE #FRTransNums; 
    IF OBJECT_ID('tempdb..#FRTransNums') IS NOT NULL
        DROP TABLE #FRTransNums; 

    -- Create a table containing one row for all Transactions that include at least one line with IS_FR_ITEM = True
    CREATE TABLE #FRTransNums(TransId int NOT NULL,
                              InvRefNum int,
                              DonorId varchar(10) COLLATE DATABASE_DEFAULT ,
                              SourceSystem varchar(10)COLLATE DATABASE_DEFAULT,
                              ActivitySeqn int);

    INSERT INTO #FRTransNums (TransId,
                              InvRefNum,
                              DonorId,
                              SourceSystem,
                              ActivitySeqn)
    SELECT DISTINCT(TRANS_NUMBER),
                   INVOICE_REFERENCE_NUM,
                   MAX(ST_ID),
                   MAX(SOURCE_SYSTEM),
                   ACTIVITY_SEQN
      FROM Trans
     WHERE ST_ID = @toDonorId AND IS_FR_ITEM = 1 AND NOT (TRANSACTION_TYPE = 'AR' AND JOURNAL_TYPE IN ('CM', 'DM', 'IN'))
     GROUP BY TRANS_NUMBER,
              INVOICE_REFERENCE_NUM,
              ACTIVITY_SEQN;

    SET NOCOUNT ON;
    SET ANSI_WARNINGS OFF;

    -- Clean up TransTemp if it's still lying around
    IF OBJECT_ID('tempdb..#TransTemp') IS NOT NULL
        DROP TABLE #TransTemp; 

    -- Create a Temp Table with all values to be passed to the StoredProcedures
    CREATE TABLE #TransTemp(TransNum int, 
                           InvoiceNum int, 
                           DonorId varchar(10) COLLATE DATABASE_DEFAULT NULL, 
                           SourceSystem varchar(10) COLLATE DATABASE_DEFAULT NULL, 
                           TransSourceSystem varchar(10) COLLATE DATABASE_DEFAULT NULL);

    ---- Populate Temp Table with the values to be passed to the Stored Procedures
    INSERT INTO #TransTemp (TransNum,
                            InvoiceNum,
                            DonorId,
                            SourceSystem,
                            TransSourceSystem)
    SELECT  a.TRANS_NUMBER,
            a.INVOICE_REFERENCE_NUM,
            a.ST_ID,
            a.SourceSystem,
            a.TransSourceSystem
      FROM(SELECT i.TransId AS TRANS_NUMBER,
                  i.InvRefNum AS INVOICE_REFERENCE_NUM,
                  i.DonorId AS ST_ID,
                  COALESCE(a.SOURCE_SYSTEM, inv.SOURCE_SYSTEM)AS SourceSystem,
                  i.SourceSystem AS TransSourceSystem
             FROM #FRTransNums AS i
                  LEFT OUTER JOIN Activity AS a ON i.ActivitySeqn = a.SEQN
                  LEFT OUTER JOIN Invoice AS inv ON i.InvRefNum = inv.REFERENCE_NUM
                  LEFT OUTER JOIN Activity AS ai ON inv.ORIGINATING_TRANS_NUM = ai.ORIGINATING_TRANS_NUM
           UNION ALL
           SELECT inv.ORIGINATING_TRANS_NUM,
                  i.InvRefNum,
                  inv.ST_ID,
                  inv.SOURCE_SYSTEM,
                  i.SourceSystem AS TransSourceSystem
             FROM #FRTransNums AS i
                  INNER JOIN [dbo].[Invoice] AS inv ON i.InvRefNum = inv.REFERENCE_NUM
                  LEFT OUTER JOIN Activity AS ai ON inv.ORIGINATING_TRANS_NUM = ai.ORIGINATING_TRANS_NUM)AS a
     GROUP BY a.TRANS_NUMBER,
              a.INVOICE_REFERENCE_NUM,
              a.ST_ID,
              a.SourceSystem,
              a.TransSourceSystem;

    -- If there are any rows in the temp table, then delete all gift history and rerun the logic
    IF (SELECT COUNT(1)
          FROM #TransTemp) <> 0
        BEGIN

            DELETE GiftReport
             WHERE ID = @toDonorId;
            DELETE DonationReport
             WHERE ID = @toDonorId;
            DELETE PledgeReport
             WHERE ID = @toDonorId;
            DELETE GiftHistorySummary
             WHERE DonorId = @toDonorId;

            IF EXISTS (SELECT 1
                         FROM #TransTemp
                        WHERE SourceSystem = 'FR' OR ((SourceSystem IS NULL OR SourceSystem = '') AND TransSourceSystem = 'FR'))
                BEGIN
                    EXEC dbo.asi_UpdateFundraisingViewTables_FR;
                END;
            IF EXISTS (SELECT 1
                         FROM #TransTemp
                        WHERE SourceSystem IN ('DUES', 'SC') OR ((SourceSystem IS NULL OR SourceSystem = '') AND TransSourceSystem IN ('DUES', 'SC')))
                BEGIN
                    EXEC dbo.asi_UpdateFundraisingViewTables_DUES;
                END;
            IF EXISTS (SELECT 1
                         FROM #TransTemp
                        WHERE SourceSystem = 'MEETING')
                BEGIN
                    EXEC dbo.asi_UpdateFundraisingViewTables_MEET;
                END;

            EXEC dbo.asi_RecalculateGiftHistorySummary @toDonorId;
        END;

    SET NOCOUNT OFF;
    SET ANSI_WARNINGS ON;

    IF OBJECT_ID('tempdb..#TransTemp') IS NOT NULL
        DROP TABLE #TransTemp; 
    IF OBJECT_ID('tempdb..#FRTransNums') IS NOT NULL
        DROP TABLE #FRTransNums; 
    IF OBJECT_ID('tempdb..#FRTransNums') IS NOT NULL
        DROP TABLE #FRTransNums; 

END;





GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_MergeSingleInstanceUserDefinedData]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_MergeSingleInstanceUserDefinedData]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_MergeSingleInstanceUserDefinedData] 
    @fromContactId varchar(10), 
    @toContactId varchar(10)
AS
BEGIN
    SET NOCOUNT ON;
    -- First move across single instance missing business object entries
    UPDATE fromParty
       SET fromParty.[RowID] = @toContactId
      FROM [dbo].[UserDefinedSingleInstanceProperty] fromParty
     WHERE fromParty.[RowID] = @fromContactId
       AND NOT EXISTS (SELECT 1 FROM [dbo].[UserDefinedSingleInstanceProperty] 
                        WHERE [RowID] = @toContactId 
                          AND [TableName] = fromParty.[TableName])

    -- Now move across single instance properties that exist in fromParty but not in toParty
    UPDATE toParty
       SET [PropertyIntValue] = COALESCE(toParty.[PropertyIntValue], fromParty.[PropertyIntValue]),
           [PropertyDateTimeValue] = COALESCE(toParty.[PropertyDateTimeValue], fromParty.[PropertyDateTimeValue]),
           [PropertyGuidValue] = COALESCE(toParty.[PropertyGuidValue], fromParty.[PropertyGuidValue]),
           [PropertyDecimalValue] = COALESCE(toParty.[PropertyDecimalValue], fromParty.[PropertyDecimalValue]),
           [PropertyBooleanValue] = COALESCE(toParty.[PropertyBooleanValue], fromParty.[PropertyBooleanValue]),
           [PropertyStringValue] = COALESCE(toParty.[PropertyStringValue], fromParty.[PropertyStringValue])
      FROM [dbo].[UserDefinedSingleInstanceProperty] fromParty 
           LEFT JOIN [dbo].[UserDefinedSingleInstanceProperty] toParty ON toParty.[TableName] = fromParty.[TableName] 
                                                                      AND toParty.[PropertyName] = fromParty.[PropertyName]
     WHERE fromParty.[RowID] = @fromContactId
       AND toParty.[RowID] = @toContactId

    -- Finally remove any remaining fromParty records
    DELETE FROM  [dbo].[UserDefinedSingleInstanceProperty]
         WHERE [RowID] = @fromContactId
END


GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_MergeUserLogin]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_MergeUserLogin]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO





----------------------------------------------------------------------------------------------
-- Stored procedure to transfer all references to @fromUserKey to @toUserkey and then
-- delete the @fromUserKey, effectively merging @fromUserKey into @toUserKey.
----------------------------------------------------------------------------------------------
CREATE PROCEDURE [dbo].[asi_MergeUserLogin](@fromUserId varchar(10),
                                    @toUserId varchar(10))
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @purgeASPNetTables bit;
    DECLARE @fromUserKey uniqueidentifier;
    DECLARE @toUserKey uniqueidentifier;

    SET @fromUserKey = (SELECT [ContactKey]
                          FROM [dbo].[ContactMain]
                         WHERE [SyncContactID] = @fromUserId);
    SET @toUserKey = (SELECT [ContactKey]
                        FROM [dbo].[ContactMain]
                       WHERE [SyncContactID] = @toUserId);
    SET @purgeASPNetTables = 1;

    -- Bail if parameters are dangerous or make no sense... should probably raise an exception
    IF EXISTS (SELECT 1
                 FROM [dbo].[UserMain]
                WHERE [UserKey] = @fromUserKey AND [UserId] IN ('ADMINISTRATOR', 'GUEST', 'MANAGER', 'SYSTEM'))
        BEGIN 
            RAISERROR('Attempted to merge an administrator, guest, manager, or system user', 16, 1)
            RETURN
        END;
    IF EXISTS (SELECT 1
                 FROM [dbo].[UserMain]um
                      INNER JOIN [dbo].[Users] u ON um.UserId = u.UserId
                WHERE [UserKey] = @fromUserKey
                   OR [UserKey] = @toUserKey)
        BEGIN 
            RAISERROR('Merging a Staff user is not currently supported', 16, 1)
            RETURN
        END;

    IF NOT EXISTS (SELECT 1
                     FROM [dbo].[UserMain]
                    WHERE [UserKey] = @toUserKey)
        BEGIN
            -- We don't have a user for the To Party. Create a new one that's exactly the same
            -- as the From User except its user key points to the To Party.
            INSERT INTO [dbo].[UserMain]
            SELECT @toUserKey,
                   @toUserId,
                   um.UserId,
                   um.IsDisabled,
                   um.EffectiveDate,
                   um.ExpirationDate,
                   um.UpdatedByUserKey,
                   um.UpdatedOn,
                   um.CreatedByUserKey,
                   um.CreatedOn,
                   um.MarkedForDeleteOn,
                   um.DefaultDepartmentGroupKey,
                   um.DefaultPerspectiveKey,
                   um.ProviderKey
              FROM [dbo].[UserMain] AS um
             WHERE um.[UserKey] = @fromUserKey;

            INSERT INTO [dbo].[UserRole]
            SELECT @toUserKey,
                   ur.RoleKey,
                   ur.MarkedForDeleteOn
              FROM [dbo].[UserRole] ur
             WHERE [UserKey] = @fromUserKey;

            -- Don't purge ASP NET Tables because they will now point to the new To User
            SET @purgeASPNetTables = 0;
        END;

    -- Update all references to @fromUserKey to be @toUserKey
    DECLARE @sql nvarchar(max);
    DECLARE @cr nchar(2);
    SET @cr = NCHAR(13);
    SET @sql = N'';
    WITH UserKeyColumns
        AS (
        SELECT cu.TABLE_SCHEMA AS [Schema],
               cu.TABLE_NAME AS [TableName],
               cu.COLUMN_NAME AS [ColumnName]
          FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS AS fk
               INNER JOIN INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE AS cu ON fk.CONSTRAINT_NAME = cu.CONSTRAINT_NAME
         WHERE fk.CONSTRAINT_SCHEMA = N'dbo' AND fk.UNIQUE_CONSTRAINT_NAME = N'PK_UserMain' AND cu.TABLE_NAME NOT IN (N'UserRole', 'UserToken')
        )
        SELECT @sql += N'UPDATE ' + QUOTENAME([Schema]) + N'.' + QUOTENAME([TableName]) + N' SET ' + QUOTENAME([ColumnName]) + N' = ''' + CAST(@toUserKey AS nvarchar(40)) + N'''' + N' WHERE ' + QUOTENAME([ColumnName]) + N' = ''' + CAST(@fromUserKey AS nvarchar(40)) + ''';' + @cr
          FROM UserKeyColumns
         ORDER BY [Schema], [TableName], [ColumnName];
    EXEC (@sql);

    -- handle the non-fk columns for updated-by and such
    SET @sql = N'';
    WITH UserByColumns
      AS (
          SELECT c.[TABLE_NAME] AS [TableName],
                 c.[COLUMN_NAME] AS [ColumnName],
                 t.TABLE_SCHEMA AS [Schema]
            FROM INFORMATION_SCHEMA.COLUMNS c
                 INNER JOIN INFORMATION_SCHEMA.TABLES t ON c.TABLE_NAME = t.TABLE_NAME
           WHERE c.[COLUMN_NAME] IN ('CREATED_BY', 'UPDATED_BY', 'ENTERED_BY', 'MODIFIED_BY')
                 AND c.[DATA_TYPE] = 'varchar'
                 AND c.[CHARACTER_MAXIMUM_LENGTH] > 40
                 AND t.TABLE_TYPE = 'BASE TABLE'
      )
      SELECT @sql += N'UPDATE ' + QUOTENAME([Schema]) + N'.' + QUOTENAME([TableName]) + N' SET ' + QUOTENAME([ColumnName]) + N' = ''' + CAST(@toUserKey AS nvarchar(40)) + N'''' + N' WHERE ' + QUOTENAME([ColumnName]) + N' = ''' + CAST(@fromUserKey AS nvarchar(40)) + ''';' + @cr
        FROM UserByColumns
    ORDER BY [Schema], [TableName], [ColumnName];
    EXEC (@sql);

    -- Merge UserRoles
    INSERT INTO [dbo].[UserRole] (UserKey, RoleKey)
    SELECT r.[UserKey],
           r.[RoleKey]
      FROM [dbo].[UserRole] AS r
     WHERE r.[UserKey] = @fromUserKey 
           AND NOT EXISTS (SELECT 1
                             FROM [dbo].[UserRole]
                            WHERE [UserKey] = @toUserKey 
                                  AND [RoleKey] = r.[RoleKey]) 
           AND NOT EXISTS (SELECT 1
                             FROM [dbo].[UserRole]
                            WHERE [UserKey] = @fromUserKey 
                                  AND [RoleKey] = r.[RoleKey]);
    DELETE FROM [dbo].[UserRole]
     WHERE [UserKey] = @fromUserKey;

    -- Purge UserToken table
    DELETE FROM [dbo].[UserToken]
    WHERE [UserKey] IN (@fromUserKey, @toUserKey);

    -- Purge aspnet tables
    IF(@purgeASPNetTables = 1)
        BEGIN
            DECLARE @applicationKey uniqueidentifier;
            DECLARE @providerKey nvarchar(100);
            SELECT @providerKey = [ProviderKey]
              FROM [dbo].[UserMain]
             WHERE [UserKey] = @fromUserKey;
            SELECT @applicationKey = [ApplicationId]
              FROM [aspnet_Applications]
             WHERE [LoweredApplicationName] = 'imis';
            DELETE a
              FROM aspnet_Profile a
             WHERE a.[UserId] = @providerKey;
            DELETE a
              FROM aspnet_Membership a
             WHERE a.[ApplicationId] = @applicationKey AND a.[UserId] = @providerKey;
            DELETE a
              FROM aspnet_Users a
             WHERE a.[ApplicationId] = @applicationKey AND a.[UserId] = @providerKey;
        END;

    --Update Name_Security for the to-party in case it was blank before
    UPDATE [dbo].[Name_Security]
       SET [WEB_LOGIN] = COALESCE((SELECT [UserId] FROM  [dbo].[UserMain] WHERE [UserKey] =  @toUserKey),[WEB_LOGIN])
    WHERE [ID] = @toUserId

    -- Ensure that the delete trigger for Name_Security will never wipe out our new id when it is called/deleted from MergePartyReferences
    UPDATE [dbo].[Name_Security]
       SET [WEB_LOGIN] = ''
      WHERE [ID] = @fromUserId

    --Get rid of the old record
    DELETE [dbo].[Name_Security]
    WHERE [ID] = @fromUserId

    -- Purge the @fromUserKey
    DELETE FROM [dbo].[UserMain]
     WHERE [UserKey] = @fromUserKey;
END;







GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_MergeV2UserDefinedData]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_MergeV2UserDefinedData]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_MergeV2UserDefinedData]
    @fromContactId varchar(10),
    @toContactId varchar(10)
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE @fieldCount int;
    DECLARE @allFields nvarchar(max);
    DECLARE @i int;
    DECLARE @sql nvarchar(max);
    DECLARE @crlf nvarchar(2);
    
    SET @fieldCount = 500;
    SET @crlf = NCHAR(13) + NCHAR(10);

    -- First move across single instance missing business object entries
    UPDATE fromParty
       SET fromParty.[RowID] = @toContactId
      FROM [dbo].[UserDefinedTableStorage] fromParty
           INNER JOIN ObjectMetaData o ON o.ObjectName = fromParty.TableName
     WHERE fromParty.[RowID] = @fromContactId 
          AND COALESCE(o.[Version], N'V1') = N'V2' 
          AND o.IsMultiInstance = 0 
          AND NOT EXISTS (SELECT 1
                          FROM [dbo].[UserDefinedTableStorage]
                         WHERE [RowID] = @toContactId AND [TableName] = fromParty.[TableName]);

    -- Now move across single instance properties that exist in fromParty but not in toParty
    DECLARE @setClause nvarchar(max);
    SET @i = 0;
    SET @setClause = N'   SET ';
    DECLARE @first bit;
    DECLARE @fieldName nvarchar(10);
    WHILE @i < @fieldCount
    BEGIN
        IF @i != 0
        BEGIN 
            SET @setClause = @setClause + N', ';
        END;
        SET @i = @i + 1;
        SET @fieldName = N'[Value' + CAST(@i AS nvarchar(3)) + ']';
        SET @setClause = @setClause + @fieldName + N'=COALESCE(toParty.' + @fieldName + N', fromParty.' + @fieldName + N')';
    END;
    SET @sql = N'UPDATE toParty' + @crlf;
    SET @sql = @sql + @setClause + @crlf;
    SET @sql = @sql + N'  FROM [dbo].[UserDefinedTableStorage] fromParty' + @crlf;
    SET @sql = @sql + N'         INNER JOIN ObjectMetaData o ON o.ObjectName = fromParty.TableName' + @crlf;
    SET @sql = @sql + N'         LEFT JOIN [dbo].[UserDefinedTableStorage] toParty ON toParty.[TableName] = fromParty.[TableName]' + @crlf;
    SET @sql = @sql + N' WHERE fromParty.[RowID] = ''' + @fromContactId + N'''' + @crlf;
    SET @sql = @sql + N'   AND toParty.[RowID] = ''' + @toContactId + N'''' + @crlf;
    SET @sql = @sql + N'     AND COALESCE(o.[Version],''V1'') = ''V2'' AND o.IsMultiInstance = 0' + @crlf;
    EXECUTE sp_executesql @sql;

    -- Finally remove any remaining fromParty records
    DELETE s
      FROM  [dbo].[UserDefinedTableStorage] s
            INNER JOIN ObjectMetaData o ON o.ObjectName = s.TableName
     WHERE [RowID] = @fromContactId 
          AND COALESCE(o.[Version], N'V1') = N'V2' 
          AND o.IsMultiInstance = 0;

    -- First move across multi-instance records the toParty doesn't have
    UPDATE fromParty
    SET fromParty.[RowID] = @toContactId
      FROM [dbo].[UserDefinedTableStorage] fromParty
           INNER JOIN ObjectMetaData o ON o.ObjectName = fromParty.TableName
     WHERE fromParty.[RowID] = @fromContactId 
          AND NOT EXISTS (SELECT 1
                         FROM [dbo].[UserDefinedTableStorage]
                        WHERE [RowID] = @toContactId AND [TableName] = fromParty.[TableName] AND [RowKey] = fromParty.[RowKey]) AND COALESCE(o.[Version], 'V1') = 'V2' AND o.IsMultiInstance = 1;

    -- Next, merge in common rows mindful of keeping the sequence numbers unique
       SET @i = 0;
    SET @allFields = '';
    WHILE @i < @fieldCount
        BEGIN
            IF @i != 0
                BEGIN SET @allFields = @allFields + ', '
                END;
            SET @i = @i + 1;
            SET @allFields = @allFields + N'[Value' + CAST(@i AS nvarchar(3)) + N']';
        END;
    SET @sql = N'INSERT INTO dbo.[UserDefinedTableStorage] (TableName, RowID, RowKey, RowSequence, CreatedOn, UpdatedOn, ' + @allFields + ')' + @crlf;
    SET @sql = @sql + N'   SELECT udm.TableName, ''' + @toContactId + ''', udm.RowKey,' + @crlf;
    SET @sql = @sql + N'             (SELECT COALESCE(MAX(RowSequence),0) FROM dbo.UserDefinedTableStorage udm2' + @crlf;
    SET @sql = @sql + N'                 WHERE udm2.TableName = udm.TableName AND udm2.RowID = ''' + @toContactId + '''' + @crlf;
    SET @sql = @sql + N'                 ) + ROW_NUMBER() OVER (PARTITION BY RowID, TableName ORDER BY RowSequence),' + @crlf;
    SET @sql = @sql + N'                 CreatedOn, UpdatedOn, ' + @allFields + @crlf;
    SET @sql = @sql + N'     FROM dbo.[UserDefinedTableStorage] udm' + @crlf;
    SET @sql = @sql + N'          INNER JOIN ObjectMetaData o ON o.ObjectName = udm.TableName' + @crlf;
    SET @sql = @sql + N'   WHERE RowID = ''' + @fromContactId + '''' + @crlf;
    SET @sql = @sql + N'      AND COALESCE(o.[Version],''V1'') = ''V2'' AND o.IsMultiInstance = 1' + @crlf;
    SET @sql = @sql + N'   ORDER BY udm.TableName, udm.RowSequence' + @crlf;
    EXECUTE sp_executesql @sql;

    -- Now remove any remaining fromParty records
    DELETE  s
      FROM [dbo].[UserDefinedTableStorage] s
           INNER JOIN ObjectMetaData o ON o.ObjectName = s.TableName
     WHERE [RowID] = @fromContactId 
          AND COALESCE(o.[Version], N'V1') = N'V2' 
          AND o.IsMultiInstance = 1;

END;

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_UpdateSingleFullName]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_UpdateSingleFullName]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_UpdateSingleFullName]
                @ID varchar(10)
AS 
    BEGIN

        DECLARE @prefixes varchar(1000)
        SELECT @prefixes = ShortValue from System_Params where ParameterName = 'Member_Control.IncludePrefixString'

        SET NOCOUNT ON 

        UPDATE [dbo].[Name]
           SET FULL_NAME = ISNULL(LTRIM(
                                       ISNULL( CASE WHEN CHARINDEX(',' + PREFIX + ',' ,',' + ISNULL(@prefixes,'') + ',') > 0 
                                                    THEN ISNULL(SUBSTRING(SUBSTRING(@prefixes, 
                                                         CHARINDEX(',' + PREFIX + ',' ,',' + @prefixes + ','), 
                                                         DATALENGTH(PREFIX)),1,
                                                         DATALENGTH(SUBSTRING(@prefixes,CHARINDEX(','+PREFIX+',' , ',' + (@prefixes)+','),
                                                         DATALENGTH(PREFIX)))
                                                         * ABS(SIGN(SIGN(DATALENGTH(SUBSTRING(@prefixes,
                                                         CHARINDEX(','+PREFIX+',' , ',' + @prefixes+','),
                                                         DATALENGTH(PREFIX)))-1) + 
                                                         SIGN(ASCII(SUBSTRING(@prefixes,
                                                         CHARINDEX(','+PREFIX+',' , ',' + @prefixes+','),
                                                         DATALENGTH(PREFIX)))-32)))) +
                                                         SUBSTRING(' ', 1, ABS(SIGN(SIGN(DATALENGTH(SUBSTRING(@prefixes, CHARINDEX(','+PREFIX+',' , ',' + @prefixes + ','),
                                                         DATALENGTH(PREFIX)))-1) + SIGN(ASCII(SUBSTRING(@prefixes, CHARINDEX(',' + PREFIX + ',' , ',' + @prefixes + ','), DATALENGTH(PREFIX)))-32)))),'') 
                                                     END ,'')
                                        +
                                         SUBSTRING(FIRST_NAME, 1 ,DATALENGTH(FIRST_NAME) * ABS(SIGN(SIGN(DATALENGTH(FIRST_NAME)-1) + COALESCE(SIGN(ASCII(FIRST_NAME)-32), 0))))
                                        + SUBSTRING(' ', 1, ABS(SIGN(SIGN(DATALENGTH(FIRST_NAME)-1) + COALESCE(SIGN(ASCII(FIRST_NAME)-32), 0)))) 
                                        + SUBSTRING(MIDDLE_NAME, 1, DATALENGTH(MIDDLE_NAME) * ABS(SIGN(SIGN(DATALENGTH(MIDDLE_NAME)-1) + COALESCE(SIGN(ASCII(MIDDLE_NAME)-32), 0)))) 
                                        + SUBSTRING(' ', 1, ABS(SIGN(SIGN(DATALENGTH(MIDDLE_NAME)-1) + COALESCE(SIGN(ASCII(MIDDLE_NAME)-32), 0)))) 
                                        + SUBSTRING(LAST_NAME, 1, DATALENGTH(LAST_NAME) * ABS(SIGN(SIGN(DATALENGTH(LAST_NAME)-1) + COALESCE(SIGN(ASCII(LAST_NAME)-32), 0)))) 
                                        + SUBSTRING(', ', 1, 2 * ABS(SIGN(SIGN(DATALENGTH(LTRIM(RTRIM(SUFFIX))))))) 
                                        + SUBSTRING(SUFFIX, 1, DATALENGTH(SUFFIX) * ABS(SIGN(SIGN(DATALENGTH(LTRIM(RTRIM(SUFFIX))))))) 
                                        + SUBSTRING(', ', 1 ,2 * ABS(SIGN(SIGN(DATALENGTH(LTRIM(RTRIM(DESIGNATION))))))) 
                                        + SUBSTRING(DESIGNATION, 1, DATALENGTH(DESIGNATION) * ABS(SIGN(SIGN(DATALENGTH(DESIGNATION)-1) + COALESCE(SIGN(ASCII(DESIGNATION)-32), 0))))
                                        ),'')
                WHERE ID = @ID  
                AND   FULL_NAME <> ISNULL(LTRIM(
                                       ISNULL( CASE WHEN CHARINDEX(',' + PREFIX + ',' ,',' + ISNULL(@prefixes,'') + ',') > 0 
                                             THEN ISNULL(SUBSTRING(SUBSTRING(@prefixes, 
                                                  CHARINDEX(',' + PREFIX + ',' ,',' + @prefixes + ','), 
                                                  DATALENGTH(PREFIX)),
                                                  1,
                                                  DATALENGTH(SUBSTRING(@prefixes,
                                                  CHARINDEX(','+PREFIX+',' , ',' + (@prefixes)+','),
                                                  DATALENGTH(PREFIX)))
                                                  * ABS(SIGN(SIGN(DATALENGTH(SUBSTRING(@prefixes,
                                                  CHARINDEX(','+PREFIX+',' , ',' + @prefixes+','),
                                                  DATALENGTH(PREFIX)))-1) + 
                                                  SIGN(ASCII(SUBSTRING(@prefixes,
                                                  CHARINDEX(','+PREFIX+',' , ',' + @prefixes+','),
                                                  DATALENGTH(PREFIX)))-32)))) +
                                                  SUBSTRING(' ', 1, ABS(SIGN(SIGN(DATALENGTH(SUBSTRING(@prefixes, CHARINDEX(','+PREFIX+',' , ',' + @prefixes + ','),
                                                  DATALENGTH(PREFIX)))-1) + SIGN(ASCII(SUBSTRING(@prefixes, CHARINDEX(',' + PREFIX + ',' , ',' + @prefixes + ','), DATALENGTH(PREFIX)))-32)))),'') 
                                             END ,'')
                                        +
                                         SUBSTRING(FIRST_NAME, 1 ,DATALENGTH(FIRST_NAME) * ABS(SIGN(SIGN(DATALENGTH(FIRST_NAME)-1) + COALESCE(SIGN(ASCII(FIRST_NAME)-32), 0))))
                                        + SUBSTRING(' ', 1, ABS(SIGN(SIGN(DATALENGTH(FIRST_NAME)-1) + COALESCE(SIGN(ASCII(FIRST_NAME)-32), 0)))) 
                                        + SUBSTRING(MIDDLE_NAME, 1, DATALENGTH(MIDDLE_NAME) * ABS(SIGN(SIGN(DATALENGTH(MIDDLE_NAME)-1) + COALESCE(SIGN(ASCII(MIDDLE_NAME)-32), 0)))) 
                                        + SUBSTRING(' ', 1, ABS(SIGN(SIGN(DATALENGTH(MIDDLE_NAME)-1) + COALESCE(SIGN(ASCII(MIDDLE_NAME)-32), 0)))) 
                                        + SUBSTRING(LAST_NAME, 1, DATALENGTH(LAST_NAME) * ABS(SIGN(SIGN(DATALENGTH(LAST_NAME)-1) + COALESCE(SIGN(ASCII(LAST_NAME)-32), 0)))) 
                                        + SUBSTRING(', ', 1, 2 * ABS(SIGN(SIGN(DATALENGTH(LTRIM(RTRIM(SUFFIX))))))) 
                                        + SUBSTRING(SUFFIX, 1, DATALENGTH(SUFFIX) * ABS(SIGN(SIGN(DATALENGTH(LTRIM(RTRIM(SUFFIX))))))) 
                                        + SUBSTRING(', ', 1 ,2 * ABS(SIGN(SIGN(DATALENGTH(LTRIM(RTRIM(DESIGNATION))))))) 
                                        + SUBSTRING(DESIGNATION, 1, DATALENGTH(DESIGNATION) * ABS(SIGN(SIGN(DATALENGTH(DESIGNATION)-1) + COALESCE(SIGN(ASCII(DESIGNATION)-32), 0))))
                                        ),'')
    END



GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_MergePerson]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_MergePerson]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO









-- =============================================
-- This is the driver procedure for merging a person.
-- =============================================
CREATE PROCEDURE [dbo].[asi_MergePerson] 
    @fromContactId varchar(10), 
    @toContactId varchar(10),
    @userName varchar(60)
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @errorMessage nvarchar(max);
    DECLARE @stage nvarchar(100);
    SET @errorMessage = '';

    BEGIN TRY
        BEGIN TRANSACTION;
            --execute any customer custom operation
            SET @stage = 'asi_MergePartyReferencesCustom: ';
            EXEC dbo.asi_MergePartyReferencesCustom @fromContactId, @toContactId;
            --log merge
            SET @stage = 'asi_LogMerge'
            EXEC dbo.asi_LogMerge @fromContactId, @toContactId, @userName;
            SET @stage = 'asi_MergeFullAddressesDeleteDuplicatePurposes';
            EXEC dbo.asi_MergeFullAddressesDeleteDuplicatePurposes @fromContactId, @toContactId;
            --merge groups - must always be ahead of merge references
            SET @stage = 'asi_MergeFinancialGroups';
            EXEC dbo.asi_MergeFinancialGroups @fromContactId, @toContactId;            
            SET @stage = 'asi_MergeGroups';
            EXEC dbo.asi_MergeGroups @fromContactId, @toContactId;
            --merge user-defined objects
            SET @stage = 'asi_MergeSingleInstanceUserDefinedData';
            EXEC dbo.asi_MergeSingleInstanceUserDefinedData  @fromContactId, @toContactId;
            SET @stage = 'asi_MergeMultiInstanceUserDefinedData';
            EXEC dbo.asi_MergeMultiInstanceUserDefinedData  @fromContactId, @toContactId;
            SET @stage = 'asi_MergeCustomizerUDTables';
            EXEC dbo.asi_MergeCustomizerUDTables  @fromContactId, @toContactId;
            SET @stage = 'asi_MergeV2UserDefinedData';
            EXEC dbo.asi_MergeV2UserDefinedData  @fromContactId, @toContactId;
            --merge login records - must always be after merge groups
            SET @stage = 'asi_MergeUserLogin';
            EXEC dbo.asi_MergeUserLogin @fromContactId, @toContactId;
            SET @stage = 'asi_MergePartyReferences: ';
            EXEC dbo.asi_MergePartyReferences @fromContactId, @toContactId;
            SET @stage = 'asi_MergeRebuildGiftHistory: ';
            EXEC dbo.asi_MergeRebuildGiftHistory @toContactId;
            SET @stage = 'asi_UpdateSingleFullName';
            EXEC dbo.asi_UpdateSingleFullName @toContactId;
        COMMIT TRANSACTION;
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0 ROLLBACK;
        
        SET @errorMessage  += 'Message = ' + @stage + CONVERT(nvarchar(max), ERROR_MESSAGE());
        RAISERROR(@errorMessage, 16, 1);
    END CATCH
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_NewAccessArea]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_NewAccessArea]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_NewAccessArea    Script Date: 7/3/2003 4:58:04 PM ******/

CREATE PROCEDURE [dbo].[asi_NewAccessArea]
	@isSharedACLOnly bit,
	@sysEntityKey uniqueidentifier,
	@userKey uniqueidentifier,
	@name varchar(50),
	@description varchar(250),
	@accessAreaKey uniqueidentifier output,
	@accessKeyForArea uniqueidentifier output
AS

DECLARE @now datetime

SET @now = GETDATE()

IF (@accessKeyForArea is null)
BEGIN
    SELECT @accessKeyForArea = NEWID()
END

SELECT @accessAreaKey = NEWID()

-- The ACL that the access area represents (protects):
INSERT INTO AccessMain(AccessKey, AccessScope, CreatedByUserKey, CreatedOn, UpdatedByUserKey, UpdatedOn)
	SELECT @accessKeyForArea, 'Area', @userKey, @now, @userKey, @now

-- The access area:
INSERT INTO AccessArea (AccessAreaKey, [Name], Description, IsSystem, ProtectedAccessKey, 
						UpdatedByUserKey, UpdatedOn, IsSharedACLOnly, CreatedByUserKey, CreatedOn)
	SELECT @accessAreaKey, @name, @description, 1, @accessKeyForArea, 
		   @userKey, @now, @isSharedACLOnly, @userKey, @now

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_NewGenTablesRecord]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_NewGenTablesRecord]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_NewGenTablesRecord    Script Date: 7/3/2003 4:58:04 PM ******/

CREATE PROCEDURE dbo.asi_NewGenTablesRecord
@Code nvarchar(60),
@TableName nvarchar(30),
@Sub nvarchar(255),
@Desc nvarchar(255)
AS
BEGIN
insert into Gen_Tables  
(TABLE_NAME, CODE, SUBSTITUTE, UPPER_CODE, DESCRIPTION)
values (@TableName, @Code, @Sub, Upper(@Code), @Desc)
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_NewQueryResultItem]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_NewQueryResultItem]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_NewQueryResultItem    Script Date: 7/3/2003 4:58:04 PM ******/

CREATE PROCEDURE dbo.asi_NewQueryResultItem
@jobKey uniqueidentifier,
@anyKey nvarchar(50)
AS
BEGIN
insert into QueryResultItem values (@jobKey, @anyKey);
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_NewQueryResultMain]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_NewQueryResultMain]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_NewQueryResultMain]
@userKey uniqueidentifier,
@jobKey uniqueidentifier
AS
BEGIN
INSERT INTO [dbo].[QueryResultMain] ([QueryResultKey], [CreatedByUserKey], [CreatedOn])
VALUES (@jobKey, @userKey, GETDATE());
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_NextSequenceValue]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_NextSequenceValue]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE proc [dbo].[asi_NextSequenceValue]
  @sequenceName nvarchar(30),
  @userKey uniqueidentifier,
  @systemEntityKey uniqueidentifier = '00000000-0000-0000-0000-000000000000',
  @increment int = 1,
  @startValue int = 0 as

declare @lastValue int

--Check to make sure the counter exists - create it if not
if not exists(select 1 from SequenceCounter where CounterName = @sequenceName and SystemEntityKey = @systemEntityKey)
   insert SequenceCounter (SystemEntityKey, CounterName, CurrentValue, UpdatedOn, UpdatedByUserKey, CreatedOn, CreatedByUserKey)
   values (@systemEntityKey, @sequenceName, @startValue, getdate(), @userKey, getdate(), @userKey)

--Increment the current value
update SequenceCounter 
   set @lastValue = CurrentValue = (CurrentValue + @increment),
       UpdatedOn = getdate(), 
       UpdatedByUserKey = @userKey
   where CounterName = @sequenceName
  	 and SystemEntityKey = @systemEntityKey

--Return the last value of the assigned counter range
select @lastValue CurrentValue

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_NextSequenceValueOut]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_NextSequenceValueOut]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE proc asi_NextSequenceValueOut
  @lastValue int OUT,
  @sequenceName nvarchar(30),
  @userKey uniqueidentifier,
  @systemEntityKey uniqueidentifier = '00000000-0000-0000-0000-000000000000',
  @increment int = 1,
  @startValue int = 0
AS

--declare @lastValue int

--Check to make sure the counter exists - create it if not
if not exists(select 1 from SequenceCounter where CounterName = @sequenceName and SystemEntityKey = @systemEntityKey)
   insert SequenceCounter (SystemEntityKey, CounterName, CurrentValue, UpdatedOn, UpdatedByUserKey, CreatedOn, CreatedByUserKey)
   values (@systemEntityKey, @sequenceName, @startValue, getdate(), @userKey, getdate(), @userKey)


--Return the last value of the assigned counter range
--select @lastValue CurrentValue


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_NextSequenceValueSub]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_NextSequenceValueSub]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE proc [dbo].[asi_NextSequenceValueSub]
  @sequenceName nvarchar(30),
  @userKey uniqueidentifier,
  @systemEntityKey uniqueidentifier = '00000000-0000-0000-0000-000000000000',
  @increment int = 1,
  @startValue int = 0,
  @lastValue int = 0 output as

--Check to make sure the counter exists - create it if not
if not exists(select 1 from SequenceCounter where CounterName = @sequenceName and SystemEntityKey = @systemEntityKey)
   insert SequenceCounter (SystemEntityKey, CounterName, CurrentValue, UpdatedOn, UpdatedByUserKey)
   values (@systemEntityKey, @sequenceName, @startValue, getdate(), @userKey)

--Increment the current value
update SequenceCounter 
   set @lastValue = CurrentValue = (CurrentValue + @increment),
       UpdatedOn = getdate(), 
       UpdatedByUserKey = @userKey
 where CounterName = @sequenceName
   and SystemEntityKey = @systemEntityKey

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_NextSequenceValueTest]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_NextSequenceValueTest]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


CREATE proc [dbo].[asi_NextSequenceValueTest]
  @sequenceName nvarchar(30),
  @userKey uniqueidentifier,
  @systemEntityKey uniqueidentifier = '00000000-0000-0000-0000-000000000000',
  @increment int = 1,
  @startValue int = 0 as

declare @lastValue int

set nocount on

exec asi_NextSequenceValueSub @sequenceName, @userKey, @systemEntityKey, @increment, @startValue, @lastValue output

set nocount off

--Return the last value of the assigned counter range
select @lastValue CurrentValue



GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_OpportunityActionPlanUpgradeReport]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_OpportunityActionPlanUpgradeReport]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE dbo.asi_OpportunityActionPlanUpgradeReport AS

IF EXISTS(SELECT 1 FROM sysobjects WHERE name='ActionPlan')
EXEC
('
DECLARE @idoc int
DECLARE @doc varchar(8000)
DECLARE @planName nvarchar(50)
DECLARE @ActionPlanKey uniqueidentifier

SET NOCOUNT ON

SELECT ActionPlanKey, Name, ActionManifest
INTO #Plans
FROM ActionPlan

CREATE TABLE #Assignee
(
	ActionPlanKey uniqueidentifier,
	PlanName nvarchar(50),
	taskId uniqueidentifier,
	taskSubject nvarchar(50),
	taskDescription nvarchar(100),
	Id uniqueidentifier,
	userKey uniqueidentifier,
	assigneeType nvarchar(50),
	groupTag nvarchar(50)
)

SELECT TOP 1 @doc = convert(varchar(8000), ActionManifest), @planName = [Name], @ActionPlanKey = ActionPlanKey
FROM #Plans

WHILE (@@ROWCOUNT <> 0)
BEGIN
	EXEC sp_xml_preparedocument @idoc output, @doc

	INSERT INTO #Assignee
	SELECT ActionPlanKey = @ActionPlanKey, PlanName = @planName, *
	FROM OPENXML(@idoc, ''/ActionManifest/Stage/EmailAction/Assignee'', 2)
		WITH (
			taskId		uniqueidentifier	''../@Id'',
			taskSubject	nvarchar(100)		''../@taskSubject'',
			taskDescription	nvarchar(100)		''../@description'',
			Id 		uniqueidentifier	''@Id'',
			userKey 	uniqueidentifier	''@userKey'',
			assigneeType 	nvarchar(100)		''@assigneeType'',
			groupTag 	nvarchar(100)		''@groupTag''
		)	

	INSERT INTO #Assignee
	SELECT ActionPlanKey = @ActionPlanKey, PlanName = @planName, *
	FROM OPENXML(@idoc, ''/ActionManifest/Stage/TaskAction/Assignee'', 2)
		WITH (
			taskId		uniqueidentifier	''../@Id'',
			taskSubject	nvarchar(100)		''../@taskSubject'',
			taskDescription	nvarchar(100)		''../@description'',
			Id 		uniqueidentifier	''@Id'',
			userKey 	uniqueidentifier	''@userKey'',
			assigneeType 	nvarchar(100)		''@assigneeType'',
			groupTag 	nvarchar(100)		''@groupTag''
		)	

	EXEC sp_xml_removedocument @idoc
	
	DELETE FROM #Plans WHERE ActionPlanKey = @ActionPlanKey

	SELECT TOP 1 @doc = convert(nvarchar(4000), ActionManifest), @planName = [Name], @ActionPlanKey = ActionPlanKey
	FROM #Plans
END

SET NOCOUNT OFF

DROP TABLE #Plans

SELECT * FROM #Assignee
WHERE assigneeType <> ''Group''

DROP TABLE #Assignee')

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_OpportunityTypes]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_OpportunityTypes]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_OpportunityTypes    Script Date: 7/3/2003 4:58:04 PM ******/

CREATE   PROC [dbo].[asi_OpportunityTypes]
	AS
BEGIN
	SELECT OpportunityTypeKey, OpportunityClass, Name, Description 
	FROM OpportunityType
	ORDER BY Name
	
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_PareDownMailingListForPreview]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_PareDownMailingListForPreview]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- This stored procedure pares down a mailing list for previewing a Package.
-- After run, the only records remaining is the one at 'startRecord' and every 
-- 'recordInterval'th record after that.  The index starts at one, so if both
-- startRecord and recordInterval are one, no records will be removed.
CREATE PROCEDURE [dbo].[asi_PareDownMailingListForPreview]
   @tableName sysname,
   @keyFieldName sysname,
   @startRecord integer,
   @recordInterval integer
AS
BEGIN
   DECLARE @sql nvarchar(800)
   DECLARE @startRecordString nvarchar(30)
   DECLARE @recordIntervalString nvarchar(30)

   CREATE TABLE #MailingListTable
   (
      MailingListTableKey uniqueidentifier,
      IntId int IDENTITY(1, 1)
   )
   
   SET @startRecordString = CAST(@startRecord AS nvarchar(30))
   SET @recordIntervalString = CAST(@recordInterval AS nvarchar(30))
	   
   SET @sql = 'INSERT #MailingListTable (MailingListTableKey) SELECT [' + @keyFieldName + '] FROM [' + @tableName + ']'
   EXEC(@sql)
	
   SET @sql = 'DELETE [' + @tableName + '] FROM #MailingListTable WHERE #MailingListTable.MailingListTableKey=[' + @tableName + '].[' + @keyFieldName + '] AND (((#MailingListTable.IntId-' + @startRecordString + ')%' + @recordIntervalString + '!=0) OR #MailingListTable.IntId<' + @startRecordString + ')'
   EXEC(@sql)
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ProcessContactFormula]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ProcessContactFormula]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE proc [dbo].[asi_ProcessContactFormula]
	(@inputFormula nvarchar(1000),
	@inputSourceTable nvarchar(200),
	@inputColumnName nvarchar(200),
	@inputColumnValue uniqueidentifier)
as
begin

set nocount on

declare @sqlStmt nvarchar(2000)
declare @substr1 nvarchar(1000)
declare @substr2 nvarchar(1000)
declare @substrPreField nvarchar(100)
declare @substrPostField nvarchar(100)
declare @substrPreStmt nvarchar(1000)
declare @substrPostStmt nvarchar(1000)

declare @pos1 int
declare @pos2 int
declare @pos3 int
declare @pos4 int
declare @pos5 int

declare @firstchar nvarchar(1)
declare @done bit

select @sqlStmt = 'select '

select @substrPreStmt = left (@inputFormula, 1)
if @substrPreStmt = '{' or @substrPreStmt = '['
	select @substrPreStmt = ''
else
	begin
	select @substrPreStmt = @inputFormula
	select @pos4 = charindex ('[', @substrPreStmt)
	select @pos5 = charindex ('{', @substrPreStmt)
	if @pos5 < @pos4 and @pos5 <> 0
	 	select @pos4 = @pos5
	select @substrPreStmt = left (@substrPreStmt, @pos4 - 1)
	end

select @sqlStmt = @sqlStmt + '''' + @substrPreStmt + '''' + ' + '

select @substrPostStmt = left (reverse(@inputFormula), 1)
if @substrPostStmt = '}' or @substrPostStmt = ']'
	select @substrPostStmt = ''
else
	begin
	select @substrPostStmt = reverse(@inputFormula)
	select @pos4 = charindex (']', @substrPostStmt)
	select @pos5 = charindex ('}', @substrPostStmt)
	if @pos5 < @pos4 and @pos5 <> 0
	 	select @pos4 = @pos5
	select @substrPostStmt = left (@substrPostStmt, @pos4 - 1)
	select @substrPostStmt = reverse(@substrPostStmt)
	end

select @substr1 = substring (@inputFormula, datalength (@substrPreStmt)/2 + 1, 
	datalength (@inputFormula)/2 - datalength (@substrPreStmt)/2 - datalength (@substrPostStmt)/2)

select @done = 0

while @done = 0
begin
select @firstchar = left (@substr1, 1)
if @firstchar = '{'
	begin	-- find a matching curly bracket
		select @substr2 = substring (@substr1, 1, charindex ('}', @substr1))
		select @pos2 = datalength (@substr2)/2
		select @substrPreField = substring (@substr1, 2, charindex ('[', @substr1) - 2)
		select @substrPostField = substring (@substr1, charindex (']', @substr1) + 1, 
			(charindex ('}', @substr1) -  charindex (']', @substr1) - 1))
		select @pos3 = (datalength (@substr2)/2) - 4 - (datalength (@substrPreField)/2) - (datalength (@substrPostField)/2)
		select @substr2 = substring (@substr2, charindex ('[', @substr2) + 1, @pos3)
		if exists (select 1 from INFORMATION_SCHEMA.COLUMNS 
				where TABLE_NAME = @inputSourceTable
				and COLUMN_NAME = @substr2)
			select @sqlStmt = @sqlStmt + ' case when ' + @substr2 + ' is null then '''' else ' + '''' + @substrPreField + '''' + ' + ' + @substr2 + ' + ' + '''' + @substrPostField + '''' + ' end '  + ' + '
		else
			select @sqlStmt = @sqlStmt + '''' + @substrPreField + '''' + ' + ' + '''[' + @substr2 + ']''' + ' + ' + '''' + @substrPostField + '''' + ' + '

		select @substr1 = right (@substr1, datalength (@substr1)/2 - @pos2)
	end
else if @firstchar = '['
	begin	-- find a matching square bracket
		select @substr2 = substring (@substr1, 1, charindex (']', @substr1))
		select @substr2 = substring (@substr2, 2, datalength (@substr2)/2 -2)	

		if exists (select 1 from INFORMATION_SCHEMA.COLUMNS 
			where TABLE_NAME = @inputSourceTable
			and COLUMN_NAME = @substr2)
			select @sqlStmt = @sqlStmt + ' case when ' + @substr2 + ' is null then '''' else ' + @substr2 + ' end '  + ' + '
		else
			select @sqlStmt = @sqlStmt + '''' + @substr2 + '''' + ' + '
		select @substr1 = right (@substr1, datalength (@substr1)/2 - datalength (@substr2) /2 - 2)
	end
else
	begin	-- find everything up to the next curly or square bracket, and treat it as a literal
		select @pos4 = charindex ('[', @substr1)
		select @pos5 = charindex ('{', @substr1)
		if @pos5 < @pos4 and @pos5 <> 0
		 	select @pos4 = @pos5
		select @substr2 = left (@substr1, @pos4)

		if (datalength (@substr2) / 2) > 0
			begin
			select @substr2 = left (@substr2, datalength (@substr2)/2 - 1)
			select @sqlStmt = @sqlStmt + '''' + @substr2 + '''' + ' + '
			end
		else
			select @done = 1
		select @substr1 = right (@substr1, datalength (@substr1)/2 - datalength (@substr2) /2)
	end

end -- while @done = 0

if substring (@sqlStmt, (datalength (@sqlStmt)/2) - 1, 1) = '+'
	select @sqlStmt = substring (@sqlStmt, 1, (datalength (@sqlStmt)/2) - 2)

if (datalength (@substrPostStmt)/2 > 0)
 	select @sqlStmt = @sqlStmt + ' + ' + '''' + @substrPostStmt + ''''

-- support <n> for embedded newline, <t> for embedded tab anywhere in formula
while (charindex ('<n>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<n>', ''' + char(13) + ''')

while (charindex ('<t>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<t>', ''' + char(9) + ''')

-- support <[> and <]> to embed square brackets anywhere in formula
while (charindex ('<[>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<[>', '[')

while (charindex ('<]>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<]>', ']')

-- support <{> and <}> to embed curly brackets anywhere in formula
while (charindex ('<{>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<{>', '{')

while (charindex ('<}>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<}>', '}')

select @sqlStmt = @sqlStmt + ' from ' + @inputSourceTable + ' where ' + @inputColumnName + ' = ' 
	+ '''' + convert (nvarchar(50), @inputColumnValue) + ''''

create table #tmptbl (formattedOutput nvarchar(1000))
insert into #tmptbl  exec (@sqlStmt)

select formattedOutput from #tmptbl

set nocount off

END -- create proc ProcessContactFormula

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ProcessContactFormulaCopy]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ProcessContactFormulaCopy]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 
CREATE proc [dbo].[asi_ProcessContactFormulaCopy]
	(@inputFormula nvarchar(1000),
	@inputSourceTable nvarchar(200),
	@inputColumnName nvarchar(200),
	@inputColumnValue uniqueidentifier)
as
begin

set nocount on

declare @sqlStmt nvarchar(2000)
declare @substr1 nvarchar(1000)
declare @substr2 nvarchar(1000)
declare @substrPreField nvarchar(100)
declare @substrPostField nvarchar(100)
declare @substrPreStmt nvarchar(1000)
declare @substrPostStmt nvarchar(1000)

declare @pos1 int
declare @pos2 int
declare @pos3 int
declare @pos4 int
declare @pos5 int

declare @firstchar nvarchar(1)
declare @done bit

select @sqlStmt = 'select '

select @substrPreStmt = left (@inputFormula, 1)
if @substrPreStmt = '{' or @substrPreStmt = '['
	select @substrPreStmt = ''
else
	begin
	select @substrPreStmt = @inputFormula
	select @pos4 = charindex ('[', @substrPreStmt)
	select @pos5 = charindex ('{', @substrPreStmt)
	if @pos5 < @pos4 and @pos5 <> 0
	 	select @pos4 = @pos5
	select @substrPreStmt = left (@substrPreStmt, @pos4 - 1)
	end

select @sqlStmt = @sqlStmt + '''' + @substrPreStmt + '''' + ' + '

select @substrPostStmt = left (reverse(@inputFormula), 1)
if @substrPostStmt = '}' or @substrPostStmt = ']'
	select @substrPostStmt = ''
else
	begin
	select @substrPostStmt = reverse(@inputFormula)
	select @pos4 = charindex (']', @substrPostStmt)
	select @pos5 = charindex ('}', @substrPostStmt)
	if @pos5 < @pos4 and @pos5 <> 0
	 	select @pos4 = @pos5
	select @substrPostStmt = left (@substrPostStmt, @pos4 - 1)
	select @substrPostStmt = reverse(@substrPostStmt)
	end

select @substr1 = substring (@inputFormula, datalength (@substrPreStmt)/2 + 1, 
	datalength (@inputFormula)/2 - datalength (@substrPreStmt)/2 - datalength (@substrPostStmt)/2)

select @done = 0

while @done = 0
begin
select @firstchar = left (@substr1, 1)
if @firstchar = '{'
	begin	-- find a matching curly bracket
		select @substr2 = substring (@substr1, 1, charindex ('}', @substr1))
		select @pos2 = datalength (@substr2)/2
		select @substrPreField = substring (@substr1, 2, charindex ('[', @substr1) - 2)
		select @substrPostField = substring (@substr1, charindex (']', @substr1) + 1, 
			(charindex ('}', @substr1) -  charindex (']', @substr1) - 1))
		select @pos3 = (datalength (@substr2)/2) - 4 - (datalength (@substrPreField)/2) - (datalength (@substrPostField)/2)
		select @substr2 = substring (@substr2, charindex ('[', @substr2) + 1, @pos3)
		if exists (select 1 from INFORMATION_SCHEMA.COLUMNS 
				where TABLE_NAME = @inputSourceTable
				and COLUMN_NAME = @substr2)
			select @sqlStmt = @sqlStmt + ' case when ' + @substr2 + ' is null then '''' else ' + '''' + @substrPreField + '''' + ' + ' + @substr2 + ' + ' + '''' + @substrPostField + '''' + ' end '  + ' + '
		else
			select @sqlStmt = @sqlStmt + '''' + @substrPreField + '''' + ' + ' + '''[' + @substr2 + ']''' + ' + ' + '''' + @substrPostField + '''' + ' + '

		select @substr1 = right (@substr1, datalength (@substr1)/2 - @pos2)
	end
else if @firstchar = '['
	begin	-- find a matching square bracket
		select @substr2 = substring (@substr1, 1, charindex (']', @substr1))
		select @substr2 = substring (@substr2, 2, datalength (@substr2)/2 -2)	

		if exists (select 1 from INFORMATION_SCHEMA.COLUMNS 
			where TABLE_NAME = @inputSourceTable
			and COLUMN_NAME = @substr2)
			select @sqlStmt = @sqlStmt + ' case when ' + @substr2 + ' is null then '''' else ' + @substr2 + ' end '  + ' + '
		else
			select @sqlStmt = @sqlStmt + '''' + @substr2 + '''' + ' + '
		select @substr1 = right (@substr1, datalength (@substr1)/2 - datalength (@substr2) /2 - 2)
	end
else
	begin	-- find everything up to the next curly or square bracket, and treat it as a literal
		select @pos4 = charindex ('[', @substr1)
		select @pos5 = charindex ('{', @substr1)
		if @pos5 < @pos4 and @pos5 <> 0
		 	select @pos4 = @pos5
		select @substr2 = left (@substr1, @pos4)

		if (datalength (@substr2) / 2) > 0
			begin
			select @substr2 = left (@substr2, datalength (@substr2)/2 - 1)
			select @sqlStmt = @sqlStmt + '''' + @substr2 + '''' + ' + '
			end
		else
			select @done = 1
		select @substr1 = right (@substr1, datalength (@substr1)/2 - datalength (@substr2) /2)
	end

end -- while @done = 0

if substring (@sqlStmt, (datalength (@sqlStmt)/2) - 1, 1) = '+'
	select @sqlStmt = substring (@sqlStmt, 1, (datalength (@sqlStmt)/2) - 2)

if (datalength (@substrPostStmt)/2 > 0)
 	select @sqlStmt = @sqlStmt + ' + ' + '''' + @substrPostStmt + ''''

-- support <n> for embedded newline, <t> for embedded tab anywhere in formula
while (charindex ('<n>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<n>', ''' + char(13) + ''')

while (charindex ('<t>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<t>', ''' + char(9) + ''')

-- support <[> and <]> to embed square brackets anywhere in formula
while (charindex ('<[>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<[>', '[')

while (charindex ('<]>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<]>', ']')

-- support <{> and <}> to embed curly brackets anywhere in formula
while (charindex ('<{>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<{>', '{')

while (charindex ('<}>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<}>', '}')

select @sqlStmt = @sqlStmt + ' from ' + @inputSourceTable + ' where ' + @inputColumnName + ' = ' 
	+ '''' + convert (nvarchar(50), @inputColumnValue) + ''''

print @sqlStmt

create table #tmptbl (formattedOutput nvarchar(1000))
insert into #tmptbl  exec (@sqlStmt)

declare @formattedOutput nvarchar(2000)

select @formattedOutput = formattedOutput from #tmptbl
print @formattedOutput

select formattedOutput from #tmptbl

set nocount off

END -- create proc ProcessContactFormula

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ProcessContactFormulaOutput]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ProcessContactFormulaOutput]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE proc [dbo].[asi_ProcessContactFormulaOutput]
	(@inputTempKey uniqueidentifier,
	@inputFormula nvarchar(1000),
	@inputSourceTable nvarchar(200),
	@inputColumnName nvarchar(200),
	@inputColumnValue uniqueidentifier)

as

begin

set nocount on

declare @sqlStmt nvarchar(2000)
declare @substr1 nvarchar(1000)
declare @substr2 nvarchar(1000)
declare @substrPreField nvarchar(100)
declare @substrPostField nvarchar(100)
declare @substrPreStmt nvarchar(1000)
declare @substrPostStmt nvarchar(1000)

declare @pos1 int
declare @pos2 int
declare @pos3 int
declare @pos4 int
declare @pos5 int

declare @firstchar nvarchar(1)
declare @done bit

select @sqlStmt = 'select '

select @substrPreStmt = left (@inputFormula, 1)
if @substrPreStmt = '{' or @substrPreStmt = '['
	select @substrPreStmt = ''
else
	begin
	select @substrPreStmt = @inputFormula
	select @pos4 = charindex ('[', @substrPreStmt)
	select @pos5 = charindex ('{', @substrPreStmt)
	if @pos5 < @pos4 and @pos5 <> 0
	 	select @pos4 = @pos5
	select @substrPreStmt = left (@substrPreStmt, @pos4 - 1)
	end

select @sqlStmt = @sqlStmt + '''' + @substrPreStmt + '''' + ' + '

select @substrPostStmt = left (reverse(@inputFormula), 1)
if @substrPostStmt = '}' or @substrPostStmt = ']'
	select @substrPostStmt = ''
else
	begin
	select @substrPostStmt = reverse(@inputFormula)
	select @pos4 = charindex (']', @substrPostStmt)
	select @pos5 = charindex ('}', @substrPostStmt)
	if @pos5 < @pos4 and @pos5 <> 0
	 	select @pos4 = @pos5
	select @substrPostStmt = left (@substrPostStmt, @pos4 - 1)
	select @substrPostStmt = reverse(@substrPostStmt)
	end

select @substr1 = substring (@inputFormula, datalength (@substrPreStmt)/2 + 1, 
	datalength (@inputFormula)/2 - datalength (@substrPreStmt)/2 - datalength (@substrPostStmt)/2)

select @done = 0

while @done = 0
begin
select @firstchar = left (@substr1, 1)
if @firstchar = '{'
	begin	-- find a matching curly bracket
		select @substr2 = substring (@substr1, 1, charindex ('}', @substr1))
		select @pos2 = datalength (@substr2)/2
		select @substrPreField = substring (@substr1, 2, charindex ('[', @substr1) - 2)
		select @substrPostField = substring (@substr1, charindex (']', @substr1) + 1, 
			(charindex ('}', @substr1) -  charindex (']', @substr1) - 1))
		select @pos3 = (datalength (@substr2)/2) - 4 - (datalength (@substrPreField)/2) - (datalength (@substrPostField)/2)
		select @substr2 = substring (@substr2, charindex ('[', @substr2) + 1, @pos3)
		if exists (select 1 from INFORMATION_SCHEMA.COLUMNS 
				where TABLE_NAME = @inputSourceTable
				and COLUMN_NAME = @substr2)
			select @sqlStmt = @sqlStmt + ' case when ' + @substr2 + ' is null then '''' else ' + '''' + @substrPreField + '''' + ' + ' + @substr2 + ' + ' + '''' + @substrPostField + '''' + ' end '  + ' + '
		else
			select @sqlStmt = @sqlStmt + '''' + @substrPreField + '''' + ' + ' + '''[' + @substr2 + ']''' + ' + ' + '''' + @substrPostField + '''' + ' + '

		select @substr1 = right (@substr1, datalength (@substr1)/2 - @pos2)
	end
else if @firstchar = '['
	begin	-- find a matching square bracket
		select @substr2 = substring (@substr1, 1, charindex (']', @substr1))
		select @substr2 = substring (@substr2, 2, datalength (@substr2)/2 -2)	

		if exists (select 1 from INFORMATION_SCHEMA.COLUMNS 
			where TABLE_NAME = @inputSourceTable
			and COLUMN_NAME = @substr2)
			select @sqlStmt = @sqlStmt + ' case when ' + @substr2 + ' is null then '''' else ' + @substr2 + ' end '  + ' + '
		else
			select @sqlStmt = @sqlStmt + '''' + @substr2 + '''' + ' + '
		select @substr1 = right (@substr1, datalength (@substr1)/2 - datalength (@substr2) /2 - 2)
	end
else
	begin	-- find everything up to the next curly or square bracket, and treat it as a literal
		select @pos4 = charindex ('[', @substr1)
		select @pos5 = charindex ('{', @substr1)
		if @pos5 < @pos4 and @pos5 <> 0
		 	select @pos4 = @pos5
		select @substr2 = left (@substr1, @pos4)

		if (datalength (@substr2) / 2) > 0
			begin
			select @substr2 = left (@substr2, datalength (@substr2)/2 - 1)
			select @sqlStmt = @sqlStmt + '''' + @substr2 + '''' + ' + '
			end
		else
			select @done = 1
		select @substr1 = right (@substr1, datalength (@substr1)/2 - datalength (@substr2) /2)
	end

end -- while @done = 0

if substring (@sqlStmt, (datalength (@sqlStmt)/2) - 1, 1) = '+'
	select @sqlStmt = substring (@sqlStmt, 1, (datalength (@sqlStmt)/2) - 2)

if (datalength (@substrPostStmt)/2 > 0)
 	select @sqlStmt = @sqlStmt + ' + ' + '''' + @substrPostStmt + ''''

-- support <n> for embedded newline, <t> for embedded tab anywhere in formula
while (charindex ('<n>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<n>', ''' + char(13) + ''')

while (charindex ('<t>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<t>', ''' + char(9) + ''')

-- support <[> and <]> to embed square brackets anywhere in formula
while (charindex ('<[>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<[>', '[')

while (charindex ('<]>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<]>', ']')

-- support <{> and <}> to embed curly brackets anywhere in formula
while (charindex ('<{>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<{>', '{')

while (charindex ('<}>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<}>', '}')

select @sqlStmt = @sqlStmt + ' from ' + @inputSourceTable + ' where ' + @inputColumnName + ' = ' 
	+ '''' + convert (nvarchar(50), @inputColumnValue) + ''''

create table #tmptbl (formattedOutput nvarchar(1000))
insert into #tmptbl  exec (@sqlStmt)

insert tempFormula (tempKey, tempValue) 
	select @inputTempKey, formattedOutput from #tmptbl

set nocount off

END -- create proc ProcessContactFormula

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ProcessEngineTypeByKey]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ProcessEngineTypeByKey]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_ProcessEngineTypeByKey    Script Date: 7/3/2003 4:58:04 PM ******/
CREATE   PROC [dbo].[asi_ProcessEngineTypeByKey]
	@typeKey uniqueidentifier
	AS
BEGIN
	SET ROWCOUNT 1
	SELECT	ProcessEngineType.ProcessEngineTypeKey, 
			ProcessEngineType.Name, 
			ProcessEngineType.Assembly, 
			ProcessEngineType.QualifiedName, 
			ProcessEngineType.HasTemplate,
			ProcessEngineType.HasDesigner

	 FROM	ProcessEngineType
			
	 WHERE	ProcessEngineType.ProcessEngineTypeKey = @typeKey
	SET ROWCOUNT 0
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ProcessEngineTypeByName]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ProcessEngineTypeByName]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_ProcessEngineTypeByName    Script Date: 7/3/2003 4:58:04 PM ******/
CREATE   PROC [dbo].[asi_ProcessEngineTypeByName]
	@processEngineType nvarchar(100)
	AS
BEGIN
	SET ROWCOUNT 1
	SELECT	ProcessEngineType.ProcessEngineTypeKey, 
			ProcessEngineType.Name, 
			ProcessEngineType.Assembly, 
			ProcessEngineType.QualifiedName, 
			ProcessEngineType.HasTemplate,
			ProcessEngineType.HasDesigner

	 FROM	ProcessEngineType
			
	 WHERE	ProcessEngineType.Name = @processEngineType
	SET ROWCOUNT 0
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ProcessFormula]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ProcessFormula]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE proc [dbo].[asi_ProcessFormula]
	(@inputFormula nvarchar(1000),
	@inputSourceTable nvarchar(200),
	@inputColumnName nvarchar(200),
	@inputColumnValue uniqueidentifier)
as
begin

set nocount on

declare @sqlStmt nvarchar(2000)
declare @substr1 nvarchar(1000)
declare @substr2 nvarchar(1000)
declare @substr3 nvarchar(1000)
declare @substrPreField nvarchar(100)
declare @substrPostField nvarchar(100)
declare @substrPreStmt nvarchar(1000)
declare @substrPostStmt nvarchar(1000)

declare @pos1 int
declare @pos2 int
declare @pos3 int
declare @pos4 int
declare @pos5 int

declare @firstchar nvarchar(1)
declare @done bit

if charindex('[', @inputFormula) > 0
begin

select @sqlStmt = 'select '

select @substrPreStmt = left (@inputFormula, 1)
if @substrPreStmt = '{' or @substrPreStmt = '['
	select @substrPreStmt = ''
else
	begin
	select @substrPreStmt = @inputFormula
	select @pos4 = charindex ('[', @substrPreStmt)
	select @pos5 = charindex ('{', @substrPreStmt)
	if @pos5 < @pos4 and @pos5 <> 0
	 	select @pos4 = @pos5
	select @substrPreStmt = left (@substrPreStmt, @pos4 - 1)
	end

select @sqlStmt = @sqlStmt + '''' + @substrPreStmt + '''' + ' + '

select @substrPostStmt = left (reverse(@inputFormula), 1)
if @substrPostStmt = '}' or @substrPostStmt = ']'
	select @substrPostStmt = ''
else
	begin
	select @substrPostStmt = reverse(@inputFormula)
	select @pos4 = charindex (']', @substrPostStmt)
	select @pos5 = charindex ('}', @substrPostStmt)
	if @pos5 < @pos4 and @pos5 <> 0
	 	select @pos4 = @pos5
	select @substrPostStmt = left (@substrPostStmt, @pos4 - 1)
	select @substrPostStmt = reverse(@substrPostStmt)
	end

select @substr1 = substring (@inputFormula, datalength (@substrPreStmt)/2 + 1, 
	datalength (@inputFormula)/2 - datalength (@substrPreStmt)/2 - datalength (@substrPostStmt)/2)

select @done = 0

while @done = 0
begin
select @firstchar = left (@substr1, 1)
if @firstchar = '{'
	begin	-- find a matching curly bracket
		select @substr3 = substring (@substr1, 1, charindex ('}', @substr1))
		select @pos2 = datalength (@substr3)/2
		select @substrPreField = substring (@substr1, 2, charindex ('[', @substr1) - 2)
		select @substrPostField = substring (@substr1, charindex (']', @substr1) + 1, 
			(charindex ('}', @substr1) -  charindex (']', @substr1) - 1))
		select @pos3 = (datalength (@substr3)/2) - 4 - (datalength (@substrPreField)/2) - (datalength (@substrPostField)/2)
		select @substr2 = substring (@substr3, charindex ('[', @substr3) + 1, @pos3)
		if exists (select 1 from INFORMATION_SCHEMA.COLUMNS 
				where TABLE_NAME = @inputSourceTable
				and COLUMN_NAME = @substr2)
			select @sqlStmt = @sqlStmt + ' case when ' + @substr2 + ' is null then '''' else ' + '''' + @substrPreField + '''' + ' + ' + @substr2 + ' + ' + '''' + @substrPostField + '''' + ' end '  + ' + '
		else
			select @sqlStmt = @sqlStmt + '''' + @substr3 + '''' + ' + '

		select @substr1 = right (@substr1, datalength (@substr1)/2 - @pos2)
	end
else if @firstchar = '['
	begin	-- find a matching square bracket
		select @substr3 = substring (@substr1, 1, charindex (']', @substr1))
		select @substr2 = substring (@substr3, 2, datalength (@substr3)/2 -2)	

		if exists (select 1 from INFORMATION_SCHEMA.COLUMNS 
			where TABLE_NAME = @inputSourceTable
			and COLUMN_NAME = @substr2)
			select @sqlStmt = @sqlStmt + ' case when ' + @substr2 + ' is null then '''' else ' + @substr2 + ' end '  + ' + '
		else
			select @sqlStmt = @sqlStmt + '''' + @substr3 + '''' + ' + '
		select @substr1 = right (@substr1, datalength (@substr1)/2 - datalength (@substr2) /2 - 2)
	end
else
	begin	-- find everything up to the next curly or square bracket, and treat it as a literal
		select @pos4 = charindex ('[', @substr1)
		select @pos5 = charindex ('{', @substr1)
		if @pos5 < @pos4 and @pos5 <> 0
		 	select @pos4 = @pos5
		select @substr2 = left (@substr1, @pos4)

		if (datalength (@substr2) / 2) > 0
			begin
			select @substr2 = left (@substr2, datalength (@substr2)/2 - 1)
			select @sqlStmt = @sqlStmt + '''' + @substr2 + '''' + ' + '
			end
		else
			select @done = 1
		select @substr1 = right (@substr1, datalength (@substr1)/2 - datalength (@substr2) /2)
	end

end -- while @done = 0

if substring (@sqlStmt, (datalength (@sqlStmt)/2) - 1, 1) = '+'
	select @sqlStmt = substring (@sqlStmt, 1, (datalength (@sqlStmt)/2) - 2)

if (datalength (@substrPostStmt)/2 > 0)
 	select @sqlStmt = @sqlStmt + ' + ' + '''' + @substrPostStmt + ''''

-- support <n> for embedded newline, <t> for embedded tab anywhere in formula
while (charindex ('<n>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<n>', ''' + char(13) + char(10) + ''')

while (charindex ('<t>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<t>', ''' + char(9) + ''')

-- support <[> and <]> to embed square brackets anywhere in formula
while (charindex ('<[>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<[>', '[')

while (charindex ('<]>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<]>', ']')

-- support <{> and <}> to embed curly brackets anywhere in formula
while (charindex ('<{>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<{>', '{')

while (charindex ('<}>', @sqlStmt) > 0)
	select @sqlStmt = replace (@sqlStmt, '<}>', '}')

select @sqlStmt = @sqlStmt + ' from ' + @inputSourceTable + ' where ' + @inputColumnName + ' = ' 
	+ '''' + convert (nvarchar(50), @inputColumnValue) + ''''

create table #tmptbl (formattedOutput nvarchar(1000))
insert into #tmptbl  exec (@sqlStmt)

select formattedOutput from #tmptbl
end
else
select formattedOutput = @inputFormula

set nocount off

END -- create proc ProcessContactFormula

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ProcessFormulaOutput]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ProcessFormulaOutput]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROC [dbo].[asi_ProcessFormulaOutput] (
	@inputTempKey uniqueidentifier,
	@inputFormula nvarchar(1000),
	@inputSourceTable nvarchar(200),
	@inputColumnName nvarchar(200),
	@inputColumnValue uniqueidentifier
	)
AS
BEGIN

	SET NOCOUNT ON

	DECLARE @sqlStmt nvarchar(2000)
	DECLARE @substr1 nvarchar(1000)
	DECLARE @substr2 nvarchar(1000)
	DECLARE @substr3 nvarchar(1000)
	DECLARE @substrPreField nvarchar(100)
	DECLARE @substrPostField nvarchar(100)
	DECLARE @substrPreStmt nvarchar(1000)
	DECLARE @substrPostStmt nvarchar(1000)

	DECLARE @pos1 int
	DECLARE @pos2 int
	DECLARE @pos3 int
	DECLARE @pos4 int
	DECLARE @pos5 int

	DECLARE @firstchar nvarchar(1)
	DECLARE @done bit

	IF charindex('[', @inputFormula) > 0
	BEGIN
		-- There are field place-holders to process
		SELECT @sqlStmt = 'select '

		SELECT @substrPreStmt = left (@inputFormula, 1)
		IF @substrPreStmt = '{' or @substrPreStmt = '['
			BEGIN
			SELECT @substrPreStmt = ''
			END
		ELSE
			BEGIN
			SELECT @substrPreStmt = @inputFormula
			SELECT @pos4 = charindex ('[', @substrPreStmt)
			SELECT @pos5 = charindex ('{', @substrPreStmt)
			IF @pos5 < @pos4 and @pos5 <> 0
	 			select @pos4 = @pos5
			SELECT @substrPreStmt = left (@substrPreStmt, @pos4 - 1)
			END

		SELECT @sqlStmt = @sqlStmt + '''' + @substrPreStmt + '''' + ' + '

		SELECT @substrPostStmt = left (reverse(@inputFormula), 1)
		IF @substrPostStmt = '}' or @substrPostStmt = ']'
			BEGIN
			SELECT @substrPostStmt = ''
			END
		ELSE
			BEGIN
			SELECT @substrPostStmt = reverse(@inputFormula)
			SELECT @pos4 = charindex (']', @substrPostStmt)
			SELECT @pos5 = charindex ('}', @substrPostStmt)
			IF @pos5 < @pos4 and @pos5 <> 0
				BEGIN
	 			SELECT @pos4 = @pos5
	 			END
			SELECT @substrPostStmt = left (@substrPostStmt, @pos4 - 1)
			SELECT @substrPostStmt = reverse(@substrPostStmt)
			END

		SELECT @substr1 = substring (@inputFormula, datalength (@substrPreStmt)/2 + 1, 
			datalength (@inputFormula)/2 - datalength (@substrPreStmt)/2 - datalength (@substrPostStmt)/2)

		SELECT @done = 0

		WHILE @done = 0
		BEGIN
			SELECT @firstchar = left (@substr1, 1)
			IF @firstchar = '{'
			BEGIN	-- find a matching curly bracket
				SELECT @substr3 = substring (@substr1, 1, charindex ('}', @substr1))
				SELECT @pos2 = datalength (@substr3)/2
				SELECT @substrPreField = substring (@substr1, 2, charindex ('[', @substr1) - 2)
				SELECT @substrPostField = substring (@substr1, charindex (']', @substr1) + 1, 
					(charindex ('}', @substr1) -  charindex (']', @substr1) - 1))
				SELECT @pos3 = (datalength (@substr3)/2) - 4 - (datalength (@substrPreField)/2) - (datalength (@substrPostField)/2)
				SELECT @substr2 = substring (@substr3, charindex ('[', @substr3) + 1, @pos3)
				IF EXISTS (select 1 FROM INFORMATION_SCHEMA.COLUMNS 
						WHERE TABLE_NAME = @inputSourceTable
						AND COLUMN_NAME = @substr2)
					SELECT @sqlStmt = @sqlStmt + ' case when ' + @substr2 + ' is null then '''' else ' + '''' + @substrPreField + '''' + ' + ' + @substr2 + ' + ' + '''' + @substrPostField + '''' + ' end '  + ' + '
				ELSE
					SELECT @sqlStmt = @sqlStmt + '''' + @substr3 + '''' + ' + '

				SELECT @substr1 = right (@substr1, datalength (@substr1)/2 - @pos2)
			END
			ELSE IF @firstchar = '['
			BEGIN	-- find a matching square bracket
				SELECT @substr3 = substring (@substr1, 1, charindex (']', @substr1))
				SELECT @substr2 = substring (@substr3, 2, datalength (@substr3)/2 -2)	

				IF EXISTS (select 1 from INFORMATION_SCHEMA.COLUMNS 
					WHERE TABLE_NAME = @inputSourceTable
					AND COLUMN_NAME = @substr2)
					SELECT @sqlStmt = @sqlStmt + ' case WHEN ' + @substr2 + ' IS NULL THEN '''' ELSE ' + @substr2 + ' end '  + ' + '
				ELSE
					SELECT @sqlStmt = @sqlStmt + '''' + @substr3 + '''' + ' + '
				SELECT @substr1 = right (@substr1, datalength (@substr1)/2 - datalength (@substr2) /2 - 2)
			END
			ELSE
			BEGIN	-- find everything up to the next curly or square bracket, and treat it as a literal
				SELECT @pos4 = charindex ('[', @substr1)
				SELECT @pos5 = charindex ('{', @substr1)
				IF @pos5 < @pos4 and @pos5 <> 0
		 			SELECT @pos4 = @pos5
				SELECT @substr2 = left (@substr1, @pos4)

				IF (datalength (@substr2) / 2) > 0
					BEGIN
					SELECT @substr2 = left (@substr2, datalength (@substr2)/2 - 1)
					SELECT @sqlStmt = @sqlStmt + '''' + @substr2 + '''' + ' + '
					END
				ELSE
					SELECT @done = 1
				SELECT @substr1 = right (@substr1, datalength (@substr1)/2 - datalength (@substr2) /2)
			END

		END -- while @done = 0

		IF substring (@sqlStmt, (datalength (@sqlStmt)/2) - 1, 1) = '+'
			SELECT @sqlStmt = substring (@sqlStmt, 1, (datalength (@sqlStmt)/2) - 2)

		IF (datalength (@substrPostStmt)/2 > 0)
 			SELECT @sqlStmt = @sqlStmt + ' + ' + '''' + @substrPostStmt + ''''

		-- support <n> for embedded newline, <t> for embedded tab anywhere in formula
		WHILE (charindex ('<n>', @sqlStmt) > 0)
			SELECT @sqlStmt = replace (@sqlStmt, '<n>', ''' + char(13) + char(10) + ''')

		WHILE (charindex ('<t>', @sqlStmt) > 0)
			SELECT @sqlStmt = replace (@sqlStmt, '<t>', ''' + char(9) + ''')

		-- support <[> and <]> to embed square brackets anywhere in formula
		WHILE (charindex ('<[>', @sqlStmt) > 0)
			SELECT @sqlStmt = replace (@sqlStmt, '<[>', '[')

		WHILE (charindex ('<]>', @sqlStmt) > 0)
			SELECT @sqlStmt = replace (@sqlStmt, '<]>', ']')

		-- support <{> and <}> to embed curly brackets anywhere in formula
		WHILE (charindex ('<{>', @sqlStmt) > 0)
			SELECT @sqlStmt = replace (@sqlStmt, '<{>', '{')

		WHILE (charindex ('<}>', @sqlStmt) > 0)
			SELECT @sqlStmt = replace (@sqlStmt, '<}>', '}')

		SELECT @sqlStmt = @sqlStmt + ' from ' + @inputSourceTable + ' where ' + @inputColumnName + ' = ' 
			+ '''' + convert (nvarchar(50), @inputColumnValue) + ''''

		CREATE TABLE #tmptbl (formattedOutput nvarchar(1000))
		INSERT INTO #tmptbl  exec (@sqlStmt)
		INSERT tempFormula (tempKey, tempValue) 
			SELECT @inputTempKey, formattedOutput FROM #tmptbl
	END
	ELSE
	BEGIN
		-- There are no field place-holders to process, so just return the formula
		INSERT tempFormula VALUES (@inputTempKey, @inputFormula)
	END

	SET NOCOUNT OFF

END -- create proc ProcessContactFormula

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_PurgeExpiredAnonymousCarts]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_PurgeExpiredAnonymousCarts]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_PurgeExpiredAnonymousCarts]
AS
BEGIN

    SET NOCOUNT ON

    -- calculate the purge date
    DECLARE @purgeDate datetime
    SET @purgeDate = DATEADD(DAY,-15,GETUTCDATE())

    -- delete Carts that only have a CreatedOn date
    DELETE
      FROM [dbo].[Cart]
     WHERE [CreatedOn] <= @purgeDate
           AND [UserId] = 'anonymous'
           AND [UpdatedOn] IS NULL

    -- delete Carts that have an UpdatedOn date
    DELETE 
      FROM [dbo].[Cart]
     WHERE [UpdatedOn] <= @purgeDate
           AND [UserId] = 'anonymous'

END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_PurgeInactiveCampaigns]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_PurgeInactiveCampaigns]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_PurgeInactiveCampaigns    Script Date: 7/3/2003 4:58:05 PM ******/
CREATE PROCEDURE [dbo].[asi_PurgeInactiveCampaigns] 

AS

declare @campaignKey uniqueidentifier
declare @appealKey uniqueidentifier
declare @solicitationKey uniqueidentifier
declare @sourceCodeKey uniqueidentifier
declare @campaignCode nvarchar(10)

set ROWCOUNT 1

--Select an inactive Campaign for deletion
SELECT @campaignKey = CampaignKey, @campaignCode = LegacyCampaignCode FROM vBoCampaign WHERE CampaignStatusCode = 1

while @@ROWCOUNT > 0
begin
	set ROWCOUNT 0
	--Start a transaction
	begin tran

	--Select an Appeal for deletion
	SELECT @appealKey = AppealKey FROM vBoAppeal WHERE CampaignKey = @campaignKey
	while @@ROWCOUNT > 0
	begin
		--Select a Solicitation for deletion
		SELECT @solicitationKey = SolicitationKey FROM vBoSolicitation WHERE AppealKey = @appealKey
		while @@ROWCOUNT > 0
		begin
			--Select a SourceCode for deletion
			SELECT @sourceCodeKey = SourceCodeKey FROM vBoSourceCode WHERE SolicitationKey = @solicitationKey
			while @@ROWCOUNT > 0
			begin
				--Delete related rows
				DELETE FROM ListItem WHERE ListKey = @sourceCodeKey
				DELETE FROM ListMain WHERE ListKey = @sourceCodeKey
				DELETE FROM SolicitationSource WHERE SourceCodeKey = @sourceCodeKey

				--Delete the Source Code
				DELETE FROM SourceCode WHERE SourceCodeKey = @sourceCodeKey
				DELETE FROM UniformRegistry WHERE UniformKey = @sourceCodeKey
				--Select the next Source Code for deletion
				SELECT @sourceCodeKey = SourceCodeKey FROM vBoSourceCode WHERE SolicitationKey = @solicitationKey
			end
			
			--Delete the Solicitation
			DELETE FROM SolicitationMain WHERE SolicitationKey = @solicitationKey
			DELETE FROM UniformRegistry WHERE UniformKey = @solicitationKey
			--Select the next Solicitation for deletion
			SELECT @solicitationKey = SolicitationKey FROM vBoSolicitation WHERE AppealKey = @appealKey
		end

		--Delete the Appeal
		DELETE FROM AppealMain WHERE AppealKey = @appealKey
		DELETE FROM UniformRegistry WHERE UniformKey = @appealKey
		--Select the next Appeal for deletion
		SELECT @appealKey = AppealKey FROM vBoAppeal WHERE CampaignKey = @campaignKey	
	end

	--Delete the Campaign
	DELETE FROM CampaignMain WHERE CampaignKey = @campaignKey
	DELETE FROM UniformRegistry WHERE UniformKey = @campaignKey
	DELETE FROM Campaign WHERE CAMPAIGN_CODE = @campaignCode
	
	--Finalize the transaction
	commit tran

	--Select the next inactive Campaign for deletion
	set ROWCOUNT 1
	SELECT @campaignKey = CampaignKey, @campaignCode = LegacyCampaignCode FROM vBoCampaign WHERE CampaignStatusCode = 1
end

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_PurgeInactiveSegmentationJobs]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_PurgeInactiveSegmentationJobs]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_PurgeInactiveSegmentationJobs    Script Date: 7/3/2003 4:58:05 PM ******/
CREATE PROCEDURE [dbo].[asi_PurgeInactiveSegmentationJobs] 

AS

DECLARE @jobKey uniqueidentifier
DECLARE @defKey uniqueIdentifier

SET ROWCOUNT  1

SELECT @jobKey = SegmentationJobKey FROM vBoSegmentationJob WHERE SegmentationJobStatusCode=1
while @@ROWCOUNT > 0
begin

	SET ROWCOUNT 1

	--Create a loop to delete all Segmentation Definitions associated with the selected Segmentation Job
	SELECT @defKey = SegmentDefinitionKey FROM vBoSegmentationDef WHERE SegmentationJobKey = @jobKey
	while @@ROWCOUNT > 0
	begin
		--Delete the rows that comprise the selected Segmentation Definition
		SET ROWCOUNT 0
		DELETE FROM ListItem WHERE ListKey = @defKey		
		DELETE FROM ListMain WHERE ListKey = @defKey
		DELETE FROM SegmentDefinition WHERE SegmentDefinitionKey = @defKey
		DELETE FROM UniformRegistry WHERE UniformKey = @defKey

		--Attempt to select the next Segmentation Definition for deletion
		SELECT @defKey = SegmentDefinitionKey FROM vBoSegmentationDef WHERE SegmentationJobKey = @jobKey
	end

	--Delete the rows that comprise the selected Segmentation Job
	DELETE FROM SegmentationJob WHERE SegmentationJobKey = @jobKey
	DELETE FROM UniformRegistry WHERE UniformKey = @jobKey

	--Attempt to select the next Segmentation Job for deletion		
	SELECT @jobKey = SegmentationJobKey FROM vBoSegmentationJob WHERE SegmentationJobStatusCode=1
 
end

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_QueryExportTypes]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_QueryExportTypes]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_QueryExportTypes    Script Date: 7/3/2003 4:58:05 PM ******/


/****** Object:  Stored Procedure dbo.asi_QueryExportTypes    Script Date: 6/13/2003 9:53:37 AM ******/
CREATE   PROC asi_QueryExportTypes
	AS
BEGIN
	select ExportTypeKey, ExportType, Name, NavMarker, ProcessEngineTypeKey from ExportType where IsQueryExport=1 order by Name
	
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ReApplyPayments]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ReApplyPayments]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE                                            PROCEDURE [dbo].[asi_ReApplyPayments]
@creditInvDistCreated bit = 0 output,
@debugging	bit = 0 --False
AS
DECLARE @pmtKey uniqueidentifier
DECLARE @srcInvoiceKey uniqueidentifier
DECLARE @srcInvLineKey uniqueidentifier
DECLARE @pmtAppKey uniqueidentifier
DECLARE @orderNumber nvarchar(50)
DECLARE @orderLineNumber int
DECLARE @paymentScheduleLineKey uniqueidentifier
DECLARE @paymentNumber int
DECLARE @dueDate datetime
DECLARE @amountDue decimal(18,4)
DECLARE @outstandingBalance decimal(18,4)
DECLARE @glAccountKey uniqueidentifier
DECLARE @invoiceKey uniqueidentifier
DECLARE @invoiceLineKey uniqueidentifier
DECLARE @invoiceKeyTarget uniqueidentifier
DECLARE @invoiceLineKeyTarget uniqueidentifier
DECLARE @pmtAmt decimal(18,4)
DECLARE @quantitySold decimal(18,4)
DECLARE @finUnitKey uniqueidentifier
DECLARE @incomeAcctKey uniqueidentifier
DECLARE @ARAcctKey uniqueidentifier
DECLARE @amtAppliedToParentLine decimal(18,4)
DECLARE @amtToApplyToDistLine decimal(18,4)
DECLARE @invDistKey uniqueidentifier
DECLARE @priority int
DECLARE @lineAmountRemaining decimal(18,4)
DECLARE @applicationAmtRemaining decimal(18,4)
DECLARE @extIncome decimal(18,4)
DECLARE @extIncomeRecognized decimal(18,4)
DECLARE @acctMethod nvarchar(50)
DECLARE @appliedTotal decimal(18,4)
DECLARE @applyingCredit bit
DECLARE @componentIncome decimal(18,4)
DECLARE @unitIncome decimal(18,4)
DECLARE @actualAmount decimal(18,4)
DECLARE @discountTaken decimal(18,4)
DECLARE @monetaryAppKey uniqueidentifier
DECLARE @appAmount decimal(18,4)
DECLARE @discountRemaining decimal(18,4)
DECLARE @proportionedDiscount decimal(18,4)
DECLARE @zeroApplication bit
DECLARE @amountToApplyToScheduleLine decimal(18,4)
DECLARE @amountToApplyToDistribution  decimal(18,4)
DECLARE @minOfScheduleLineDistributionAmounts decimal(18,4)
DECLARE @amountToApply  decimal(18,4)
DECLARE @applyToPaymentScheduleFirst bit
DECLARE @transactionType int
DECLARE @transactionDate datetime
DECLARE @batchKey uniqueidentifier
DECLARE @invoiceNumber nvarchar(50)
SET @zeroApplication = 0
SET @applicationAmtRemaining = 0
set @lineAmountRemaining = 0
SET @amtAppliedToParentLine = 0
SET @pmtAmt = 0
/*
Read through the payments applied (at the order, invoice, order line, or invoice line level).
For each one:
	1. Create cursors to iterate over PaymentScheduleLines and #tmpInvoice lines -- the details of the 
	   cursors depends on whether the distribution is being done to an Invoice, Order, InvoiceLine, 
	   or OrderLine.
	2. If we are applying to Invoice or Order ("normal" application):
		a) for each PaymentScheduleLine with unrecognized income:
			i)  Note how much needs to be paid
			ii) For each InvoiceDistribution line, where the GLAccount matches the PaymentScheduleLine:
				- figure out how much to apply.  Each application is made to both a schedule line and an
				  distribution line, so the amount of each application is the lesser of the amount owed
				  for the current schedule line and the amount for the current distribution line
	Get the invoice distribution lines, ordered by pay priority of the invoice lines, for the invoice.
	For each line:
		- Create a new payment application for the line, for an amount up to
		the the non-recognized total income.
		- Decrement the counter keeping track of how much of the original
		application has been re-applied.
		- Make sure to also re-apply the unearned income (DiscountTaken) amounts
	End
	Delete the original application line.

   04/14/05 - rrk - Allow zero-amount monetary applications to create sales history
   06/24/05 - rrk - Re-worked so that there are two methods of applying payments:
                    1) The "normal" way, which is to apply to the PaymentScheduleLines in numerical order.
                       For each PaymentScheduleLine application, we
   
*/
		
DECLARE Get_Pmts CURSOR FOR 
SELECT SrcPaymentKey, SrcInvoiceLineKey, ISNULL(Amount,0), MonetaryApplicationKey, ISNULL(AppliedAmount,0), OrderNumber,
OrderLineNumber,InvoiceKey,InvoiceLineKey,InvoiceDistributionKey, SrcInvoiceKey, DiscountTaken, 
TransactionDate, TransactionType, ApplicationBatchKey
FROM #tmpPayments
WHERE OrderNumber IS NOT NULL OR OrderLineNumber IS NOT NULL OR InvoiceKey IS NOT NULL OR InvoiceLineKey IS NOT NULL
ORDER BY OrderNumber asc, OrderLineNumber desc, PaymentTypePriority asc, InvoiceLineKey desc
OPEN Get_Pmts
FETCH NEXT FROM Get_Pmts INTO @pmtKey,@srcInvLineKey, @pmtAmt,@pmtAppKey, @amtAppliedToParentLine,
@orderNumber, @orderLineNumber, @invoiceKey, @invoiceLineKey, @invDistKey, @srcInvoiceKey, @discountTaken,
@transactionDate, @transactionType, @batchKey
WHILE @@FETCH_STATUS = 0
BEGIN
   /* IF @amtAppliedToParentLine = 0
	    SET @zeroApplication = 1
    ELSE
	    SET @zeroApplication = 0 */
	SET @zeroApplication = 0
	
	SET @actualAmount = @amtAppliedToParentLine - @discountTaken
	SET @applicationAmtRemaining = @actualAmount
	SET @discountRemaining = @discountTaken
	IF @invDistKey is not null
		GOTO nextPmtApp
	
		
	IF @invoiceKey is not null AND @invoiceLineKey is null
	BEGIN
		-- Create cursors to iterate over PaymentScheduleLines and InvoiceDistributions, based on 
		-- invoice key.
		SET @applyToPaymentScheduleFirst = 1
		DECLARE ApplyToScheduleLines CURSOR FOR
			SELECT PaymentScheduleLineKey, PaymentNumber, DueDate, AmountDue, OutstandingBalance, GLAccountKey
			FROM PaymentScheduleLine psl
			INNER JOIN InvoiceMain im on psl.InvoiceKey = im.InvoiceKey
			WHERE im.InvoiceKey =  @invoiceKey AND OutstandingBalance > 0
			ORDER BY PaymentNumber ASC, PayPriority ASC
		
	    DECLARE ApplyToDistributionLines cursor for
			SELECT InvoiceKey, InvoiceLineKey, InvoiceDistributionKey, ISNULL(ExtendedIncome,0), ISNULL(ExtendedIncomeRecognized,0), AccountingMethodCode, AppliedTotal, ApplyingCredit, QuantitySold, FinancialEntityKey, IncomeGLAccountKey, ARGLAccountKey, UnitIncome, OrderLineNumber, InvoiceNumber
			FROM #tmpInvoice
			WHERE #tmpInvoice.InvoiceKey =  @invoiceKey
			ORDER BY PayPriority ASC
	END
	ELSE IF @orderNumber is not null AND LEN(@orderNumber) > 0 AND (@orderLineNumber is null OR @orderLineNumber <= 0)
	BEGIN
		SET @applyToPaymentScheduleFirst = 1
		-- Create cursors to iterate over PaymentScheduleLines and InvoiceDistributions, based on 
		-- invoice key.
		DECLARE ApplyToScheduleLines CURSOR FOR
			SELECT PaymentScheduleLineKey, PaymentNumber, DueDate, AmountDue, OutstandingBalance, GLAccountKey
			FROM  PaymentScheduleLine psl
			INNER JOIN InvoiceMain im on psl.InvoiceKey = im.InvoiceKey
			WHERE im.OrderNumber = @orderNumber AND OutstandingBalance > 0
			ORDER BY PaymentNumber ASC, PayPriority ASC
		
	    DECLARE ApplyToDistributionLines cursor for
			SELECT InvoiceKey, InvoiceLineKey, InvoiceDistributionKey, ISNULL(ExtendedIncome,0), ISNULL(ExtendedIncomeRecognized,0), AccountingMethodCode, AppliedTotal, ApplyingCredit, QuantitySold, FinancialEntityKey, IncomeGLAccountKey, ARGLAccountKey, UnitIncome, OrderLineNumber, InvoiceNumber
			FROM #tmpInvoice
			WHERE OrderNumber = @orderNumber
			ORDER BY PayPriority ASC
	END
	ELSE IF @invoiceLineKey is not null 
	BEGIN
		SET @applyToPaymentScheduleFirst = 0
		SELECT @componentIncome = SUM(ISNULL(ExtendedIncome,0)) from #tmpInvoice
		WHERE ParentInvoiceLineKey = @invoiceLineKey
		IF @componentIncome > 0
		BEGIN
			DECLARE GetApplyToLines cursor for
				SELECT InvoiceKey, InvoiceLineKey, InvoiceDistributionKey, PayPriority, ISNULL(ExtendedIncome,0), ISNULL(ExtendedIncomeRecognized,0), AccountingMethodCode, AppliedTotal, ApplyingCredit, QuantitySold, FinancialEntityKey, IncomeGLAccountKey, ARGLAccountKey, UnitIncome, OrderLineNumber, InvoiceNumber
				FROM #tmpInvoice
				WHERE ParentInvoiceLineKey = @invoiceLineKey
				ORDER BY PayPriority ASC
		END
		ELSE
		BEGIN
			DECLARE GetApplyToLines cursor for
				SELECT InvoiceKey, InvoiceLineKey, InvoiceDistributionKey, PayPriority, ISNULL(ExtendedIncome,0), ISNULL(ExtendedIncomeRecognized,0), AccountingMethodCode, AppliedTotal, ApplyingCredit, QuantitySold, FinancialEntityKey, IncomeGLAccountKey, ARGLAccountKey, UnitIncome, OrderLineNumber, InvoiceNumber
				FROM #tmpInvoice
				WHERE InvoiceLineKey = @invoiceLineKey
				ORDER BY PayPriority ASC
		END
		DECLARE ApplyToScheduleLines CURSOR FOR
			SELECT PaymentScheduleLineKey, PaymentNumber, DueDate, AmountDue, OutstandingBalance, GLAccountKey
			FROM  InvoiceLine il
			INNER JOIN PaymentScheduleLine psl on psl.InvoiceKey = il.InvoiceKey
			WHERE il.InvoiceLineKey = @invoiceLineKey AND OutstandingBalance > 0
			ORDER BY psl.PaymentNumber ASC, psl.PayPriority ASC
	END
	ELSE IF @orderLineNumber is not null AND @orderLineNumber > 0
	BEGIN
		SET @applyToPaymentScheduleFirst = 0
		SELECT @componentIncome = SUM(ISNULL(ExtendedIncome,0)) from #tmpInvoice
		WHERE ParentInvoiceLineKey in
		(SELECT InvoiceLineKey
		FROM #tmpInvoice WHERE OrderLineNumber = @orderLineNumber AND OrderNumber = @orderNumber)
		IF @componentIncome > 0
		BEGIN
			DECLARE GetApplyToLines cursor for
				SELECT InvoiceKey, InvoiceLineKey, InvoiceDistributionKey, PayPriority, ISNULL(ExtendedIncome,0), ISNULL(ExtendedIncomeRecognized,0), AccountingMethodCode, AppliedTotal, ApplyingCredit, QuantitySold, FinancialEntityKey, IncomeGLAccountKey, ARGLAccountKey, UnitIncome, @orderLineNumber, InvoiceNumber
				FROM #tmpInvoice
				WHERE ParentInvoiceLineKey in
				(SELECT InvoiceLineKey FROM #tmpInvoice WHERE OrderLineNumber = @orderLineNumber AND OrderNumber = @orderNumber)
				ORDER BY PayPriority ASC
		END
		ELSE
		BEGIN
			DECLARE GetApplyToLines cursor for
				SELECT InvoiceKey, InvoiceLineKey, InvoiceDistributionKey, PayPriority, ISNULL(ExtendedIncome,0), ISNULL(ExtendedIncomeRecognized,0), AccountingMethodCode, AppliedTotal, ApplyingCredit, QuantitySold, FinancialEntityKey, IncomeGLAccountKey, ARGLAccountKey, UnitIncome, @orderLineNumber, InvoiceNumber
				FROM #tmpInvoice
				WHERE OrderLineNumber = @orderLineNumber  AND OrderNumber = @orderNumber
				ORDER BY PayPriority ASC
		END
		DECLARE ApplyToScheduleLines CURSOR FOR
			SELECT PaymentScheduleLineKey, PaymentNumber, DueDate, AmountDue, OutstandingBalance, GLAccountKey
			FROM  InvoiceLine il
			INNER JOIN PaymentScheduleLine psl on psl.InvoiceKey = il.InvoiceKey
			WHERE il.InvoiceLineKey in 
				(SELECT InvoiceLineKey from #tmpInvoice 
					WHERE OrderLineNumber = @orderLineNumber)
				AND OutstandingBalance > 0
			ORDER BY psl.PaymentNumber ASC, psl.PayPriority ASC
	END
	ELSE 
		GOTO nextPmtApp
		
	IF 	@applyToPaymentScheduleFirst = 1
	BEGIN
		/* Method 1: apply to payment schedule lines in order, and then to distributions.
		*/
		OPEN ApplyToScheduleLines
		FETCH next from ApplyToScheduleLines into
			@paymentScheduleLineKey, @paymentNumber, @dueDate, @amountDue, @outstandingBalance, @glAccountKey
		WHILE @@FETCH_STATUS = 0 AND (ABS(@applicationAmtRemaining) > 0 OR ABS(@discountRemaining) > 0 OR @zeroApplication = 1)
		BEGIN
			SET @amountToApplyToScheduleLine = @outstandingBalance
				
 			OPEN ApplyToDistributionLines
			FETCH next from ApplyToDistributionLines into
				@invoiceKeyTarget, @invoiceLineKeyTarget, @invDistKey, @extIncome, @extIncomeRecognized, @acctMethod, 
				@appliedTotal, @applyingCredit, @quantitySold, @finUnitKey, @incomeAcctKey, @ARAcctKey, 
				@unitIncome, @orderLineNumber, @invoiceNumber
			WHILE @@FETCH_STATUS = 0 AND 
				@amountToApplyToScheduleLine > 0 AND 
				(ABS(@applicationAmtRemaining) > 0 OR ABS(@discountRemaining) > 0 OR @zeroApplication = 1)
			BEGIN
				IF @invDistKey is null OR @ARAcctKey != @glAccountKey
					GOTO FetchNextDistribution
			
				IF @applicationAmtRemaining > 0 OR @discountRemaining > 0
					SET @amountToApplyToDistribution = @extIncome - @appliedTotal
				ELSE    /* (@applicationAmtRemaining < 0 OR @discountRemaining < 0 - this is a negative payment) */
					SET @amountToApplyToDistribution = @appliedTotal
				
				/* nothing more to do with this distribution */
				IF @amountToApplyToDistribution = 0
					GOTO FetchNextDistribution
				
				/* find the minium of schedule line and distribution amounts */
				IF ABS(@amountToApplyToScheduleLine) <= ABS(@amountToApplyToDistribution)
					SET @minOfScheduleLineDistributionAmounts = @amountToApplyToScheduleLine
				ELSE
					SET @minOfScheduleLineDistributionAmounts = @amountToApplyToDistribution
									
				SET @amountToApply = @minOfScheduleLineDistributionAmounts
			
				IF ABS(@applicationAmtRemaining) < ABS(@amountToApply)
					SET @amountToApply = @applicationAmtRemaining
				
				
				/* Handle early payment discounts */
				IF ABS(@discountRemaining) > 0		/* (could be a reversal of discount - on a negative pmt) */
				BEGIN
					IF @discountRemaining > 0
						SET @proportionedDiscount = @minOfScheduleLineDistributionAmounts - @amountToApply
					ELSE /* (negative / reversal of discount... - note that this is assuming a zero or negative amount being applied by @amtToApplyToDistLine) */
						SET @proportionedDiscount = -1 * (@minOfScheduleLineDistributionAmounts + @amountToApply)
					IF ABS(@proportionedDiscount) > ABS(@discountRemaining)
						SET @proportionedDiscount = @discountRemaining
			
					SET @discountRemaining = @discountRemaining - @proportionedDiscount
				END
				ELSE
					SET @proportionedDiscount = 0	
					
		
				INSERT MonetaryApplication
					(MonetaryApplicationKey, SrcPaymentKey, SrcInvoiceLineKey, Amount, InvoiceKey, InvoiceLineKey, 
						InvoiceDistributionKey, DiscountTaken, OrderNumber, OrderLineNumber, PaymentScheduleLineKey,
						TransactionDate, TransactionType, BatchKey, InvoiceNumber)
				VALUES (NEWID(), @pmtKey, @srcInvLineKey, @amountToApply, @invoiceKeyTarget, @invoiceLineKeyTarget, 
						@invDistKey, @proportionedDiscount, @orderNumber, @orderLineNumber, @paymentScheduleLineKey,
						@transactionDate, @transactionType, @batchKey, @invoiceNumber)
				SET @applicationAmtRemaining = @applicationAmtRemaining - @amountToApply
				SET @amountToApplyToScheduleLine = @amountToApplyToScheduleLine - @amountToApply
				UPDATE #tmpInvoice SET AppliedTotal = AppliedTotal + @amountToApply
					WHERE InvoiceDistributionKey = @invDistKey
				UPDATE PaymentScheduleLine SET OutstandingBalance = OutstandingBalance - (@amountToApply + @proportionedDiscount)
					WHERE PaymentScheduleLineKey = @paymentScheduleLineKey
				
				FetchNextDistribution:
				FETCH next from ApplyToDistributionLines into
					@invoiceKeyTarget, @invoiceLineKeyTarget, @invDistKey, @extIncome, @extIncomeRecognized, @acctMethod, 
					@appliedTotal, @applyingCredit, @quantitySold, @finUnitKey, @incomeAcctKey, @ARAcctKey,
					@unitIncome, @orderLineNumber, @invoiceNumber
			END
			CLOSE ApplyToDistributionLines
		
			FETCH next from ApplyToScheduleLines into
				@paymentScheduleLineKey, @paymentNumber, @dueDate, @amountDue, @outstandingBalance, @glAccountKey
		END
		CLOSE ApplyToScheduleLines
		DEALLOCATE ApplyToScheduleLines
		DEALLOCATE ApplyToDistributionLines
	
	END
	ELSE
	BEGIN
		/* Method 2: apply to distributions by invoice line, then to payment schedule lines
		*/
		OPEN GetApplyToLines
		FETCH next from GetApplyToLines into
		@invoiceKeyTarget, @invoiceLineKeyTarget, @invDistKey, @priority, @extIncome, @extIncomeRecognized, @acctMethod, @appliedTotal, @applyingCredit, @quantitySold, @finUnitKey, @incomeAcctKey, @ARAcctKey, @unitIncome, @orderLineNumber, @invoiceNumber
			/* These will be ordered by pay priority... */
		WHILE @@FETCH_STATUS = 0 AND (ABS(@applicationAmtRemaining) > 0 OR ABS(@discountRemaining) > 0 OR @zeroApplication = 1)
		BEGIN
			IF @invDistKey is null
				GOTO nextApplyToLine
					
			OPEN ApplyToScheduleLines
			FETCH next from ApplyToScheduleLines into
				@paymentScheduleLineKey, @paymentNumber, @dueDate, @amountDue, @outstandingBalance, @glAccountKey
			WHILE @@FETCH_STATUS = 0
			BEGIN
			
				IF @applicationAmtRemaining > 0 OR @discountRemaining > 0
					SET @lineAmountRemaining = @extIncome - @appliedTotal
				ELSE    /* (@applicationAmtRemaining < 0 OR @discountRemaining < 0 - this is a negative payment) */
					SET @lineAmountRemaining = @appliedTotal
			
				IF @lineAmountRemaining <=0 AND @zeroApplication = 0 
					GOTO nextApplyToLine   /* can't apply any amount(s) to this line... */
				/*
				   If the distribution line amount yet to be applied is greater than or equal to 
				   (in absolute value) the payment being applied, then we can apply *all* of the 
				   payment being applied  so init the "amount to apply to the distribution line"
				   to the entire payment being applied.
				*/	
				IF @lineAmountRemaining >= ABS(@applicationAmtRemaining)
					SET @amtToApplyToDistLine = @applicationAmtRemaining
				ELSE
				/*
					Otherwise, the distribution line amount yet to be applied is less than 
					(in absolute value) the payment being applied, so we can only apply 
					some of the payment
				*/
				BEGIN
					SET @amtToApplyToDistLine = @lineAmountRemaining
					IF @applicationAmtRemaining < 0
						SET @amtToApplyToDistLine = -1 * @amtToApplyToDistLine
				END
				
			
				IF @outstandingBalance < @amtToApplyToDistLine
					SET @amtToApplyToDistLine = @outstandingBalance
				
					/* Handle early payment discounts */
				IF ABS(@discountRemaining) > 0		/* (could be a reversal of discount - on a negative pmt) */
				BEGIN
					IF @discountRemaining > 0
						SET @proportionedDiscount = @lineAmountRemaining - @amtToApplyToDistLine
					ELSE /* (negative / reversal of discount... - note that this is assuming a zero or negative amount being applied by @amtToApplyToDistLine) */
						SET @proportionedDiscount = -1 * (@lineAmountRemaining + @amtToApplyToDistLine)
					IF ABS(@proportionedDiscount) > ABS(@discountRemaining)
						SET @proportionedDiscount = @discountRemaining
			
					SET @discountRemaining = @discountRemaining - @proportionedDiscount
				END
				ELSE
					SET @proportionedDiscount = 0
				
			
				INSERT MonetaryApplication
					(MonetaryApplicationKey, SrcPaymentKey, SrcInvoiceLineKey, Amount, InvoiceKey, InvoiceLineKey, 
					InvoiceDistributionKey, DiscountTaken, OrderNumber, OrderLineNumber, PaymentScheduleLineKey,
					TransactionDate, TransactionType, BatchKey, InvoiceNumber)
					VALUES (NEWID(), @pmtKey, @srcInvLineKey, @amtToApplyToDistLine, @invoiceKeyTarget, @invoiceLineKeyTarget, 
					@invDistKey, @proportionedDiscount, @orderNumber, @orderLineNumber, @paymentScheduleLineKey,
					@transactionDate, @transactionType, @batchKey, @invoiceNumber)
				SET @applicationAmtRemaining = @applicationAmtRemaining - @amtToApplyToDistLine
				-- update the amount of this distribution we applied to this schedule line
				SET @appliedTotal = @appliedTotal + @amtToApplyToDistLine
				UPDATE #tmpInvoice SET AppliedTotal = AppliedTotal + @amtToApplyToDistLine
					WHERE InvoiceDistributionKey = @invDistKey
				UPDATE PaymentScheduleLine SET OutstandingBalance = OutstandingBalance - (@amtToApplyToDistLine + @proportionedDiscount)
					WHERE PaymentScheduleLineKey = @paymentScheduleLineKey
				/* If this 'payment' line is actually a credit invoice line being applied, we need to insert a distribution line for the */
				/* credit invoice line to correspond to the amount being applied to the target invoice distribution line. */
				IF @applyingCredit = 1 AND @amtToApplyToDistLine != 0
				BEGIN
					SET @creditInvDistCreated = 1
					INSERT InvoiceDistribution (InvoiceDistributionKey, InvoiceKey, InvoiceLineKey, QuantitySold,
					FinancialEntityKey, UnitIncome, ExtendedIncome, ExtendedIncomeRecognized, IncomeGLAccountKey, ARGLAccountKey)
					VALUES (NEWID(), @srcInvoiceKey, @srcInvLineKey, @quantitySold, @finUnitKey, -1 * @unitIncome, -1 * @amtToApplyToDistLine, 0, @incomeAcctKey, @ARAcctKey)
				END
				FETCH next from ApplyToScheduleLines into
					@paymentScheduleLineKey, @paymentNumber, @dueDate, @amountDue, @outstandingBalance, @glAccountKey
			END
			CLOSE ApplyToScheduleLines
			nextApplyToLine:
			FETCH next from GetApplyToLines into
			@invoiceKeyTarget, @invoiceLineKeyTarget, @invDistKey, @priority, @extIncome, @extIncomeRecognized, @acctMethod, @appliedTotal, @applyingCredit, @quantitySold, @finUnitKey, @incomeAcctKey, @ARAcctKey, @unitIncome, @orderLineNumber, @invoiceNumber
		END
		CLOSE GetApplyToLines
		DEALLOCATE GetApplyToLines
		DEALLOCATE ApplyToScheduleLines
	END
	-- -------------------------------------------------------------
	
	IF ABS(@applicationAmtRemaining) <= 0 AND ABS(@discountRemaining) <= 0
		DELETE FROM MonetaryApplication WHERE MonetaryApplicationKey = @pmtAppKey
	ELSE IF ABS(@applicationAmtRemaining) < ABS(@actualAmount) OR ABS(@discountRemaining) < ABS(@discountTaken)
		UPDATE MonetaryApplication SET Amount = @applicationAmtRemaining, DiscountTaken = @discountRemaining WHERE MonetaryApplicationKey = @pmtAppKey
nextPmtApp:
FETCH NEXT FROM Get_Pmts INTO @pmtKey,@srcInvLineKey, @pmtAmt,@pmtAppKey, @amtAppliedToParentLine,
@orderNumber, @orderLineNumber, @invoiceKey, @invoiceLineKey, @invDistKey, @srcInvoiceKey, @discountTaken,
@transactionDate, @transactionType, @batchKey
END
CLOSE Get_Pmts
DEALLOCATE Get_Pmts
IF @debugging = 1
BEGIN
PRINT 'MonetaryApplication: '
SELECT * from MonetaryApplication
END  --IF @debugging

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_RebuildCounters]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_RebuildCounters]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =================================================
-- Author:		Paul Bradshaw
-- Create date: 29-Nov-2006
-- Description:	Resets all the counters in the 
--              Counter table, based on the values
--				in the appropriate tables
-- =================================================
CREATE PROCEDURE [dbo].[asi_RebuildCounters]
AS
BEGIN
	SET NOCOUNT ON;
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Activity'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(SEQN), 1) FROM Activity), LAST_UPDATED = getdate(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Activity'
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Activity_Attach'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(ATTACH_SEQN), 1) FROM Activity_Attach), LAST_UPDATED = getdate(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Activity_Attach'
	END
	------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Batch' AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
    BEGIN
        IF EXISTS (SELECT 1 FROM System_Params WHERE ParameterName = 'AR_Control.UseBatches' AND ShortValue = '2')
        BEGIN
            IF EXISTS (SELECT 1 FROM System_Params WHERE ParameterName = 'IgnoreNonNumericBatchNumbersForCounter' AND ShortValue <> '0')
            BEGIN
                UPDATE [dbo].[Counter] 
                   SET [LAST_VALUE] = (SELECT MAX(COALESCE (CASE WHEN ISNUMERIC(BATCH_NUM) = 1 THEN CONVERT(bigint, BATCH_NUM) ELSE 0 END, 1)) 
                                         FROM Batch), 
                       [LAST_UPDATED] = GETDATE(), [UPDATED_BY] = 'MANAGER'
                 WHERE [COUNTER_NAME] = 'Batch'
            END
            ELSE
            BEGIN
                UPDATE [dbo].[Counter] 
                   SET [LAST_VALUE] = (SELECT COALESCE (MAX(CAST(SUBSTRING([BATCH_NUM], 1, CASE WHEN CHARINDEX('-', [BATCH_NUM]) > 0 THEN CHARINDEX('-', [BATCH_NUM])- 1 ELSE LEN([BATCH_NUM]) END) AS bigint)), 1) 
                                         FROM Batch 
                                        WHERE SUBSTRING([BATCH_NUM], 1, CASE WHEN CHARINDEX('-', [BATCH_NUM]) > 0 THEN CHARINDEX('-', [BATCH_NUM])- 1 ELSE LEN([BATCH_NUM]) END) NOT LIKE '%[^0-9]%'), 
                       [LAST_UPDATED] = GETDATE(), [UPDATED_BY] = 'MANAGER'
                 WHERE [COUNTER_NAME] = 'Batch'
            END
        END
    END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Cert_Register'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(SEQN), 1) FROM Cert_Register), LAST_UPDATED = getdate(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Cert_Register'
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Cmty_Discussion_Forums'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(FORUM_SEQ), 1) FROM Cmty_Discussion_Forums), LAST_UPDATED = getdate(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Cmty_Discussion_Forums'
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Cmty_Discussion_Posts'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(POST_SEQ), 1) FROM Cmty_Discussion_Posts), LAST_UPDATED = getdate(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Cmty_Discussion_Posts'
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Cmty_Discussion_Posts'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(TOPIC_SEQ), 1) FROM Cmty_Discussion_Posts), LAST_UPDATED = getdate(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Cmty_Discussion_Topics'
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Cmty_Discussion_Forums'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(FORUM_SEQ), 1) FROM Cmty_Discussion_Forums), LAST_UPDATED = getdate(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Cmty_Forum'
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Cmty_News'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(NEWS_SEQ), 1) FROM Cmty_News), LAST_UPDATED = getdate(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Cmty_News'
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Cmty_Shared_Files'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(FILE_SEQ), 1) FROM Cmty_Shared_Files), LAST_UPDATED = getdate(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Cmty_Shared_Files'
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Cmty_Shared_Folders'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(FOLDER_SEQ), 1) FROM Cmty_Shared_Folders), LAST_UPDATED = getdate(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Cmty_Shared_Folders'
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Comment_Log'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(COMMENT_LOG_NUM), 1) FROM Comment_Log), LAST_UPDATED = getdate(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Comment_Log'
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Community'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(COMMUNITY_SEQ), 1) FROM Community), LAST_UPDATED = getdate(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Community'
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Content_Pages'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(PAGE_NUM), 1) FROM Content_Pages), LAST_UPDATED = getdate(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Content_Pages'
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Country_Addr_Layouts'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(ADDRESS_FORMAT), 1) FROM Country_Addr_Layouts), LAST_UPDATED = getdate(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Country_Addr_Layouts'
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Exhb_Form_Master'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (COALESCE((SELECT MAX(CAST(SEQN AS INT)) 
										             FROM (SELECT FORM_ID as SEQN FROM Exhb_Form_Master WHERE ISNUMERIC(FORM_ID) = 1 
										           UNION 
											       SELECT PRODUCT_ID as SEQN FROM Exhb_Prod_Mast WHERE ISNUMERIC(PRODUCT_ID) = 1) AS Q
										), 0)), LAST_UPDATED = getdate(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Exhb_Form_Master'
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'ExpenseItem'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(EXPENSE_SEQN), 1) FROM ExpenseItem), LAST_UPDATED = getdate(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Expense'
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Hotel_Log'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(HOTEL_LOG_NUMBER), 1) FROM Hotel_Log), LAST_UPDATED = getdate(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'HotelLog'
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Invoice'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(INVOICE_NUM), 1) FROM Invoice), LAST_UPDATED = getdate(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Invoice'
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Invoice'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(REFERENCE_NUM), 1) FROM Invoice), LAST_UPDATED = getdate(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Invoice_Ref'
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(Trans.INVOICE_REFERENCE_NUM), 1) FROM Trans), LAST_UPDATED = getdate(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Invoice_Ref' AND (SELECT COALESCE(MAX(Trans.INVOICE_REFERENCE_NUM), 1) FROM Trans) > LAST_VALUE		
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Job_Record'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(JobId), 1) FROM Job_Record), LAST_UPDATED = getdate(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Job_Record'
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Name'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(CAST(ID AS INT)), 1) FROM [Name] WHERE ISNUMERIC(ID) = 1), LAST_UPDATED = getdate(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Name'
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Name_Address'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(ADDRESS_NUM), 1) FROM Name_Address), LAST_UPDATED = getdate(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Name_Address'
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Name_MatchPlan'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(SEQN), 1) FROM Name_MatchPlan), LAST_UPDATED = getdate(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Name_MatchPlan'
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Name_Note'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(NOTE_NUM), 1) FROM Name_Note), LAST_UPDATED = getdate(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Name_Note'
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Name_Picture'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(PICTURE_NUM), 1) FROM Name_Picture), LAST_UPDATED = getdate(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Name_Picture'
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Orders'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(ORDER_NUMBER), 1) FROM Orders), LAST_UPDATED = getdate(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Orders'
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Product_Kit'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(SEQN), 1) FROM Product_Kit), LAST_UPDATED = getdate(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Product_Kit'
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Product_Substitute'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(SEQN), 1) FROM Product_Substitute), LAST_UPDATED = getdate(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Product_Substitute'
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Product_Trans'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(PTRANS_NUMBER), 1) FROM Product_Trans), LAST_UPDATED = getdate(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Product_Trans'
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Product_Trans'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(TRANS_GROUP_NUMBER), 1) FROM Product_Trans), LAST_UPDATED = getdate(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'ProductGroupTrans'
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Prospect'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COUNT(1) FROM Prospect), LAST_UPDATED = getdate(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Prospect'
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Receipt'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(Auto_Receipt_Num), 1) FROM Receipt), LAST_UPDATED = GETDATE(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Receipt'
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Receipt'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(ID), 1) FROM Receipt), LAST_UPDATED = GETDATE(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Receipt_ID'
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Ref_Client'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(CAST(CLIENT_ID AS int)), 1) FROM Ref_Client WHERE ISNUMERIC(CLIENT_ID) = 1), LAST_UPDATED = GETDATE(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Ref_Client'
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Referral'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(CAST(REFERRAL_ID AS int)), 1) FROM Referral WHERE ISNUMERIC(REFERRAL_ID) = 1), LAST_UPDATED = GETDATE(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Referral'
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Relationship'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(SEQN), 1) FROM Relationship), LAST_UPDATED = GETDATE(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Relationship'
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Service_Request'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(CAST(ServiceReference AS int)), 1) FROM Service_Request WHERE ISNUMERIC(ServiceReference) = 1), LAST_UPDATED = GETDATE(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Service_Request'
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Stored_List'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(NumberSequence), 1) FROM Stored_List), LAST_UPDATED = GETDATE(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Stored_List'
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Trans'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(TRANS_NUMBER), 1) FROM Trans), LAST_UPDATED = GETDATE(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'Trans'
	END
	------------------------------------------------------------------------------
	IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'User_Tab_Pref_Detail'
			   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
	BEGIN
		UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(PREF_ID), 1) - 1 FROM User_Tab_Pref_Detail), LAST_UPDATED = GETDATE(), UPDATED_BY = 'MANAGER'
		WHERE COUNTER_NAME = 'TabProfile'
	END
	------------------------------------------------------------------------------

	-- Now set the counters for any User Defined Tables
	DECLARE @tableName nvarchar(50)
	DECLARE @sql nvarchar(1000)
	DECLARE theCursor CURSOR FORWARD_ONLY FOR
		SELECT TABLE_NAME FROM UD_Table WHERE ALLOW_MULTIPLE_INSTANCES = 1

	OPEN theCursor
	FETCH NEXT FROM theCursor INTO @tableName
	WHILE (@@FETCH_STATUS = 0)
	BEGIN
		IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = @tableName
				   AND TABLE_SCHEMA = 'dbo' AND TABLE_TYPE = 'BASE TABLE')
		BEGIN
			SET @sql = 'UPDATE Counter SET LAST_VALUE = (SELECT COALESCE(MAX(SEQN), 1) FROM ' +
					   @tableName + '), LAST_UPDATED = getdate(), UPDATED_BY = ''MANAGER''
			WHERE COUNTER_NAME = ''' + @tableName + ''''

			EXEC (@sql)
		END
		FETCH NEXT FROM theCursor INTO @tableName
	END
	CLOSE theCursor
	DEALLOCATE theCursor
END



GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_SetNameAllViewPermissions]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_SetNameAllViewPermissions]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- Author:		Paul Bradshaw
-- Create date: Jan 30th, 2007
-- Description:	Set Name_All View permissions
-- =============================================
CREATE PROCEDURE asi_SetNameAllViewPermissions 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	GRANT INSERT, DELETE, REFERENCES, SELECT, UPDATE ON Name_All TO IMIS
END

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_RebuildNameAllView]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_RebuildNameAllView]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- Author:		Paul Bradshaw
-- Create date: Jan 30th, 2007
-- Description:	Rebuild Name_All View
-- =============================================
CREATE PROCEDURE asi_RebuildNameAllView 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	EXEC asi_DropNameAllView
	EXEC asi_BuildNameAllView
	EXEC asi_SetNameAllViewPermissions
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_RenameTable]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_RenameTable]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_RenameTable] @oldTableName nvarchar(512), @newTableName nvarchar(512) AS
BEGIN
	DECLARE @oldName nvarchar(512)
	DECLARE @newName nvarchar(512)
	DECLARE @type nvarchar(6)

	-- cursor gets all of the children of table and renames them too
	DECLARE GetChildren CURSOR FOR
	SELECT [name], 'OBJECT'
	  FROM sysobjects
	 WHERE parent_obj = OBJECT_ID(@oldTableName)
	   AND xtype = 'D' AND [name] IS NOT NULL
	UNION
	SELECT [name], 'INDEX'
	  FROM sysindexes
	 WHERE id = OBJECT_ID(@oldTableName) AND keycnt != 0 
	       AND [name] IS NOT NULL AND ([name] NOT LIKE '_WA_Sys%' AND name NOT LIKE '_dta_stat%')

	OPEN GetChildren

	FETCH GetChildren INTO @oldName, @type

	-- rename all of the table's child objects (keys, indexes, constraints)
	WHILE @@FETCH_STATUS = 0
	BEGIN
		SET @newName = REPLACE(@oldName, @oldTableName, @newTableName)
		IF @newName = @oldName OR @newName IS NULL
			SET @newName = @oldName + '_OLD'

		-- renaming index has to have old table name and [ ] around column to avoid ambiguity
		IF @type = 'INDEX'
			SET @oldName = @oldTableName + '.' + '[' + @oldName + ']' 

		PRINT 'sp_rename ''' + @oldName + ''', ''' + @newName + ''',''' + @type + ''''
		EXEC ('sp_rename ''' + @oldName + ''', ''' + @newName + ''',''' + @type + '''')

		FETCH GetChildren INTO @oldName, @type
	END

	CLOSE GetChildren
	DEALLOCATE GetChildren

	-- finally, rename the able itself
	EXEC ('sp_rename ''' + @oldTableName + ''', ''' + @newTableName + ''',''OBJECT''')
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ResultPage]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ResultPage]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_ResultPage    Script Date: 7/3/2003 4:58:05 PM ******/



CREATE    proc [dbo].[asi_ResultPage]
            @select nvarchar(4000),
            @offset int = 0,
            @pageSize int = 10,
            @returnRowCount bit = 0 As
begin
-- ***************************************************************************************
-- Declare variables
-- ***************************************************************************************
declare @countSelect nvarchar(4000)
declare @limiter int
declare @posFrom int
declare @posOrderBy int
declare @posSelectList int
declare @tmp nvarchar(4000)
declare @tmpTable char(38)
-- <SQL_7>
declare @tmpTable2 char(38)
-- </SQL_7>
declare @tmpTable3 char(38)
declare @upperSelect nvarchar(4000)
-- ***************************************************************************************
-- Calculate Limiter Value
-- ***************************************************************************************
set @limiter = 500
if (@offset) >= (@limiter - @pageSize)
begin
set @limiter = @offset + (@pageSize * 2)
end
-- ***************************************************************************************
-- Name Temp Tables
-- ***************************************************************************************
set @tmpTable = N'#z' + replace(cast(newid() As nchar(36)),N'-',N'')
-- <SQL_7> 
set @tmpTable2 = N'#z' + replace(cast(newid() As nchar(36)),N'-',N'')
-- </SQL_7>
set @tmpTable3 = N'#z' + replace(cast(newid() as nchar(36)),N'-',N'')
-- ***************************************************************************************
-- Clean up select statement
-- ***************************************************************************************
set @select = ltrim(@select)
set @select = replace(@select,nchar(9),N' ')
set @select = replace(@select,nchar(10),N' ')
set @select = replace(@select,nchar(13),N' ')
-- ***************************************************************************************
-- Convert to uppercase for pattern searching
-- ***************************************************************************************
set @upperSelect = upper(@select)
-- ***************************************************************************************
-- Find position of first item to be displayed in resultset
-- ***************************************************************************************
if charindex(' DISTINCT ', @upperSelect) = 0 
begin 
	set @posSelectList = charindex(N' ', @upperSelect) + 1 
end
else 
begin 
	set @posSelectList = charindex(N' DISTINCT ', @upperSelect) + 10 
end
-- ***************************************************************************************
-- Find position of first object in from clause
-- ***************************************************************************************
set @posFrom = charindex(N' FROM ', @upperSelect)
-- ***************************************************************************************
-- Find position order by clause
-- ***************************************************************************************
set @posOrderBy = charindex(N' ORDER BY ', @upperSelect)
-- ***************************************************************************************
-- Copy select statment without the order by clause to be used for returning a count
-- ***************************************************************************************
set @countSelect = @select
if  @posOrderBy > 0 
begin 
	set @countSelect = left(@countSelect, @posOrderBy) 
end
set @countSelect = stuff(@countSelect, @posSelectList, @posFrom - @posSelectList, N' count(*) AS Row_Count ')
-- ***************************************************************************************
-- If @pageSize = 0 or @offset = 0 
-- ***************************************************************************************
if @offset = 0 or @pageSize = 0
begin
	set @tmp = @select
	set @tmp = stuff(@tmp,@posSelectList,0,N'cast(0 as int) As ResultRow,')
	if @pageSize > 0
	begin
		set @tmp = stuff(@tmp,@posSelectList,0,N'TOP ' + cast(@pageSize As varchar(10)) + N' ')
	end
	set @tmp = N'set nocount on'+nchar(13)+nchar(10)+@tmp
	if  @returnRowCount <> 0 and @pageSize = 0
	begin 
		set @tmp = @tmp+nchar(13)+nchar(10)+N'select @@ROWCOUNT AS Row_Count'
	end
	if  @returnRowCount <> 0 and @pageSize <> 0 
	begin
		set @countSelect = @select
		if  @posOrderBy > 0 
		begin 
			set @countSelect = left(@countSelect,@posOrderBy) 
		end
		set @countSelect = stuff(@countSelect,@posSelectList,@posFrom - @posSelectList,N' TOP '+cast(@limiter As varchar(10))+N' 0 AS rc INTO '+@tmpTable3)
		set @countSelect = @countSelect+nchar(13)+nchar(10)+N'select @@ROWCOUNT AS Row_Count'
		set @countSelect = @countSelect+nchar(13)+nchar(10)+N'drop table '+@tmpTable3
		--set @countSelect = stuff(@countSelect,@posSelectList,@posFrom - @posSelectList,N' count(*) AS Row_Count ')
		set @tmp = @tmp+nchar(13)+nchar(10)+@countSelect
	end
	set @tmp = @tmp+nchar(13)+nchar(10)+N'set nocount off'
end
else
begin --@offset <> 0 and @pageSize <> 0
-- ***************************************************************************************
-- Copy select statement for inserting into the temp table
-- ***************************************************************************************
set @tmp = @select
set @tmp = stuff(@tmp,@posFrom,0,N' into '+@tmpTable)
-- <SQL_7> 
set @tmp = stuff(@tmp,@posSelectList,0,N'top '+convert(nvarchar(10),(@offset+@pageSize))+N' ')
-- </SQL_7> 
-- <SQL_2000> 
-- set @tmp = stuff(@tmp,@posSelectList,0,N'top '+convert(nvarchar(10),(@offset+@pageSize))+N' identity(int,1,1) As ResultRow,')
-- </SQL_2000> 
-- ***************************************************************************************
-- Create the statement that will do the work
-- ***************************************************************************************
set @tmp = N'set nocount on'+nchar(13)+nchar(10)+@tmp
-- <SQL_7>
set @tmp = @tmp+nchar(13)+nchar(10)+N'select identity(int,1,1) As ResultRow,* into '+@tmpTable2+N' from '+@tmpTable
set @tmp = @tmp+nchar(13)+nchar(10)+N'drop table '+@tmpTable
set @tmp = @tmp+nchar(13)+nchar(10)+N'set rowcount '+cast(@pageSize As varchar(10))
set @tmp = @tmp+nchar(13)+nchar(10)+N'select * from '+@tmpTable2+N' where ResultRow > '+convert(nvarchar(10),@offset)
-- </SQL_7>
-- <SQL_2000>
-- set @tmp = @tmp+char(13)+char(10)+'select * from '+@tmpTable+' where ResultRow > '+convert(varchar(10),@offset)
-- </SQL_2000>
set @tmp = @tmp+nchar(13)+nchar(10)+N'set rowcount 0'
-- <SQL_7>
set @tmp = @tmp+nchar(13)+nchar(10)+N'drop table '+@tmpTable2
-- </SQL_7>
-- <SQL_2000>
-- set @tmp = @tmp+nchar(13)+nchar(10)+N'drop table '+@tmpTable
-- <SQL_2000>
if  @returnRowCount <> 0 
begin 
	set @tmp = @tmp+nchar(13)+nchar(10)+@countSelect 
end
set @tmp = @tmp+nchar(13)+nchar(10)+N'set nocount off'
end --@offset <> 0 and @pageSize <> 0
-- ***************************************************************************************
-- Execute
-- ***************************************************************************************
exec(@tmp)
end

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_RosterManagementCreateCompanyAdministrators]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_RosterManagementCreateCompanyAdministrators]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE asi_RosterManagementCreateCompanyAdministrators 
@MEMBER_TYPE varchar(50)
AS
/*
This Stored Procedure will add all members that have the specified member type
and are a member of a company to the Company Administrator Role, allowing 
them to edit other members of thier company
*/
INSERT INTO UserRole([UserKey],[RoleKey])
SELECT [UserKey],'4f0f93a9-00ee-40ba-bcbc-99a5beb21179' FROM UserMain
INNER JOIN [Name] ON [Name].[ID] = [UserMain].[ContactMaster]
WHERE [Name].[MEMBER_TYPE] = @MEMBER_TYPE AND [Name].[CO_ID] <> ''
AND [UserKey] NOT IN (Select [UserKey] FROM [UserRole] WHERE [RoleKey] = '4f0f93a9-00ee-40ba-bcbc-99a5beb21179')

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_SalesTeamAddDateRange]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_SalesTeamAddDateRange]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE   PROCEDURE [dbo].[asi_SalesTeamAddDateRange] (@salesTeamKey uniqueidentifier, @newStartDate datetime, @userKey uniqueidentifier) 
AS
/*
This storage procedure is used by Asi.Business.Commerce.SalesTeam.SalesTeamUtilities.AddRange method
to add a new date range for an existing Sales Team.
Parameters:
	@salesTeamKey is Guid of the Group object that a new Date Rage is to be added.
	@newStartDate is a DateTime value that the new Date Range is to start from
	@userKey is the Guid of the User object who is creating the new Date Range.
Return values:
	-1 - There are no existing GroupMemberDetails for the Group specified
	-2 - The new Date Range occurs prior to the first GroupMemberDetails date range
	-4 - The Start Date specified is either
		a. the date directly preceeding an existing start date
		b. the date of an existing start date
		c. the date directly following an existing start date
*/
BEGIN
SET NOCOUNT ON

DECLARE @DetailCount int

-- Determine if there are any existing GroupMemberDetail records for this sales team if not return an error code of -1
IF (SELECT COUNT(*) FROM GroupMemberDetail WHERE GroupKey = @salesTeamKey) < 1
BEGIN
	SELECT -1
	RETURN -1
END
-- Determine if @newStartDate occurs prior to the first date range for the sales team and if so return an error code of -2
IF (DATEDIFF(day,@newStartDate,(SELECT MIN(EffectiveDate) FROM GroupMemberDetail WHERE GroupKey = @salesTeamKey)) > 0)
BEGIN
	SELECT -2
	RETURN -2
END
-- Determine if @newStartDate equals an existing start date, the date following an existing start date, or an existing expiration date for this Sales Team
SELECT @DetailCount = COUNT(*) FROM GroupMemberDetail WHERE GroupKey = @salesTeamKey AND DATEDIFF(day,EffectiveDate,@newStartDate) IN (0,1) OR DATEDIFF(day,@newStartDate,ExpirationDate) = 0
-- If we find existing Detail records that means the @newStartDate is invalid.
IF @DetailCount > 0
BEGIN
	SELECT -4
	RETURN -4
END

BEGIN TRANSACTION
CREATE TABLE #tmpGroupMemberDetail (GroupMemberKey uniqueidentifier,GroupRoleKey uniqueidentifier,EffectiveDate datetime,
	ExpirationDate datetime,TypeSpecificData nvarchar(250),TypeSpecificKey uniqueidentifier,TypeSpecificFlag bit,
	CreatedOn datetime,CreatedByUserKey uniqueidentifier,UpdatedOn datetime,UpdatedByUserKey uniqueidentifier,
	TypeSpecificInt int,GroupMemberStatusCode nvarchar(4),IsActive bit,GroupMemberDetailKey uniqueidentifier,
	GroupKey uniqueidentifier)

-- Get the EffectiveDate of the next range if one exists
DECLARE @nextEffectiveDate datetime
SELECT @nextEffectiveDate = MIN(EffectiveDate) FROM GroupMemberDetail WHERE GroupKey = @salesTeamKey AND EffectiveDate > @newStartDate

-- Create the new range records in the temp table
INSERT INTO #tmpGroupMemberDetail(GroupMemberKey,GroupRoleKey,EffectiveDate,ExpirationDate,TypeSpecificData,TypeSpecificKey,TypeSpecificFlag,CreatedOn,CreatedByUserKey,
	UpdatedOn,UpdatedByUserKey,TypeSpecificInt,GroupMemberStatusCode,IsActive,GroupMemberDetailKey,GroupKey)
Select GroupMemberKey,GroupRoleKey,@newStartDate,DATEADD(day,-1,@nextEffectiveDate),TypeSpecificData,TypeSpecificKey,TypeSpecificFlag,GetDate(),@userKey,
	GetDate(),@userKey,TypeSpecificInt,GroupMemberStatusCode,IsActive,NEWID(),GroupKey
From GroupMemberDetail
WHERE GroupKey = @salesTeamKey AND
(@newStartDate BETWEEN EffectiveDate AND ExpirationDate OR (ExpirationDate IS NULL AND DATEDIFF(day,EffectiveDate,@newStartDate) > 0))
Order by EffectiveDate, GroupMemberKey

-- Set the expiration date of the existing records with the @newStartDate less 1 day
UPDATE GroupMemberDetail
SET ExpirationDate = DATEADD(day,-1,@newStartDate), UpdatedOn = GetDate(), UpdatedByUserKey = @userKey
WHERE GroupKey = @salesTeamKey AND
(@newStartDate BETWEEN EffectiveDate AND ExpirationDate OR (ExpirationDate IS NULL AND DATEDIFF(day,EffectiveDate,@newStartDate) > 0))

-- Insert the new records into the database table
INSERT INTO GroupMemberDetail(GroupMemberKey,GroupRoleKey,EffectiveDate,ExpirationDate,TypeSpecificData,TypeSpecificKey,TypeSpecificFlag,CreatedOn,CreatedByUserKey,
	UpdatedOn,UpdatedByUserKey,TypeSpecificInt,GroupMemberStatusCode,IsActive,GroupMemberDetailKey,GroupKey)
Select GroupMemberKey,GroupRoleKey,EffectiveDate,ExpirationDate,TypeSpecificData,TypeSpecificKey,TypeSpecificFlag,CreatedOn,CreatedByUserKey,
	UpdatedOn,UpdatedByUserKey,TypeSpecificInt,GroupMemberStatusCode,IsActive,GroupMemberDetailKey,GroupKey
From #tmpGroupMemberDetail
COMMIT

SELECT 0

DROP TABLE #tmpGroupMemberDetail

SET NOCOUNT OFF
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_SalesTeamChangeRange]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_SalesTeamChangeRange]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE  PROCEDURE [dbo].[asi_SalesTeamChangeRange] 
	@salesTeamKey uniqueidentifier, 
	@oldStartDate DateTime,
	@newStartDate DateTime,
	@userKey uniqueidentifier
AS
SET NOCOUNT ON

-- Check if there are any existing GroupMemberDetail records for this Group, if no records are found return with an error code of -1
IF (SELECT Count(*) FROM GroupMemberDetail WHERE GroupKey = @salesTeamKey) < 1
BEGIN
	SELECT -1
	RETURN -1
END

IF (SELECT Count(*) FROM GroupMemberDetail WHERE GroupKey = @salesTeamKey AND EffectiveDate = @oldStartDate) < 1
BEGIN
	SELECT -2
	RETURN -2
END

-- Verify that @newStartDate is valid
IF	(
		(SELECT DATEADD(day,1,MAX(EffectiveDate)) FROM GroupMemberDetail WHERE GroupKey = @salesTeamKey AND EffectiveDate < @oldStartDate) < @newStartDate
		OR (SELECT DATEADD(day,1,MAX(EffectiveDate)) FROM GroupMemberDetail WHERE GroupKey = @salesTeamKey AND EffectiveDate < @oldStartDate) IS NULL
	)
	AND
	(
		@newStartDate < (SELECT DISTINCT ExpirationDate FROM GroupMemberDetail WHERE GroupKey = @salesTeamKey AND EffectiveDate = @oldStartDate) 
		OR (SELECT DISTINCT ExpirationDate FROM GroupMemberDetail WHERE GroupKey = @salesTeamKey AND EffectiveDate = @oldStartDate) IS NULL
	)
BEGIN
BEGIN TRANSACTION
	--Previous Range
	UPDATE GroupMemberDetail SET ExpirationDate = DATEADD(day,-1,@newStartDate), UpdatedOn = GetDate(), UpdatedByUserKey = @userKey
	WHERE GroupKey = @salesTeamKey AND EffectiveDate = (SELECT MAX(EffectiveDate) FROM GroupMemberDetail WHERE GroupKey = @salesTeamKey AND EffectiveDate < @oldStartDate)
	
	--Current Range
	UPDATE GroupMemberDetail SET EffectiveDate = @newStartDate, UpdatedOn = GetDate(), UpdatedByUserKey = @userKey
	WHERE GroupKey = @salesTeamKey AND EffectiveDate =  @oldStartDate
	SELECT 0
COMMIT
END
ELSE
BEGIN
	SELECT -2
	RETURN -2
END

SET NOCOUNT OFF

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ScheduledTaskAcquire]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ScheduledTaskAcquire]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE   PROCEDURE [dbo].[asi_ScheduledTaskAcquire]
@lockKey uniqueidentifier = null,
@category nvarchar(50) = null
AS

DECLARE @tmp nvarchar(800)

SET @tmp = N'SELECT ScheduledTaskKey, SelectionLock INTO #pick '
SET @tmp = @tmp + N'FROM ScheduledTask '
SET @tmp = @tmp + N'WHERE IsDisabled = 0 AND (SelectionLock IS NULL OR SelectionLock = ''' + CAST(@lockKey AS nvarchar(40)) + N''' OR KeepAlive < dateadd(mi, -15, getdate())) '
IF DATALENGTH(@category) > 0
BEGIN
    SET @tmp = @tmp + N'AND Category LIKE ''' + @category + N'%'' '
END

SET @tmp = @tmp + N'UPDATE ScheduledTask SET SelectionLock = ''' + CAST(@lockKey AS nvarchar(40)) + N''', KeepAlive = getdate() '
SET @tmp = @tmp + N'FROM ScheduledTask INNER JOIN #pick ON ScheduledTask.ScheduledTaskKey = #pick.ScheduledTaskKey '
SET @tmp = @tmp + N'WHERE (ScheduledTask.SelectionLock IS NULL OR ScheduledTask.SelectionLock = #pick.SelectionLock) '

SET @tmp = @tmp + N'DROP TABLE #pick '

SET @tmp = @tmp + N'SELECT count(*) FROM ScheduledTask WHERE SelectionLock = ''' + CAST(@lockKey AS nvarchar(40)) + N''''

EXEC(@tmp)

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ScheduledTaskHistoryAppendLog]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ScheduledTaskHistoryAppendLog]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE  proc [dbo].[asi_ScheduledTaskHistoryAppendLog]
 @key uniqueidentifier,
 @textToAppend nvarchar(4000) as

DECLARE @ptr varbinary(16)

SELECT  @ptr = TEXTPTR(LogText)
 FROM   ScheduledTaskHistory
 WHERE  ScheduledTaskHistoryKey = @key
IF TEXTVALID('ScheduledTaskHistory.LogText', @ptr) = 1
BEGIN
   UPDATETEXT ScheduledTaskHistory.LogText @ptr NULL 0 @textToAppend --Append to end
   --UPDATETEXT ScheduledTaskHistory.LogText @ptr 0 0 @textToAppend --Insert at beginning
END
ELSE
BEGIN
   UPDATE ScheduledTaskHistory
      SET LogText = @textToAppend
    WHERE ScheduledTaskHistoryKey = @key
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_ScheduleWorkflow]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_ScheduleWorkflow]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_ScheduleWorkflow    Script Date: 7/3/2003 4:58:05 PM ******/
CREATE PROCEDURE asi_ScheduleWorkflow

@itemCount int = 3

AS

--======================================================================
--Update the appropriate number of rows with a UniqueIdentifier to mark them as 'Selected'
--======================================================================

--Get a new GUID
DECLARE @id uniqueidentifier
SET @id=newid()

DECLARE @tmp nvarchar(600)

SET @tmp = 'UPDATE WorkflowQueue SET SelectionKey = ''' + CAST(@id AS nvarchar(40)) + ''' '
SET @tmp = @tmp + 'FROM WorkflowQueue wfq '
SET @tmp = @tmp + 'WHERE wfq.WorkFlowQueueKey IN (SELECT TOP ' + CAST(@itemCount as nvarchar(10)) + ' WorkFlowQueueKey '
SET @tmp = @tmp + 'FROM WorkflowQueue '
SET @tmp = @tmp + 'WHERE SelectionKey IS NULL '
SET @tmp = @tmp + 'ORDER BY CreatedOn ASC) '
SET @tmp = @tmp + 'AND wfq.SelectionKey IS NULL'

--Update the values of up to the top three rows
EXEC (@tmp)

--======================================================================
--Select the rows previously marked for execution and return them to the client
--======================================================================

SELECT WorkFlowQueueKey FROM WorkflowQueue WHERE SelectionKey = @id

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_SearchGetEvents]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_SearchGetEvents]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


CREATE PROCEDURE [dbo].[asi_SearchGetEvents]
    @timeStamp bigint = null,
    @lastTimeStamp bigint OUTPUT
AS
----------------------------------------------------------
-- Returns events 
-- Called by the Search Indexer
----------------------------------------------------------

SELECT 
    CONVERT(bigint, MM.TIME_STAMP) AS [TimeStamp]
    , MM.ADDRESS_1 AS Address1
    , MM.ADDRESS_2 AS Address2
    , MM.ADDRESS_3 AS Address3
    , MM.BEGIN_DATE AS BeginDate
    , MM.CITY AS City
    , MM.CONTACT_ID AS ContactId
    , MM.COORDINATORS AS Coordinators
    , MM.COUNTRY AS Country
    , MM.DESCRIPTION AS [Description]
    , MM.DIRECTIONS AS Directions
    , MM.EARLY_CUTOFF AS EarlyCutoff
    , MM.EMAIL_REGISTRATION AS EmailRegistration
    , MM.END_DATE AS EndDate
    , MM.HEAD_COUNT AS Attendees
    , MM.IS_FR_MEET AS IsFrMeeting
    , MM.LATE_CUTOFF AS LateCutoff
    , MM.MAX_REGISTRANTS AS MaxRegistrants
    , MM.MEET_APPEAL AS MeetAppeal
    , MM.MEET_CAMPAIGN AS MeetCampaign
    , MM.MEETING AS EventCode
    , MM.MEETING_IMAGE_NAME AS MeetingImageName
    , MM.MEETING_TYPE AS MeetingType
    , MM.MEETING_URL AS MeetingUrl
    , MM.NOTES AS Notes
    , MM.ORG_CODE AS EntityCode
    , MM.REG_CUTOFF AS RegCutoff
    , MM.STATE_PROVINCE AS StateProvince
    , MM.STATUS AS Status
    , MM.TITLE AS Title
    , MM.TOTAL_CANCELATIONS AS TotalCancelations
    , MM.TOTAL_REGISTRANTS AS TotalRegistrants
    , MM.TOTAL_REVENUE AS TotalRevenue
    , MM.WEB_ENABLED AS WebEnabled
    , MM.WEB_VIEW_ONLY AS WebViewOnly
    , MM.ZIP AS Zip
    , MM.PUBLISH_START_DATE AS PublishStartDate
    , MM.PUBLISH_END_DATE AS PublishEndDate 
FROM Meet_Master MM
WHERE ( CONVERT(bigint, MM.TIME_STAMP) > COALESCE(@timeStamp, 0) )

SELECT @lastTimeStamp = MAX(CONVERT(bigint, MM.TIME_STAMP)) 
FROM Meet_Master MM



GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_SearchGetProducts]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_SearchGetProducts]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_SearchGetProducts]
    @timeStamp bigint = null,
    @lastTimeStamp bigint OUTPUT
AS
----------------------------------------------------------
-- Returns the legacy and the gift products 
-- Called by the Search Indexer
----------------------------------------------------------
SELECT        
    CONVERT(bigint, p.TIME_STAMP) AS [TimeStamp]
    , p.DEFERRED_INCOME_ACCOUNT AS DeferredIncomeAccount
    , p.DESCRIPTION
    , p.INCOME_ACCOUNT AS IncomeAccount
    , p.PRICE_1 AS Price1
    , p.PRICE_2 AS Price2
    , p.PRICE_3 AS Price3
    , p.PROD_TYPE AS ProductType
    , p.PRODUCT_CODE AS ProductCode
    , p.PRODUCT_MAJOR AS ProductMajor
    , p.PRODUCT_MINOR AS ProductMinor
    , p.STATUS
    , p.TITLE
    , p.TITLE_KEY AS TitleKey
    , p.CATEGORY AS ProductCategory
    , p.APPLY_IMAGE
    , p.APPLY_THUMBNAIL
    , p.IMAGE_URL
    , p.THUMBNAIL_URL
    , p.WEB_DESC
    , p.WEB_OPTION
    , p.PUBLISH_START_DATE as PublishStartDate
    , p.PUBLISH_END_DATE   as PublishEndDate
    , op.IsSuperProduct
    , op.SellOnWeb
    , opcl.IsFeatured
    , p.TIME_STAMP
FROM 
    dbo.Product AS p 
        LEFT OUTER JOIN dbo.OrderProduct AS op ON p.PRODUCT_CODE = op.ProductCode 
        LEFT OUTER JOIN dbo.OrderProductCategoryLookup AS opcl ON op.OrderProductID = opcl.OrderProductID
WHERE 
    (( p.PROD_TYPE = 'SALES' AND WEB_OPTION >= 1 ) 
        OR
    (p.PROD_TYPE = 'GIFT'))
    AND ( CONVERT(bigint, p.TIME_STAMP) > COALESCE(@timeStamp, 0) )

SELECT @lastTimeStamp = MAX(CONVERT(bigint, p.TIME_STAMP)) 
FROM Product p


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_SeasonalAddress]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_SeasonalAddress]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/*
  asi_SeasonalAddress

  Updates AddressToUse.FullAddressKey values
  based on the SeasonalFullAddress table.
*/

CREATE  PROCEDURE [dbo].[asi_SeasonalAddress] AS

/* Variables used by Procedure */

DECLARE @Now DATETIME
SET @Now = GETDATE()
DECLARE @NotSeasonalInstances INT

/* Select all SeasonalFullAddress -> curSeasonalFullAddress */
DECLARE curSeasonalFullAddress CURSOR FOR
  SELECT FullAddressKey, 
	 ReplacesFullAddressKey,
	 BeginDate,
	 EndDate,
	 IsSeasonalAnnually
  FROM 	 SeasonalFullAddress
  /* 
    A non-annual address will override an annual address in the same timeframe.
    Ordering by IsSeasonalAnnually DESC will let non-annual addresses do this.
    Ordering by BeginDate ASC allows one seasonal address to transparently follow another.
  */
  ORDER BY IsSeasonalAnnually DESC, BeginDate ASC

/* Variables used by a SeasonalFullAddress */
DECLARE @FullAddressKey UNIQUEIDENTIFIER
DECLARE @ReplacesFullAddressKey UNIQUEIDENTIFIER
DECLARE @BeginDate DATETIME
DECLARE @EndDate DATETIME
DECLARE @IsSeasonalAnnually BIT

/* Open: curSeasonalFullAddress */
OPEN curSeasonalFullAddress

FETCH NEXT 
  FROM curSeasonalFullAddress
  INTO  @FullAddressKey, 
	@ReplacesFullAddressKey,
	@BeginDate,
	@EndDate,
	@IsSeasonalAnnually

/* Iterate: curSeasonalFullAddress */
WHILE @@FETCH_STATUS = 0
BEGIN

  /* If it's seasonal annually, bring the year up to this year */
  IF (@IsSeasonalAnnually = 1)
  BEGIN 
    SET @BeginDate = CAST(CAST(DATEPART(mm, @BeginDate) AS NVARCHAR(2)) + '/' + CAST(DATEPART(dd, @BeginDate) AS NVARCHAR(2)) + '/' + CAST(DATEPART(yyyy, @Now) AS NVARCHAR(4)) AS DATETIME)
    SET @EndDate = CAST(CAST(DATEPART(mm, @EndDate) AS NVARCHAR(2)) + '/' + CAST(DATEPART(dd, @EndDate) AS NVARCHAR(2)) + '/' + CAST(DATEPART(yyyy, @Now) AS NVARCHAR(4)) AS DATETIME)
  END

  /* Is this SeasonalFullAddress valid? */
  IF ( @BeginDate <= @Now AND ( @Now < @EndDate OR @EndDate IS NULL ) )
  /* Is valid, make the seasonal change */
  BEGIN
    /* Now, Swap the actual pointer */
    UPDATE AddressToUse
      SET FullAddressKey = @ReplacesFullAddressKey,
          SeasonalRevertFullAddressKey = FullAddressKey
      WHERE FullAddressKey = @FullAddressKey
  END
  ELSE
  /* Not valid, reverse the seasonal change */
  BEGIN
    UPDATE AddressToUse
      SET FullAddressKey = SeasonalRevertFullAddressKey,
          SeasonalRevertFullAddressKey = NULL
      WHERE FullAddressKey = @ReplacesFullAddressKey
        /* 
          Only revert if this one is the cause
        */
      AND SeasonalRevertFullAddressKey = @FullAddressKey
        /* 
          If this address is in AddressToUse but isn't seasonal,
          we don't want to revert.
        */
      AND SeasonalRevertFullAddressKey IS NOT NULL
  END

  /* Get next row */
  FETCH NEXT 
    FROM curSeasonalFullAddress
    INTO  @FullAddressKey, 
	  @ReplacesFullAddressKey,
  	  @BeginDate,
	  @EndDate,
	  @IsSeasonalAnnually
END
/* End iterate: curSeasonalFullAddress */

/* Close and Dealloc: curSeasonalFullAddress */
CLOSE curSeasonalFullAddress
DEALLOCATE curSeasonalFullAddress

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_SequencePeek]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_SequencePeek]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_SequencePeek]
	@SequenceName nvarchar(30) AS

SELECT CurrentValue FROM SequenceCounter WHERE CounterName = @SequenceName

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_SetAppealParticipationResponseTypeCodes]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_SetAppealParticipationResponseTypeCodes]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- Author:		Paul Rogers
-- Create date: August 2006
-- Description:	Obtain the campaign for a given
-- appeal and set the ResponseTypeCode for all
-- AppealParticipation records that are associated
-- with the campaign for the particular respondent.
-- =============================================

CREATE PROCEDURE [dbo].[asi_SetAppealParticipationResponseTypeCodes]
	@respondentKey uniqueidentifier,
	@appealKey uniqueidentifier,
	@responseTypeCode int
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

BEGIN TRAN

	DECLARE @campaignKey UNIQUEIDENTIFIER
	DECLARE @returnCount int
	SET @returnCount = 0

	-- Given an Appeal, figure out the Campaign
	SELECT @campaignKey = cm.CampaignKey
	FROM CampaignMain cm
	INNER JOIN AppealMain am ON am.CampaignKey = cm.CampaignKey
	WHERE am.AppealKey=@appealKey

	-- Set the response type code for all
	-- AppealParticipation records involving
	-- the Campaign and the Respondent
	UPDATE AppealParticipation
	SET
		ResponseTypeCode=@responseTypeCode
	FROM AppealParticipation ap
	INNER JOIN AppealMain am ON ap.AppealKey = am.AppealKey
	INNER JOIN CampaignMain cm ON am.CampaignKey = cm.CampaignKey
	WHERE ap.RespondentUserKey=@respondentKey
	AND cm.CampaignKey = @campaignKey

	SET @returnCount = @@ROWCOUNT

	
	SELECT @returnCount AS ReturnCount
COMMIT TRAN
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_SetDatabaseVersion]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_SetDatabaseVersion]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- Author:		Paul Bradshaw
-- Create date: Sept 19, 2006
-- Description:	Set DB Version string
-- =============================================
CREATE PROCEDURE [dbo].[asi_SetDatabaseVersion]
	@p1 nvarchar(20) = '' -- Specify the version string
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @version nvarchar(24)
	DECLARE @major nvarchar(10)
	DECLARE @minor nvarchar(10)
	DECLARE @patch nvarchar(10)
	DECLARE @build nvarchar(10)
	DECLARE @systemEntity uniqueidentifier
	DECLARE @type nvarchar(20)
	DECLARE @pos1 int
	DECLARE @pos2 int
	DECLARE @pos3 int
	DECLARE @pos4 int

	SET @version = UPPER(LTRIM(RTRIM(@p1)))

	SELECT @systemEntity = [SystemEntityKey] FROM [dbo].[SystemEntity] WHERE [SystemKeyword] = 'Organization'

	SELECT @major = [ParameterValue] FROM [dbo].[SystemConfig]
     WHERE [ParameterName] = 'System.Database.Version.Major'
	   AND [OrganizationKey] = '00000000-0000-0000-0000-000000000000' AND [SystemEntityKey] = @systemEntity
	SELECT @minor = [ParameterValue] FROM [dbo].[SystemConfig] 
     WHERE [ParameterName] = 'System.Database.Version.Minor'
	   AND [OrganizationKey] = '00000000-0000-0000-0000-000000000000' AND [SystemEntityKey] = @systemEntity
	SELECT @patch = [ParameterValue] FROM [dbo].[SystemConfig] 
     WHERE [ParameterName] = 'System.Database.Version.Patch'
	   AND [OrganizationKey] = '00000000-0000-0000-0000-000000000000' AND [SystemEntityKey] = @systemEntity
	SELECT @build = [ParameterValue] FROM [dbo].[SystemConfig] 
     WHERE [ParameterName] = 'System.Database.Version.Build'
	   AND [OrganizationKey] = '00000000-0000-0000-0000-000000000000' AND [SystemEntityKey] = @systemEntity

	IF @version IS NOT NULL AND @version <> '' AND
	   @major IS NOT NULL AND @minor IS NOT NULL AND @patch IS NOT NULL AND @build IS NOT NULL
	BEGIN
		IF @version <> 'INCBUILD'
		BEGIN
			SET @pos1 = CHARINDEX('.', @version, 1)
			IF (@pos1 > 0) 
			BEGIN
				SET @major = SUBSTRING(@version, 1, @pos1 - 1)
				SET @pos2 = CHARINDEX('.', @version, @pos1 + 1)
				IF (@pos2 > 0)
				BEGIN
					SET @minor = SUBSTRING(@version, @pos1 + 1, (@pos2 - @pos1) -1)
					SET @pos3 = CHARINDEX('.', @version, @pos2 + 1)
					IF (@pos3 > 0)
					BEGIN
						SET @patch = SUBSTRING(@version, @pos2 + 1, (@pos3 - @pos2) -1)
						SET @pos4 = CHARINDEX('.', @version, @pos3 + 1)
						IF (@pos4 > 0)
						BEGIN
							SET @build = SUBSTRING(@version, @pos3 + 1, (@pos4 - @pos3) -1)
						END
						ELSE
						BEGIN
							SET @build = SUBSTRING(@version, @pos3 + 1, LEN(@version))
						END
					END
					ELSE
					BEGIN
						SET @patch = SUBSTRING(@version, @pos2 + 1, LEN(@version))
					END
				END
				ELSE
				BEGIN
					SET @minor = SUBSTRING(@version, @pos1 + 1, LEN(@version))
				END
			END
			ELSE
			BEGIN
				SET @major = @version
			END
		END
		ELSE IF @version = 'INCBUILD'
		BEGIN
			SET @build = @build + 1
		END

		UPDATE [SystemConfig] SET [ParameterValue] = @major 
         WHERE [ParameterName] = 'System.Database.Version.Major'
		   AND [OrganizationKey] = '00000000-0000-0000-0000-000000000000' AND SystemEntityKey = @systemEntity
		UPDATE [SystemConfig] SET [ParameterValue] = @minor 
         WHERE [ParameterName] = 'System.Database.Version.Minor'
		   AND [OrganizationKey] = '00000000-0000-0000-0000-000000000000' AND SystemEntityKey = @systemEntity
		UPDATE [SystemConfig] SET [ParameterValue] = @patch 
         WHERE [ParameterName] = 'System.Database.Version.Patch'
		   AND [OrganizationKey] = '00000000-0000-0000-0000-000000000000' AND SystemEntityKey = @systemEntity
		UPDATE [SystemConfig] SET [ParameterValue] = @build 
         WHERE [ParameterName] = 'System.Database.Version.Build'
		   AND [OrganizationKey] = '00000000-0000-0000-0000-000000000000' AND SystemEntityKey = @systemEntity

        UPDATE [dbo].[System_Params] 
           SET [ShortValue] = [dbo].[fn_asi_DatabaseVersion]('') 
         WHERE [ParameterName] = 'System_Control.Version'

	END

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_SetMailingListIdentityField]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_SetMailingListIdentityField]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- This stored procedure assigns the identity field in temporary mailing list
-- tables in the order that the mailing list table should be queried.
CREATE PROCEDURE [dbo].[asi_SetMailingListIdentityField]
   @tableName sysname,
   @fieldName sysname,
   @keyFieldName sysname,
   @orderByClause nvarchar(256)
AS
BEGIN
   DECLARE @sql nvarchar(800)

   CREATE TABLE #SetIdentityTable
   (
      SetIdentityTableKey uniqueidentifier,
      IntId int IDENTITY(1, 1)
   )
	   
   SET @sql = 'INSERT #SetIdentityTable (SetIdentityTableKey) SELECT [' + @keyFieldName + '] FROM [' + @tableName + '] ' + @orderByClause
   EXEC(@sql)
	
   SET @sql = 'UPDATE [' + @tableName + '] SET [' + @fieldName + ']=#SetIdentityTable.IntId FROM #SetIdentityTable WHERE #SetIdentityTable.SetIdentityTableKey=[' + @tableName + '].[' + @keyFieldName + ']'
   EXEC(@sql)
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_SyncMemberTypeSecurityGroups]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_SyncMemberTypeSecurityGroups]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- Synchronize the Member Type Security Groups with Member_Types
CREATE PROCEDURE [dbo].[asi_SyncMemberTypeSecurityGroups]
AS
BEGIN
    SET NOCOUNT ON
    -- Declare all variables needed
    DECLARE @now datetime
    DECLARE @userKey uniqueidentifier
    DECLARE @accessKey uniqueidentifier
    DECLARE @groupTypeKey uniqueidentifier
    DECLARE @systemEntityKey uniqueidentifier
    DECLARE @groupComponentKey uniqueidentifier
    DECLARE @groups TABLE ([GroupKey] uniqueidentifier, [Name] nvarchar(65), [Description] nvarchar(250))

    -- Grab some constant values
    SELECT @now = GETDATE()
    SELECT @userKey = [UserKey] FROM [dbo].[UserMain] WHERE [UserId] = 'SYSTEM'
    IF @userKey IS NULL SELECT @userKey = [UserKey] FROM [dbo].[UserMain] WHERE [UserId] = 'MANAGER'
    SELECT @accessKey = [ProtectedAccessKey] FROM [dbo].[AccessArea] WHERE [Name] = 'Everyone Full Control'
    SET @groupTypeKey = '636A1E55-38BC-4A8F-AC8D-A6873D697F18'
    SELECT @systemEntityKey = [SystemEntityKey] FROM [dbo].[SystemEntity] WHERE [SystemKeyword] = 'Organization'
    SELECT @groupComponentKey = [ComponentKey] FROM [dbo].[ComponentRegistry] WHERE [Name] = 'Group' AND [InterfaceName] = 'BusinessController'

    -- Create Group Type if it doesn't already exist
    IF NOT EXISTS (SELECT 1 FROM [dbo].[GroupTypeRef] WHERE [GroupTypeName] = 'Member Type Security')
    BEGIN
        INSERT INTO [dbo].[GroupTypeRef] ([GroupTypeKey], [GroupTypeName], [IsSystem], [IsPaymentRequired], [IsDateLimited], 
                                          [GroupMemberBranchName], [IsInvitationOnly], [DefaultGroupStatusCode], [IsSimpleGroup],
                                          [MemberQueryFolderKey], [InheritRolesFlag], [IsSingleRole], [GroupTypeDesc],
                                          [CreatedByUserKey], [UpdatedByUserKey], [CreatedOn], [UpdatedOn])
        VALUES (@groupTypeKey, 'Member Type Security', 1, 0, 0,
                NULL, 0, 'A', 1, NULL, 0, 0, 'Member Type Security Group Type',
                @userKey, @userKey, @now, @now) 
    END

    -- Get a list of all the groups we should have, one for each member type
    INSERT INTO @groups ([GroupKey], [Name], [Description])
        SELECT COALESCE(gm.GroupKey, NEWID()), mt.[DESCRIPTION], 'Security Group for ' + mt.[DESCRIPTION] + ' users'
          FROM [dbo].[Member_Types] mt LEFT OUTER JOIN [dbo].[GroupMain] gm ON gm.[Name] = mt.[DESCRIPTION]

    -- Remove any Members of Member Type Security groups that don't have a corresponding member type in Member_Types
    DELETE m 
      FROM [dbo].[GroupMember] m 
           INNER JOIN [dbo].[GroupMain] gm ON m.GroupKey = gm.[GroupKey]
           LEFT OUTER JOIN @groups g ON gm.[Name] = g.[Name]
     WHERE gm.[GroupTypeKey] = @groupTypeKey
       AND g.[Name] IS NULL

    -- Remove any Member Type Security groups that don't have a corresponding member type in Member_Types
    DELETE gm
      FROM [dbo].[GroupMain] gm 
           LEFT OUTER JOIN @groups g ON gm.[Name] = g.[Name]
           INNER JOIN [dbo].[UniformRegistry] ON gm.[GroupKey] = gm.[GroupKey]
     WHERE gm.[GroupTypeKey] = @groupTypeKey
       AND g.[Name] IS NULL

    -- Remove Uniform Registry entries for the deleted groups
    DELETE ur
      FROM [dbo].[UniformRegistry] ur 
           LEFT OUTER JOIN [dbo].[GroupMain] gm ON ur.[UniformKey] = gm.[GroupKey]
     WHERE ur.[ComponentKey] = @groupComponentKey AND gm.[GroupKey] IS NULL

    -- Create Uniform Registry entry for each new security group
    INSERT INTO [dbo].[UniformRegistry] ([UniformKey], [ComponentKey])
        SELECT g.[GroupKey], @groupComponentKey 
          FROM @groups g LEFT OUTER JOIN [dbo].[UniformRegistry] ur ON ur.[UniformKey] = g.[GroupKey] AND ur.[ComponentKey] = @groupComponentKey
         WHERE  ur.[UniformKey] IS NULL

    -- Create a new Member Type Security group for each member type in Member_Types
    INSERT INTO [dbo].[GroupMain] ([GroupKey], [Name], [Description], [UpdatedByUserKey], [UpdatedOn], [IsSystem], [IsAutoGenerated], 
                                   [GroupTypeKey], [Priority], [OwnerAccessKey], [OverrideOwnerGroupKey], [AccessKey], 
                                   [CreatedByUserKey], [CreatedOn], [SystemEntityKey],
                                   [IsInvitationOnly], [GroupStatusCode], [IsSimpleGroup], [InheritRolesFlag], [IsSingleRole])
        SELECT g.[GroupKey], g.[Name], g.[Description], @userKey, @now, 1, 1,
               @groupTypeKey, NULL, NULL, NULL, @accessKey, @userKey, @now, @systemEntityKey, 0, 'A', 1, 0, 0
          FROM @groups g
         WHERE NOT EXISTS (SELECT 1 FROM [dbo].[GroupMain] gm WHERE g.[Name] = gm.[Name] AND gm.[GroupTypeKey] = @groupTypeKey)

    -- Populate the new Security Groups
    INSERT INTO [dbo].[GroupMember] ([GroupMemberKey], [GroupKey], [MemberContactKey], [IsActive],
                                     [CreatedByUserKey], [CreatedOn], [UpdatedByUserKey], [UpdatedOn],
                                     [DropDate], [JoinDate], [MarkedForDeleteOn])
        SELECT NEWID(), g.GroupKey, cm.ContactKey, 1, @userKey, @now, @userKey, @now, NULL, NULL, NULL  
          FROM [dbo].[Name] n INNER JOIN [Member_Types] mt ON n.MEMBER_TYPE = mt.[MEMBER_TYPE]
               INNER JOIN [dbo].[ContactMain] cm ON n.[ID] = cm.[SyncContactID]
               INNER JOIN [dbo].[UserMain] um ON um.UserKey = cm.ContactKey
               INNER JOIN [dbo].[GroupMain] g ON g.[Name] = mt.[DESCRIPTION]
         WHERE NOT EXISTS (SELECT 1 FROM [dbo].[GroupMember] gm WHERE gm.GroupKey = g.GroupKey AND gm.MemberContactKey = um.UserKey)
    SET NOCOUNT OFF
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_SyncNetContacts]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_SyncNetContacts]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- sync them, 1000 per transaction, to the new tables
CREATE PROCEDURE [dbo].[asi_SyncNetContacts] AS
BEGIN
    SET NOCOUNT ON
    DECLARE @isDone bit
    DECLARE @count int
    DECLARE @rowcount int
    DECLARE @totalCount int
    DECLARE @msg nvarchar(255)
    
    SET @count = 0
    SELECT @totalCount = COUNT(1) 
      FROM Name c LEFT OUTER JOIN ContactMain d
        ON c.ID = d.SyncContactID
     WHERE d.SyncContactID IS NULL
     
    SET @msg = 'Total contact records to sync: ' + CAST(@totalCount AS nvarchar(12))
    RAISERROR (@msg, 0, 1) WITH NOWAIT;
    
    SET @isDone = 0
    WHILE @isDone = 0
    BEGIN
        BEGIN TRANSACTION
        UPDATE a 
           SET LAST_FIRST = LAST_FIRST
          FROM Name a INNER JOIN (
                SELECT TOP 2000 c.ID
                  FROM Name c LEFT OUTER JOIN ContactMain d
                    ON c.ID = d.SyncContactID
                 WHERE d.SyncContactID IS NULL) b
            ON a.ID = b.ID

        SET @rowcount = @@ROWCOUNT
        IF @rowcount = 0 
        BEGIN
            SET @isDone = 1
        END
        ELSE
        BEGIN
            SET @count = @count + @rowcount
            SET @msg = '   Contacts synced: ' + CAST(@count AS nvarchar(12))  
            RAISERROR (@msg, 0, 1) WITH NOWAIT;
        END
        COMMIT
    END

	-- fix up the problem where the company a person works for is in a later block than the 
	-- person is.  e.g., the CO_ID > the ID
	INSERT INTO GroupMember 
		   (GroupMemberKey, GroupKey, MemberContactKey, IsActive, CreatedByUserKey, CreatedOn, UpdatedByUserKey, UpdatedOn)
	SELECT NewId(), d.InstituteGroupKey, b.ContactKey, 1, b.CreatedByUserKey, b.CreatedOn, b.CreatedByUserKey, b.CreatedOn
	  FROM Name a inner join ContactMain b ON a.ID = b.ID 
	  	   inner join ContactMain c ON a.CO_ID = c.ID
		   inner join Institute d ON c.ContactKey = d.ContactKey
		   left outer join GroupMember e ON d.InstituteGroupKey = e.GroupKey AND b.ContactKey = e.MemberContactKey
	 WHERE e.GroupKey IS NULL

	INSERT INTO GroupMemberDetail 
		   (GroupMemberDetailKey, GroupMemberKey, GroupKey, GroupRoleKey, EffectiveDate, 
			CreatedByUserKey, CreatedOn, UpdatedByUserKey, UpdatedOn, GroupMemberStatusCode, IsActive)
	SELECT newid(), c.GroupMemberKey, c.GroupKey, f.GroupRoleKey, c.CreatedOn, 
		   c.CreatedByUserKey, c.CreatedOn, c.CreatedByUserKey, c.CreatedOn, f.DefaultMemberStatusCode, 1
	  FROM GroupMain a 
	  	   inner join ContactTypeRef b ON a.GroupTypeKey = b.GroupTypeKey and b.ContactTypeDesc = 'Company'
	       inner join GroupMember c ON a.GroupKey = c.GroupKey
	       left outer join GroupMemberDetail d ON c.GroupMemberKey = d.GroupMemberKey
		   inner join GroupTypeRole f on b.GroupTypeKey = f.GroupTypeKey AND f.IsDefault = 1
	 WHERE d.GroupMemberKey IS NULL

    RAISERROR ('Sync complete', 0, 1) WITH NOWAIT;
    SET NOCOUNT OFF
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEValidateCultureExists]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEValidateCultureExists]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:      <Author,,Name>
-- Create date: <Create Date,,>
-- Description: <Description,,>
-- version 1.0
-- =============================================
CREATE procedure [dbo].[asi_TEValidateCultureExists]
    @LocalizationCultureId nvarchar(50)
AS
BEGIN 
    SET NOCOUNT ON

    DECLARE @ncount int
    DECLARE @ret_value  int
    DECLARE @error_code  int

    SET @error_code = 0

    SELECT @ncount = COUNT(1) 
      FROM [dbo].[LocalizationCulture]
     WHERE [LocalizationCultureId] = @LocalizationCultureId

    IF @ncount = 0 
    BEGIN
        SET @error_code = -25
        GOTO error_handler
    END


    error_handler:
    SET @ret_value = @error_code

    endit:
    RETURN  @ret_value

    SET NOCOUNT OFF
    END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEValidateStatusExists]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEValidateStatusExists]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:      <Author,,Name>
-- Create date: <Create Date,,>
-- Description: <Description,,>
-- version 1.0
-- =============================================
CREATE PROCEDURE [dbo].[asi_TEValidateStatusExists]
(
    @Status nvarchar(5)
)
AS
BEGIN 
    SET NOCOUNT ON

    DECLARE @ncount int
    DECLARE @ret_value  int
    DECLARE @error_code  int

    SET @error_code = 0

    SELECT @ncount = COUNT(1) 
      FROM [dbo].[LocalizationLookup]
     WHERE [LocalizationLookup] = 'STATUS' AND [LocalizationCode] = @Status

    IF @ncount = 0 
    BEGIN
        SET @error_code = -25
        GOTO error_handler
    END


    error_handler:
    SET @ret_value = @error_code

    endit:
    RETURN  @ret_value

    SET NOCOUNT OFF
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEValidateUpdateSourceExists]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEValidateUpdateSourceExists]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:      <Author,,Name>
-- Create date: <Create Date,,>
-- Description: <Description,,>
-- version 1.0
-- =============================================
CREATE PROCEDURE [dbo].[asi_TEValidateUpdateSourceExists]
(
    @UpdateSource nvarchar(250)
)
AS
BEGIN 
    SET NOCOUNT ON

    DECLARE @ncount int
    DECLARE @ret_value  int
    DECLARE @error_code  int

    SET @error_code = 0

    SELECT @ncount = COUNT(1) 
      FROM [dbo].[LocalizationLookup] 
     WHERE [LocalizationLookup] = 'SOURCE' AND [LocalizationCode] = @UpdateSource

    IF @ncount = 0 
    BEGIN
        SELECT @ncount = COUNT(1) 
          FROM [dbo].[Name]
         WHERE [ID] = @UpdateSource

        IF @ncount = 0
        BEGIN
            SET @error_code = -22
            GOTO error_handler
        END
    END

    error_handler:
    SET @ret_value = @error_code

    endit:
    RETURN  @ret_value

    SET NOCOUNT OFF
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEValidateVersionIdExists]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEValidateVersionIdExists]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:        <Author,,Name>
-- Create date: <Create Date,,>
-- Description:   <Description,,>
-- version 1.0
-- =============================================
CREATE PROCEDURE [dbo].[asi_TEValidateVersionIdExists]
    @LocalizationVersionId uniqueidentifier,
    @CheckEmpty bit = 1
AS
BEGIN 
    SET NOCOUNT ON

    DECLARE @ncount int
    DECLARE @ret_value  int
    DECLARE @error_code  int

    SET @error_code = 0

    SELECT @ncount = COUNT(1)
      FROM [dbo].[LocalizationVersion]
    WHERE [LocalizationVersionId] = @LocalizationVersionId

    -- check that the versionid exists before insert
    IF @ncount <> 1
    BEGIN
        SET @error_code = -21
        GOTO error_handler
    END
         
    IF @CheckEmpty = 1 
    BEGIN     
        -- version being inserted, count should be zero or will get duplicate error, check before insert that verion empty
        SELECT @ncount = COUNT(1)
          FROM [dbo].[LocalizationVersionPhrase] as p1
         WHERE LocalizationVersionId = @LocalizationVersionId
           AND EXISTS (SELECT 1 FROM [LocalizationVersionPhrase] p2
                        WHERE p2.[LocalizationPhraseTranslatedId] = p1.[LocalizationPhraseTranslatedId]
                       )

        IF @ncount > 0
        BEGIN
            SET @error_code = -22
            GOTO error_handler
        END
    END     
         
    error_handler:
    SET @ret_value = @error_code

    endit:
    RETURN  @ret_value

    SET NOCOUNT OFF

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionCopyVersion]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionCopyVersion]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_TEVersionCopyVersion]
(
    @LocalizationVersionIdFrom uniqueidentifier,
    @LocalizationVersionIdTo uniqueidentifier,
    @CreatedBy nvarchar(250)
)
AS
BEGIN 
 -- 09/01/2013 - added [DoNotLocalize], [ControlType], [Description]

    SET NOCOUNT ON

    DECLARE @ncount int
    DECLARE @ret_value  int
    DECLARE @error_code  int

    SET @error_code = 0

    SELECT @ncount = COUNT(1)
      FROM [dbo].[LocalizationVersion]
     WHERE [LocalizationVersionId] = @LocalizationVersionIdFrom

    -- check that the versionid exists before insert
    IF @ncount <> 1
    BEGIN
        SET @error_code = -21
        GOTO error_handler
    END

    SELECT @ncount = COUNT(1)
      FROM [dbo].[LocalizationVersion]
     WHERE [LocalizationVersionId] = @LocalizationVersionIdTo

    -- check that the versionid exists before insert
    IF @ncount <> 1
    BEGIN
        SET @error_code = -22
        GOTO error_handler
    END

    -- version being inserted, count should be zero or will get duplicate error, check before insert
    SELECT @ncount = COUNT(1)
      FROM [dbo].[LocalizationVersionPhrase] AS p1
     WHERE [LocalizationVersionId] = @LocalizationVersionIdTo
       AND EXISTS (SELECT 1 FROM [LocalizationVersionPhrase] p2
                    WHERE p2.[LocalizationPhraseTranslatedId] = p1.[LocalizationPhraseTranslatedId]
                   )

    IF @ncount > 0
    BEGIN
        SET @error_code = -23
        GOTO error_handler
    END

    BEGIN TRY
        --********** create version copying of exisitng version - Spanish 1 Version
        --********** created Spanish 2 Version
        -- created PK/FK with [LocalizationVersion] on [LocalizationVersionId]
        INSERT INTO [dbo].[LocalizationVersionPhrase] ([LocalizationVersionPhraseId], [LocalizationVersionId], 
                                                       [LocalizationPhraseTranslatedId], [Phrase], [TranslatedPhrase], 
                                                       [DateCreated], [CreatedBy], [DateUpdated], [UpdatedBy], [LocalizationPhraseId],
                                                       [DoNotLocalize], [ControlType], [Description])

            SELECT NEWID(), @LocalizationVersionIdTo, 
                   [LocalizationPhraseTranslatedId], [Phrase], [TranslatedPhrase], 
                   GETDATE(), @CreatedBy, GETDATE(), @CreatedBy, [LocalizationPhraseId],
                   [DoNotLocalize], [ControlType], [Description]
              FROM [dbo].[LocalizationVersionPhrase]
             WHERE [LocalizationVersionId] = @LocalizationVersionIdFrom 
    END TRY
    BEGIN CATCH
        SET @error_code = @@error
    END CATCH

    --goto endit

    error_handler:
    SET @ret_value = @error_code

    endit:
    RETURN  @ret_value
    --select @ret_value

    SET NOCOUNT OFF

END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionCopyVersionOriginal]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionCopyVersionOriginal]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_TEVersionCopyVersionOriginal]
(
@CultureID nvarchar(50),
@LocalizationVersionIdTo uniqueidentifier,
@CreatedBy nvarchar(250)
)
AS
BEGIN
    -- 09/01/2013 - added [DoNotLocalize], [ControlType]

    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON;

    DECLARE @ncount int;
    DECLARE @ret_value  int;
    DECLARE @error_code  int;

    SET @error_code = 0;

    SELECT @ncount = COUNT(*)
      FROM [dbo].[LocalizationVersion]
     WHERE [LocalizationVersionId] = @LocalizationVersionIdTo;

    -- check that the versionid exists before insert
    IF @ncount <> 1
        BEGIN
            SET @error_code = -22;
            GOTO error_handler;
        END;

    -- version being inserted, count should be zero or will get duplicate error, check before insert
    SELECT @ncount = COUNT(*)
      FROM [dbo].[LocalizationVersionPhrase] AS p1
     WHERE LocalizationVersionId = @LocalizationVersionIdTo AND EXISTS (SELECT 1
                                                                          FROM [LocalizationVersionPhrase] AS p2
                                                                         WHERE p2.[LocalizationPhraseTranslatedId] = p1.[LocalizationPhraseTranslatedId]
           );

    IF @ncount > 0
        BEGIN
            SET @error_code = -23;
            GOTO error_handler;
        END;

    BEGIN TRY

        IF EXISTS (SELECT TOP 1 *
                     FROM [dbo].[LocalizationPhraseTranslated]
                    WHERE LocalizationCultureId = @CultureID)
            BEGIN
                -- created PK/FK with [LocalizationVersion] on [LocalizationVersionId]
                INSERT INTO [dbo].[LocalizationVersionPhrase] ([LocalizationVersionPhraseId],
                                                               [LocalizationVersionId],
                                                               [LocalizationPhraseTranslatedId],
                                                               [Phrase],
                                                               [TranslatedPhrase],
                                                               [DateCreated],
                                                               [CreatedBy],
                                                               [DateUpdated],
                                                               [UpdatedBy],
                                                               [LocalizationPhraseId],
                                                               [DoNotLocalize],
                                                               [ControlType])

                SELECT NEWID(),
                       @LocalizationVersionIdTo,
                       lpt.LocalizationPhraseTranslatedId,
                       lp.Phrase,
                       lpt.TranslatedPhrase,
                       GETDATE(),
                       @CreatedBy,
                       GETDATE(),
                       @CreatedBy,
                       lp.LocalizationPhraseId,
                       DoNotLocalize,
                       ControlType
                  FROM [dbo].[LocalizationPhraseTranslated] AS lpt
                       LEFT OUTER JOIN LocalizationPhrase AS lp ON lp.LocalizationPhraseId = lpt.LocalizationPhraseId
                 WHERE lpt.LocalizationCultureId = @CultureID;
            END;
        ELSE
            BEGIN
                INSERT INTO [dbo].[LocalizationVersionPhrase] ([LocalizationVersionPhraseId],
                                                               [LocalizationVersionId],
                                                               [Phrase],
                                                               [DateCreated],
                                                               [CreatedBy],
                                                               [DateUpdated],
                                                               [UpdatedBy],
                                                               [LocalizationPhraseId],
                                                               [DoNotLocalize],
                                                               [ControlType])

                SELECT NEWID(),
                       @LocalizationVersionIdTo,
                       lp.Phrase,
                       GETDATE(),
                       @CreatedBy,
                       GETDATE(),
                       @CreatedBy,
                       lp.LocalizationPhraseId,
                       lp.DoNotLocalize,
                       lp.ControlType
                  FROM [dbo].[LocalizationPhrase] AS lp;
            END;

    END TRY
    BEGIN CATCH

        SET @error_code = @@error;

    END CATCH;

    --goto endit

    error_handler:
    SET @ret_value = @error_code;

    endit:
    RETURN  @ret_value;
    --select @ret_value

    SET NOCOUNT OFF;
END;


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionCreate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionCreate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:        <Author,,Name>
-- Create date: <Create Date,,>
-- Description:   <Description,,>
-- version 1.0
-- =============================================
CREATE PROCEDURE [dbo].[asi_TEVersionCreate]
(
    @LocalizationVersionId [uniqueidentifier] output,
    @Name nvarchar(250),
    @Description nvarchar(400),
    @Note nvarchar(400),
    @CreatedBy nvarchar(250),
    @UpdatedBy nvarchar(250),
    @CultureId nvarchar(50),
    @Status nvarchar(5)
)
AS
BEGIN 
    SET NOCOUNT ON

    DECLARE @ncount int
    DECLARE @ret_value  int
    DECLARE @error_code  int

    SET @error_code = 0

    SELECT @ncount = COUNT(1)
      FROM [dbo].[LocalizationVersion] as p1
     WHERE LocalizationVersionName = @Name

    IF @ncount > 0
    BEGIN
        SET @error_code = -21
        GOTO error_handler
    END

    SET @LocalizationVersionId = NEWID()

    BEGIN TRY
        -- created PK/FK with [LocalizationCulture] on [CultureId] - de, es, ar - FK error if not valid entry on PK table
        INSERT INTO [dbo].[LocalizationVersion] ([LocalizationVersionId], [LocalizationVersionName], [LocalizationVersionDesc], [Note], 
                                                 [DateCreated], [CreatedBy], [DateUpdated], [UpdatedBy], 
                                                 [CultureId], ActiveVersion, ActiveVersionLoaded, StatusID)
            SELECT @LocalizationVersionId, @Name, @Description, @Note, 
                   GETDATE(), @CreatedBy,  GETDATE(), @UpdatedBy,  
                   @CultureId, 0, null, @Status 
    END TRY
    BEGIN CATCH
        SET @error_code = @@error

        --if @@error <> 0
        --          begin
        --          set @error_code = @@error
        --          goto error_handler
        --          end
    END CATCH

    --if @inv_num = 0 
    --         goto error_handler

    --if @@error <> 0
    --         begin
    --         set @error_hold = @@error
    --         goto error_handler
    --         end

    --goto endit

    error_handler:
    SET @ret_value = @error_code

    endit:
    RETURN  @ret_value
    --select @ret_value

    SET NOCOUNT OFF

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionCultureCreate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionCultureCreate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:      <Author,,Name>
-- Create date: <Create Date,,>
-- Description: <Description,,>
-- version 1.0
-- =============================================
CREATE PROCEDURE [dbo].[asi_TEVersionCultureCreate]
(
    @CultureID nvarchar(50),
    @Name nvarchar(50)
)
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @ncount int
    DECLARE @ret_value  int
    DECLARE @error_code  int

    SET @error_code = 0

    SELECT @ncount = COUNT(*)
      FROM [dbo].[LocalizationVersion] as p1
     WHERE LocalizationVersionName  = @Name

    IF @ncount > 0
    BEGIN
        SET @error_code = -21
        GOTO error_handler
    END

    BEGIN TRY
    -- created PK/FK with [LocalizationCulture] on [CultureId] - de, es, ar - FK error if not valid entry on PK table
        INSERT INTO [dbo].[LocalizationCulture] ([LocalizationCultureId], [LocalizationCultureName])
        VALUES (@CultureID, @Name)
    END TRY
    BEGIN CATCH
        SET @error_code = @@error
    END CATCH

    error_handler:
    SET @ret_value = @error_code

    endit:
    RETURN  @ret_value
    --select @ret_value

    SET NOCOUNT OFF
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionCultureDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionCultureDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:      <Author,,Name>
-- Create date: <Create Date,,>
-- Description: <Description,,>
-- version 1.0
-- =============================================
CREATE PROCEDURE [dbo].[asi_TEVersionCultureDelete]
(
    @CultureID nvarchar(50)
)
AS
BEGIN
    SET NOCOUNT ON;

    --DECLARE @LocalizationPhraseTranslatedId UNIQUEIDENTIFIER
    DECLARE @ncount int
    DECLARE @ret_value  int
    DECLARE @error_code  int

    SET @error_code = 0

    SELECT @ncount = COUNT(1)
      FROM [dbo].[LocalizationCulture]
     WHERE [LocalizationCultureId] = @CultureID

    -- check that the versionid exists before insert
    IF @ncount <> 1
    BEGIN
        SET @error_code = -21
        GOTO error_handler
    END

    BEGIN TRY
        BEGIN TRANSACTION
        -- DELETE ALL VERSION TRANSLATED PHRASES
        DELETE FROM [dbo].[LocalizationVersionPhrase]
         WHERE [LocalizationVersionId] IN (SELECT [LocalizationVersionId] FROM [LocalizationVersion] WHERE [CultureId] = @CultureID)

        -- DELETE ALL TRANSLATED PHRASES
        DELETE FROM [dbo].[LocalizationPhraseTranslated]
         WHERE [LocalizationCultureId] = @CultureID 

        -- DELETE ALL VERSIONS FOR THIS CULTURE ID
        DELETE FROM [dbo].[LocalizationVersion] 
         WHERE [CultureId] = @CultureID

        -- FINALLY, DELETE CULTURE
        DELETE FROM [dbo].[LocalizationCulture]
         WHERE [LocalizationCultureId] = @CultureID

        COMMIT TRANSACTION
    END TRY
    BEGIN CATCH
        ROLLBACK TRANSACTION
        SET @error_code = @@error
    END CATCH

    --goto endit

    error_handler:
    SET @ret_value = @error_code

    endit:
    RETURN  @ret_value
    --select @ret_value

    SET NOCOUNT OFF
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionCultureUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionCultureUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:      <Author,,Name>
-- Create date: <Create Date,,>
-- Description: <Description,,>
-- version 1.0
-- =============================================
CREATE PROCEDURE [dbo].[asi_TEVersionCultureUpdate]
(
    @LocalizationCultureId nvarchar(50),
    @Name nvarchar(50)
)
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @ncount int
    DECLARE @ret_value  int
    DECLARE @error_code  int

    SET @error_code = 0

    SELECT @ncount = COUNT(*) FROM LocalizationCulture AS p1
    WHERE [LocalizationCultureId] = @LocalizationCultureId

    IF @ncount <> 1
    BEGIN
        SET @error_code = -21
        GOTO error_handler
    END

    BEGIN TRY
        UPDATE [LocalizationCulture] 
           SET [LocalizationCultureName] = @Name
         WHERE [LocalizationCultureId] = @LocalizationCultureId

        IF @@ROWCOUNT <> 1
        BEGIN
            SET @error_code = -22
            GOTO error_handler
        END

    END TRY
    BEGIN CATCH
        SET @error_code = @@error
    END CATCH

    --goto endit
    error_handler:
    SET @ret_value = @error_code

    endit:
    RETURN  @ret_value
    --select @ret_value

    SET NOCOUNT off
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionDeactivate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionDeactivate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:      <Author,,Name>
-- Create date: <Create Date,,>
-- Description: <Description,,>
-- version 1.1
-- =============================================
CREATE PROCEDURE [dbo].[asi_TEVersionDeactivate]
(
    @CultureID nvarchar(50),
    @UpdatedBy nvarchar(250)
)
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON;

    DECLARE @ncount int
    DECLARE @ret_value  int
    DECLARE @error_code  int

    SET @error_code = 0

    --SELECT @ncount = COUNT(*)
    --FROM [LocalizationVersion]
    --WHERE LocalizationVersionId =  @LocalizationVersionId

    ---- check that the versionid exists before update
    --IF @ncount <> 1
    --BEGIN
    --    SET @error_code = -21
    --    GOTO error_handler
    --END


    BEGIN TRY
        BEGIN TRANSACTION

        -- 1) DEACTIVATE ACTIVE Version if exists
        UPDATE [dbo].[LocalizationVersion]
           SET ActiveVersion = 0, 
               ActiveVersionLoaded = NULL,
               DateUpdated = GETDATE(), 
               UpdatedBy = @UpdatedBy
         WHERE ActiveVersion = 1 AND CultureId = @CultureID

        -- 2) SET NULL TO field LocalizationTranslatedPhraseId for ALL RECORDS IN LocalizationVersionPhrase table for this culture ID
        --    this required because of foreign key in the table and all phrases in translated table for this culture would be deleted

        --UPDATE lvp    -- turned off, not required
        --    SET lvp.LocalizationPhraseTranslatedId = NULL
        --FROM LocalizationVersionPhrase as lvp
        --LEFT OUTER JOIN LocalizationVersion AS lv ON lv.LocalizationVersionId = lvp.LocalizationVersionId
        --WHERE lv.CultureId = @CultureID

        -- 3) DELETING ALL RECORDS IN Translated table for this Culture ID

        --DELETE FROM LocalizationPhraseTranslated  -- turned off, not required
        --WHERE LocalizationCultureId = @CultureID

        COMMIT TRANSACTION

    END TRY
    BEGIN CATCH
        ROLLBACK TRANSACTION
        SET @error_code = @@error
    END CATCH

    --goto endit

    error_handler:
    SET @ret_value = @error_code

    endit:
    RETURN  @ret_value
    --select @ret_value

    SET NOCOUNT OFF
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:      <Author,,Name>
-- Create date: <Create Date,,>
-- Description: <Description,,>
-- version 1.0
-- =============================================
CREATE PROCEDURE [dbo].[asi_TEVersionDelete]
(
    @LocalizationVersionId uniqueidentifier
)
AS
BEGIN 
    SET NOCOUNT ON

    DECLARE @ncount int
    DECLARE @ret_value  int
    DECLARE @error_code  int

    SET @error_code = 0

    SELECT @ncount = COUNT(1)
      FROM [dbo].[LocalizationVersion]
     WHERE [LocalizationVersionId] =  @LocalizationVersionId

    -- check that the versionid exists before insert
    IF @ncount <> 1
    BEGIN
        SET @error_code = -21
        GOTO error_handler
    END

    BEGIN TRY
        BEGIN TRANSACTION
        DELETE FROM [dbo].[LocalizationVersionPhrase] 
        WHERE [LocalizationVersionId] = @LocalizationVersionId 

        DELETE FROM [dbo].[LocalizationVersion] 
         WHERE [LocalizationVersionId] = @LocalizationVersionId 

        COMMIT TRANSACTION
    END TRY
    BEGIN CATCH
        ROLLBACK TRANSACTION
        SET @error_code = @@error
    END CATCH

    --goto endit

    error_handler:
    SET @ret_value = @error_code

    endit:
    RETURN  @ret_value
    --select @ret_value

    SET NOCOUNT OFF
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionGetCulture]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionGetCulture]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author: <Author,,Name>
-- Create date: <Create Date,,>
-- Description: <Description,,>
-- version 1.0
-- =============================================
CREATE PROCEDURE [dbo].[asi_TEVersionGetCulture]
(
    @cultureID nvarchar(50)
)
AS
BEGIN
    SET NOCOUNT ON;

    SELECT lc.LocalizationCultureId AS [CultureId],
           lc.LocalizationCultureName AS [CultureName],
           (SELECT COUNT(1) 
              FROM dbo.LocalizationVersion 
             WHERE CultureId = lc.LocalizationCultureId
            ) AS [Versions],
           ISNULL(lv.LocalizationVersionName,'')            AS [ActiveVersion]
      FROM [dbo].[LocalizationCulture] AS lc
           LEFT JOIN dbo.LocalizationVersion AS lv ON lv.CultureId = lc.LocalizationCultureId AND lv.ActiveVersion = 1
     WHERE lc.LocalizationCultureId = @cultureID
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionGetCultures]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionGetCultures]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author: <Author,,Name>
-- Create date: <Create Date,,>
-- Description: <Description,,>
-- version 1.0
-- =============================================
CREATE PROCEDURE [dbo].[asi_TEVersionGetCultures]
AS
BEGIN
    SET NOCOUNT ON;

    SELECT lc.LocalizationCultureId AS [CultureId],
           lc.LocalizationCultureName AS [CultureName],
           (SELECT COUNT(1) 
              FROM dbo.LocalizationVersion 
             WHERE CultureId = lc.LocalizationCultureId
            ) AS [Versions],
           ISNULL(lv.LocalizationVersionName,'') AS [ActiveVersion]
    FROM [dbo].[LocalizationCulture] AS lc
         LEFT JOIN dbo.LocalizationVersion AS lv ON lv.CultureId = lc.LocalizationCultureId AND lv.ActiveVersion = 1

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionGetCulturesNew]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionGetCulturesNew]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:      <Author,,Name>
-- Create date: <Create Date,,>
-- Description: <Description,,>
-- Get cultures from LocalizationPhraseTranslated table 
-- which would be used in Culture table for new created records
-- version 1.0
-- =============================================
CREATE PROCEDURE [dbo].[asi_TEVersionGetCulturesNew]
AS
BEGIN
    SET NOCOUNT ON;

    SELECT [CultureID] 
      FROM (SELECT DISTINCT(LocalizationCultureId) AS [CultureID] 
              FROM LocalizationPhraseTranslated) AS lpt
     WHERE lpt.CultureID NOT IN (SELECT [LocalizationCultureId] FROM LocalizationCulture)
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionGetCultureVersions]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionGetCultureVersions]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:      <Author,,Name>
-- Create date: <Create Date,,>
-- Description: <Description,,>
-- version 1.0
-- =============================================
CREATE PROCEDURE [dbo].[asi_TEVersionGetCultureVersions]
(
    @CultureID nvarchar(50)
)
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON;

    SELECT lv.[LocalizationVersionId] AS [LocalizationVersionId],
           lv.[LocalizationVersionName] AS [LocalizationVersionName],
           lv.[LocalizationVersionDesc] AS [LocalizationVersionDesc],
           lv.[Note] AS [Note],
           lv.[DateCreated] AS [DateCreated],
           lv.[CreatedBy] AS [CreatedBy],
           lv.[DateUpdated] AS [DateUpdated],
           lv.[UpdatedBy] AS [UpdatedBy],
           lv.[CultureId] AS [CultureId],
           lv.[ActiveVersion] AS [ActiveVersion],
           lv.[ActiveVersionLoaded] AS [ActiveVersionLoaded],
           lv.[StatusID] AS [StatusID],
           lc.[LocalizationCultureName] AS [CultureName], 
           ls.[LocalizationDesc] AS [StatusName],
           (SELECT COUNT(1) FROM [dbo].[LocalizationVersionPhrase] WHERE [LocalizationVersionId] = lv.LocalizationVersionId
            ) AS [Phrases]
      FROM [dbo].[LocalizationVersion] AS lv
           LEFT OUTER JOIN LocalizationCulture AS lc ON lv.CultureId = lc.LocalizationCultureId 
           LEFT OUTER JOIN LocalizationLookup  AS ls ON ls.LocalizationCode = lv.StatusID AND ls.[LocalizationLookup] = 'SOURCE'
     WHERE lv.CultureId = @CultureID

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionGetLookup]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionGetLookup]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:      <Author,,Name>
-- Create date: <Create Date,,>
-- Description: <Description,,>
-- version 1.1
-- =============================================
CREATE PROCEDURE [dbo].[asi_TEVersionGetLookup] 
(
    @lookupType nvarchar(50)
)
AS
BEGIN
    SET NOCOUNT ON;

    SELECT [LocalizationLookup],
           [LocalizationCode],
           [LocalizationDesc],
           [IsActive]
      FROM [dbo].[LocalizationLookup]
     WHERE [LocalizationLookup] = @lookupType
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionGetTransferPhrases]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionGetTransferPhrases]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_TEVersionGetTransferPhrases]
AS
BEGIN
-- 09/01/2013 - added [DoNotLocalize] and [VersionPhraseTransferDesc]
    SET NOCOUNT ON;

    SELECT [LocalizationVersionPhraseId],
           [Phrase],
           [TranslatedPhrase],
           [Result],
           [DoNotLocalize],
           [VersionPhraseTransferDesc]
      FROM [dbo].[LocalizationVersionPhraseTransfer]
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionGetVersion]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionGetVersion]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:        <Author,,Name>
-- Create date: <Create Date,,>
-- Description:   <Description,,>
-- version 1.1
-- =============================================
CREATE PROCEDURE [dbo].[asi_TEVersionGetVersion] 
(
    @LocalizationVersionId uniqueidentifier
)
AS
BEGIN
    SET NOCOUNT ON;

    SELECT [LocalizationVersionId],
           [LocalizationVersionName],
           [LocalizationVersionDesc],
           [Note],
           [DateCreated],
           [CreatedBy],
          [DateUpdated],
           [UpdatedBy],
           [CultureId],
           [ActiveVersion],
           [ActiveVersionLoaded],
           [StatusID],
           (SELECT COUNT(1) FROM [dbo].[LocalizationVersionPhrase] WHERE LocalizationVersionId = LocalizationVersion.LocalizationVersionId
            ) AS [Phrases]
      FROM [dbo].[LocalizationVersion]
     WHERE [LocalizationVersionId] = @LocalizationVersionId

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionGetVersionPhrases]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionGetVersionPhrases]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_TEVersionGetVersionPhrases]
(
    @LocalizationVersionId uniqueidentifier
)
AS
BEGIN
    SET NOCOUNT ON;
-- 09/01/2013 - added [DoNotLocalize], [Description] and [ControlType]
    SELECT [LocalizationVersionPhraseId],
           [LocalizationVersionId],
           [LocalizationPhraseTranslatedId],
           [LocalizationPhraseId],
           [Phrase],
           [TranslatedPhrase],
           [DateCreated],
           [CreatedBy],
           [DateUpdated],
           [UpdatedBy],
               [DoNotLocalize],
               [Description],          
               [ControlType]                      
      FROM [dbo].[LocalizationVersionPhrase]
     WHERE [LocalizationVersionId] = @LocalizationVersionId
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionGetVersionPhrasesLiveCount]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionGetVersionPhrasesLiveCount]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:      <Author,,Name>
-- Create date: <Create Date,,>
-- Description: <Description,,>
-- version 1.0
-- =============================================
CREATE PROCEDURE [dbo].[asi_TEVersionGetVersionPhrasesLiveCount]
(
    @LocalizationCultureId nvarchar(50)
)
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @retValue INT

    SELECT @retValue = COUNT(1) 
      FROM [dbo].[LocalizationPhraseTranslated]
     WHERE [LocalizationCultureId] = @LocalizationCultureId

    RETURN @retValue
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionGetVersionPhrasesPage]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionGetVersionPhrasesPage]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_TEVersionGetVersionPhrasesPage]
(
    @LocalizationVersionId uniqueidentifier,
    @PageSize int = NULL,
    @CurrentPage int = NULL,
    @Search nvarchar(250),
    @ShowAll bit = 1
)
AS
BEGIN
    SET NOCOUNT ON;


    DECLARE @UpperBand int
    DECLARE @LowerBand int        

    SET @LowerBand  = (@CurrentPage - 1) * @PageSize
    SET @UpperBand  = (@CurrentPage * @PageSize) + 1

    IF (@Search<>'')
    BEGIN
    -- 09/01/2013 - added [DoNotLocalize], [ControlType] and [Description] to selects
        WITH tempPhrases AS (  
            SELECT [LocalizationVersionPhraseId],
                   [LocalizationVersionId],
                   [LocalizationPhraseTranslatedId],
                   [LocalizationPhraseId],
                   [Phrase],
                   [TranslatedPhrase],
                   [DateCreated],
                   [CreatedBy],
                   [DateUpdated],
                   [UpdatedBy],
                   [Status],
                   [DoNotLocalize],
                   [Description],
                   [ControlType],
                   ROW_NUMBER() OVER (ORDER BY [Phrase] ASC ) AS [RowNumber]
              FROM [dbo].[LocalizationVersionPhrase]
             WHERE [LocalizationVersionId] = @LocalizationVersionId
               AND ([Phrase] LIKE ('%' + @Search + '%') OR [TranslatedPhrase] LIKE ('%' + @Search + '%'))
               AND (@ShowAll = 1 OR [Status] = 'N')
        ) 
        SELECT [LocalizationVersionPhraseId], [LocalizationVersionId], [LocalizationPhraseTranslatedId],
               [LocalizationPhraseId], [Phrase], [TranslatedPhrase], [DateCreated], [CreatedBy],
               [DateUpdated], [UpdatedBy], [Status], [DoNotLocalize], [Description], [ControlType], [RowNumber]
          FROM tempPhrases 
         WHERE RowNumber > @LowerBand AND RowNumber <= @UpperBand
    END
    ELSE
    BEGIN
        WITH tempPhrases AS (  
        SELECT [LocalizationVersionPhraseId],
               [LocalizationVersionId],
               [LocalizationPhraseTranslatedId],
               [LocalizationPhraseId],
               [Phrase],
               [TranslatedPhrase],
               [DateCreated],
               [CreatedBy],
               [DateUpdated],
               [UpdatedBy],
               [Status],
               [DoNotLocalize],
               [Description],
               [ControlType],
               ROW_NUMBER() OVER (ORDER BY [Phrase] ASC ) AS [RowNumber]
          FROM [LocalizationVersionPhrase]
         WHERE [LocalizationVersionId] = @LocalizationVersionId
           AND (@ShowAll = 1 OR [Status] = 'N')
        ) 
        SELECT [LocalizationVersionPhraseId], [LocalizationVersionId], [LocalizationPhraseTranslatedId],
               [LocalizationPhraseId], [Phrase], [TranslatedPhrase], [DateCreated], [CreatedBy],
               [DateUpdated], [UpdatedBy], [Status], [DoNotLocalize], [Description], [ControlType], [RowNumber] 
          FROM tempPhrases 
         WHERE RowNumber > @LowerBand AND RowNumber <= @UpperBand
    END
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionGetVersionPhrasesPageCount]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionGetVersionPhrasesPageCount]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:      <Author,,Name>
-- Create date: <Create Date,,>
-- Description: <Description,,>
-- version 1.1
-- =============================================
CREATE PROCEDURE [dbo].[asi_TEVersionGetVersionPhrasesPageCount]
(
    @LocalizationVersionId uniqueidentifier,
    @Search nvarchar(250),
    @ShowAll bit = 1
)
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @RET_VALUE INT

    IF (@Search<>'')
    BEGIN
        SELECT @RET_VALUE = COUNT(1) 
          FROM [dbo].[LocalizationVersionPhrase]
         WHERE [LocalizationVersionId] = @LocalizationVersionId
           AND ([Phrase] LIKE ('%' + @Search + '%') OR [TranslatedPhrase] LIKE ('%' + @Search + '%'))
           AND (@ShowAll = 1 OR [Status] = 'N')
    END
    ELSE
    BEGIN
        SELECT @RET_VALUE = COUNT(1) 
          FROM [dbo].[LocalizationVersionPhrase]
         WHERE [LocalizationVersionId] = @LocalizationVersionId
           AND (@ShowAll = 1 OR [Status] = 'N')
    END

    RETURN @RET_VALUE
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionRefeshNew]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionRefeshNew]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


CREATE PROCEDURE [dbo].[asi_TEVersionRefeshNew]
(
    @CultureID nvarchar(50),
    @LocalizationVersionId uniqueidentifier,
    @UpdatedBy nvarchar(250)
)
AS
BEGIN
    SET NOCOUNT ON;


    -- First, update any nulls in the LocalizationVersionPhrase table 
    -- (some imported phrases may not have LocalizationPhraseTranslatedId populated yet)
    UPDATE lvp
       SET lvp.[LocalizationPhraseTranslatedId] = lpt.[LocalizationPhraseTranslatedId]
      FROM [dbo].[LocalizationVersionPhrase] AS lvp INNER JOIN [dbo].[LocalizationPhraseTranslated] AS lpt 
        ON lvp.[LocalizationPhraseId] = lpt.[LocalizationPhraseId]
           INNER JOIN [dbo].[LocalizationVersion] AS lv
        ON lv.[LocalizationVersionId] = lvp.[LocalizationVersionId]
     WHERE lvp.[LocalizationPhraseTranslatedId] IS NULL
       AND lvp.[LocalizationVersionId] = @LocalizationVersionId
       AND lv.[CultureId] = @CultureID
       AND lpt.[LocalizationCultureId] = @CultureID

    INSERT INTO [dbo].[LocalizationVersionPhrase]  
                ([LocalizationVersionPhraseId], [LocalizationVersionId], [LocalizationPhraseTranslatedId],
                [Phrase], [TranslatedPhrase], [DateCreated], [CreatedBy], [DateUpdated], [UpdatedBy], 
                [LocalizationPhraseId], [TranslatedBy], [SystemTranslation], [Status], [StatusDate], [DoNotLocalize], [ControlType])
        SELECT NEWID(), @LocalizationVersionId, lpt.[LocalizationPhraseTranslatedId], 
               lp.[Phrase], lpt.[TranslatedPhrase], GETDATE(), @UpdatedBy, GETDATE(), @UpdatedBy, 
               lp.[LocalizationPhraseId], '', 0, 'N', GETDATE(), [DoNotLocalize], [ControlType]
          FROM [dbo].[LocalizationPhraseTranslated] AS lpt
               LEFT OUTER JOIN [dbo].[LocalizationPhrase] AS lp ON lp.[LocalizationPhraseId] = lpt.[LocalizationPhraseId]
         WHERE lpt.[LocalizationCultureId] = @CultureID
           AND lpt.[LocalizationPhraseTranslatedId] NOT IN 
               (SELECT lvp.[LocalizationPhraseTranslatedId] 
                  FROM [dbo].[LocalizationVersionPhrase] AS lvp LEFT OUTER JOIN [dbo].[LocalizationVersion] AS lv 
                    ON lv.[LocalizationVersionId] = lvp.[LocalizationVersionId]
                 WHERE lv.[CultureId] = @CultureID 
                   AND lvp.[LocalizationVersionId] = @LocalizationVersionId
                   AND lvp.[LocalizationPhraseTranslatedId] IS NOT NULL)
END



GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionLoadLiveNew]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionLoadLiveNew]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


CREATE PROCEDURE [dbo].[asi_TEVersionLoadLiveNew]
(
      @CultureID nvarchar(50),
      @LocalizationVersionId uniqueidentifier,
      @UpdatedBy nvarchar(250)
)
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @ncount int
    DECLARE @ret_value  int
    DECLARE @error_code  int

    SET @error_code = 0

    SELECT @ncount = COUNT(1)
      FROM [dbo].[LocalizationVersion]
     WHERE [LocalizationVersionId] =  @LocalizationVersionId

    -- check that the versionid exists before update
    IF @ncount <> 1
    BEGIN
        SET @error_code = -21
        GOTO error_handler
    END

    BEGIN TRY
        BEGIN TRANSACTION
        
        -- 1) DEACTIVATE ACTIVE Version
        UPDATE [dbo].[LocalizationVersion]
           SET [ActiveVersion] = 0,
               [ActiveVersionLoaded] = NULL 
         WHERE [ActiveVersion] = 1 AND [CultureId] = @CultureID

        -- 2) updating records in translated table
        DECLARE @LocalizationVersionPhraseId uniqueidentifier
        DECLARE @LocalizationPhraseTranslatedId uniqueidentifier
        DECLARE @LocalizationPhraseId uniqueidentifier
        DECLARE @TranslatedPhrase nvarchar(4000)
        
        DECLARE @NeedToUpdateVersionTable bit = 0

        DECLARE table1Cursor CURSOR FOR 
            SELECT [LocalizationPhraseTranslatedId], [TranslatedPhrase], [LocalizationPhraseId] 
              FROM [dbo].[LocalizationVersionPhrase]
             WHERE [LocalizationVersionId] = @LocalizationVersionId

        OPEN table1Cursor
        FETCH NEXT FROM table1Cursor 
         INTO @LocalizationPhraseTranslatedId, @TranslatedPhrase, @LocalizationPhraseId

        WHILE @@FETCH_STATUS = 0
        BEGIN
        
            IF (@LocalizationPhraseTranslatedId IS NULL)
            BEGIN
            
                SET @NeedToUpdateVersionTable = 1
            
                SELECT @LocalizationPhraseTranslatedId = [LocalizationPhraseTranslatedId]
                  FROM [dbo].[LocalizationPhraseTranslated]
                 WHERE [LocalizationPhraseId] = @LocalizationPhraseId
                   AND [LocalizationCultureId] = @CultureID
                   
            END
        
            IF (@LocalizationPhraseTranslatedId IS NULL)
            BEGIN
                SET @LocalizationPhraseTranslatedId = NEWID()
                
                INSERT INTO [dbo].[LocalizationPhraseTranslated] 
                           ([LocalizationPhraseTranslatedId], [LocalizationPhraseId],
                            [LocalizationCultureId], [TranslatedPhrase])
                    VALUES (@LocalizationPhraseTranslatedId, @LocalizationPhraseId, 
                            @CultureID, @TranslatedPhrase)
                
            END
            ELSE
            BEGIN
                UPDATE [dbo].[LocalizationPhraseTranslated]
                   SET [TranslatedPhrase] = @TranslatedPhrase
                 WHERE [LocalizationPhraseTranslatedId] = @LocalizationPhraseTranslatedId
            END
            
            IF (@NeedToUpdateVersionTable = 1)
            BEGIN
                SET @NeedToUpdateVersionTable = 0
            
                UPDATE [dbo].[LocalizationVersionPhrase]
                   SET [LocalizationPhraseTranslatedId] = @LocalizationPhraseTranslatedId
                 WHERE [LocalizationVersionId] = @LocalizationVersionId
                   AND [LocalizationPhraseId] = @LocalizationPhraseId
            END

              --PRINT '@LocalizationPhraseTranslatedId = ' +  @LocalizationPhraseTranslatedId
              --PRINT '@TranslatedPhrase = ' +  @TranslatedPhrase
              --PRINT '@LocalizationPhraseId = ' + @LocalizationPhraseId

            UPDATE lp
               SET [DoNotLocalize] = lvp.[DoNotLocalize]
              FROM [dbo].[LocalizationPhrase] AS lp INNER JOIN LocalizationVersionPhrase AS lvp 
                ON lvp.[LocalizationPhraseId] = lp.[LocalizationPhraseId]
             WHERE lp.[LocalizationPhraseId] = @LocalizationPhraseId

            FETCH NEXT FROM table1Cursor 
             INTO @LocalizationPhraseTranslatedId, @TranslatedPhrase, @LocalizationPhraseId
        END

        CLOSE table1Cursor
        DEALLOCATE table1Cursor

        -- 3) Syncronyzing all records from both tables, adding not existiing records from translated to version phrases table
        EXEC [dbo].[asi_TEVersionRefeshNew] @CultureID, @LocalizationVersionId, @UpdatedBy

        -- 4) ACTIVATING VERSION, set Active to 1, and ActiveVersionLoad to Current Date
        UPDATE [dbo].[LocalizationVersion]
           SET [ActiveVersion] = 1, 
               [ActiveVersionLoaded] = GETDATE(),
               [DateUpdated] = GETDATE(), 
               [UpdatedBy] = @UpdatedBy
         WHERE [LocalizationVersionId] = @LocalizationVersionId
         
        COMMIT TRANSACTION
    END TRY
    BEGIN CATCH
        ROLLBACK TRANSACTION
        SET @error_code = @@error
    END CATCH

    --goto endit

    error_handler:
    SET @ret_value = @error_code

    endit:
    RETURN  @ret_value
    --select @ret_value

    SET NOCOUNT OFF
END



GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionPhraseDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionPhraseDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:      <Author,,Name>
-- Create date: <Create Date,,>
-- Description: <Description,,>
-- version 1.0
-- =============================================
CREATE PROCEDURE [dbo].[asi_TEVersionPhraseDelete]
(
    @LocalizationVersionPhraseId uniqueidentifier
)
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON;

    DECLARE @LocalizationPhraseTranslatedId uniqueidentifier
    DECLARE @ncount int
    DECLARE @ret_value  int
    DECLARE @error_code  int

    SET @error_code = 0

    SELECT @ncount = COUNT(*)
      FROM [dbo].[LocalizationVersionPhrase]
    WHERE [LocalizationVersionPhraseId] = @LocalizationVersionPhraseId

    -- check that the versionid exists before insert
    IF @ncount <> 1
    BEGIN
        SET @error_code = -21
        GOTO error_handler
    END

    BEGIN TRY
        BEGIN TRANSACTION
        SELECT @LocalizationPhraseTranslatedId = LocalizationPhraseTranslatedId 
          FROM [dbo].[LocalizationVersionPhrase]
         WHERE LocalizationVersionPhraseId = @LocalizationVersionPhraseId 


        DELETE FROM [dbo].[LocalizationVersionPhrase] 
         WHERE LocalizationVersionPhraseId = @LocalizationVersionPhraseId 

        --DELETE LocalizationPhraseTranslated
        --WHERE LocalizationPhraseTranslatedId = @LocalizationPhraseTranslatedId 

        COMMIT TRANSACTION
    END TRY
    BEGIN CATCH
        ROLLBACK TRANSACTION
        SET @error_code = @@error
    END CATCH

    --goto endit

    error_handler:
    SET @ret_value = @error_code

    endit:
    RETURN  @ret_value
    --select @ret_value

    SET NOCOUNT OFF
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionPhraseUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionPhraseUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_TEVersionPhraseUpdate]
(
    @LocalizationVersionPhraseId uniqueidentifier,
    @TranslatedPhrase nvarchar(4000),
    @UpdatedBy nvarchar(250),
    @Status nvarchar(5),
    @DoNotLocalize bit,
    @Description nvarchar(300)
)
AS
BEGIN
    SET NOCOUNT ON;

      -- 09/01/2013 - added [DoNotLocalize] and [Description]
    UPDATE [dbo].[LocalizationVersionPhrase] 
       SET [TranslatedPhrase]= @TranslatedPhrase,
           [UpdatedBy] = @UpdatedBy, 
           [DateUpdated] = GETDATE(),
           [Status] = @Status,
           [DoNotLocalize] = @DoNotLocalize,
           [Description] = @Description
     WHERE [LocalizationVersionPhraseId] = @LocalizationVersionPhraseId
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionTransferClear]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionTransferClear]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:      <Author,,Name>
-- Create date: <Create Date,,>
-- Description: <Description,,>
-- version 1.0
-- =============================================
CREATE PROCEDURE [dbo].[asi_TEVersionTransferClear]
AS
BEGIN
    SET NOCOUNT ON;
    TRUNCATE TABLE [dbo].[LocalizationVersionPhraseTransfer]
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionTransferCreate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionTransferCreate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_TEVersionTransferCreate]
(
    @phraseId uniqueidentifier,
    @phrase nvarchar(4000),
    @translatedPhrase nvarchar(4000),
      @doNotLocalize bit,
    @description nvarchar(300)

)
AS
BEGIN
      -- 09/01/2013 - added columns and params @doNotLocalize, @description
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON;

    INSERT INTO [dbo].[LocalizationVersionPhraseTransfer] (LocalizationVersionPhraseId, Phrase, TranslatedPhrase, DoNotLocalize, [VersionPhraseTransferDesc])
    VALUES (@phraseId, @phrase, @translatedPhrase, @doNotLocalize, @description)
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionTransferIn]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionTransferIn]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[asi_TEVersionTransferIn] 
(
      @LocalizationVersionId uniqueidentifier,
      @UpdatedBy nvarchar(250)
)
AS
BEGIN
-- 08/30/2013 - added logic for @DoNotLocalize/DoNotLocalize 
-- and @Description to move to version tables

    SET NOCOUNT ON

    DECLARE @ncount INT
    DECLARE @ret_value  INT
    DECLARE @error_code  INT

    SET @error_code = 0

    SELECT @ncount = COUNT(*)
      FROM [dbo].[LocalizationVersion]
     WHERE LocalizationVersionId = @LocalizationVersionId

    -- check that the versionid exists before update
    IF @ncount <> 1
    BEGIN
        SET @error_code = -21
        GOTO error_handler
    END

    BEGIN TRY
        DECLARE @PhraseID UNIQUEIDENTIFIER
        DECLARE @TranslatedPhrase NVARCHAR(4000)
        DECLARE @DoNotLocalize bit    
        DECLARE @Description NVARCHAR(300)
        
        DECLARE @OriginalTranslatedPhrase NVARCHAR(4000)
        DECLARE @OriginalPhrase NVARCHAR(4000)   
        DECLARE @OriginalDoNotLocalize bit    
        DECLARE @OriginalDescription NVARCHAR(300)

        DECLARE table1Cursor CURSOR FOR 
            SELECT [LocalizationVersionPhraseId], [Phrase], [TranslatedPhrase], DoNotLocalize, [VersionPhraseTransferDesc]
              FROM [dbo].[LocalizationVersionPhraseTransfer] 

        OPEN table1Cursor

        FETCH NEXT FROM table1Cursor 
         INTO @PhraseID, @OriginalPhrase, @TranslatedPhrase, @DoNotLocalize, @Description

        WHILE @@FETCH_STATUS = 0
        BEGIN
            -- check if exist in original phrase table
            SELECT @ncount = COUNT(1)
              FROM [dbo].[LocalizationPhraseTranslated]
             WHERE [LocalizationPhraseTranslatedId] = @PhraseID

            IF (@ncount = 1) --phrase exists in original phrase table, compare if it changed
            BEGIN
                -- check if phrase exists in version phrase table
                SELECT @ncount = COUNT(1)
                  FROM [dbo].[LocalizationVersionPhrase] 
                 WHERE [LocalizationVersionId] = @LocalizationVersionId AND LocalizationPhraseTranslatedId = @PhraseID 

                IF (@ncount = 1) --phrase exists in version phrase table, 
                BEGIN
                    -- get previous value to compare
                    SELECT    @OriginalTranslatedPhrase = TranslatedPhrase, 
                                          @OriginalDoNotLocalize = DoNotLocalize,
                                          @OriginalDescription = [Description] 
                      FROM [dbo].[LocalizationVersionPhrase]
                     WHERE [LocalizationVersionId] = @LocalizationVersionId AND LocalizationPhraseTranslatedId = @PhraseID 

                    -- compare if it changed
                    IF (@OriginalTranslatedPhrase<>@TranslatedPhrase or 
                                    @OriginalDoNotLocalize <> @DoNotLocalize or
                                    @OriginalDescription <> @Description)
                    BEGIN -- changed
                        -- set result as #1
                        UPDATE [dbo].[LocalizationVersionPhraseTransfer]
                           SET [Result] = 1 
                         WHERE [LocalizationVersionPhraseId] = @PhraseID
                         
                        -- update tranlsated phrase
                        UPDATE [dbo].[LocalizationVersionPhrase] 
                           SET [TranslatedPhrase] = @TranslatedPhrase, 
                               [DateUpdated] = GETDATE(), 
                               [UpdatedBy] = @UpdatedBy,
                               [DoNotLocalize] = @DoNotLocalize,
                               [Description] = @Description
                         WHERE [LocalizationVersionId] = @LocalizationVersionId AND LocalizationPhraseTranslatedId = @PhraseID 
                    END
                    ELSE -- phrase hasn't changed, save result as 2; no changes in versionphrases table
                    BEGIN 
                        UPDATE [dbo].[LocalizationVersionPhraseTransfer]
                           SET [Result] = 2 
                         WHERE [LocalizationVersionPhraseId] = @PhraseID
                    END
                END
                ELSE  -- phrase doesn't exist in version phrase table
                BEGIN
                    -- create new record in versionphrases table
                    
                    INSERT INTO [dbo].[LocalizationVersionPhrase] (LocalizationVersionPhraseId, LocalizationVersionId, 
                                                                   LocalizationPhraseTranslatedId, Phrase, TranslatedPhrase, 
                                                                   DateCreated, CreatedBy, DateUpdated, UpdatedBy, LocalizationPhraseId, 
                                                                   DoNotLocalize, [Description])
                        SELECT NEWID(), @LocalizationVersionId, 
                               @PhraseID, @OriginalPhrase, @TranslatedPhrase, 
                               GETDATE(), @UpdatedBy, GETDATE(), @UpdatedBy, lpt.LocalizationPhraseId, 
                               @DoNotLocalize, @Description
                          FROM [dbo].[LocalizationVersionPhraseTransfer] AS lvpt 
                               LEFT OUTER JOIN dbo.LocalizationPhraseTranslated AS lpt ON lpt.LocalizationPhraseTranslatedId = lvpt.LocalizationVersionPhraseId
                        WHERE lvpt.LocalizationVersionPhraseId = @PhraseID

                    -- set result as #3
                    UPDATE [dbo].[LocalizationVersionPhraseTransfer]
                       SET [Result] = 3 
                     WHERE [LocalizationVersionPhraseId] = @PhraseID
                END
            END
            ELSE
            BEGIN
                -- set result as #4
                UPDATE [dbo].[LocalizationVersionPhraseTransfer]
                   SET [Result] = 4 
                 WHERE [LocalizationVersionPhraseId] = @PhraseID
            END

            FETCH NEXT FROM table1Cursor 
             INTO @PhraseID, @OriginalPhrase, @TranslatedPhrase,  @DoNotLocalize, @Description
        END

        CLOSE table1Cursor
        DEALLOCATE table1Cursor

    END TRY
    BEGIN CATCH
        SET @error_code = @@error
    END CATCH

    --goto endit

    error_handler:
    SET @ret_value = @error_code

    endit:
    RETURN  @ret_value

    SET NOCOUNT OFF
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionTransferInFromExternalDB]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionTransferInFromExternalDB]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO




CREATE PROCEDURE [dbo].[asi_TEVersionTransferInFromExternalDB] 
(
      @LocalizationVersionId uniqueidentifier,
      @UpdatedBy nvarchar(250)
)
AS
BEGIN

    SET NOCOUNT ON
    DECLARE @count int
    DECLARE @retValue int
    DECLARE @errorCode int
    DECLARE @cultureId nvarchar(50)

    SET @errorCode = 0

    -- check that the versionid exists before update and retrieve culture id for processing new phrases
    SELECT @count = COUNT(1), @cultureId = MAX([CultureId])
      FROM [dbo].[LocalizationVersion]
     WHERE LocalizationVersionId = @LocalizationVersionId

    -- check that the versionid exists before update
    IF @count <> 1
    BEGIN
        SET @errorCode = -21
        GOTO errorHandler
    END

    BEGIN TRY
        DECLARE @LocalizationVersionPhraseId uniqueidentifier
        DECLARE @Phrase nvarchar(4000)  
        DECLARE @TranslatedPhrase nvarchar(4000)
        DECLARE @DoNotLocalize bit    
        DECLARE @Description nvarchar(300) 
        
        DECLARE @LocalizationPhraseId uniqueidentifier
        DECLARE @PhraseExists bit
        DECLARE @LocalizationPhraseTranslatedId uniqueidentifier 

        DECLARE table1Cursor CURSOR FOR 
            SELECT [LocalizationVersionPhraseId], [Phrase], [TranslatedPhrase], [DoNotLocalize], [VersionPhraseTransferDesc]
              FROM [dbo].[LocalizationVersionPhraseTransfer] 

        OPEN table1Cursor

        FETCH NEXT FROM table1Cursor 
            INTO @LocalizationVersionPhraseId, @Phrase, @TranslatedPhrase, @DoNotLocalize, @Description

        WHILE @@FETCH_STATUS = 0
        BEGIN
        
            SET @LocalizationPhraseId = NULL
            SELECT @LocalizationPhraseId = [LocalizationPhraseId] 
              FROM [dbo].[LocalizationPhrase]
             WHERE LTRIM(RTRIM([Phrase])) = LTRIM(RTRIM(@Phrase))
             
            IF (@LocalizationPhraseID IS NULL)
            BEGIN
                SET @PhraseExists = 0
                SET @LocalizationPhraseId = NEWID()
            END
            ELSE
            BEGIN
                SET @PhraseExists = 1
            END
        
            -- check if phrase exists in LocalizationVersionPhrase table
            -- as long as the phrase exists (otherwise, the count should be 0)          
            SELECT @count = COUNT(1)
              FROM [dbo].[LocalizationVersionPhrase]
             WHERE [LocalizationVersionId] = @LocalizationVersionId
               AND [LocalizationPhraseId] = @LocalizationPhraseId
               AND @PhraseExists = 1

            IF (@count > 0) --phrase exists in version phrase table
            BEGIN
            
                IF EXISTS(SELECT 1 FROM [dbo].[LocalizationVersionPhrase] 
                                  WHERE [LocalizationVersionId] = @LocalizationVersionId
                                    AND [LocalizationPhraseId] = @LocalizationPhraseId
                                    AND (ISNULL(TranslatedPhrase,'') <> @TranslatedPhrase 
                                         OR [DoNotLocalize] <> @DoNotLocalize 
                                         OR [Description] <> @Description))
                BEGIN
                    -- changes in versionphrases table, save result as 1
                    UPDATE [dbo].[LocalizationVersionPhraseTransfer]
                       SET [Result] = 1 
                     WHERE [LocalizationVersionPhraseId] = @LocalizationVersionPhraseId
                         
                    -- update LocalizationVersionPhrase.  No need to worry about other tables
                    UPDATE [dbo].[LocalizationVersionPhrase] 
                       SET [TranslatedPhrase] = @TranslatedPhrase, 
                           [DateUpdated] = GETDATE(), 
                           [UpdatedBy] = @UpdatedBy,
                           [DoNotLocalize] = @DoNotLocalize,
                           [Description] = @Description
                     WHERE [LocalizationVersionId] = @LocalizationVersionId
                       AND [LocalizationPhraseId] = @LocalizationPhraseId     
                END   
                ELSE -- phrase hasn't changed, save result as 2; no changes in versionphrases table
                BEGIN
                    UPDATE [dbo].[LocalizationVersionPhraseTransfer]
                       SET [Result] = 2 
                     WHERE [LocalizationVersionPhraseId] = @LocalizationVersionPhraseId
                END                                  
            END
            ELSE  -- phrase doesn't exist in version phrase table
            BEGIN        
             
                IF (@PhraseExists = 0)
                BEGIN
                    -- create new record in LocalizationPhrase table
                    INSERT INTO [dbo].[LocalizationPhrase] ([LocalizationPhraseId], [LocalizationApplicationId], 
                                                            [Phrase], [DoNotLocalize], [ControlType])
                         VALUES ( @LocalizationPhraseId, 0, @Phrase, @DoNotLocalize, '')      
                END
                
                -- update existing or create new record in LocalizationPhraseTranslated table
                SET @LocalizationPhraseTranslatedId = NULL
                SELECT @LocalizationPhraseTranslatedId = [LocalizationPhraseTranslatedId] 
                  FROM [dbo].[LocalizationPhraseTranslated] 
                 WHERE [LocalizationPhraseId] = @LocalizationPhraseID AND [LocalizationCultureId] = @cultureId
                   
                -- create new record in LocalizationVersionPhrase table
                INSERT INTO [dbo].[LocalizationVersionPhrase] 
                                  ([LocalizationVersionPhraseId], [LocalizationVersionId], 
                                   [LocalizationPhraseTranslatedId], [Phrase], [TranslatedPhrase], 
                                   [DateCreated], [CreatedBy], [DateUpdated], [UpdatedBy], 
                                   [Description], [LocalizationPhraseId], [DoNotLocalize])
                        SELECT NEWID(), @LocalizationVersionId, 
                               @LocalizationPhraseTranslatedId, @Phrase, @TranslatedPhrase, 
                               GETDATE(), @UpdatedBy, GETDATE(), @UpdatedBy, 
                               @Description, @LocalizationPhraseId, @DoNotLocalize
                          FROM [dbo].[LocalizationVersionPhraseTransfer]
                         WHERE [LocalizationVersionPhraseId] = @LocalizationVersionPhraseId

                    -- set result as #3
                    UPDATE [dbo].[LocalizationVersionPhraseTransfer]
                       SET [Result] = 3 
                     WHERE [LocalizationVersionPhraseId] = @LocalizationVersionPhraseId
            END
            
            FETCH NEXT FROM table1Cursor 
             INTO @LocalizationVersionPhraseId, @Phrase, @TranslatedPhrase, @DoNotLocalize, @Description
        END

        CLOSE table1Cursor
        DEALLOCATE table1Cursor

    END TRY
    
    BEGIN CATCH
        SET @errorCode = @@error
    END CATCH

    errorHandler:
    SET @retValue = @errorCode

    RETURN  @retValue

    SET NOCOUNT OFF
END



GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_TEVersionUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_TEVersionUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

-- =============================================
-- Author:      <Author,,Name>
-- Create date: <Create Date,,>
-- Description: <Description,,>
-- version 1.0
-- =============================================
CREATE PROCEDURE [dbo].[asi_TEVersionUpdate]
(
    @LocalizationVersionId uniqueidentifier,
    @Name nvarchar(250),
    @Description nvarchar(400),
    @Note nvarchar(400),
    @UpdatedBy nvarchar(250),
    @Status nvarchar(5)
)
AS
BEGIN 
    SET NOCOUNT ON

    DECLARE @ncount int
    DECLARE @ret_value  int
    DECLARE @error_code  int

    SET @error_code = 0

    SELECT @ncount = COUNT(1) 
      FROM [dbo].[LocalizationVersion] AS p1
     WHERE [LocalizationVersionId] = @LocalizationVersionId

    IF @ncount <> 1
    BEGIN
        SET @error_code = -21
        GOTO error_handler
    END

    BEGIN TRY

        UPDATE [dbo].[LocalizationVersion] 
           SET [LocalizationVersionName] = @Name,
               [LocalizationVersionDesc] = @Description, 
               [Note] = @Note, 
               [DateUpdated] = GETDATE(), 
               [UpdatedBy] = @UpdatedBy, 
               [StatusID] = @Status 
        WHERE [LocalizationVersionId] = @LocalizationVersionId

        IF @@ROWCOUNT <> 1
        BEGIN
            SET @error_code = -22
            GOTO error_handler
        END

    END TRY
    BEGIN CATCH
        SET @error_code = @@error
        --if @@error <> 0
        --          begin
        --          set @error_code = @@error
        --          goto error_handler
        --          end
    END CATCH

    --if @inv_num = 0 
    --         goto error_handler

    --if @@error <> 0
    --         begin
    --         set @error_hold = @@error
    --         goto error_handler
    --         end

    --goto endit

    error_handler:
    SET @ret_value = @error_code

    endit:
    RETURN  @ret_value
    --select @ret_value

    SET NOCOUNT OFF
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_UniformString]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_UniformString]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


CREATE    PROC [dbo].[asi_UniformString]
	@organizationKey uniqueidentifier,
   	@userKey uniqueidentifier,
   	@loggedInUserGroupKey uniqueidentifier = '00000000-0000-0000-0000-000000000000', -- if this is empty, we assume the user is not logged in
	@uniformString nvarchar(850) OUTPUT
	AS
BEGIN
	SET @uniformString = N' (UniformMain.OrganizationKey='+NCHAR(39)+CAST(@organizationKey As nchar(36))+NCHAR(39)+' OR UniformMain.OrganizationKey='+NCHAR(39)+N'{00000000-0000-0000-0000-000000000000}'+NCHAR(39)+')'
	SET	@uniformString = @uniformString+N'AND(EXISTS(SELECT 1 FROM AccessItem INNER JOIN UserToken ON AccessItem.Grantee = UserToken.Grantee OR AccessItem.Grantee = '+NCHAR(39)+CAST(@loggedInUserGroupKey As nchar(36))+NCHAR(39)+' WHERE AccessItem.AccessKey = UniformMain.AccessKey AND UserToken.UserKey='+NCHAR(39)+CAST(@userKey As nchar(36))+NCHAR(39)+' AND (AccessItem.Permission&3)>0))'
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_UpdateCampaignResponses]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_UpdateCampaignResponses]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE           PROCEDURE [dbo].[asi_UpdateCampaignResponses]
@useImplicit	bit, 
@userKey 	uniqueidentifier,
@debugging	bit = 0  --False
AS

-- call the CS stored proc
exec asi_CsUpdateCampaignResponses @useImplicit,@userKey 
--The following values were used during testing
--SET @useImplicit = 1 
--SET @userKey = '73493EB2-7F2E-4345-A800-0BF5582B16BC' 
 -- EO 09-21-06 Commenting the rest out, since
-- there's no need for it in Medina
/*
DECLARE @firstSalesHistory	datetime
DECLARE @lastSalesHistory	datetime
DECLARE @newGuid		uniqueidentifier
DECLARE @now 			datetime
DECLARE @systemConfigParamName	varchar(50)

SET @systemConfigParamName = 'UpdateCampaignResponsesIsRunning'

SET XACT_ABORT ON -- Any runtime error will result in rollback of transaction

BEGIN TRANSACTION

-- Allow other instances of this sproc to see SystemConfig parameter while this instance is running.
-- This prevents deadlock due to this SystemConfig parameter.
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED 

-- If necessary, setup the SystemConfig setting to indicate whether this procedure is currently running
IF NOT EXISTS(SELECT 1 FROM SystemConfig WHERE ParameterName = @systemConfigParamName)
   BEGIN
	SET @newGuid = newid()
	SET @now = getdate()

	INSERT SystemConfig (SystemConfigKey, ParameterName, ParameterValue, [Description], 
	       OrganizationKey, SystemEntityKey, CreatedByUserKey, CreatedOn, UpdatedByUserKey, UpdatedOn)
	VALUES(	@newGuid, 
		@systemConfigParamName, 
		'True', 
		'Indicates whether the asi_UpdateCampaignResponses stored procedure is running.',
		'00000000-0000-0000-0000-000000000000',
		NULL,
		@userKey, 
		@now, 
		@userKey, 
		@now)
   END
ELSE  -- SystemConfig param already exists
   BEGIN
      -- Check if this sproc is already running and, if so, return an error.
      IF EXISTS(SELECT 1 
                  FROM SystemConfig 
                 WHERE ParameterName = @systemConfigParamName 
                   AND ParameterValue = 'True')
         BEGIN
            RAISERROR('Stored procedure asi_UpdateCampaignResponses is already running', 1, 1) WITH SETERROR
            RETURN @@ERROR
         END
      ELSE  -- This sproc is not already running
         BEGIN
	    -- Set the SystemConfig param to indicate this sproc is now running
            UPDATE SystemConfig
               SET ParameterValue = 'True'
             WHERE ParameterName = @systemConfigParamName
         END
   END

SET TRANSACTION ISOLATION LEVEL READ COMMITTED -- The default

--Get the last SalesHistory row used in a response update and update the number
-- to the current max
EXECUTE asi_GetSalesHistoryResponseStart @userKey, @firstSalesHistory OUTPUT, 
	@lastSalesHistory OUTPUT
 
SET @now = getdate()

IF EXISTS (SELECT * FROM tempdb..sysobjects WHERE id = OBJECT_ID(N'tempdb..#tmpResponse'))
   DROP TABLE #tmpResponse

CREATE TABLE #tmpResponse(
	InvoiceNumber		nvarchar(50), 
	InvoiceLineNumber	int,
	OrderDate		datetime, 
	UserKey			uniqueidentifier,
	ProductKey		uniqueidentifier,
	SourceCode		nvarchar(40), 
	TotalRevenue		decimal(18,4),
	WasSolicited		bit NOT NULL DEFAULT 1)

IF @debugging = 1
BEGIN
PRINT 'SalesHistory records where SC is not null'
SELECT sh.InvoiceNumber, sh.InvoiceLineNumber, sh.OrderDate, 
       sh.BillToContactKey, sh.ProductKey, sc.Code, sh.ExtendedPrice
  FROM SalesHistory sh
 INNER JOIN SourceCode sc ON sh.SourceCodeKey = sc.SourceCodeKey
 WHERE sh.CreatedOn > @firstSalesHistory AND sh.CreatedOn <= @lastSalesHistory
   AND sh.SourceCodeKey IS NOT NULL
   AND sc.SourceCodeStatusCode = 0 -- i.e. Is Active
END  --IF @debugging

--SalesHistory records with matching source code
INSERT #tmpResponse(InvoiceNumber, InvoiceLineNumber, OrderDate,  
       UserKey, ProductKey, SourceCode, TotalRevenue)
SELECT sh.InvoiceNumber, sh.InvoiceLineNumber, sh.OrderDate, 
       sh.BillToContactKey, sh.ProductKey, sc.Code, sh.ExtendedPrice
  FROM SalesHistory sh
 INNER JOIN SourceCode sc ON sh.SourceCodeKey = sc.SourceCodeKey
 WHERE sh.CreatedOn > @firstSalesHistory AND sh.CreatedOn <= @lastSalesHistory
   AND sh.SourceCodeKey IS NOT NULL
   AND sc.SourceCodeStatusCode = 0 -- i.e. Is Active
 
IF @debugging = 1
BEGIN
PRINT '#tmpResponse after insert of above'
SELECT * FROM #tmpResponse
END  --IF @debugging

IF @useImplicit = 1
BEGIN

IF @debugging = 1
BEGIN
PRINT 'SalesHistoryRecords where SC is null and relates to appeal'
SELECT DISTINCT sh.InvoiceNumber, sh.InvoiceLineNumber, sh.OrderDate, 
       sh.BillToContactKey, sh.ProductKey, sh.ExtendedPrice 
  FROM SalesHistory sh
 INNER JOIN AppealProduct ap ON sh.ProductKey = ap.ProductKey
 INNER JOIN AppealMain am ON ap.AppealKey = am.AppealKey
 WHERE sh.CreatedOn > @firstSalesHistory AND sh.CreatedOn <= @lastSalesHistory
   AND sh.SourceCodeKey IS NULL
   AND am.AppealStatusCode = 0 -- 0 is Active
END  --IF @debugging

-- SalesHistory records with matching products and no explicit source code
INSERT #tmpResponse(InvoiceNumber, InvoiceLineNumber, OrderDate, 
       UserKey, ProductKey, TotalRevenue)
SELECT DISTINCT sh.InvoiceNumber, sh.InvoiceLineNumber, sh.OrderDate, 
       sh.BillToContactKey, sh.ProductKey, sh.ExtendedPrice 
  FROM SalesHistory sh
 INNER JOIN AppealProduct ap ON sh.ProductKey = ap.ProductKey
 INNER JOIN AppealMain am ON ap.AppealKey = am.AppealKey
 WHERE sh.CreatedOn > @firstSalesHistory AND sh.CreatedOn <= @lastSalesHistory
   AND sh.SourceCodeKey IS NULL
   AND am.AppealStatusCode = 0 -- 0 is Active

IF @debugging = 1
BEGIN
PRINT '#temResponse after insert of above'
SELECT * FROM #tmpResponse
END  --IF @debugging

--Attempt to find a match using the product and user key
UPDATE tr
   SET SourceCode = 
       (SELECT TOP 1 sc.Code 
          FROM AppealProduct ap
         INNER JOIN SolicitationMain s ON ap.AppealKey = s.AppealKey
         INNER JOIN SourceCode sc ON s.SolicitationKey = sc.SolicitationKey
         WHERE ap.ProductKey = tr.ProductKey
           AND EXISTS( SELECT 1
                       FROM ListItem
                       WHERE ListKey = sc.SourceCodeKey
                         AND ObjectKey = tr.UserKey)
	                 AND sc.LastDropDate = 
                             (SELECT MAX(sc2.LastDropDate)
		                FROM AppealProduct ap2
		               INNER JOIN SolicitationMain s2 ON ap2.AppealKey = s2.AppealKey
		               INNER JOIN SourceCode sc2 ON s2.SolicitationKey = sc2.SolicitationKey
		               WHERE ap2.ProductKey = tr.ProductKey)) 
  FROM #tmpResponse tr
 WHERE tr.SourceCode IS NULL

--Attempt to find a match just using the product
UPDATE tr
   SET SourceCode = 
       (SELECT TOP 1 sc.Code
 	  FROM AppealProduct ap
	 INNER JOIN SolicitationMain s ON ap.AppealKey = s.AppealKey
	 INNER JOIN SourceCode sc ON s.SolicitationKey = sc.SolicitationKey
	 WHERE ap.ProductKey = tr.ProductKey
           AND sc.LastDropDate = (SELECT MAX(sc2.LastDropDate)
		                    FROM AppealProduct ap2
		                   INNER JOIN SolicitationMain s2 ON ap2.AppealKey = s2.AppealKey
		                   INNER JOIN SourceCode sc2 ON s2.SolicitationKey = sc2.SolicitationKey
		                   WHERE ap2.ProductKey = tr.ProductKey)),
       WasSolicited = 0
  FROM #tmpResponse tr
 WHERE tr.SourceCode IS NULL

IF @debugging = 1
BEGIN
PRINT '#tmpResponse before delete of recs w/o source code'
SELECT * FROM #tmpResponse
END  --IF @debugging

--Remove records without a source code
DELETE #tmpResponse
 WHERE SourceCode IS NULL

IF @debugging = 1
BEGIN
PRINT '#tmpResponse after delete of recs w/o source code'
SELECT * FROM #tmpResponse
END  --IF @debugging

END  --IF @useImplicit = 1


IF EXISTS (SELECT * FROM tempdb..sysobjects WHERE id = OBJECT_ID(N'tempdb..#bySourceCode'))
   DROP TABLE #bySourceCode

CREATE TABLE #bySourceCode(
	SourceCode	nvarchar(60), 
	TotalRevenue	decimal(18,4), 
	FirstResponse	datetime, 
	LastResponse	datetime, 
	LowResponse	decimal(18,4), 
	HighResponse	decimal(18,4), 
	TotalResponses	int)
 
-- Aggregate the responses by source code
INSERT #bySourceCode
SELECT SourceCode, SUM(TotalRevenue), MIN(OrderDate), MAX(OrderDate), MIN(TotalRevenue), 
       MAX(TotalRevenue), COUNT(*)
  FROM #tmpResponse
 GROUP BY SourceCode

IF @debugging = 1
BEGIN
PRINT '#bySourceCode table after insert'
SELECT * FROM #bySourceCode
END  --IF @debugging

IF EXISTS (SELECT * FROM tempdb..sysobjects WHERE id = OBJECT_ID(N'tempdb..#byAppeal'))
   DROP TABLE #byAppeal

CREATE TABLE #byAppeal(
	CampaignKey		uniqueidentifier, 
	AppealKey		uniqueidentifier, 
	SolicitationKey		uniqueidentifier, 
	SourceCodeKey		uniqueidentifier, 
	UserKey			uniqueidentifier, 
	WasSolicited		bit)

--Aggregate the responses by appeal and user
INSERT #byAppeal
SELECT DISTINCT c.CampaignKey, a.AppealKey, s.SolicitationKey, sc.SourceCodeKey,  tr.UserKey, tr.WasSolicited
  FROM #tmpResponse tr
 INNER JOIN SourceCode sc ON tr.SourceCode = sc.Code
 INNER JOIN SolicitationMain s ON sc.SolicitationKey = s.SolicitationKey
 INNER JOIN AppealMain a ON s.AppealKey = a.AppealKey 
 INNER JOIN CampaignMain c ON a.CampaignKey = c.CampaignKey

IF @debugging = 1
BEGIN
PRINT '#byAppeal table after insert'
SELECT * FROM #byAppeal
END  --IF @debugging

--Allow only one record per Appeal and User combination
SET rowcount 1
 
DECLARE @appealKey 		uniqueidentifier
DECLARE @campaignKey 		uniqueidentifier
DECLARE @respondentUserKey 	uniqueidentifier
 
SELECT @appealKey = AppealKey, @campaignKey = CampaignKey, @respondentUserKey = UserKey
  FROM #byAppeal
 GROUP BY CampaignKey, AppealKey, UserKey
HAVING COUNT(*) > 1

WHILE @@ROWCOUNT > 0
BEGIN
   DELETE #byAppeal
    WHERE AppealKey = @appealKey
      AND CampaignKey = @campaignKey
      AND UserKey = @respondentUserKey
   SELECT @appealKey = AppealKey, @campaignKey = CampaignKey, @respondentUserKey = UserKey
     FROM #byAppeal
    GROUP BY CampaignKey, AppealKey, UserKey
   HAVING COUNT(*) > 1
END  -- WHILE @@ROWCOUNT > 0
 
SET rowcount 0
 
--Update SourceCode
UPDATE sc
   SET TotalRevenue = sc.TotalRevenue + bsc.TotalRevenue,
       FirstResponseDate = CASE
				WHEN sc.FirstResponseDate IS NULL THEN bsc.FirstResponse 
				WHEN bsc.FirstResponse < sc.FirstResponseDate THEN bsc.FirstResponse 
				ELSE sc.FirstResponseDate END,
       LastResponseDate = CASE
				WHEN sc.LastResponseDate IS NULL THEN bsc.LastResponse 
				WHEN bsc.LastResponse > sc.LastResponseDate THEN bsc.LastResponse 
				ELSE sc.LastResponseDate END,
       LowResponseAmount = CASE
				WHEN sc.LowResponseAmount < 0 THEN bsc.LowResponse 
				WHEN bsc.LowResponse < sc.LowResponseAmount THEN bsc.LowResponse   	
				ELSE sc.LowResponseAmount END,
       HighResponseAmount = CASE 
				WHEN bsc.HighResponse > sc.HighResponseAmount THEN bsc.HighResponse 
				ELSE sc.HighResponseAmount END,
       TotalPositiveResponse = sc.TotalPositiveResponse + bsc.TotalResponses, 
       ResponsesTotalledOn = @now,
       UpdatedOn = @now,
       UpdatedByUserKey = @userKey
  FROM SourceCode sc
 INNER JOIN #bySourceCode bsc ON sc.Code = bsc.SourceCode

IF @debugging = 1
BEGIN
PRINT 'SourceCode table after update'
SELECT * FROM SourceCode
END  --IF @debugging

--Create campaign opt-in
INSERT CampaignParticipation(CampaignParticipationKey, 
       CampaignKey, RespondentUserKey, ResponseTypeCode, CreatedByUserKey, CreatedOn, UpdatedByUserKey, UpdatedOn)
SELECT newid(), CampaignKey, UserKey, 1, @userKey, @now, @userKey, 
       @now -- UnsolicitedResponse = Opt-In = ResponseStatus of one (1)
  FROM #byAppeal ba
 WHERE NOT EXISTS(SELECT 1 
                    FROM CampaignParticipation 
                   WHERE CampaignKey = ba.CampaignKey 
		     AND RespondentUserKey = ba.UserKey)

IF @debugging = 1
BEGIN
PRINT 'CampaignParticipation table after insert'
SELECT * FROM CampaignParticipation
END  --IF @debugging

--Update appeal participation
UPDATE ap
   SET SolicitationKey = ba.SolicitationKey,
       SourceCodeKey = ba.SourceCodeKey,
       ResponseTypeCode = CASE WHEN WasSolicited = 1 THEN 0 ELSE 1 END,
       UpdatedOn = @now,
       UpdatedByUserKey = @userKey
  FROM AppealParticipation ap
 INNER JOIN #byAppeal ba ON ap.AppealKey = ba.AppealKey AND ap.RespondentUserKey = ba.UserKey

IF @debugging = 1
BEGIN
PRINT 'AppealParticipation table after update'
SELECT * FROM AppealParticipation
END  --IF @debugging

--Create appeal participation
INSERT AppealParticipation
       (AppealParticipationKey, AppealKey, RespondentUserKey, SolicitationKey, SourceCodeKey, 
       ResponseTypeCode, CreatedByUserKey, CreatedOn, UpdatedByUserKey, UpdatedOn)
SELECT newid(), AppealKey, UserKey, SolicitationKey, SourceCodeKey, 
       CASE WHEN WasSolicited = 1 THEN 0 ELSE 1 END, 
       @userKey, @now, @userKey, 
       @now --SolicitedResponse = Responded = ResponseStatus of zero (0)
  FROM #byAppeal ba
 WHERE NOT EXISTS(SELECT 1 
                    FROM AppealParticipation 
                   WHERE AppealKey = ba.AppealKey 
                     AND RespondentUserKey = ba.UserKey)

IF @debugging = 1
BEGIN
PRINT 'AppealParicipation table after insert'
SELECT * FROM AppealParticipation
END  --IF @debugging

COMMIT TRANSACTION

-- Cleanup temp tables
IF EXISTS (SELECT * FROM tempdb..sysobjects WHERE id = OBJECT_ID(N'tempdb..#byAppeal'))
   DROP TABLE #byAppeal
IF EXISTS (SELECT * FROM tempdb..sysobjects WHERE id = OBJECT_ID(N'tempdb..#bySourceCode'))
   DROP TABLE #bySourceCode
IF EXISTS (SELECT * FROM tempdb..sysobjects WHERE id = OBJECT_ID(N'tempdb..#tmpResponse'))
   DROP TABLE #tmpResponse

-- Set the SystemConfig param to indicate this sproc has completed running
UPDATE	SystemConfig
   SET	ParameterValue = 'False' 
 WHERE	ParameterName = @systemConfigParamName




*/

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_UpdateContactSalutation]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_UpdateContactSalutation]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_UpdateContactSalutation]
	(@inputSalutationKey uniqueidentifier)
AS
BEGIN

SET NOCOUNT ON

DECLARE @sql nvarchar(2000)
DECLARE @contactKey uniqueidentifier
DECLARE @IndividualFormula nvarchar(2000)
DECLARE @InstituteFormula nvarchar(2000)

DECLARE @calcFormula nvarchar(2000) 

DECLARE @tempKey uniqueidentifier
DECLARE @tempValue nvarchar(1000)

DECLARE @isDeletable as bit
DECLARE @autoCreate as bit

SELECT @IndividualFormula = IndividualFormula, @InstituteFormula = InstituteFormula, @autoCreate = AutoCreate
	FROM vBoSalutationRef 
	WHERE SalutationKey = @inputSalutationKey
	
IF @@ROWCOUNT = 0
    RETURN

IF @autoCreate = 1
	select @isDeletable = 0
ELSE
	select @isDeletable = 1

DECLARE theCursor CURSOR FAST_FORWARD FOR 
	SELECT ContactKey
		FROM vBoContactSalutation
		WHERE SalutationKey = @inputSalutationKey
			AND IsOverridden = 0

OPEN theCursor
FETCH NEXT FROM theCursor INTO @contactKey

WHILE @@FETCH_STATUS = 0
BEGIN

	SET @tempKey = newid()
	
	SELECT @sql =  
		CASE 
		WHEN IsInstitute = 1 THEN
			' asi_ProcessFormulaOutput ' 
				+ '''' + convert (nvarchar(100), @tempKey) + ''', '
				+ '''' + @InstituteFormula + ''', '
				+ '''vBoInstitute'', ''ContactKey'', ' 
				+ '''' + convert (nvarchar(50), @contactKey) 
				+ ''''
	
		WHEN IsInstitute = 0 THEN
			' asi_ProcessFormulaOutput ' 
				+ '''' + convert (nvarchar(100), @tempKey) + ''', '
				+ '''' + @IndividualFormula + ''', '
				+ '''vBoIndividual'', ''ContactKey'', ' 
				+ '''' + convert (nvarchar(50), @contactKey) 
				+ ''''
		END
	FROM vBoContact WHERE ContactKey = @contactKey
	
	EXEC (@sql)
	
	SELECT @tempValue = tempValue from tempFormula
		WHERE tempKey = @tempKey
	
	IF datalength (@tempValue) > 0 AND @tempValue IS NOT NULL
		UPDATE vBoContactSalutation SET SalutationText = @tempValue, IsDeletable = @isDeletable
		WHERE ContactKey = @contactKey and SalutationKey = @inputSalutationKey
	
	DELETE FROM tempFormula WHERE tempKey = @tempKey
	
	FETCH NEXT FROM theCursor INTO @contactKey
END

CLOSE theCursor
DEALLOCATE theCursor

UPDATE SalutationRef SET NeedsUpdateFlag = 0 WHERE SalutationKey = @inputSalutationKey

SET NOCOUNT OFF

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_UpdateContactSalutations]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_UpdateContactSalutations]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure [dbo].[asi_UpdateContactSalutations]
	(@inputSalutationKey uniqueidentifier)
as
begin

set nocount on

/* create table tempFormula
	(tempKey uniqueidentifier,
	tempValue nvarchar(1000) )  */

declare @sql nvarchar(2000)
declare @contactKey uniqueidentifier
declare @IndividualFormula nvarchar(2000)
declare @InstituteFormula nvarchar(2000)

declare @calcFormula nvarchar(2000) 

declare @tempKey uniqueidentifier
declare @tempValue nvarchar(1000)

select @IndividualFormula = IndividualFormula, 
	@InstituteFormula = InstituteFormula 
	from vBoSalutationRef where SalutationKey = @inputSalutationKey

declare theCursor cursor for 
	select ContactKey
		from vBoContactSalutation
		where SalutationKey = @inputSalutationKey
			and IsOverridden = 0

open theCursor
fetch next from theCursor into @contactKey

WHILE @@FETCH_STATUS = 0
begin

set @tempKey = newid()

select @sql =  
	case 
	when IsInstitute = 1 then
			' asi_ProcessContactFormulaOutput ' 
				+ '''' + convert (nvarchar(100), @tempKey) + ''', '
				+ '''' + @InstituteFormula + ''', '
				+ '''vBoInstitute'', ''ContactKey'', ' 
				+ '''' + convert (nvarchar(50), @contactKey) 
				+ ''''

	when IsInstitute = 0 then
			' asi_ProcessContactFormulaOutput ' 
				+ '''' + convert (nvarchar(100), @tempKey) + ''', '
				+ '''' + @IndividualFormula + ''', '
				+ '''vBoIndividual'', ''ContactKey'', ' 
				+ '''' + convert (nvarchar(50), @contactKey) 
				+ ''''
	end
from vBoContact where ContactKey = @contactKey

exec (@sql)

select @tempValue = tempValue from tempFormula
	where tempKey = @tempKey

if datalength (@tempValue) > 0 and @tempValue is not null
	update vBoContactSalutation set
		SalutationText = @tempValue
	where ContactKey = @contactKey and SalutationKey = @inputSalutationKey

delete from tempFormula where tempKey = @tempKey

fetch next from theCursor into @contactKey
end

close theCursor
deallocate theCursor

set nocount off

end

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_UpdatePublishRequest]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_UpdatePublishRequest]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_UpdatePublishRequest]
	@PublishRequestKey uniqueidentifier,
	@PublishedDateTime datetime
AS
BEGIN

	SET NOCOUNT ON;
	DECLARE @PendingCount int
	DECLARE @ErrorCount int

	SELECT @PendingCount = Count(*) FROM PublishRequestDetail
	WHERE PublishRequestStatusCode = 0
      AND PublishRequestKey = @PublishRequestKey
	SELECT * FROM PublishRequestDetail
	WHERE PublishRequestStatusCode = 0
      AND PublishRequestKey = @PublishRequestKey

	SELECT @ErrorCount = Count(*) FROM PublishRequestDetail
	WHERE PublishRequestStatusCode = 3
      AND PublishRequestKey = @PublishRequestKey

    if (@PendingCount = 0)
	BEGIN
		UPDATE PublishRequest
		   SET PublishedDateTime = @PublishedDateTime
		 WHERE PublishRequestKey = @PublishRequestKey

		IF (@ErrorCount = 0)
		BEGIN
			UPDATE PublishMessageLog
			   SET DisplayFlag = 0
			 WHERE PublishRequestKey = @PublishRequestKey
		END
	END
END


SET ANSI_NULLS ON

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_UserHasNetSecurity]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_UserHasNetSecurity]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_UserHasNetSecurity]
	@contactMaster varchar(50)
AS
	declare @userKey uniqueidentifier
	select @userKey = UserKey from UserMain where ContactMaster = @contactMaster
	if @@ROWCOUNT = 0
	begin
		select 0
		return
	end

	if exists (select * from UserRole where UserKey = @userKey and RoleKey <> (select RoleKey from RoleMain where Name = 'Everyone' and IsSystem = 1))
	begin
		select 1
		return
	end

	if exists (select * from GroupMember where MemberContactKey = @userKey)
	begin
		select 1
		return
	end

	if exists (
		select 1 from UserMain um left outer join AccessItem ai on um.UserKey = ai.UserKey
		where ai.AccessKey IS NOT NULL AND um.UserKey = @userKey
		GROUP BY um.UserId HAVING COUNT(um.UserId) > 1
	)
	begin
		select 1
		return
	end

	select 0

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_UserTokenUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_UserTokenUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO



CREATE PROCEDURE [dbo].[asi_UserTokenUpdate]
    @userKey uniqueidentifier 
AS
BEGIN
    DECLARE @now datetime;
    DECLARE @everyoneRoleKey uniqueidentifier;
    SET @now = GETDATE();
    SELECT @everyoneRoleKey = ParameterValue 
      FROM [dbo].[SystemConfig] 
     WHERE [ParameterName] = N'Security.Token.EveryoneRoleKey'

    -- A Table variable to hold our intermediate results
    DECLARE @token TABLE ([Grantee] uniqueidentifier null, [RoleName] nvarchar(65))

    -- Add Self
    INSERT INTO @token ([Grantee], [RoleName])
    VALUES (@userKey, N'')

    -- Add Everyone Role
    INSERT INTO @token ([Grantee], [RoleName])
    VALUES	(@everyoneRoleKey, N'Everyone')

    -- Add Assigned Roles
    INSERT INTO @token ([Grantee], [RoleName])
        SELECT ur.[RoleKey], rm.[Name]
          FROM [dbo].[UserRole] ur
               INNER JOIN [dbo].[RoleMain] rm ON ur.[RoleKey] = rm.[RoleKey]
         WHERE ur.[UserKey] = @userKey
           AND ur.[RoleKey] <> @everyoneRoleKey

    -- Add Effective Group Membership
    INSERT INTO @token ([Grantee], [RoleName])
        SELECT [GroupKey], [Name]
          FROM [dbo].[GroupMain]
         WHERE GroupKey IN ( SELECT DISTINCT GroupKey
                               FROM [dbo].[GroupMember]
                              WHERE [MemberContactKey] = @userKey
                                AND ([JoinDate] <= @now OR [JoinDate] IS NULL)
                                AND ([DropDate] >= @now OR [DropDate] IS NULL)
                           )

    -- Add legacy security group - use newid because it needs to be unique and will never actually be accessed by key
    INSERT INTO @token ([Grantee], [RoleName])
        SELECT NEWID(), nsg.[SECURITY_GROUP]
          FROM [dbo].[Name_Security] ns
	           INNER JOIN [dbo].[Name_Security_Groups] nsg ON ns.[ID] = nsg.[ID]
               INNER JOIN [dbo].[UserMain] b ON ns.ID = b.[ContactMaster]
         WHERE b.UserKey = @userKey
           AND LEN(LTRIM(RTRIM(nsg.[SECURITY_GROUP]))) > 0

    -- Add Member type - use newid because it needs to be unique and will never actually be accessed by key
    INSERT INTO @token ([Grantee], [RoleName])
        SELECT NEWID(), n.[MEMBER_TYPE]
          FROM Name n
	          INNER JOIN UserMain um ON n.ID = um.ContactMaster
         WHERE um.UserKey = @userKey
           AND LEN(LTRIM(RTRIM(n.[MEMBER_TYPE]))) > 0

    -- Add Member
    DECLARE @memberGroupKey uniqueidentifier
    DECLARE @groupName nvarchar(65)

    SELECT @memberGroupKey = [ParameterValue]
      FROM [dbo].[SystemConfig]
     WHERE [ParameterName] = N'CM.MemberGroupKey'

    SELECT @groupName = [Name] 
      FROM [dbo].[GroupMain]
     WHERE [GroupKey] = @memberGroupKey

    INSERT INTO @token ([Grantee], [RoleName])
        SELECT @memberGroupKey, @groupName
          FROM Name n
               INNER JOIN Member_Types mt ON n.MEMBER_TYPE = mt.MEMBER_TYPE
               INNER JOIN UserMain u ON n.ID = u.ContactMaster
         WHERE mt.MEMBER_RECORD = 1
               AND u.UserKey = @userKey

    -- Remove Expired Records From Persisted Source
    DELETE	UserToken
     WHERE	UserKey = @userKey
            AND NOT EXISTS ( SELECT 1 FROM @token WHERE	Grantee = UserToken.Grantee )

    -- Add Missing Records To Persisted Source
    INSERT INTO [dbo].[UserToken] ([UserKey], [Grantee], [RoleName])
        SELECT	@userKey, [Grantee], [RoleName]
          FROM	@token t
         WHERE	NOT EXISTS ( SELECT	1 FROM [dbo].[UserToken] WHERE [UserKey] = @userKey AND [Grantee] = t.Grantee )

    -- Return Tokens
    SELECT Grantee, RoleName
      FROM @token

END



GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_UserMainLogin]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_UserMainLogin]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROC [dbo].[asi_UserMainLogin]
    @ProviderKey nvarchar(100)
AS
BEGIN
    -- Set nocount option to surpress row count messages
    SET NOCOUNT ON
    -- Declare variables
    DECLARE @userKey uniqueidentifier
    DECLARE @contactMaster varchar(50)
    DECLARE @name nvarchar(50)
    DECLARE @userIdTest nvarchar(50)
    DECLARE @organizationKey uniqueidentifier
    DECLARE @loggedInUserGroupKey uniqueidentifier
    DECLARE @now datetime
    
    SET @now = GETDATE();
    
    -- Initialize local variables if User/Password combination is valid and user is active
    SELECT TOP 1 @userKey = [UserKey], 
                 @contactMaster = [ContactMaster], 
                 @name = [UserId], 
                 @userIdTest = [UserId]
      FROM [dbo].[UserMain]
     WHERE [ProviderKey] = @ProviderKey
           AND [IsDisabled] = 0
           AND COALESCE([EffectiveDate], DATEADD(DAY,-1,@now)) <= @now
           AND COALESCE([ExpirationDate], DATEADD(DAY,1,@now)) >= @now

    SELECT @organizationKey = [OrganizationKey]
      FROM [dbo].[OrganizationMain]
     WHERE [IsDefault] = 1

    -- If validation succeeded, then continue
    IF @userKey IS NOT NULL
    BEGIN
        -- Return variables as first resultset
        SELECT @userKey AS [UserKey], 
               @contactMaster AS [ContactMaster], 
               @name AS [Name], 
               @userIdTest AS [UserId],
               @organizationKey AS [OrganizationKey]
               
        -- Return roles as second resultset
        EXEC asi_UserTokenUpdate @userKey
        
        -- Return legacy roles as third resultset
        SELECT [UserId], [UserKey], [Role]
          FROM [dbo].[vLegacySecurityRole] 
         WHERE [UserKey] = @userKey
        
        SELECT @loggedInUserGroupKey = [ParameterValue]
          FROM [dbo].[SystemConfig] 
         WHERE [ParameterName] = N'CM.LoggedInUserGroupKey'
         
         -- Create Temporary Table
        DECLARE @token TABLE (Grantee uniqueidentifier NULL, RoleName nvarchar(65))
        
        INSERT INTO @token ([Grantee], [RoleName])
        SELECT [GroupKey], [Name]
          FROM [dbo].[GroupMain] 
         WHERE [GroupKey] = @loggedInUserGroupKey
         
         -- Add a row to represent Content Authority Group membership
        INSERT INTO @token ([Grantee], [RoleName])
        SELECT 'C4D78A02-048A-4D35-8440-74B5C82CF62F', 'ContentAuthority'
         WHERE EXISTS(SELECT 1 
          FROM [dbo].[GroupMember] gm 
                INNER JOIN [dbo].[GroupMain] g ON gm.[GroupKey] = g.[GroupKey]
          WHERE gm.[MemberContactKey] = @userKey
                AND gm.[IsActive] = 1
                AND g.[GroupTypeKey] = 'C4D78A02-048A-4D35-8440-74B5C82CF62F')
                
        -- Return Tokens
        SELECT Grantee, RoleName
          FROM @token
    END

    -- Reset nocount option
    SET NOCOUNT OFF

END



GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_UserMainUniqueUserId]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_UserMainUniqueUserId]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  Stored Procedure dbo.asi_UserMainUniqueUserId    Script Date: 7/3/2003 4:58:05 PM ******/
CREATE PROC asi_UserMainUniqueUserId
	@userKey uniqueidentifier,
	@userId nvarchar(50)
	AS
BEGIN
	DECLARE @isUnique bit

	SET @isUnique = 1

	SET ROWCOUNT 1

	SELECT	@isUnique = 0
	 FROM	UserMain
	 WHERE	UserId = @userId
	   AND	UserKey <> @userKey

	SET ROWCOUNT 0

	SELECT @isUnique AS UserIdIsUnique
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_WorkflowInstanceAppendLog]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_WorkflowInstanceAppendLog]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE  proc [dbo].[asi_WorkflowInstanceAppendLog]
 @instanceKey uniqueidentifier,
 @textToAppend nvarchar(4000) as

DECLARE @ptr varbinary(16)

SELECT  @ptr = TEXTPTR(LogText)
 FROM   WorkflowInstance
 WHERE  WorkflowInstanceKey = @instanceKey
IF TEXTVALID('WorkflowInstance.LogText', @ptr) = 1
BEGIN
   UPDATETEXT WorkflowInstance.LogText @ptr NULL 0 @textToAppend --Append to end
   --UPDATETEXT WorkflowInstance.LogText @ptr 0 0 @textToAppend --Insert at beginning
END
ELSE
BEGIN
   UPDATE WorkflowInstance
      SET LogText = @textToAppend
    WHERE WorkflowInstanceKey = @instanceKey
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_WorkItemQueueFetch]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_WorkItemQueueFetch]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE       PROCEDURE [dbo].[asi_WorkItemQueueFetch]
@itemCount int = 3,
@category nvarchar(50) = null
AS

DECLARE @id uniqueidentifier
SET @id=newid()

DECLARE @tmp nvarchar(800)

SET @tmp = N'SELECT TOP ' + CAST(@itemCount as nvarchar(10)) + N' WorkItemQueueKey, SelectionLock INTO #pick '
SET @tmp = @tmp + N'FROM WorkItemQueue '
SET @tmp = @tmp + N'WHERE IsInteractive = 0 AND (SelectionLock IS NULL OR KeepAlive < dateadd(mi, - dbo.asi_GetWorkItemLockDuration(), getdate())) AND (BeginOn IS NULL OR BeginOn >= getdate()) '
IF DATALENGTH(@category) > 0
BEGIN
    SET @tmp = @tmp + N'AND Category LIKE ''' + @category + N'%'' '
END
SET @tmp = @tmp + N'ORDER BY Priority ASC, EnqueuedOn ASC '

SET @tmp = @tmp + N'UPDATE WorkItemQueue SET SelectionLock = ''' + CAST(@id AS nvarchar(40)) + N''', SelectedOn = getdate(), KeepAlive = getdate() '
SET @tmp = @tmp + N'FROM WorkItemQueue INNER JOIN #pick ON WorkItemQueue.WorkItemQueueKey = #pick.WorkItemQueueKey '
SET @tmp = @tmp + N'WHERE (WorkItemQueue.SelectionLock IS NULL OR WorkItemQueue.SelectionLock = #pick.SelectionLock) '

SET @tmp = @tmp + N'DROP TABLE #pick '

SET @tmp = @tmp + N'SELECT WorkItemQueueKey FROM WorkItemQueue WHERE SelectionLock = ''' + CAST(@id AS nvarchar(40)) + N''''

EXEC(@tmp)

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[asi_WriteGLTransactionLines]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[asi_WriteGLTransactionLines]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[asi_WriteGLTransactionLines]
@transKey uniqueidentifier,
@sequenceNumber int,
@glEntryType nvarchar(50) 
AS
	DECLARE @glTransactionLineKey uniqueidentifier
	DECLARE @glTransactionKey uniqueidentifier 
	DECLARE @amount decimal (18,4)
	DECLARE @glAccountKey uniqueidentifier 
	DECLARE @description nvarchar(50)
	DECLARE @paymentKey uniqueidentifier 
	DECLARE @productKey uniqueidentifier 
	DECLARE @deferralTermsKey uniqueidentifier 
	DECLARE @targetGLAccountKey uniqueidentifier 
	DECLARE @deferralProcessedFlag bit 
	DECLARE @invoiceLineKey uniqueidentifier 
	DECLARE @transactionSequenceNumber int 
	DECLARE @lineGroup int
	DECLARE @realSequenceNumber int
	DECLARE @lineGroupNumber int
	DECLARE @groupCounter int
	SET @groupCounter = 0
	SET @realSequenceNumber = -1
	SET @transactionSequenceNumber = 0
	
	-- The UniqueLineGroups table variable keeps track of the unique combination of GLAccounts and
	-- PaymentKeys used in the GLTransactionLines.
	-- We need to set different LineGroup values for different combinations.
	DECLARE @UniqueLineGroups TABLE
		(GLAccountKey uniqueidentifier, 
		 PaymentKey uniqueidentifier, 
		 GroupNumber int)

	DECLARE Get_TransactionLines cursor for 
	SELECT  newid(), @transKey, sum(#tmpTransLine.Amount), 
			#tmpTransLine.AccountKey, #tmpTransLine.Description, #tmpTransLine.PaymentKey, 
			#tmpTransLine.ProductKey, #tmpTransLine.DeferralTermsKey, 
			#tmpTransLine.TargetGLAccountKey, 0, #tmpTransLine.InvoiceLineKey,
			MIN(#tmpTransLine.TransactionSequenceNumber)
		FROM #tmpTransLine
		INNER JOIN #tmpTransaction 
			ON (#tmpTransLine.InvoiceKey = #tmpTransaction.InvoiceKey
			   OR #tmpTransLine.PaymentKey = #tmpTransaction.PaymentKey)
			AND #tmpTransLine.FinEntityKey = #tmpTransaction.FinEntityKey
		WHERE #tmpTransaction.TransactionKey = @transKey
			AND #tmpTransLine.GLEntryType = @glEntryType		
		GROUP BY 
			#tmpTransLine.AccountKey, #tmpTransLine.Description, #tmpTransLine.PaymentKey, 
			#tmpTransLine.ProductKey, #tmpTransLine.DeferralTermsKey, 
			#tmpTransLine.TargetGLAccountKey, #tmpTransLine.InvoiceLineKey, 
			#tmpTransLine.GLEntryType,
			#tmpTransLine.InvoiceLineNumber
		ORDER BY #tmpTransLine.InvoiceLineNumber
		

	OPEN Get_TransactionLines
	FETCH NEXT FROM Get_TransactionLines into @glTransactionLineKey, @glTransactionKey, @amount,
		@glAccountKey, @description, @paymentKey, @productKey , @deferralTermsKey, @targetGLAccountKey,
		@deferralProcessedFlag, @invoiceLineKey,  @transactionSequenceNumber
	WHILE @@FETCH_STATUS = 0
	BEGIN
		IF (@glEntryType = 'UnearnedIncome'
		  OR @glEntryType = 'AccountsReceivable')
		BEGIN
			SET @lineGroupNumber = null
			SELECT @lineGroupNumber = GroupNumber from @UniqueLineGroups 
				WHERE GLAccountKey = @glAccountKey
					AND PaymentKey = ISNULL(@paymentKey, '00000000-0000-0000-0000-000000000000')
			IF @lineGroupNumber IS NULL
			BEGIN
			    -- found a new account
				INSERT @UniqueLineGroups(GLAccountKey, GroupNumber, PaymentKey) 
					VALUES(@glAccountKey, @groupCounter, ISNULL(@paymentKey, '00000000-0000-0000-0000-000000000000'))
				SET @lineGroupNumber = @groupCounter
				SET @groupCounter = @groupCounter + 1
			END	
			IF (@realSequenceNumber < 0)
				SET @realSequenceNumber = @transactionSequenceNumber + @sequenceNumber
			ELSE
				SET  @realSequenceNumber =  @realSequenceNumber + 1
		
			INSERT GLTransactionLine(GLTransactionLineKey, GLTransactionKey, Amount, GLAccountKey,
			Description, PaymentKey, ProductKey, DeferralTermsKey, 
			TargetGLAccountKey, DeferralProcessedFlag, InvoiceLineKey, GLEntryType, 
			TransactionSequenceNumber, LineGroup)
			VALUES (@glTransactionLineKey, @glTransactionKey, @amount, @glAccountKey, 
				@description, @paymentKey, @productKey , @deferralTermsKey, @targetGLAccountKey,
				@deferralProcessedFlag, @invoiceLineKey, @glEntryType, @realSequenceNumber, 
				@lineGroupNumber)
		
		END  
		
		ELSE
		BEGIN
			INSERT GLTransactionLine(GLTransactionLineKey, GLTransactionKey, Amount, GLAccountKey,
			Description, PaymentKey, ProductKey, DeferralTermsKey, 
			TargetGLAccountKey, DeferralProcessedFlag, InvoiceLineKey, GLEntryType, 
			TransactionSequenceNumber, LineGroup)
			VALUES (@glTransactionLineKey, @glTransactionKey, @amount, @glAccountKey, 
				@description, @paymentKey, @productKey , @deferralTermsKey, @targetGLAccountKey,
				@deferralProcessedFlag, @invoiceLineKey, @glEntryType, @transactionSequenceNumber + @sequenceNumber, 
				@transactionSequenceNumber)
		
		END
	nextTransactionLine:
	FETCH NEXT FROM Get_TransactionLines into @glTransactionLineKey, @glTransactionKey, @amount,
		@glAccountKey, @description, @paymentKey, @productKey , @deferralTermsKey, @targetGLAccountKey,
		@deferralProcessedFlag, @invoiceLineKey,  @transactionSequenceNumber
	END
	CLOSE Get_TransactionLines
	DEALLOCATE Get_TransactionLines
	DELETE @UniqueLineGroups
		
	SET @sequenceNumber = @sequenceNumber + @transactionSequenceNumber
	RETURN @sequenceNumber

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AsiGPSAnnualReportPivot]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[AsiGPSAnnualReportPivot]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
--------------------------------------------------------------
-- Create AsiGPSAnnualReportPivot table and populate with defaults
--------------------------------------------------------------
CREATE PROCEDURE [dbo].[AsiGPSAnnualReportPivot]
AS
BEGIN
 
    ;WITH PivotData AS (
            SELECT    YEAR(P.PeriodEnd) AS [Year]
                    , Ref.AsiGPSMeasureDesc AS MeasureDescription
                    , P.MeasureName
                    , P.MeasureValue
                    , P.SerialNo
                    , Goal.MeasureName AS GoalMeasureName, Goal.MeasureValue AS GoalMeasureValue
                    , Goal.SerialNo AS GoalSerialNo, Goal.PeriodEnd AS GoalPeriodEnd
                    , CASE  WHEN Goal.MeasureValue <> 0 THEN P.MeasureValue/Goal.MeasureValue END AS GoalPercentage 
                    , CASE  WHEN Goal.MeasureValue <> 0 AND P.MeasureValue/Goal.MeasureValue >= .95 THEN 'Green'
                            WHEN Goal.MeasureValue <> 0 AND .90 <= P.MeasureValue/Goal.MeasureValue AND P.MeasureValue/Goal.MeasureValue < .95 THEN 'Yellow'
                            WHEN Goal.MeasureValue <> 0 AND .90 > P.MeasureValue/Goal.MeasureValue THEN 'Red'
                            ELSE 'Gray'
                      END AS GoalColor
                    , Industry.MeasureName AS IndustryMeasureName, Industry.MeasureValue AS IndustryMeasureValue
                    , Industry.SerialNo AS IndustrySerialNo, Industry.PeriodEnd AS IndustryPeriodEnd
                    , CASE  WHEN Industry.MeasureValue <> 0 THEN P.MeasureValue/Industry.MeasureValue END AS IndustryPercentage
                    , CASE  WHEN Industry.MeasureValue <> 0 AND P.MeasureValue/Industry.MeasureValue >= .95 THEN 'Green'
                            WHEN Industry.MeasureValue <> 0 AND .90 <= P.MeasureValue/Industry.MeasureValue AND P.MeasureValue/Industry.MeasureValue < .95 THEN 'Yellow'
                            WHEN Industry.MeasureValue <> 0 AND .90 > P.MeasureValue/Industry.MeasureValue THEN 'Red'
                            ELSE 'Gray'
                      END AS IndustryColor
            -- SELECT   *
            FROM    AsiGPSPivotData P                    
                    INNER JOIN AsiGPSMeasureRef Ref ON P.MeasureName = Ref.AsiGPSMeasureName AND Ref.IsActive = 1
                    LEFT OUTER JOIN (SELECT     *
                                     FROM       AsiGPSPivotData
                                     WHERE      RowType = 'OrgGoal' -- Goal
                                     AND        YEAR(PeriodEnd)= YEAR(GETDATE())-1) Goal 
                        ON P.MeasureName = Goal.MeasureName
                        AND YEAR(P.PeriodEnd) = YEAR(Goal.PeriodEnd)
                    LEFT OUTER JOIN (SELECT     *
                                     FROM       AsiGPSPivotData
                                     WHERE      RowType = 'Industry' -- Industry
                                     AND        YEAR(PeriodEnd)= YEAR(GETDATE())-1) Industry 
                        ON P.MeasureName = Industry.MeasureName
                        AND YEAR(P.PeriodEnd) = YEAR(Industry.PeriodEnd)                        
            WHERE   P.RowType = 'Organization'
            AND     Ref.IsActive = 1
            GROUP BY YEAR(P.PeriodEnd)
                    , Ref.AsiGPSMeasureDesc
                    , P.MeasureName
                    , P.MeasureValue
                    , P.SerialNo
                    , Goal.MeasureName, Goal.MeasureValue
                    , Goal.SerialNo, Goal.PeriodEnd
                    , CASE  WHEN Goal.MeasureValue <> 0 THEN P.MeasureValue/Goal.MeasureValue END
                    , CASE  WHEN Goal.MeasureValue <> 0 AND P.MeasureValue/Goal.MeasureValue >= .95 THEN 'Green'
                            WHEN Goal.MeasureValue <> 0 AND .90 <= P.MeasureValue/Goal.MeasureValue AND P.MeasureValue/Goal.MeasureValue < .95 THEN 'Yellow'
                            WHEN Goal.MeasureValue <> 0 AND .90 > P.MeasureValue/Goal.MeasureValue THEN 'Red'
                            ELSE 'Gray'
                      END
                    , Industry.MeasureName, Industry.MeasureValue
                    , Industry.SerialNo, Industry.PeriodEnd
                    , CASE  WHEN Industry.MeasureValue <> 0 THEN P.MeasureValue/Industry.MeasureValue END
                    , CASE  WHEN Industry.MeasureValue <> 0 AND P.MeasureValue/Industry.MeasureValue >= .95 THEN 'Green'
                            WHEN Industry.MeasureValue <> 0 AND .90 <= P.MeasureValue/Industry.MeasureValue AND P.MeasureValue/Industry.MeasureValue < .95 THEN 'Yellow'
                            WHEN Industry.MeasureValue <> 0 AND .90 > P.MeasureValue/Industry.MeasureValue THEN 'Red'
                            ELSE 'Gray'
                      END
    ) 
       SELECT MeasureDescription, MeasureName, SerialNo,
         MAX(CASE [Year] WHEN YEAR(GETDATE())-3 THEN MeasureValue END) [3],
         MAX(CASE [Year] WHEN YEAR(GETDATE())-2 THEN MeasureValue END) [2],
         MAX(CASE [Year] WHEN YEAR(GETDATE())-1 THEN MeasureValue END) [1],
         MAX(CASE [Year] WHEN YEAR(GETDATE())-1 THEN GoalMeasureValue END) [Goal],
         MAX(CASE [Year] WHEN YEAR(GETDATE())-1 THEN GoalPercentage END) [GoalPercentage],
         MAX(CASE [Year] WHEN YEAR(GETDATE())-1 THEN GoalColor END) [GoalColor],
         MAX(CASE [Year] WHEN YEAR(GETDATE())-1 THEN IndustryMeasureValue END) [Industry],
         MAX(CASE [Year] WHEN YEAR(GETDATE())-1 THEN IndustryPercentage END) [IndustryPercentage],
         MAX(CASE [Year] WHEN YEAR(GETDATE())-1 THEN IndustryColor END) [IndustryColor]
      FROM PivotData
       GROUP BY MeasureDescription, MeasureName, SerialNo
 
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AsiGPSAnnualUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[AsiGPSAnnualUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO



----------------------------------------------------------------
-- Alter AsiGPSAnnualUpdate SP that currently exists on Gold DB
----------------------------------------------------------------
CREATE PROCEDURE [dbo].[AsiGPSAnnualUpdate] (@ThisYear nvarchar(4) = '', @ReCalculate bit = 0) 
AS
BEGIN

-- Testing block
-- DECLARE @ThisYear nvarchar(4) = '2013',
--         @ReCalculate bit = 0

    ------------------------------------------------------------------------------------------------------------
    -- The following declaration defines the ActivityType codes that are considered as Financial Activities.  --
    -- Modify this list as needed to reflect any custom ActivityTypes.                                        --
    --    NOTE: Be sure to separate each new value with a comma and keep within the outer quotes              --
    ------------------------------------------------------------------------------------------------------------
    DECLARE @FinancialActivities  varchar(8000);
    SET @FinancialActivities  = 'CEU,DUES,EXPO,GIFT,MEETFUNC,MEETING,ORDER,PLEDGE,REFUND,REQUEST,SALES';

        -- Validate query
        -- SELECT @FinancialActivities

    DECLARE @PrevYearNewMbrs    TABLE (Id varchar(10) NOT NULL, 
                                       JoinDate datetime, 
                                       PaidThru datetime, 
                                       MemberStatus varchar(5) NOT NULL, 
                                       MemberStatusDate datetime)
    DECLARE @CurrYearNewMbrs    TABLE (Id varchar(10) NOT NULL, 
                                       JoinDate datetime, 
                                       PaidThru datetime, 
                                       MemberStatus varchar(5) NOT NULL, 
                                       MemberStatusDate datetime)
    DECLARE @PrevYrNonFinAct    TABLE (Id varchar(10) NOT NULL, 
                                       Seqn int, 
                                       RowType varchar(10), 
                                       RelatedSeqn int, 
                                       KeyValue varchar(255) NULL)
    DECLARE @CurrYrNonFinAct    TABLE (Id varchar(10) NOT NULL, 
                                       Seqn int, 
                                       RowType varchar(10), 
                                       RelatedSeqn int, 
                                       KeyValue varchar(255) NULL)
    DECLARE @PrevYrFinAct       TABLE (Id varchar(10) NOT NULL, 
                                       Seqn int, 
                                       RowType varchar(10), 
                                       RelatedSeqn int, 
                                       KeyValue varchar(255) NULL)
    DECLARE @CurrYrFinAct       TABLE (Id varchar(10) NOT NULL, 
                                       Seqn int, 
                                       RowType varchar(10), 
                                       RelatedSeqn int, 
                                       KeyValue varchar(255) NULL)
    DECLARE @EventRegsCurrYear  TABLE (Id varchar(10) NOT NULL, 
                                       Seqn int, 
                                       RowType varchar(10), 
                                       RelatedSeqn int, 
                                       KeyValue varchar(255) NULL)

    DECLARE @RunDate            datetime,
            @PrevFiscalBegin    datetime,
            @PrevFiscalEnd      datetime,
            @CurrFiscalBegin    datetime,
            @CurrFiscalEnd      datetime,
            @FiscalBegin        int,
            @CurrYear           int,
            @CurrYearText       varchar(4),
            @SerialNo           varchar(255),
            @PrevYearMembers    int,
            @CurrMembers        int,
            @NewMbrPrevYear     int,
            @NewMbrPrevYTD      int,             -- Not Yet Implemented
            @NewMbrCurrYear     int,
            @NewMbrPct          decimal(18,9),
            @RenewMbrCurrYear   int,
            @RenewBillCurrYear  int,
            @RenewRateCurrYr    decimal(18,9),
            @NewUserPrevYear    int,
            @NewUserPrevYTD     int,             -- Not Yet Implemented
            @NewUserCurrYear    int,
            @NewUserPct         decimal(18,9),
            @PrevYrNewRenew     int,
            @PrevYrNewRenewPct  decimal(18,9),
            @NonFinActPrevYr    int,
            @NonFinActCurrYr    int,
            @FinActPrevYr       int,
            @FinActCurrYr       int,
            @CmteActPrevYr      int,             -- Not Yet Implemented
            @CmteActCurrYr      int,
            @WebVisitsPrevYr    int,             -- Not Yet Implemented
            @WebVisitsCurrYr    int,             -- Not Yet Implemented
            @EmailsPrevYr       int,             -- Not Yet Implemented
            @EmailsCurrYr       int,
            @LettersPrevYr      int,             -- Not Yet Implemented
            @LettersCurrYr      int,
            @NonFinActPerMbr    decimal(18,9),
            @FinActPerMbr       decimal(18,9),
            @CmteActPerMbr      decimal(18,9),
            @WebVisitsPerMbr    decimal(18,9),   -- Not Yet Implemented
            @EmailsPerMbr       decimal(18,9),
            @LettersPerMbr      decimal(18,9),
            @EventRegCurrYr     int,
            @AvgEventReg        decimal(18,9),
            @PrevYrAvgEventReg  decimal(18,9),
            @AvgEventRegIncreasePct     decimal(18,9),
            @PrevYearExists     bit,
            @MbrIncreasePct     decimal(18,9),
            @PrevYearRevenue    money,
            @TotalRevenue       money,
            @RevenueIncreasePct decimal(18,9),
            @RevenuePerMember   decimal(18,9),
            @IndexRecruit       decimal(18,9),
            @IndexEngage        decimal(18,9),
            @IndexGrow          decimal(18,9),
            @IndexOverall       decimal(18,9)

    SET @PrevYearExists = 0;
    SET @WebVisitsPerMbr = NULL;
            
    ---------------------------------------------------
    -- Establish the date that this procedure is run --
    ---------------------------------------------------
    SET @RunDate = GETDATE()
        
    -------------------------------------------------------------------------
    -- Establish the date ranges for the previous and current Fiscal Years --
    -------------------------------------------------------------------------
    SET @FiscalBegin = 
        CASE WHEN EXISTS(SELECT * FROM System_Params WHERE ParameterName = 'AR_Control.YearBegins') 
            THEN (SELECT ShortValue FROM System_Params WHERE ParameterName = 'AR_Control.YearBegins')
            ELSE 1
        END;

    SET @CurrFiscalBegin = 
    CASE WHEN @ThisYear > '' THEN CAST(@ThisYear + '-' + CAST(@FiscalBegin AS VARCHAR(2)) + '-1' AS datetime)
         WHEN MONTH(GETDATE()) >= @FiscalBegin THEN CAST(CAST(YEAR(GETDATE()) AS VARCHAR) + '-' + CAST(@FiscalBegin AS VARCHAR(2)) + '-1' AS datetime)
         WHEN MONTH(GETDATE()) <  @FiscalBegin THEN CAST(CAST(YEAR(GETDATE())-1 AS VARCHAR) + '-' + CAST(MONTH(GETDATE()) AS VARCHAR(2)) + '-1' AS datetime)
    END;
    
    SET @CurrFiscalEnd = DATEADD(DAY,-1,DATEADD(YEAR,1,@CurrFiscalBegin))
    SET @PrevFiscalBegin = DATEADD(YEAR,-1,@CurrFiscalBegin)
    SET @PrevFiscalEnd = DATEADD(YEAR,-1,@CurrFiscalEnd)
    SET @CurrYear = YEAR(@CurrFiscalEnd)                       -- 12/4/2012 JHS: Added
    SET @CurrYearText = CAST(@CurrYear AS varchar(4))          -- 12/4/2012 JHS: Added

    -- Determine whether data exists for previous fiscal year --
    IF EXISTS (SELECT 1 FROM AsiGPSData WHERE PeriodBegin = @PrevFiscalBegin) 
        SET @PrevYearExists = 1

    -- Validation query
    -- SELECT @FiscalBegin , @CurrFiscalBegin , @CurrFiscalEnd , @PrevFiscalBegin , @PrevFiscalEnd

    -------------------------------------------------
    -- Delete existing rows if ReCalculate is True --
    -------------------------------------------------
    IF EXISTS (SELECT 1 FROM AsiGPSData WHERE PeriodBegin = @CurrFiscalBegin) AND @ReCalculate <> 0
      BEGIN
        DELETE AsiGPSData WHERE PeriodBegin = @CurrFiscalBegin 
        DELETE AsiGPSPivotData WHERE PeriodBegin = @CurrFiscalBegin AND RowType = 'Organization'
      END
    --ELSE IF EXISTS (SELECT 1 FROM AsiGPSData WHERE PeriodBegin = @CurrFiscalBegin) AND @ReCalculate = 0
    --  BEGIN
    --    RETURN 2 -- Exit and return a value of 2 which indicates that data for the specified year already exists
    --  END

    ------------------------------------
    -- Identify License Serial Number --
    ------------------------------------
    SELECT  @SerialNo = ShortValue FROM System_Params WHERE ParameterName = 'System_Control.SerialNo'
        
    -------------------------------
    -- Count all current members --
    -------------------------------
    SELECT @CurrMembers = COUNT(n.ID)
      FROM Name n  LEFT JOIN Member_Types mt ON n.MEMBER_TYPE = mt.MEMBER_TYPE 
     WHERE mt.MEMBER_RECORD <> 0 -- 2574

    -- Validation query
    -- SELECT @CurrMembers 

    -----------------------------
    -- BEGIN SECTION   RECRUIT --
    -----------------------------

    ------------------------------------------
    -- Calculate New Members By Fiscal Year --
    ------------------------------------------

    -- Previous Fiscal Year --
    INSERT INTO @PrevYearNewMbrs(Id, JoinDate, PaidThru, MemberStatus, MemberStatusDate)
     SELECT ID, JOIN_DATE, PAID_THRU, MEMBER_STATUS, MEMBER_STATUS_DATE
       FROM Name 
      WHERE JOIN_DATE >= @PrevFiscalBegin 
        AND JOIN_DATE <= @PrevFiscalEnd 

    -- Validate query
    -- SELECT * FROM @PrevYearNewMbrs

    SELECT @NewMbrPrevYear = COUNT(Id) 
      FROM @PrevYearNewMbrs 

    -- Validate query
    -- SELECT @NewMbrPrevYear
 
    SELECT @NewMbrPrevYTD = COUNT(Id) FROM @PrevYearNewMbrs
     WHERE JoinDate <= DATEADD(YEAR,-1,GETDATE())

    -- Current Fiscal Year --
    INSERT INTO @CurrYearNewMbrs(Id, JoinDate, PaidThru, MemberStatus, MemberStatusDate)
     SELECT ID, JOIN_DATE, PAID_THRU, MEMBER_STATUS, MEMBER_STATUS_DATE
       FROM Name 
      WHERE JOIN_DATE >= @CurrFiscalBegin 
        AND JOIN_DATE <= @CurrFiscalEnd 

    -- Validate query
    -- SELECT * FROM @CurrYearNewMbrs

    SELECT @NewMbrCurrYear = COUNT(Id) FROM @CurrYearNewMbrs 

    -- Validate query
    -- SELECT @NewMbrPrevYear , @NewMbrPrevYTD , @NewMbrCurrYear

    -------------------------------------------------       ---------------
    -- Calculate New Members as Pct of All Members --       -- RECRUIT-1 --
    -------------------------------------------------       ---------------
    SELECT @NewMbrPct = 
        CASE WHEN @CurrMembers > 0 
            THEN CAST(@NewMbrCurrYear AS decimal(18,9))/CAST(@CurrMembers AS decimal(18,9))
            ELSE NULL
        END

    -- Validate query
    -- SELECT @NewMbrPct

    -----------------------------------                     ---------------
    -- Calculate Conversion Renewals --                     -- RECRUIT-2 --
    -----------------------------------                     ---------------
    SELECT @PrevYrNewRenew = COUNT(n.ID)
      FROM Name n
           JOIN @PrevYearNewMbrs p  ON n.ID = p.Id
     WHERE n.MEMBER_STATUS = 'R'

    -- Validate query
    -- SELECT @PrevYrNewRenew 

    SELECT @PrevYrNewRenewPct = 
        CASE WHEN @CurrMembers > 0 
            THEN CAST(@PrevYrNewRenew AS decimal(18,9))/CAST(@NewMbrPrevYear AS decimal(18,9))
            ELSE NULL
        END

    -- Validate query
    -- SELECT @PrevYrNewRenewPct

    ----------------------------------------
    -- Calculate New Users By Fiscal Year --
    ----------------------------------------

    -- Previous Fiscal Year --
    SELECT @NewUserPrevYear = COUNT(UserId) FROM UserMain 
     WHERE CreatedOn >= @PrevFiscalBegin 
       AND CreatedOn <= @PrevFiscalEnd 

    SELECT @NewUserPrevYTD = COUNT(UserId) FROM UserMain
     WHERE CreatedOn >= @PrevFiscalBegin
       AND CreatedOn <= DATEADD(YEAR,-1,GETDATE())
       
    -- Current Fiscal Year --
    SELECT @NewUserCurrYear = COUNT(UserId) FROM UserMain 
     WHERE CreatedOn >= @CurrFiscalBegin 
       AND CreatedOn <= @CurrFiscalEnd 

    -- Validate query
    -- SELECT @NewUserPrevYear , @NewUserPrevYTD , @NewUserCurrYear

    -----------------------------------------------             ---------------
    -- Calculate New Users as Pct of All Members --             -- RECRUIT-3 --
    -----------------------------------------------             ---------------
    SELECT @NewUserPct = 
        CASE WHEN @CurrMembers > 0 
            THEN CAST(@NewUserCurrYear AS decimal(18,9))/CAST(@CurrMembers AS decimal(18,9))
            ELSE NULL
        END
    ----------------------------
    -- BEGIN SECTION   ENGAGE --
    ----------------------------

    -----------------------------------------
    -- Calculate Activities By Fiscal Year --
    -----------------------------------------

    -- Previous Fiscal Year --
    -- Identify Non-Financial Activities --
    INSERT INTO @PrevYrNonFinAct(Id, Seqn, RowType, RelatedSeqn)
     SELECT ID, SEQN, ACTIVITY_TYPE, ORIGINATING_TRANS_NUM
       FROM Activity a
            LEFT OUTER JOIN dbo.asi_SplitString(@FinancialActivities, ',') exc ON a.ACTIVITY_TYPE = exc.Element
      WHERE TRANSACTION_DATE >= @PrevFiscalBegin 
        AND TRANSACTION_DATE <= @PrevFiscalEnd 
        AND exc.Element IS NULL

     SELECT @NonFinActPrevYr = COUNT(Seqn) FROM @PrevYrNonFinAct

    -- Identify Financial Activities --             
    INSERT INTO @PrevYrFinAct(Id, Seqn, RowType, RelatedSeqn)
     SELECT ID, SEQN, ACTIVITY_TYPE, ORIGINATING_TRANS_NUM
       FROM Activity a
            LEFT OUTER JOIN dbo.asi_SplitString(@FinancialActivities, ',') inc ON a.ACTIVITY_TYPE = inc.Element
      WHERE TRANSACTION_DATE >= @PrevFiscalBegin 
        AND TRANSACTION_DATE <= @PrevFiscalEnd 
        AND inc.Element IS NOT NULL

     SELECT @FinActPrevYr = COUNT(Seqn) FROM @PrevYrFinAct

    -- Current Fiscal Year --
    -- Identify Non-Financial Activities --
    INSERT INTO @CurrYrNonFinAct(Id, Seqn, RowType, RelatedSeqn)
     SELECT ID, SEQN, ACTIVITY_TYPE, ORIGINATING_TRANS_NUM
       FROM Activity a
            LEFT OUTER JOIN dbo.asi_SplitString(@FinancialActivities, ',') exc ON a.ACTIVITY_TYPE = exc.Element
      WHERE TRANSACTION_DATE >= @CurrFiscalBegin 
        AND TRANSACTION_DATE <= @CurrFiscalEnd 
        AND exc.Element IS NULL

     SELECT @NonFinActCurrYr = COUNT(Seqn) FROM @CurrYrNonFinAct

    -- Identify Financial Activities --             
    INSERT INTO @CurrYrFinAct(Id, Seqn, RowType, RelatedSeqn)
     SELECT ID, SEQN, ACTIVITY_TYPE, ORIGINATING_TRANS_NUM 
       FROM Activity a
           LEFT OUTER JOIN dbo.asi_SplitString(@FinancialActivities, ',') inc ON a.ACTIVITY_TYPE = inc.Element 
      WHERE TRANSACTION_DATE >= @CurrFiscalBegin 
        AND TRANSACTION_DATE <= @CurrFiscalEnd 
        AND inc.Element IS NOT NULL

     SELECT @FinActCurrYr = COUNT(Seqn) FROM @CurrYrFinAct

    -- Identify Committee Activities --
    SELECT @CmteActCurrYr = COUNT(Seqn) FROM @CurrYrNonFinAct 
     WHERE RowType = 'COMMITTEE'
    
    SELECT @CmteActPerMbr = CAST(@CmteActCurrYr AS decimal(18,9))/CAST(@CurrMembers AS decimal(18,9))
    
    -- Identify Email Activities --
    SELECT @EmailsCurrYr = COUNT(Seqn) FROM @CurrYrNonFinAct 
     WHERE RowType = 'EMAIL'
    
    SELECT @EmailsPerMbr = CAST(@EmailsCurrYr AS decimal(18,9))/CAST(@CurrMembers AS decimal(18,9))
    
     -- TODO: Calculate and include emails from Marketing Suite

    -- Identify Letter Activities --
    SELECT @LettersCurrYr = COUNT(Seqn) FROM @CurrYrNonFinAct 
     WHERE RowType = 'LETTER'
    
    SELECT @LettersPerMbr = CAST(@LettersCurrYr AS decimal(18,9))/CAST(@CurrMembers AS decimal(18,9))

     -- TODO: Calculate and include letters from Marketing Suite

    -- Validate query
    -- SELECT @NonFinActPrevYr, @FinActPrevYr, @NonFinActCurrYr, @FinActCurrYr, @CmteActCurrYr, @EmailsCurrYr, @LettersCurrYr

    ---------------------------                             ---------------------
    -- Activities per Member --                             -- ENGAGE-1 THRU 6 --
    ---------------------------                             ---------------------
    SELECT @NonFinActPerMbr = 
     CASE WHEN @CurrMembers > 0 
         THEN CAST(@NonFinActCurrYr AS decimal(18,9))/CAST(@CurrMembers AS decimal(18,9))
         ELSE NULL
     END
    SELECT @FinActPerMbr = 
     CASE WHEN @CurrMembers > 0 
         THEN CAST(@FinActCurrYr AS decimal(18,9))/CAST(@CurrMembers AS decimal(18,9))
         ELSE NULL
     END
    SELECT @CmteActPerMbr = 
     CASE WHEN @CurrMembers > 0 
         THEN CAST(@CmteActCurrYr AS decimal(18,9))/CAST(@CurrMembers AS decimal(18,9))
         ELSE NULL
     END
    SELECT @WebVisitsPerMbr = 
     CASE WHEN @CurrMembers > 0 
         THEN CAST(@WebVisitsPrevYr AS decimal(18,9))/CAST(@CurrMembers AS decimal(18,9))
         ELSE NULL
     END
    SELECT @EmailsPerMbr = 
     CASE WHEN @CurrMembers > 0 
         THEN CAST(@EmailsCurrYr AS decimal(18,9))/CAST(@CurrMembers AS decimal(18,9))
         ELSE NULL
     END
    SELECT @LettersPerMbr = 
     CASE WHEN @CurrMembers > 0 
         THEN CAST(@LettersCurrYr AS decimal(18,9))/CAST(@CurrMembers AS decimal(18,9))
         ELSE NULL
     END
    
     -- Validate query
     -- SELECT @NonFinActPerMbr, @FinActPerMbr, @CmteActPerMbr, @EmailsPerMbr, @LettersPerMbr
             
    --------------------------
    -- BEGIN SECTION GROW --
    --------------------------

    -----------------------------------------                   ------------
    -- Calculate Current Year Renewal Rate --                   -- GROW-1 --
    -----------------------------------------                   ------------
    -- Calculate Renewals in the Current Year --
    SELECT @RenewMbrCurrYear = COUNT(ID)
      FROM Name
     WHERE MEMBER_STATUS = 'R'
       AND MEMBER_STATUS_DATE >= @CurrFiscalBegin
       AND MEMBER_STATUS_DATE <= @CurrFiscalEnd
        
    -- Calculate Renewal Billings in the Current Year --
    SELECT @RenewBillCurrYear = COUNT(DISTINCT(ID))
      FROM Subscriptions
     WHERE BILL_BEGIN >= @CurrFiscalBegin
       AND BILL_BEGIN <= @CurrFiscalEnd

    --
    SELECT @RenewRateCurrYr = 
        CASE WHEN @RenewBillCurrYear > 0 
            THEN CAST(@RenewMbrCurrYear AS decimal(18,9))/CAST(@RenewBillCurrYear AS decimal(18,9))
            ELSE NULL
        END
        
     -- Validate query
     -- SELECT @RenewRateCurrYr

 
    ----------------------------------------                ------------
    -- Calculate Registrations Per Member --                -- GROW-2 --
    ----------------------------------------                ------------
    -- Identify Open Registrations within the current fiscal year
    INSERT INTO @EventRegsCurrYear(Id, Seqn, RowType, RelatedSeqn, KeyValue)
        SELECT o.ST_ID, o.ORDER_NUMBER, 'OrderLine', o.ORIGINATING_TRANS_NUM,
               o.ST_ID + '/' + ol.PRODUCT_CODE
          FROM Orders o LEFT OUTER JOIN Order_Lines ol ON o.ORDER_NUMBER = ol.ORDER_NUMBER 
                        LEFT OUTER JOIN Product_Function pf ON ol.PRODUCT_CODE = pf.PRODUCT_CODE
                        LEFT OUTER JOIN Meet_Master m ON pf.PRODUCT_CODE LIKE m.MEETING + '/%'
         WHERE (pf.IS_EVENT_REGISTRATION_OPTION <> 0 OR pf.PRODUCT_CODE LIKE '%/MAIN')
           AND o.ORDER_DATE >= @CurrFiscalBegin
           AND o.ORDER_DATE <= @CurrFiscalEnd

    -- Calculate the Total Registrations for the current fiscal year
    SELECT @EventRegCurrYr = COUNT(Id) FROM @EventRegsCurrYear 

    -- Calculate the average of Event Registrations for the Current Year per Total Members
    SELECT  @AvgEventReg = 
        CASE WHEN @CurrMembers > 0 
            THEN CAST(@EventRegCurrYr AS decimal(18,9))/CAST(@CurrMembers AS decimal(18,9))
            ELSE NULL
        END

    -----------------------------------                     ------------
    -- Calculate Increase in Members --                     -- GROW-3 --
    -----------------------------------                     ------------
    -- Retrieve Previous Year Total Members
    SELECT @PrevYearMembers =
        CASE
            WHEN @PrevYearExists <> 0 THEN (SELECT TotalMembers FROM AsiGPSData WHERE PeriodBegin = @PrevFiscalBegin)
            ELSE 0
        END

    -- Calculate Current Year Increase of Total Members over Previous Year
    SELECT  @MbrIncreasePct =
        CASE
            WHEN @PrevYearExists = 0 THEN NULL
            WHEN @PrevYearMembers <> 0 THEN ((CAST(@CurrMembers AS DECIMAL(18,9)) - CAST(@PrevYearMembers AS DECIMAL(18,9)))/CAST(@PrevYearMembers AS DECIMAL(18,9)))
            ELSE NULL
        END

        -- Validate query
        -- SELECT @PrevFiscalBegin, @PrevYearExists, @PrevYearMembers, @CurrFiscalBegin, @CurrMembers, @MbrIncreasePct, @MbrIncreasePct * 100

    --------------------------------                        ------------
    -- Calculate Revenue Increase --                        -- GROW-4 --
    --------------------------------                        ------------
    -- Retrieve Previous Year Total Revenue
    SELECT @PrevYearRevenue =
        CASE
            WHEN @PrevYearExists <> 0 THEN (SELECT TotalRevenue FROM AsiGPSData WHERE PeriodBegin = @PrevFiscalBegin)
            ELSE 0
        END

    -- Calculate Current Yerar Total Revenue
    SELECT @TotalRevenue = ABS(SUM(AMOUNT))
      FROM Trans
     WHERE TRANSACTION_TYPE = 'DIST'
       AND TRANSACTION_DATE >= @CurrFiscalBegin
       AND TRANSACTION_DATE <= @CurrFiscalEnd

    -- Calculate Total Revenue per Member
    SELECT @RevenuePerMember =
        CASE WHEN @CurrMembers <> 0 
            THEN CAST(@TotalRevenue AS decimal(18,9))/CAST(@CurrMembers AS decimal(18,9))
            ELSE NULL
        END

    -- Calculate Current Year Increase of Total Revenue over Previous Year
    SELECT  @RevenueIncreasePct =
        CASE
            WHEN @PrevYearExists = 0 THEN NULL
            WHEN @PrevYearRevenue <> 0 THEN ((@TotalRevenue - @PrevYearRevenue)/@PrevYearRevenue)
            ELSE NULL
        END

        -- Validate query
        -- SELECT @PrevYearRevenue, @TotalRevenue, @RevenuePerMember, @RevenueIncreasePct


    ------------------------------------------
    -- Convert percentages to whole numbers --
    ------------------------------------------
    SET @NewMbrPct = @NewMbrPct * 100
    SET @PrevYrNewRenewPct = @PrevYrNewRenewPct * 100
    SET @NewUserPct = @NewUserPct * 100
    SET @MbrIncreasePct = @MbrIncreasePct * 100
    SET @RevenueIncreasePct = @RevenueIncreasePct * 100
    SET @AvgEventRegIncreasePct = @AvgEventRegIncreasePct * 100

    ----------------------------
    -- Calculate Index values --
    ----------------------------
    SELECT @IndexRecruit = (@NewMbrPct + @PrevYrNewRenewPct + @NewUserPct)
    SELECT @IndexEngage = (@NonFinActPerMbr + @FinActPerMbr + @CmteActPerMbr + ISNULL(@WebVisitsPerMbr,0) + @EmailsPerMbr + @LettersPerMbr) * 100
    SELECT @IndexGrow = (@RenewRateCurrYr/8 + @AvgEventReg + @MbrIncreasePct + @RevenueIncreasePct) 
    SELECT @IndexOverall = (@IndexRecruit + @IndexEngage + @IndexGrow)/3
    
        -- Validate query
        -- SELECT @RenewRateCurrYr, @AvgEventReg, @MbrIncreasePct, @RevenueIncreasePct
        -- SELECT @IndexRecruit, @IndexEngage, @IndexGrow, @IndexOverall


    ---------------------------------------------------
    -- Populate current year values in Summary Table --
    ---------------------------------------------------
    INSERT AsiGPSData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           TotalRevenue,
           Recruit1,
           Recruit2,
           Recruit3,
           Engage1,
           Engage2,
           Engage3,
           Engage4,
           Engage5,
           Engage6,
           Grow1,
           Grow2,
           Grow3,
           Grow4,
           IndexRecruit,
           IndexEngage,
           IndexGrowth,
           IndexOverallPerformance,
           RunDate,
           SerialNo,
           RowType)
    SELECT @CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @TotalRevenue,
           @NewMbrPct,
           @PrevYrNewRenewPct,
           @NewUserPct,
           @NonFinActPerMbr,
           @FinActPerMbr,
           @CmteActPerMbr,
           @WebVisitsPerMbr,
           @EmailsPerMbr,
           @LettersPerMbr,
           @RenewRateCurrYr,
           @AvgEventReg,
           @MbrIncreasePct,
           @RevenuePerMember,
           @IndexRecruit,
           @IndexEngage,
           @IndexGrow,
           @IndexOverall,
           @RunDate,
           @SerialNo,
           'Organization'
    -------------------------------------------------------
    -- Populate Current Year values in Pivot Data tables --
    -------------------------------------------------------
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @CurrYear,         
           @CurrYearText,     
           'CurrMbr',         
           0,                 
           'CurrentMembers',
           CAST(@CurrMembers AS decimal(18, 9)),
           @RunDate,
           @SerialNo,
           'Organization')
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @CurrYear,         
           @CurrYearText,     
           'Recruit',         
           1,                 
           'Recruit1',
           @NewMbrPct * 100,
           @RunDate,
           @SerialNo,
           'Organization')
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @CurrYear,         
           @CurrYearText,     
           'Recruit',         
           2,                 
           'Recruit2',                      
           @PrevYrNewRenewPct * 100,
           @RunDate,
           @SerialNo,
           'Organization')
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @CurrYear,         
           @CurrYearText,     
           'Recruit',         
           3,                 
           'Recruit3',
           @NewUserPct * 100,
           @RunDate,
           @SerialNo,
           'Organization')
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @CurrYear,         
           @CurrYearText,     
           'Engage',          
           1,                 
           'Engage1',            
           @NonFinActPerMbr,
           @RunDate,
           @SerialNo,
           'Organization')
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @CurrYear,         
           @CurrYearText,     
           'Engage',          
           2,                 
           'Engage2',
           @FinActPerMbr,
           @RunDate,
           @SerialNo,
           'Organization')
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @CurrYear,         
           @CurrYearText,     
           'Engage',          
           3,                 
           'Engage3',
           @CmteActPerMbr,
           @RunDate,
           @SerialNo,
           'Organization')
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @CurrYear,         
           @CurrYearText,     
           'Engage',          
           4,                 
           'Engage4',
           @WebVisitsPerMbr,
           @RunDate,
           @SerialNo,
           'Organization')
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @CurrYear,         
           @CurrYearText,     
           'Engage',          
           5,                 
           'Engage5',
           @EmailsPerMbr,
           @RunDate,
           @SerialNo,
           'Organization')
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @CurrYear,         
           @CurrYearText,     
           'Engage',          
           6,                 
           'Engage6',
           @LettersPerMbr,
           @RunDate,
           @SerialNo,
           'Organization')
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @CurrYear,         
           @CurrYearText,     
           'Grow',            
           1,                 
           'Grow1',
           @RenewRateCurrYr,
           @RunDate,
           @SerialNo,
           'Organization')
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @CurrYear,         
           @CurrYearText,     
           'Grow',            
           2,                 
           'Grow2',
           @AvgEventReg,
           @RunDate,
           @SerialNo,
           'Organization')
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @CurrYear,         
           @CurrYearText,     
           'Grow',            
           3,                 
           'Grow3',
           @MbrIncreasePct,
           @RunDate,
           @SerialNo,
           'Organization')
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @CurrYear,         
           @CurrYearText,     
           'Grow',            
           4,                 
           'Grow4',
           @RevenuePerMember,
           @RunDate,
           @SerialNo,
           'Organization')
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @CurrYear,         
           @CurrYearText,     
           'Index',           
           2,                 
           'IndexRecruit',
           @IndexRecruit,
           @RunDate,
           @SerialNo,
           'Organization')
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @CurrYear,         
           @CurrYearText,     
           'Index',           
           3,                 
           'IndexEngage',
           @IndexEngage,
           @RunDate,
           @SerialNo,
           'Organization')
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @CurrYear,         
           @CurrYearText,     
           'Index',           
           4,                 
           'IndexGrow',
           @IndexGrow,
           @RunDate,
           @SerialNo,
           'Organization')
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@CurrFiscalBegin,
           @CurrFiscalEnd,
           @CurrMembers,
           @CurrYear,         
           @CurrYearText,     
           'Index',           
           1,                 
           'IndexOverallPerformance',
           @IndexOverall,       
           @RunDate,
           @SerialNo,
           'Organization')   

  --RETURN 0

END




GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AsiGPSUpdateValues]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[AsiGPSUpdateValues]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

--------------------------------------------------------------
-- Create AsiGPSUpdateValues table and populate with defaults
--------------------------------------------------------------
CREATE PROCEDURE [dbo].[AsiGPSUpdateValues] (
        @DataYear           nvarchar(4),    -- The Year (YYYY) for which the data is being updated
        @RowType            nvarchar(20),   -- VALID VALUES: 'OrgGoal' or 'Industry'
        @CurrMembers        int,
        @NewMbrPct          decimal(18,9),
        @PrevYrNewRenewPct  decimal(18,9),
        @NewUserPct         decimal(18,9),
        @NonFinActPerMbr    decimal(18,9),
        @FinActPerMbr       decimal(18,9),
        @CmteActPerMbr      decimal(18,9),
        @WebVisitsPerMbr    decimal(18,9),  -- NYI
        @EmailsPerMbr       decimal(18,9),
        @LettersPerMbr      decimal(18,9),
        @RenewRateCurrYr    decimal(18,9),
        @EventRegPerMbr     decimal(18,9),
        @MbrIncrease        int,
        @RevenuePerMember   decimal(18,9),
        @IndexRecruit       decimal(18,9),
        @IndexEngage        decimal(18,9),
        @IndexGrow          decimal(18,9),
        @IndexOverall       decimal(18,9)
   ) AS
   

    DECLARE @RunDate            datetime,
            @ThisYear           int,
            @FiscalBegin        int,
            @ThisFiscalBegin    datetime,
            @ThisFiscalEnd      datetime,
            @ThisDimension      nvarchar(30),
            @SerialNo           varchar(255)
            

---------------------------------------
-- Establish the dimension being set --
---------------------------------------
    SET @ThisDimension = 
        CASE WHEN @RowType = 'OrgGoal' THEN 'Goal'
             WHEN @RowType = 'Industry' THEN 'Industry'
             ELSE null -- Need to stop execution and return an error
        END;

IF @ThisDimension IS NULL
  BEGIN
      PRINT 'ERROR: Invalid value for @RowType parameter. Valid values = OrgGoal or Industry.'
      RETURN
  END
ELSE
  BEGIN    

    ---------------------------------------------------
    -- Establish the date that this procedure is run --
    ---------------------------------------------------
    SET @RunDate = GETDATE()
        
    -------------------------------------------------------------------------
    -- Establish the date ranges for the previous and current Fiscal Years --
    -------------------------------------------------------------------------
    SET @FiscalBegin = 
        CASE WHEN EXISTS(SELECT * FROM System_Params WHERE ParameterName = 'AR_Control.YearBegins') 
            THEN (SELECT ShortValue FROM System_Params WHERE ParameterName = 'AR_Control.YearBegins')
            ELSE 1
        END;

    SET @ThisYear = CAST(@DataYear AS int)
    
    SET @ThisFiscalBegin = 
        CASE WHEN @FiscalBegin > 1 THEN CAST(CAST(@ThisYear-1 AS varchar(4)) + '-' + CAST(@FiscalBegin AS VARCHAR(2)) + '-1' AS datetime)
             ELSE CAST(@DataYear + '-' + CAST(@FiscalBegin AS VARCHAR(2)) + '-1' AS datetime)
        END;
    
    SET @ThisFiscalEnd = DATEADD(DAY,-1,DATEADD(YEAR,1,@ThisFiscalBegin))

    ------------------------------------
    -- Identify License Serial Number --
    ------------------------------------
    SELECT  @SerialNo = ShortValue FROM System_Params WHERE ParameterName = 'System_Control.SerialNo'

    --------------------------------------------------
    -- Delete Summary Data row if it already exists --
    --------------------------------------------------

    DELETE AsiGPSData
      FROM AsiGPSData a
     WHERE a.PeriodBegin = @ThisFiscalBegin
       AND a.PeriodEnd = @ThisFiscalEnd
       AND a.SerialNo = @SerialNo 
       AND a.RowType = @RowType

    ------------------------------------------------
    -- Delete Pivot Data row if it already exists --
    ------------------------------------------------

    DELETE AsiGPSPivotData
     FROM AsiGPSPivotData a
     WHERE a.DataYear = @ThisYear
       AND a.SerialNo = @SerialNo 
       AND a.RowType = @RowType

    ----------------------------------------------------------
    -- Populate Summary Data with corresponding Goal values --
    ----------------------------------------------------------
    INSERT AsiGPSData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           Recruit1,
           Recruit2,
           Recruit3,
           Engage1,
           Engage2,
           Engage3,
           Engage4,
           Engage5,
           Engage6,
           Grow1,
           Grow2,
           Grow3,
           Grow4,
           IndexRecruit,
           IndexEngage,
           IndexGrowth,
           IndexOverallPerformance,
           RunDate,
           SerialNo,
           RowType)
    SELECT @ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @NewMbrPct,
           @PrevYrNewRenewPct,
           @NewUserPct,
           @NonFinActPerMbr,             
           @FinActPerMbr,             
           @CmteActPerMbr,             
           @WebVisitsPerMbr,
           @EmailsPerMbr,
           @LettersPerMbr,
           @RenewRateCurrYr,
           @EventRegPerMbr,
           @MbrIncrease,
           @RevenuePerMember,
           @IndexRecruit,
           @IndexEngage,
           @IndexGrow,
           @IndexOverall,
           @RunDate,
           @SerialNo,
           @RowType

 
    --------------------------------------------------------
    -- Populate Pivot Data with corresponding Goal values --
    --------------------------------------------------------
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @ThisYear,
           @ThisDimension,
           'CurrMbr',
           0,                 
           'CurrentMembers',
           CAST(@CurrMembers AS decimal(18, 9)),
           @RunDate,
           @SerialNo,
           @RowType)
                  
           -- Recruit Dimensions ------------------------
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @ThisYear,         
           @ThisDimension,            
           'Recruit',         
           1,                 
           'Recruit1',
           @NewMbrPct,
           @RunDate,
           @SerialNo,
           @RowType)
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES         
           (@ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @ThisYear,         
           @ThisDimension,            
           'Recruit',         
           2,                 
           'Recruit2',                      
           @PrevYrNewRenewPct,
           @RunDate,
           @SerialNo,
           @RowType)
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @ThisYear,         
           @ThisDimension,            
           'Recruit',         
           3,                 
           'Recruit3',
           @NewUserPct,
           @RunDate,
           @SerialNo,
           @RowType)
                
           -- Engage Dimensions ------------------------
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @ThisYear,         
           @ThisDimension,            
           'Engage',          
           1,                 
           'Engage1',            
           @NonFinActPerMbr,
           @RunDate,
           @SerialNo,
           @RowType)
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @ThisYear,         
           @ThisDimension,            
           'Engage',          
           2,                 
           'Engage2',
           @FinActPerMbr,
           @RunDate,
           @SerialNo,
           @RowType)        
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @ThisYear,         
           @ThisDimension,            
           'Engage',          
           3,                 
           'Engage3',
           @CmteActPerMbr,
           @RunDate,
           @SerialNo,
           @RowType)
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @ThisYear,         
           @ThisDimension,            
           'Engage',          
           4,                 
           'Engage4',
           @WebVisitsPerMbr,
           @RunDate,
           @SerialNo,
           @RowType)
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @ThisYear,         
           @ThisDimension,            
           'Engage',          
           5,                 
           'Engage5',
           @EmailsPerMbr,
           @RunDate,
           @SerialNo,
           @RowType)
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @ThisYear,         
           @ThisDimension,            
           'Engage',          
           6,                 
           'Engage6',
           @LettersPerMbr,
           @RunDate,
           @SerialNo,
           @RowType)
                  
           -- Grow Dimensions ------------------------
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @ThisYear,         
           @ThisDimension,            
           'Grow',            
           1,                 
           'Grow1',
           @RenewRateCurrYr,
           @RunDate,
           @SerialNo,
           @RowType)
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @ThisYear,         
           @ThisDimension,            
           'Grow',            
           2,                 
           'Grow2',
           @EventRegPerMbr,
           @RunDate,
           @SerialNo,
           @RowType)

    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @ThisYear,         
           @ThisDimension,            
           'Grow',            
           3,                 
           'Grow3',
           @MbrIncrease,
           @RunDate,
           @SerialNo,
           @RowType)       
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @ThisYear,         
           @ThisDimension,            
           'Grow',            
           4,                 
           'Grow4',
           @RevenuePerMember,
           @RunDate,
           @SerialNo,
           @RowType)
           
           -- Index Dimensions ------------------------
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @ThisYear,         
           @ThisDimension,            
           'Index',            
           2,                 
           'IndexRecruit',
           @IndexRecruit,
           @RunDate,
           @SerialNo,
           @RowType)
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @ThisYear,         
           @ThisDimension,            
           'Index',            
           3,                 
           'IndexEngage',
           @IndexEngage,
           @RunDate,
           @SerialNo,
           @RowType)
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @ThisYear,         
           @ThisDimension,            
           'Index',            
           4,                 
           'IndexGrow',
           @IndexGrow,
           @RunDate,
           @SerialNo,
           @RowType)
           
    INSERT INTO AsiGPSPivotData (
           PeriodBegin,
           PeriodEnd,
           TotalMembers,
           DataYear,
           ReportLabel,
           Dimension,
           Ordinal,
           MeasureName,
           MeasureValue,
           RunDate,
           SerialNo,
           RowType)
    VALUES (@ThisFiscalBegin,
           @ThisFiscalEnd,
           @CurrMembers,
           @ThisYear,         
           @ThisDimension,            
           'Index',            
           1,                 
           'IndexOverallPerformance',
           @IndexOverall,
           @RunDate,
           @SerialNo,
           @RowType)        

  END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEAccountPendingDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEAccountPendingDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEAccountPendingDelete] @AccountPendingID int as
DELETE FROM AccountPending WHERE AccountPendingID = @AccountPendingID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEAccountPendingGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEAccountPendingGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEAccountPendingGetAll] as
SELECT * FROM AccountPending WHERE RecordAdded = 0;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEAccountPendingInsert]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEAccountPendingInsert]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROC [dbo].[BAEAccountPendingInsert]
	@Username varchar(64),
	@Password varchar(104),
	@Prefix varchar(32),
	@FirstName varchar(24),
	@MiddleInitial varchar(24),
	@LastName varchar(302),
	@Suffix varchar(16),
	@Designation varchar(32),
	@Informal varchar(32),
	@Title varchar(96),
 	@Organization varchar(96),
	@Address1 varchar(48),
	@Address2 varchar(48),
	@Address3 varchar(48),
	@County varchar(56),
	@City varchar(48), 
	@StateProvince varchar(16),
	@PostalCode varchar(16),
	@Country varchar(24),
	@AddressPurpose varchar(24),
	@Email varchar(128),
	@Website varchar(128),
	@WorkPhone varchar(24),
	@HomePhone varchar(24),
	@TollFree varchar(24),
	@Fax varchar(24),
	@BirthDate varchar(24),
	@Gender varchar(8),
	@SICCode varchar(32),
	@ExcludeDirectory bit,
	@UserDefinedField text,
	@ExcludeMail bit,
	@RecordAdded bit,
	@MemberType varchar(5)
AS
	INSERT INTO AccountPending (Username, [Password], Prefix, FirstName, MiddleName, LastName, Suffix, Designation, Informal, Title, Organization, Address1, Address2, Address3,
					County, City, StateProvince, PostalCode, Country, AddressPurpose, Email, Website, WorkPhone, HomePhone, 
					TollFree, Fax, BirthDate, Gender, SICCode, ExcludeDirectory,UserDefinedField, ExcludeMail,RecordAdded, MemberType)
	VALUES (@Username, @Password, @Prefix, @FirstName, @MiddleInitial, @LastName,  @Suffix, @Designation, @Informal, @Title, @Organization, @Address1, @Address2, @Address3,
			@County, @City, @StateProvince, @PostalCode, @Country, @AddressPurpose,@Email, @Website, @WorkPhone, @HomePhone, 
			@TollFree,@Fax, @BirthDate, @Gender, @SICCode, @ExcludeDirectory, @UserDefinedField, @ExcludeMail,@RecordAdded, @MemberType);

	SELECT CAST(@@IDENTITY AS int) 'InsertedAccountPending';


----------------------------
set ANSI_NULLS ON
set QUOTED_IDENTIFIER ON

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEAccountPendingLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEAccountPendingLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEAccountPendingLoad] @AccountPendingID int as
SELECT * FROM AccountPending WHERE AccountPendingID = @AccountPendingID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEAccountPendingUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEAccountPendingUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEAccountPendingUpdate] @AccountPendingpID int as
UPDATE AccountPending SET RecordAdded = 1 WHERE AccountPendingID = @AccountPendingpID

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEActivityTypeGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEActivityTypeGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[BAEActivityTypeGetAll] @UserId AS VARCHAR(15)
AS

/* previously: SELECT DISTINCT ACTIVITY_TYPE FROM Activity ORDER BY ACTIVITY_TYPE ASC;  */


DECLARE @ActivityAccessKeys TABLE 
	(
	[PROD_TYPE] VARCHAR(10),
	[ACCESS_KEYWORDS] VARCHAR(255)
	)

DECLARE @ActivityAccessKeysSplit TABLE
	(
	[PROD_TYPE] VARCHAR(10),
	[ACCESS_KEYWORD] VARCHAR(60)
	)

DECLARE @UserAccessKeysSplit TABLE
	(
	[ACCESS_KEYWORD] VARCHAR(60)
	)

INSERT @ActivityAccessKeys (PROD_TYPE, ACCESS_KEYWORDS)
	SELECT Product_Type.PROD_TYPE, Product_Type.ACCESS_KEYWORDS FROM dbo.Product_Type

DECLARE thecursor CURSOR FAST_FORWARD FOR SELECT PROD_TYPE, ACCESS_KEYWORDS FROM @ActivityAccessKeys

DECLARE @PROD_TYPE VARCHAR(10)
DECLARE @ACCESS_KEYWORDS VARCHAR(255)
DECLARE @ACCESS_KEYWORD VARCHAR(60)
DECLARE @token VARCHAR(60)

OPEN thecursor

FETCH NEXT FROM thecursor INTO @PROD_TYPE, @ACCESS_KEYWORDS

WHILE @@FETCH_STATUS = 0
BEGIN
		IF (DATALENGTH (@ACCESS_KEYWORDS) = 0)
		BEGIN
			INSERT INTO @ActivityAccessKeysSplit ([PROD_TYPE], [ACCESS_KEYWORD]) 	VALUES (@PROD_TYPE, '')
		END

		-- assume comma delimiter, and eliminate the special case of the last key
		SET @ACCESS_KEYWORDS = @ACCESS_KEYWORDS + ','

		WHILE (DATALENGTH (@ACCESS_KEYWORDS) > 0)
		BEGIN
			SET @token = LTRIM(RTRIM(SUBSTRING (@ACCESS_KEYWORDS, 1, CHARINDEX (',', @ACCESS_KEYWORDS) - 1)))
			SET @ACCESS_KEYWORDS = SUBSTRING (@ACCESS_KEYWORDS, CHARINDEX (',', @ACCESS_KEYWORDS) + 1, 255) 

			IF (DATALENGTH(@token) > 0 AND @token <> ',')
			BEGIN
				INSERT INTO @ActivityAccessKeysSplit ([PROD_TYPE], [ACCESS_KEYWORD])   VALUES (@PROD_TYPE, @token)
			END
		END

FETCH NEXT FROM thecursor INTO @PROD_TYPE, @ACCESS_KEYWORDS

END

CLOSE thecursor
DEALLOCATE thecursor

SELECT @ACCESS_KEYWORDS = LTRIM(RTRIM(Users.AccessKeywords)) + ',' FROM [dbo].[Users] WHERE Users.UserId = @UserId

WHILE (DATALENGTH (@ACCESS_KEYWORDS) > 0)
BEGIN
	SET @token = LTRIM(RTRIM(SUBSTRING (@ACCESS_KEYWORDS, 1, CHARINDEX (',', @ACCESS_KEYWORDS) - 1)))
	SET @ACCESS_KEYWORDS = SUBSTRING (@ACCESS_KEYWORDS, CHARINDEX (',', @ACCESS_KEYWORDS) + 1, 255) 

	IF (DATALENGTH(@token) > 0 AND @token <> ',')
	BEGIN
		INSERT INTO @UserAccessKeysSplit ([ACCESS_KEYWORD])   VALUES (@token)
	END
END

INSERT INTO @UserAccessKeysSplit ([ACCESS_KEYWORD])   VALUES ('') -- user has to be able to join to Activity types with blank access keywords	


SELECT aa.PROD_TYPE ACTIVITY_TYPE
FROM @ActivityAccessKeysSplit aa
INNER JOIN @UserAccessKeysSplit ua
ON aa.ACCESS_KEYWORD = ua.ACCESS_KEYWORD

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEActivityTypeGetFundraising]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEActivityTypeGetFundraising]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/* 
 * Gets the Activity Types only for Fundraising
 *
 * PURPOSE:	In case the activity types change for fundraising, it would be
 *			easier to change in a stored procedure rather in code.
 */


CREATE procedure [dbo].[BAEActivityTypeGetFundraising]
AS
SELECT DISTINCT ACTIVITY_TYPE
FROM Activity
WHERE ACTIVITY_TYPE = 'PLEDGE' OR ACTIVITY_TYPE = 'GIFT'
ORDER BY ACTIVITY_TYPE ASC;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEBillingBillingCategories]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEBillingBillingCategories]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/*
	This procedure returns all of the billing categories available for the user to select.

	NOTE:

	While this procedure may return an empty resultset, you MUST have the CODE and DESCRIPTION columns.
	The billing categories come from the General Lookup table in iMIS.
*/
CREATE PROCEDURE [dbo].[BAEBillingBillingCategories]
	@UserID			AS	varchar(10),
	@MemberType 	AS	varchar(5)
AS
	SELECT CODE, DESCRIPTION FROM Gen_Tables WHERE TABLE_NAME = 'CATEGORY';


set ANSI_NULLS OFF
set QUOTED_IDENTIFIER OFF

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEBillingMembershipSignupCheck]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEBillingMembershipSignupCheck]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/*
	This procedure handles the logic for determining if a user is already a member with an organization.

	NOTE:

	This procedure MUST return either 1 (True) or 0 (False) as a bit data type in a column called
	"IMIS_MEMBER"!
*/
CREATE PROCEDURE [dbo].[BAEBillingMembershipSignupCheck]
	@UserID AS varchar(10)
AS
	DECLARE @IsMember bit;

	SELECT @IsMember = MEMBER_RECORD FROM Name WHERE ID = @UserID;

	-- This is the basic framework for returning a value of 1 or 0 as a column called "IMIS_MEMBER"
	IF (@IsMember = 1)
		BEGIN
			SELECT @IsMember AS 'IMIS_MEMBER';
		END
	ELSE IF (@IsMember = 0)
		BEGIN
			SELECT @IsMember AS 'IMIS_MEMBER';
		END


set ANSI_NULLS ON
set QUOTED_IDENTIFIER ON

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEBillingMemberTypes]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEBillingMemberTypes]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/*
	This procedure returns all of the member types that will be available for the user to select from.

	NOTE:

	You MUST return at least 1 record with the columns MEMBER_TYPE and DESCRIPTION.
*/
CREATE PROCEDURE [dbo].[BAEBillingMemberTypes]
	@UserID as varchar(10)
AS
	SELECT MEMBER_TYPE, DESCRIPTION FROM Member_Types;


set ANSI_NULLS ON
set QUOTED_IDENTIFIER ON

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEBillingSetupDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEBillingSetupDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEBillingSetupDelete] @ProductCode as
varchar(256)
AS
	DELETE FROM BillingSetup WHERE ProductCode = @ProductCode;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEBillingSetupGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEBillingSetupGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEBillingSetupGetAll] as
SELECT * FROM BillingSetup;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEBillingSetupInsert]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEBillingSetupInsert]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEBillingSetupInsert] @ProductCode as
varchar(256),	
	@Title AS varchar(256),	
	@Description AS varchar(256),	
	@OrderProductCode AS varchar(256),	
	@MemberTypes AS varchar(256)
AS
	INSERT INTO BillingSetup
	(
	ProductCode,
	Title,
	Description,
	OrderProductCode,
	MemberTypes)

	VALUES 
	(
	@ProductCode,
	@Title,
	@Description,
	@OrderProductCode,
	@MemberTypes);

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEBillingSetupLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEBillingSetupLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEBillingSetupLoad] @ProductCode varchar(256) as
SELECT * FROM BillingSetup WHERE ProductCode = @ProductCode;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEBillingSetupUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEBillingSetupUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEBillingSetupUpdate] @ProductCode as
varchar(256),	
	@Title AS varchar(256),	
	@Description AS varchar(256),	
	@OrderProductCode AS varchar(256),	
	@MemberTypes AS varchar(256)
AS
	UPDATE BillingSetup
	SET
		Title = @Title,
		Description = @Description,
		OrderProductCode = @OrderProductCode,
		MemberTypes = @MemberTypes
	WHERE ProductCode = @ProductCode;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartBillingDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartBillingDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartBillingDelete] @CartBillingId int as
DECLARE @cartItemId AS int;
	SELECT @cartItemId = CartItemId FROM CartBilling WHERE CartBillingId = @CartBillingId;
	
	DELETE FROM CartBilling WHERE CartBillingId = @CartBillingId;

	DELETE FROM CartItem WHERE CartItemID = @cartItemId;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartBillingGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartBillingGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartBillingGetAll] as
SELECT * FROM CartBilling

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartBillingGetAllByUser]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartBillingGetAllByUser]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartBillingGetAllByUser] @UserID as
varchar(32)
AS
	SELECT *
	FROM CartBilling cb
	INNER JOIN CartItem ci on ci.CartItemID = cb.CartItemId
	WHERE ci.UserID = @UserID ORDER BY cb.Title;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartBillingInsert]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartBillingInsert]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

create procedure [dbo].[BAECartBillingInsert] @CartItemId as
int,
	@ProductCode AS varchar(256),	
	@Title AS varchar(256),	
	@DuesType AS varchar(256),	
	@Price AS money,
	@ID As varchar(10)
AS
	INSERT INTO CartBilling
	(
	CartItemId, 
	ProductCode,
	Title,
	DuesType,
	Price,
	ID)
	VALUES 
	(
	@CartItemId,
	@ProductCode,
	@Title,
	@DuesType,
	@Price,
	@ID);
SELECT CAST(@@IDENTITY AS int) AS CartBillingId


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartBillingLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartBillingLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartBillingLoad] @CartBillingId int as
SELECT * FROM CartBilling WHERE CartBillingId = @CartBillingId;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartBillingUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartBillingUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

create procedure [dbo].[BAECartBillingUpdate] @CartBillingId as
int,	
	@CartItemId AS int,	
	@ProductCode AS varchar(256),	
	@Title AS varchar(256),	
	@DuesType AS varchar(256),	
	@Price AS money,
	@ID AS varchar(10)
AS
	UPDATE CartBilling
	SET 	CartItemId = @CartItemId,
		ProductCode = @ProductCode,
		Title = @Title,
		DuesType = @DuesType,
		Price = @Price,
		ID = @ID
	WHERE CartBillingId = @CartBillingId;


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventDeleteRegistrant]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventDeleteRegistrant]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventDeleteRegistrant] @registrantId varchar(16),
 	@eventCode varchar(16) as
DELETE FROM EventRegistrant
	WHERE RegistrantID = @registrantId AND EventCode = @eventCode;

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartEventDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartEventDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure [dbo].[BAECartEventDelete] @CartEventID as
int
AS
	DECLARE @registrantId as varchar(16), @eventCode as varchar(16);

	SELECT @registrantId = CartEvent.RegistrantID, @eventCode = CartEvent.EventCode
	FROM CartEvent
	WHERE CartEvent.CartEventID = @CartEventID;
	
	DELETE
	FROM CartEvent
	WHERE CartEventID = @CartEventID;


	EXEC BAEEventDeleteRegistrant @registrantId, @eventCode;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartEventFunctionDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartEventFunctionDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartEventFunctionDelete] @CartEventFunctionId as
int
AS
	DELETE
	FROM CartEventFunction
	WHERE CartEventFunctionID = @CartEventFunctionId;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartEventFunctionGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartEventFunctionGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartEventFunctionGetAll] as
SELECT *
	FROM CartEventFunction
	ORDER BY CartEventFunctionID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartEventFunctionGetAllForEvent]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartEventFunctionGetAllForEvent]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartEventFunctionGetAllForEvent] @Id int as
SELECT cef.* 
	FROM CartEventFunction cef
	INNER JOIN CartEvent ce on ce.CartEventID = cef.CartEventID
	WHERE ce.CartEventID =  @Id

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartEventFunctionGetForUserByFunctionCode]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartEventFunctionGetForUserByFunctionCode]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartEventFunctionGetForUserByFunctionCode] @CartEventId int,
 	@FunctionCode varchar(32) as
SELECT cef.CartEventFunctionID
	FROM CartEventFunction cef
	INNER JOIN CartEvent ce on ce.CartEventID = cef.CartEventID
	WHERE ce.CartEventID = @CartEventId
		AND cef.FunctionCode = @FunctionCode

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartEventFunctionInsert]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartEventFunctionInsert]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartEventFunctionInsert] @CartEventID as
int,
	@FunctionCode AS varchar(32),
	@Quantity AS int,
	@Title AS varchar(128),
	@Price AS money
AS
	INSERT INTO CartEventFunction
	(CartEventID, 
	 FunctionCode, 
	 Quantity, 
	 Title,
	 Price)
	VALUES 
	(@CartEventID,
	@FunctionCode,
	@Quantity,
	@Title,
	@Price);

SELECT CAST(@@IDENTITY AS int) AS "InsertedCartEventFunction";

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartEventFunctionLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartEventFunctionLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartEventFunctionLoad] @CartEventFunctionId as
int
AS
	SELECT * 
	FROM CartEventFunction
	WHERE CartEventFunctionID = @CartEventFunctionId;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartEventFunctionUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartEventFunctionUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartEventFunctionUpdate] @CartEventFunctionID as
int,
	@CartEventID AS int,
	@FunctionCode AS varchar(32),
	@Quantity AS int,
	@Title AS varchar(128),
	@Price AS money
AS
	UPDATE CartEventFunction
	SET CartEventID = @CartEventID, 
	FunctionCode = @FunctionCode,
	Quantity = @Quantity,
	Title = @Title,
	Price = @Price
	WHERE CartEventFunctionID = @CartEventFunctionID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartEventGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartEventGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartEventGetAll] as
SELECT *
	FROM CartEvent
	ORDER BY CartEventID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartEventGetAllForUser]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartEventGetAllForUser]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartEventGetAllForUser] @Id varchar(32) as
SELECT *
	FROM CartEvent ce
	INNER JOIN CartItem ci on ci.CartItemID = ce.CartItemID
	WHERE ci.UserID = @Id ORDER BY ce.Title

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartEventGetForUserByEventCode]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartEventGetForUserByEventCode]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartEventGetForUserByEventCode] @UserId varchar(32),
 	@EventCode varchar(64),
 	@RegId varchar(32) as
SELECT *
	FROM CartEvent ce
	INNER JOIN CartItem ci on ci.CartItemID = ce.CartItemID
	WHERE ci.UserID = @UserId
		AND ce.EventCode = @EventCode
		AND ce.RegistrantID = @RegId

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartEventInsert]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartEventInsert]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartEventInsert] @CartItemID as
int,	
	@EventCode AS varchar(64),	
	@Title AS varchar(128),	
	@RegistrantClass AS varchar(64),	
	@RegistrantID AS varchar(16),	
	@Complete AS bit
AS
	INSERT INTO CartEvent
	(CartItemID, 
	EventCode, 
	Title,
	RegistrantClass,
	RegistrantID,
	Complete)
	VALUES 
	(@CartItemID,
	@EventCode,
	@Title,
	@RegistrantClass,
	@RegistrantID,
	@Complete);
	
SELECT CAST(@@IDENTITY AS int) AS 'InsertedCartEvent';

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartEventLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartEventLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartEventLoad] @CartEventID as
int
AS
	SELECT * 
	FROM CartEvent
	WHERE CartEventID = @CartEventID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartEventUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartEventUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartEventUpdate] @CartEventID as
int,	
	@CartItemID AS int,	
	@EventCode AS varchar(64),	
	@Title AS varchar(128),	
	@RegistrantClass AS varchar(64),	
	@RegistrantID AS varchar(16),	
	@Complete AS bit	
AS
	UPDATE CartEvent
	SET CartItemID = @CartItemID, 
		EventCode = @EventCode, 
		Title = @Title,
		RegistrantClass = @RegistrantClass,
		RegistrantID = @RegistrantID,
		Complete = @Complete
	WHERE CartEventID = @CartEventID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartGetBestShippingRate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartGetBestShippingRate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartGetBestShippingRate] @zone varchar(20),
 	@zone_id int, 
 	@weight money as
SELECT DISTINCT top 1 RATE 
	FROM Freight_Rate F JOIN Zone_Code Z 
	ON F.SHIP_METHOD = Z.SHIP_METHOD
	WHERE F.SHIP_METHOD = @zone AND ZONE_ID = @zone_id AND WEIGHT >= @weight
	ORDER BY RATE asc

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartGetCartUsers]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartGetCartUsers]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartGetCartUsers] as
SELECT DISTINCT ci.UserID, n.LAST_NAME + ', ' + n.FIRST_NAME AS 'FullName'
	FROM CartItem AS ci
	LEFT JOIN Name AS n on n.ID COLLATE database_default = ci.UserID COLLATE database_default
	ORDER BY ci.UserID desc

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartGetCCAuthAccountInfo]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartGetCCAuthAccountInfo]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartGetCCAuthAccountInfo] @CAC varchar(10) as
SELECT *
	FROM CCAuthAcct
	WHERE CCAuthAcctCode = (
		SELECT CCAuthAcctCode 
		FROM Cash_Accounts 
		WHERE CASH_ACCOUNT_CODE = @CAC)

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartGetFlatRateHandling]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartGetFlatRateHandling]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartGetFlatRateHandling] as
SELECT ShortValue 
	FROM System_Params 
	WHERE ParameterName = 'Order_Control.FlatRateHandling'

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartGetHandlingChargeType]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartGetHandlingChargeType]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartGetHandlingChargeType] as
SELECT ShortValue 
	FROM System_Params 
	WHERE ParameterName = 'Order_Control.HandlingChargeType'

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartGetHandlingMaxChargeOfFreight]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartGetHandlingMaxChargeOfFreight]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartGetHandlingMaxChargeOfFreight] as
SELECT ShortValue 
	FROM System_Params 
	WHERE ParameterName = 'Order_Control.MaxFreightCharge'

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartGetHandlingMaxChargeOfTotal]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartGetHandlingMaxChargeOfTotal]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartGetHandlingMaxChargeOfTotal] as
SELECT ShortValue 
	FROM System_Params 
	WHERE ParameterName = 'Order_Control.MaxChargeOfTotal'

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartGetHandlingMinChargeOfFreight]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartGetHandlingMinChargeOfFreight]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartGetHandlingMinChargeOfFreight] as
SELECT ShortValue 
	FROM System_Params 
	WHERE ParameterName = 'Order_Control.MinFreightCharge'

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartGetHandlingMinChargeOfTotal]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartGetHandlingMinChargeOfTotal]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartGetHandlingMinChargeOfTotal] as
SELECT ShortValue 
	FROM System_Params 
	WHERE ParameterName = 'Order_Control.MinChargeOfTotal'

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartGetHandlingMinOrder]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartGetHandlingMinOrder]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartGetHandlingMinOrder] as
SELECT ShortValue 
	FROM System_Params 
	WHERE ParameterName = 'Order_Control.MinimumOrder'

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartGetHandlingPercentOfFreight]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartGetHandlingPercentOfFreight]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartGetHandlingPercentOfFreight] as
SELECT ShortValue 
	FROM System_Params 
	WHERE ParameterName = 'Order_Control.PercentOfFreight'

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartGetHandlingPercentOfTotal]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartGetHandlingPercentOfTotal]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartGetHandlingPercentOfTotal] as
SELECT ShortValue 
	FROM System_Params 
	WHERE ParameterName = 'Order_Control.PercentOfTotal'

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartGetMaxAutoFreight]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartGetMaxAutoFreight]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartGetMaxAutoFreight] as
SELECT ShortValue FROM System_Params WHERE ParameterName ='Order_Control.MaxAutoFreightCharge'

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartGetMinAutoFreight]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartGetMinAutoFreight]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartGetMinAutoFreight] as
SELECT ShortValue FROM System_Params WHERE ParameterName = 'Order_Control.MinAutoFreightCharge'

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartGetZoneCode]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartGetZoneCode]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure [dbo].[BAECartGetZoneCode] 
@Country as varchar(25)
 AS
      SELECT *
      FROM Zone_Code AS ci
      WHERE ci.COUNTRY = @Country;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartItemDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartItemDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartItemDelete] @CartItemID as
int
AS
	DELETE
	FROM CartItem
	WHERE CartItemID = @CartItemID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartItemGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartItemGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartItemGetAll] as
SELECT *
	FROM CartItem
	ORDER BY CartItemID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartItemGetAllForUser]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartItemGetAllForUser]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartItemGetAllForUser] @Id varchar(32) as
SELECT *
	FROM CartItem
	WHERE UserID =  @Id

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartItemInsert]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartItemInsert]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartItemInsert] @UserID as
varchar(64),
	@ItemType AS varchar(64),
	@Created AS datetime,
	@LastUpdated AS datetime
AS
	INSERT INTO CartItem
	(UserID, 
	 ItemType, 
	 Created, 
	 LastUpdated)
	VALUES 
	(@UserID,
	@ItemType,
	@Created,
	@LastUpdated);

SELECT CAST(@@IDENTITY AS int) AS 'Identity';

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartItemLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartItemLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartItemLoad] @CartItemID as
int
AS
	SELECT * 
	FROM CartItem
	WHERE CartItemID = @CartItemID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartItemUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartItemUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartItemUpdate] @CartItemID as
int,
	@UserID AS varchar(64),
	@ItemType AS varchar(64),
	@Created AS datetime,
	@LastUpdated AS datetime
AS
	UPDATE CartItem
	SET UserID = @UserID, 
	ItemType = @ItemType, 
	LastUpdated = @LastUpdated
	WHERE CartItemID = @CartItemID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartOrderDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartOrderDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartOrderDelete] @CartOrderID as
int
AS
	DELETE
	FROM CartOrder
	WHERE CartOrderID = @CartOrderID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartOrderGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartOrderGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartOrderGetAll] as
SELECT *
	FROM CartOrder
	ORDER BY CartOrderID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartOrderGetAllForUser]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartOrderGetAllForUser]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartOrderGetAllForUser] @Id varchar(32) as
SELECT *
	FROM CartOrder co
	INNER JOIN CartItem ci on ci.CartItemID = co.CartItemID
	WHERE ci.UserID = @Id ORDER BY co.Title

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartOrderGetForUserByProductCode]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartOrderGetForUserByProductCode]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartOrderGetForUserByProductCode] @UserId varchar(32),
 	@OrderProductId int as
SELECT co.CartOrderID 
	FROM CartOrder co
	INNER JOIN CartItem ci on ci.CartItemID = co.CartItemID
	WHERE ci.UserID = @UserId 
		AND co.OrderProductID = @OrderProductId

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartOrderInsert]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartOrderInsert]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartOrderInsert] @CartItemID as
int,
	@Quantity AS int,
	@Price AS money,
	@Title AS varchar(128),
	@ProductCode AS varchar(64),
	@OrderProductID AS int
AS
	INSERT INTO CartOrder
	(CartItemID, Quantity,
	Price, 
	Title,
	ProductCode,
	OrderProductID)
	VALUES 
	(@CartItemID, @Quantity,
	@Price, 
	@Title,
	@ProductCode,
	@OrderProductID);

SELECT CAST(@@IDENTITY AS int) AS 'InsertedCartOrder';

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartOrderLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartOrderLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartOrderLoad] @CartOrderId as
int
AS
	SELECT * 
	FROM CartOrder
	WHERE CartOrderID = @CartOrderId;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECartOrderUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECartOrderUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECartOrderUpdate] @CartOrderID as
int,
	@CartItemID AS int,
	@Quantity AS int,
	@Price AS money,
	@Title AS varchar(128),
	@ProductCode AS varchar(64),
	@OrderProductID AS int
AS
	UPDATE CartOrder
	SET CartItemID = @CartItemID,
	Quantity = @Quantity,
	Price = @Price, 
	Title = @Title,
	ProductCode = @ProductCode,
	OrderProductID = @OrderProductID
	WHERE CartOrderID = @CartOrderID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEChangeLogGetByType]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEChangeLogGetByType]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure [dbo].[BAEChangeLogGetByType] @LogType as varchar(10), @UserID as
varchar(32) 
AS
IF @LogType = '1' --Shows only the past 6 months of records
	BEGIN 
		SELECT Name_Log.DATE_TIME AS 'Date/Time', 
		Name_Log.USER_ID AS 'User', 
		Name_Log.LOG_TEXT AS 'Log' 		
		
		FROM Name_Log
		WHERE Name_Log.ID = @UserID
		AND DATE_TIME >= dateadd(month,-6,getdate()) 
		ORDER BY DATE_TIME DESC, USER_ID
	END
ELSE --Shows all records if no selection is passed in
	BEGIN 
		SELECT Name_Log.DATE_TIME AS 'Date/Time', 
		Name_Log.USER_ID AS 'User', 
		Name_Log.LOG_TEXT AS 'Log' 		
		
		FROM Name_Log
		WHERE Name_Log.ID = @UserID
		ORDER BY DATE_TIME DESC, USER_ID
	END



set ANSI_NULLS ON
set QUOTED_IDENTIFIER ON

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECheckIfStoredProcExists]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECheckIfStoredProcExists]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECheckIfStoredProcExists] @procName varchar(64) as
SELECT 	name 
FROM		sysobjects
WHERE	name = @procName and type='p'

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECompanyContactLoginValidation]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECompanyContactLoginValidation]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[BAECompanyContactLoginValidation]
      @UserID as varchar(10)
AS
      /* General Notes:
            Ideally, you would want this procedure to only return one row in order to maximize efficiency.
            Regardless of how it determines who has access, it absolutely must return the ID field from the
            iMIS Name table in some fashion.
      */
      SELECT ID FROM Name WHERE MEMBER_TYPE IN('CM') AND CO_ID <> '' AND ID = @UserID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECompanySearch]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECompanySearch]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure [dbo].[BAECompanySearch] 
    @CompanyName AS varchar(80),    
    @MemberType AS varchar(2500)
AS
    SET @CompanyName = UPPER(@CompanyName)
    IF LEN(@MemberType) > 0
    BEGIN
        SELECT *
          FROM [dbo].[Name]
         WHERE [COMPANY_RECORD] = 1 
               AND [MEMBER_TYPE] IN (SELECT * FROM [dbo].[GetValueListTable](@MemberType))
               AND UPPER([COMPANY]) LIKE '%' + @CompanyName + '%' 
         ORDER BY [COMPANY]
    END
    ELSE
    BEGIN
        SELECT *
          FROM [dbo].[Name]
         WHERE [COMPANY_RECORD] = 1 
               AND UPPER([COMPANY]) LIKE '%' + @CompanyName + '%'
         ORDER BY [COMPANY]
    END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECustom_GetUserInfoForFormLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECustom_GetUserInfoForFormLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECustom_GetUserInfoForFormLoad] @uID varchar(8) as
SELECT	n.FIRST_NAME, 
		n.LAST_NAME,
		n.HOME_PHONE,
		n.EMAIL, 
		na.ADDRESS_1, 
		na.ADDRESS_2,
		na.ADDRESS_3, 
		na.CITY, 
		na.STATE_PROVINCE,
		na.ZIP

FROM		Name n INNER JOIN
		Name_Address na ON n.MAIL_ADDRESS_NUM = na.ADDRESS_NUM

WHERE	@uID = n.ID

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECustomerFindPendingRecord]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECustomerFindPendingRecord]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure [dbo].[BAECustomerFindPendingRecord] @accountpendingid varchar(10),
 	@firstName varchar(20),
 	@lastName varchar(30),
 	@zip varchar(10),
 	@email varchar(100) as
IF @email <> ''  --Find user by email
	BEGIN
		SELECT DISTINCT AccountPendingID
		FROM AccountPending n
		WHERE UPPER(n.Email) = UPPER(@email);
	END
	ELSE IF (@accountpendingid <> '' AND @lastName <> '')  --Find user by id AND last name
	BEGIN
		SELECT DISTINCT AccountPendingID
		FROM AccountPending n
		WHERE n.AccountPendingID = @accountpendingid AND UPPER(n.LastName) = UPPER(@lastName);
	END
	ELSE IF (@zip <> '' AND @firstName <> '' AND @lastName <> '') --Find user by zip, last, first name
	BEGIN 
		SELECT DISTINCT AccountPendingID
		FROM AccountPending n
		WHERE UPPER(n.PostalCode) like UPPER(@zip) + '%' AND UPPER(n.LastName) = UPPER(@lastName) AND (UPPER(n.Informal) = UPPER(@firstName) OR UPPER(n.FirstName) = UPPER(@firstName) OR UPPER(n.MiddleName) = UPPER(@firstName))
		UNION
		SELECT DISTINCT n.AccountPendingID
		FROM AccountPending n
		INNER JOIN Name_Address na ON na.ID = n.AccountPendingID
		WHERE UPPER(na.ZIP) like UPPER(@zip) + '%' AND UPPER(n.LastName) = UPPER(@lastName) AND (UPPER(n.Informal) = UPPER(@firstName) OR UPPER(n.FirstName) = UPPER(@firstName) OR UPPER(n.MiddleName) = UPPER(@firstName))
	END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECustomerFindRecord]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECustomerFindRecord]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECustomerFindRecord] @id varchar(10),
 	@firstName varchar(20),
 	@lastName varchar(30),
 	@zip varchar(10),
 	@email varchar(100) as
IF @email <> ''  --Find user by email
	BEGIN
		SELECT DISTINCT ID
		FROM Name n
		WHERE n.EMAIL = @email
		UNION
		SELECT DISTINCT n.ID
		FROM Name n
		INNER JOIN Name_Address na ON na.ID = n.ID
		WHERE UPPER(na.EMAIL) = UPPER(@email);
	END
	ELSE IF (@id <> '' AND @lastName <> '')  --Find user by id AND last name
	BEGIN
		SELECT DISTINCT ID
		FROM Name n
		WHERE n.ID = @id AND UPPER(n.LAST_NAME) = UPPER(@lastName);
	END
	ELSE IF (@zip <> '' AND @firstName <> '' AND @lastName <> '') --Find user by zip, last, first name
	BEGIN 
		SELECT DISTINCT ID
		FROM Name n
		WHERE UPPER(n.ZIP) like UPPER(@zip) + '%' AND UPPER(n.LAST_NAME) = UPPER(@lastName) AND (UPPER(n.INFORMAL) = UPPER(@firstName) OR UPPER(n.FIRST_NAME) = UPPER(@firstName) OR UPPER(n.MIDDLE_NAME) = UPPER(@firstName))
		UNION
		SELECT DISTINCT n.ID
		FROM Name n
		INNER JOIN Name_Address na ON na.ID = n.ID
		WHERE UPPER(na.ZIP) like UPPER(@zip) + '%' AND UPPER(n.LAST_NAME) = UPPER(@lastName) AND (UPPER(n.INFORMAL) = UPPER(@firstName) OR UPPER(n.FIRST_NAME) = UPPER(@firstName) OR UPPER(n.MIDDLE_NAME) = UPPER(@firstName))
	END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECustomerGetDirectory]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECustomerGetDirectory]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECustomerGetDirectory] @name varchar(30),
 	@company varchar(30) as
SELECT n.ID
	FROM Name n
	WHERE UPPER(LAST_FIRST) like '%' + UPPER(@name) + '%'
	AND UPPER(n.COMPANY) like '%' + UPPER(@company) + '%'

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECustomerValidateLogin]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECustomerValidateLogin]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECustomerValidateLogin] @pUsername as
varchar(60),
	@pPassword AS varchar(100)
AS
	SELECT ID FROM
	Name_Security
	WHERE
	WEB_LOGIN = @pUsername AND [PASSWORD] = @pPassword;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAECustomerValidateWebLogin]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAECustomerValidateWebLogin]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAECustomerValidateWebLogin] @login varchar(60) as
SELECT ID FROM Name_Security
	WHERE WEB_LOGIN = @login

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEDisplayGetSelectiveContent]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEDisplayGetSelectiveContent]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEDisplayGetSelectiveContent] @pCategoryID  varchar(8),
 	@pResultsRequested  varchar(8),
 	@pHotContent varchar(20) as
DECLARE @SQLquery AS Nvarchar(2000)
	SET @SQLquery = N'SELECT Top ' + @pResultsRequested + 'vCo.*, vCa.Title AS "CategoryTitle"'
	SET @SQLquery = @SQLquery + N'FROM         VimCategory vCa INNER JOIN VimCategoryLookup vCaL ON vCa.CategoryID = vCaL.CategoryID FULL OUTER JOIN VimContent vCo ON vCaL.ContentID = vCo.ContentID '
	SET @SQLquery = @SQLquery + N' WHERE   (vCo.IsPreview = 0) AND (vCo.IsPublished = 1) AND (vCo.IsDeleted = 0)
		AND (vCo.PostDate <= GETDATE())
	 	AND (vCo.RemoveDate >= GETDATE() OR vCo.RemoveDate IS NULL) 
		AND (vCo.ArchiveDate >= GETDATE() OR	vCo.ArchiveDate IS NULL) 
		AND (vCo.ApprovalState = ''approved'') AND (vCaL.CategoryID =  '+@pCategoryID+'  ) '+@pHotContent+'
	ORDER BY vCo.OrderPosition, vCo.PostDate, vCo.Title'

execute sp_executesql @SQLquery

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEErrorDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEErrorDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEErrorDelete] @ErrorID as
int
AS
	DELETE
	FROM Error
	WHERE ErrorID = @ErrorID

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEErrorGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEErrorGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEErrorGetAll] @sortId as
int
AS
	IF(@sortId = 1)
		BEGIN
			SELECT * FROM Error
			ORDER BY ErrorID asC;
		END
	ELSE IF(@sortId = 2)
		BEGIN
			SELECT * FROM Error
			ORDER BY FriendlyErrorMessage asC;
		END
	ELSE IF(@sortId = 3)
		BEGIN
			SELECT * FROM Error
			ORDER BY FriendlyErrorMessage DESC;
		END
	ELSE IF(@sortId = 4)
		BEGIN
			SELECT * FROM Error
			ORDER BY UserID asC;
		END
	ELSE IF(@sortId = 5)
		BEGIN
			SELECT * FROM Error
			ORDER BY UserID DESC;
		END
	ELSE 
		BEGIN
			SELECT * FROM Error
			ORDER BY ErrorID DESC;
		END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEErrorInsert]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEErrorInsert]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEErrorInsert] @ErrorID as
int,
	@StackTrace 	AS 	varchar(255),
	@FriendlyErrorMessage	AS	varchar(255),
	@ErrorType	AS	varchar(255),
	@ErrorDate	AS	datetime,
	@HttpRefer	AS	varchar(255),
	@HttpPath	AS	varchar(255),
	@HttpHost	AS	varchar(255),
	@HttpAll	AS	varchar(255),
	@UserID	AS	varchar(255),
	@CookieData	AS	varchar(255)
AS
	INSERT INTO Error
	(	
	StackTrace,
	FriendlyErrorMessage,
	ErrorType,
	ErrorDate,
	HttpRefer,
	HttpPath,
	HttpHost,
	HttpAll,
	UserID,
	CookieData
	)
	VALUES 
	(	
	@StackTrace,
	@FriendlyErrorMessage,
	@ErrorType,
	@ErrorDate,
	@HttpRefer,
	@HttpPath,
	@HttpHost,
	@HttpAll,
	@UserID,
	@CookieData
	);

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEErrorLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEErrorLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEErrorLoad] @ErrorID as
int
AS
	SELECT * 
	FROM Error
	WHERE ErrorID = @ErrorID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEErrorUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEErrorUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEErrorUpdate] @ErrorID as
int,
	@StackTrace 	AS 	varchar(255),
	@FriendlyErrorMessage	AS	varchar(255),
	@ErrorType	AS	varchar(255),
	@ErrorDate	AS	datetime,
	@HttpRefer	AS	varchar(255),
	@HttpPath	AS	varchar(255),
	@HttpHost	AS	varchar(255),
	@HttpAll	AS	varchar(255),
	@UserID	AS	varchar(255),
	@CookieData	AS	varchar(255)
AS
	UPDATE Error
	SET 
	StackTrace = @StackTrace,
	FriendlyErrorMessage = @FriendlyErrorMessage,
	ErrorType = @ErrorType,
	ErrorDate = @ErrorDate,
	HttpRefer = @HttpRefer,
	HttpPath = @HttpPath,
	HttpHost = @HttpHost,
	HttpAll = @HttpAll,
	UserID = @UserID,
	CookieData = @CookieData

	WHERE ErrorID = @ErrorID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventAddGuest]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventAddGuest]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure [dbo].[BAEEventAddGuest] @GuestID int,
      @RegistrantID varchar(300),
      @EventCode varchar(50),
      @GuestBadge varchar(50),
      @FirstName varchar(50),
      @MiddleInitial varchar(50),
      @LastName varchar(50),
      @Address varchar(50),
      @Address2 varchar(50),
      @Address3 varchar(50),
      @City varchar(64),
      @State varchar(48),
      @PostalCode varchar(50),
      @Country varchar(25),
      @cartEventFuncID int,
      @Prefix varchar(25),
      @Suffix varchar(10),
      @Nickname varchar(20),  
	  @Designation varchar(20),
	  @MyTitle varchar(50),
	  @Company varchar(80) as

DECLARE @CartEventID int, @Quantity int, @Title varchar(512), @Description varchar(2048), @FunctionStart datetime, @FunctionEnd datetime, @Price money

      -- Get the CartEventID
      SELECT @CartEventID = CartEventID
      FROM CartEvent
      WHERE RegistrantID = @RegistrantID AND EventCode = @EventCode

      SELECT EventGuestID
      FROM EventGuest
      WHERE EventGuestID = @GuestID

      --If rowcount > 0, then guest IS already in the system
      IF @@ROWCOUNT > 0
      begin
            UPDATE EventGuest
                  SET GuestBadge = @GuestBadge,
                  FirstName = @FirstName,
                  MiddleInitial = @MiddleInitial,
                  LastName = @LastName,
                  Address1 = @Address,
                  Address2 = @Address2,
                  Address3 = @Address3,
                  City = @City,
                  StateProvince = @State,
                  PostalCode = @PostalCode,
                  Country = @Country,
                  CartEventFunctionID = @cartEventFuncID,
                  Prefix = @Prefix,
                  Suffix = @Suffix,
                  Nickname = @Nickname,  
	              Designation = @Designation,
	              Title = @MyTitle,
	              Company = @Company
            WHERE EventGuestID = @GuestID;

            SELECT * FROM EventGuest WHERE EventGuestID = @GuestID;
      end   

       --If rowcount = 0, then guest IS NOT IN the system
      IF @@ROWCOUNT = 0
      begin
            -- INSERT the guest info INTO the temp table
            INSERT INTO EventGuest(RegistrantID, EventCode, GuestBadge, FirstName, MiddleInitial, LastName, Address1, Address2, Address3, City, StateProvince, PostalCode, Country, CartEventFunctionID, Prefix, Suffix, Nickname, Designation, Title, Company)
            VALUES(@RegistrantID, @EventCode, @GuestBadge, @FirstName, @MiddleInitial, @LastName, @Address, @Address2, @Address3, @City, @State, @PostalCode, @Country, @cartEventFuncID, @Prefix, @Suffix, @Nickname, @Designation, @MyTitle, @Company)

            SELECT CAST(@@IDENTITY AS INT);
      end

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventAddRegistrant]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventAddRegistrant]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure [dbo].[BAEEventAddRegistrant] @UID VARCHAR(16),
      @RegistrantID VARCHAR(16),
      @EventCode VARCHAR(16),
      @SessionStartDate DATETIME,
      @RegistrantClass VARCHAR(32),
      @F_Name VARCHAR(24),
      @M_Initial VARCHAR(24),
      @L_Name VARCHAR(32),
      @Address_1 VARCHAR(128),
      @Address_2 VARCHAR(128),
      @Address_3 VARCHAR(128),
      @City VARCHAR(64),
      @State VARCHAR(48),
      @PostalCode VARCHAR(16),
      @ApplyChanges bit,
      @Purpose varchar(64),
      @Phone varchar(32),
      @Email varchar(128),
      @Country varchar(25) as

IF @EventCode!=''
BEGIN
SELECT * FROM EventRegistrant
WHERE RegistrantID = @RegistrantID AND EventCode=@EventCode;

IF @@rowcount > 0
      BEGIN
            UPDATE EventRegistrant 
                  SET   UserID = @UID,    RegistrantID = @RegistrantID, EventCode = @EventCode, SessionStartDate = @SessionStartDate, RegistrantClass = @RegistrantClass, FirstName = @F_Name, MiddleInitial = @M_Initial, LastName = @L_Name, Address1 = @Address_1, Address2 = @Address_2, Address3 = @Address_3, City = @City, StateProvince = @State, PostalCode = @PostalCode, ApplyPermanentChanges = @ApplyChanges, AddressPurpose = @Purpose, Phone = @Phone, Email = @Email, Country = @Country
            WHERE RegistrantID = @RegistrantID AND EventCode=@EventCode;
      END
ELSE
      BEGIN
            INSERT INTO EventRegistrant (
                  UserID,     RegistrantID, EventCode, SessionStartDate, RegistrantClass,  FirstName, MiddleInitial, LastName, Address1, Address2, Address3, City, StateProvince, PostalCode,
                  ApplyPermanentChanges, AddressPurpose, Phone, Email, Country )
            VALUES(
                  @UID, @RegistrantID, @EventCode, @SessionStartDate, @RegistrantClass, @F_Name, @M_Initial, @L_Name, @Address_1,
                  @Address_2, @Address_3, @City, @State, @PostalCode,
                  @ApplyChanges, @Purpose, @Phone, @Email, @Country )
      END
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventAddRegistrantAnswer]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventAddRegistrantAnswer]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure [dbo].[BAEEventAddRegistrantAnswer] @eventCode varchar(15),
 	@registrantID varchar(10),
 	@questionID int,
 	@answer varchar(512) as
DELETE FROM EventRegistrationAnswer 
	WHERE EventCode = @eventCode AND RegistrantID = @registrantID AND QuestionID = @questionID;
	
	INSERT INTO EventRegistrationAnswer (EventCode, RegistrantID, QuestionID, Answer)
	VALUES (@eventCode, @registrantID, @questionID, @answer);

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventCheckRegistrantStatus]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventCheckRegistrantStatus]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventCheckRegistrantStatus] @userID varchar(10),
 	@eventCode varchar(10) as
SELECT * FROM Orders o, Order_Meet om
	WHERE ST_ID = @userID AND o.ORDER_NUMBER = om.ORDER_NUMBER AND MEETING = @eventCode;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventDeleteGuest]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventDeleteGuest]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventDeleteGuest] @GuestID int as
DELETE FROM EventGuest
	WHERE EventGuestID = @GuestID

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventDeleteRegistrationAnswer]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventDeleteRegistrationAnswer]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventDeleteRegistrationAnswer] @eventCode varchar(16),
 	@registrantId varchar(16),
 	@questionId int as
DELETE FROM EventRegistrationAnswer
	WHERE RegistrantID = @registrantId AND EventCode = @eventCode AND QuestionID = @questionId;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventGetAllLinkedFunctions]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventGetAllLinkedFunctions]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[BAEEventGetAllLinkedFunctions] @eventCode varchar(64) as
SELECT parent.PRODUCT_CODE AS 'PARENT_PRODUCT_CODE', p.* 
	FROM Product_Sub ps
	INNER JOIN Product p on p.PRODUCT_CODE = ps.CHILD_PRODUCT_CODE
	INNER JOIN Product parent ON ps.PRODUCT_CODE = parent.PRODUCT_CODE
	WHERE parent.PRODUCT_MAJOR = @eventCode

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventGetAutoEnrollFunctions]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventGetAutoEnrollFunctions]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventGetAutoEnrollFunctions] @eventCode varchar(10) as
SELECT * FROM 
	Product p
	INNER JOIN  Product_Function pf on p.PRODUCT_CODE = pf.PRODUCT_CODE
	 WHERE p.PRODUCT_MAJOR = @eventCode AND AUTO_ENROLL = '1'
	AND pf.WEB_ENABLED = '1'
	ORDER BY TITLE_KEY

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventGetCoupons]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventGetCoupons]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventGetCoupons] @eventCode varchar(10) as
SELECT * FROM Product p
	INNER JOIN Product_Function pf on pf.PRODUCT_CODE = p.PRODUCT_CODE
	 WHERE p.PRODUCT_MAJOR = @eventCode AND  p.PRODUCT_MINOR like 'CPN%'
	AND pf.WEB_ENABLED = '1'

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventGetCoworkers]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventGetCoworkers]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventGetCoworkers] @UID VARCHAR(30), @eventCode VARCHAR (10),	@letter varchar(5) AS
	DECLARE @COID varchar(50), @Corec bit

	SELECT @COID = CO_ID, @Corec = COMPANY_RECORD
	FROM Name
	WHERE ID = @UID

	IF @letter = 'ALL'
		SET @letter = ''

	-- if this IS a company record, then get the list by a slightly different method
	IF @Corec = 1
	begin
		SELECT DISTINCT ID, *
		FROM Name AS N
		WHERE ID <> @UID AND N.CO_ID = @UID AND LAST_NAME LIKE @letter + '%' AND ID NOT IN(
			SELECT ST_ID
			FROM Orders AS o
			INNER JOIN Order_Meet AS om ON o.ORDER_NUMBER = om.ORDER_NUMBER
			WHERE MEETING = @eventCode)
		UNION 
		SELECT DISTINCT ID, *
		FROM Name AS N
		WHERE ID <> @UID AND N.CO_ID = @UID AND LAST_NAME LIKE @letter + '%' AND ID IN(
			SELECT ST_ID
			FROM Orders AS o
			INNER JOIN Order_Meet AS om ON o.ORDER_NUMBER = om.ORDER_NUMBER
			WHERE MEETING = @eventCode)
		ORDER BY LAST_NAME, FIRST_NAME;
	end
	ELSE
	begin
		SELECT DISTINCT ID,*
		FROM Name AS N
		WHERE ID <> @UID AND (N.CO_ID = @COID OR (N.ID = @COID AND N.COMPANY_RECORD = 1)) AND LEN(LAST_NAME) > 0  AND LAST_NAME LIKE @letter+'%' AND ID NOT IN(
			SELECT ST_ID
			FROM Orders AS o
			INNER JOIN Order_Meet AS om ON o.ORDER_NUMBER = om.ORDER_NUMBER
			WHERE MEETING = @eventCode)
		UNION
		SELECT DISTINCT ID, *
		FROM Name AS N
		WHERE ID <> @UID AND (N.CO_ID = @COID OR (N.ID = @COID AND N.COMPANY_RECORD = 1)) AND LEN(LAST_NAME) > 0 AND LAST_NAME LIKE @letter+'%' AND ID IN(
			SELECT ST_ID
			FROM Orders AS o
			INNER JOIN Order_Meet AS om ON o.ORDER_NUMBER = om.ORDER_NUMBER
			WHERE MEETING = @eventCode)		
		ORDER BY LAST_NAME, FIRST_NAME;
	end

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventGetDetails]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventGetDetails]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventGetDetails] @meetingID varchar(10) as
SELECT * FROM Meet_Master 
	 WHERE MEETING = @meetingID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventGetFunction]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventGetFunction]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure [dbo].[BAEEventGetFunction] @productCode varchar(31) as
SELECT p.[PRODUCT_CODE], p.[PRODUCT_MAJOR], p.[PRODUCT_MINOR], p.[PROD_TYPE], p.[CATEGORY], p.[TITLE_KEY], p.[TITLE], 
       p.[DESCRIPTION], p.[STATUS], p.[NOTE], p.[GROUP_1], p.[GROUP_2], p.[GROUP_3], p.[PRICE_RULES_EXIST], p.[LOT_SERIAL_EXIST], 
       p.[PAYMENT_PRIORITY], p.[RENEW_MONTHS], p.[PRORATE], p.[STOCK_ITEM], p.[UNIT_OF_MEASURE], p.[WEIGHT], p.[TAXABLE], 
       p.[COMMISIONABLE], p.[COMMISION_PERCENT], p.[DECIMAL_POINTS], p.[INCOME_ACCOUNT], p.[DEFERRED_INCOME_ACCOUNT], 
       p.[INVENTORY_ACCOUNT], p.[ADJUSTMENT_ACCOUNT], p.[COG_ACCOUNT], p.[INTENT_TO_EDIT], p.[PRICE_1], p.[PRICE_2], p.[PRICE_3], 
       p.[COMPLIMENTARY], p.[ATTRIBUTES], p.[PST_TAXABLE], p.[TAXABLE_VALUE], p.[ORG_CODE], p.[TAX_AUTHORITY], p.[WEB_OPTION], 
       p.[IMAGE_URL], p.[APPLY_IMAGE], p.[IS_KIT], p.[INFO_URL], p.[APPLY_INFO], p.[PLP_CODE], p.[PROMOTE], p.[THUMBNAIL_URL], 
       p.[APPLY_THUMBNAIL], p.[CATALOG_DESC], p.[WEB_DESC], p.[OTHER_DESC], p.[LOCATION], p.[PREMIUM], p.[FAIR_MARKET_VALUE], 
       p.[IS_FR_ITEM], p.[APPEAL_CODE], p.[CAMPAIGN_CODE], p.[TIME_STAMP], p.[ProductKey], 
       pf.[PRODUCT_CODE], pf.[FUNCTION_TYPE], pf.[BEGIN_DATE_TIME], pf.[END_DATE_TIME], pf.[SEQ], 
       pf.[MINIMUM_ATTENDANCE], pf.[EXPECTED_ATTENDANCE], pf.[GUARANTEED_ATTENDANCE], pf.[ACTUAL_ATTENDANCE], pf.[SETTINGS], 
       pf.[SETUP_DATE_TIME], pf.[POST_DATE_TIME], pf.[AUTO_ENROLL], pf.[PRINT_TICKET], pf.[LAST_TICKET], pf.[CEU_TYPE], 
       pf.[CEU_AMOUNT], pf.[COURSE_CODE], pf.[OTHER_TICKETS], pf.[CEU_ENTERED], pf.[MAXIMUM_ATTENDANCE], pf.[PARENT], 
       pf.[CONFLICT_CODE], pf.[WEB_ENABLED], pf.[WEB_MULTI_REG], pf.[SQUARE_FEET], pf.[IS_FR_ITEM], pf.[IS_GUEST_FUNCTION], 
       pf.[CREATE_DETAIL_ACTIVITY], pf.[TIME_STAMP]
	FROM Product p
	INNER JOIN Product_Function pf on pf.PRODUCT_CODE = p.PRODUCT_CODE
	WHERE p.PRODUCT_CODE = @productCode 
	AND (pf.IS_GUEST_FUNCTION IS NULL OR pf.IS_GUEST_FUNCTION = 0)
	AND pf.WEB_ENABLED = '1';

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventGetFunctionPricing]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventGetFunctionPricing]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventGetFunctionPricing] @productCode as
varchar(31),
	@pMemberType AS varchar(10)
AS
	SELECT RATE_1 AS 'EarlyRate', RATE_2  AS 'NormalRate', RATE_3 AS 'LateRate'
	FROM Product_Price 
	WHERE PRODUCT_CODE = @productCode AND CUSTOMER_TYPE = @pMemberType

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventGetFunctionRegistrationCount]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventGetFunctionRegistrationCount]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventGetFunctionRegistrationCount] @eventCode varchar(64),
 	@productCode varchar(64) as
SELECT CONVERT(int, SUM(ol.QUANTITY_ORDERED)) AS 'NumberRegistered'
	FROM Order_Lines AS ol
	WHERE ol.PRODUCT_CODE = @eventCode + '/' + @productCode

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventGetFunctionRegistrationCounts]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventGetFunctionRegistrationCounts]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[BAEEventGetFunctionRegistrationCounts] @eventCode varchar(64)
AS
SELECT p.[PRODUCT_MINOR] AS 'FunctionCode', ISNULL(CONVERT(int, SUM(ol.[QUANTITY_ORDERED])), 0) AS 'NumberRegistered'
	FROM [dbo].[Product] p
	LEFT OUTER JOIN [dbo].[Order_Lines] AS ol ON p.[PRODUCT_CODE] = ol.[PRODUCT_CODE]
	WHERE p.[PRODUCT_MAJOR] = @eventCode
	GROUP BY p.[PRODUCT_MINOR]
	ORDER BY p.[PRODUCT_MINOR]

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventGetFunctions]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventGetFunctions]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure [dbo].[BAEEventGetFunctions] @eventCode varchar(15) as
SELECT *
	FROM Product p
	INNER JOIN Product_Function pf on pf.PRODUCT_CODE = p.PRODUCT_CODE
	WHERE p.PRODUCT_MAJOR = @eventCode AND LEN(p.PRODUCT_MINOR) > 1 
	AND (pf.IS_GUEST_FUNCTION IS NULL OR pf.IS_GUEST_FUNCTION = 0)
	AND pf.WEB_ENABLED = '1';

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventGetGuest]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventGetGuest]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventGetGuest] @GuestID INT as
SELECT *
	FROM EventGuest
	WHERE EventGuestID = @GuestID

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventGetGuestBadgeList]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventGetGuestBadgeList]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure [dbo].[BAEEventGetGuestBadgeList] @eventCode varchar(15) = '' as
SELECT * 
	FROM Product p
	INNER JOIN Product_Function pf ON pf.PRODUCT_CODE = p.PRODUCT_CODE
	WHERE PRODUCT_MAJOR = @eventCode AND pf.IS_GUEST_FUNCTION = 1 AND pf.WEB_ENABLED = '1'
	ORDER BY TITLE ASC;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventGetGuests]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventGetGuests]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventGetGuests] @RegistrantID varchar(16),
 	@EventCode varchar(16) as
SELECT eg.EventGuestID, eg.RegistrantID, eg.EventCode, eg.GuestBadge, p.TITLE AS 'GuestBadgeTitle', eg.FirstName, eg.MiddleInitial, eg.LastName, eg.Address1, eg.City, eg.StateProvince, eg.PostalCode, cef.Price
	FROM CartEventFunction AS cef, EventGuest AS eg
	INNER JOIN Product AS p ON p.PRODUCT_CODE COLLATE database_default = eg.GuestBadge COLLATE database_default
	WHERE eg.RegistrantID = @RegistrantID AND eg.EventCode = @EventCode AND cef.CartEventFunctionID = eg.CartEventFunctionID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventGetLinkedFunctions]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventGetLinkedFunctions]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventGetLinkedFunctions] @productCode varchar(64) as
SELECT p.* 
	FROM Product_Sub ps
	INNER JOIN Product p on p.PRODUCT_CODE = ps.CHILD_PRODUCT_CODE
	WHERE ps.PRODUCT_CODE = @productCode

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventGetList]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventGetList]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure [dbo].[BAEEventGetList] @showAll int,
 	@city varchar(40),
 	@date varchar(20) as
 	declare @justdate datetime
	set @justdate = DATEADD(dd,(DATEDIFF(dd,0,@date)),0)
if(@showAll=1 AND @city <> ''  AND @date <> '')
		SELECT *
		FROM Meet_Master
		WHERE CITY = @city AND BEGIN_DATE = @date AND  WEB_ENABLED = '1' AND (DATEADD(dd,(DATEDIFF(dd,0,BEGIN_DATE)),0) >= @justdate OR DATEADD(dd,(DATEDIFF(dd,0,END_DATE)),0) >= @justdate)
		ORDER BY BEGIN_DATE;
	else if(@showAll = 1 AND @city <>'')
		SELECT *
		FROM Meet_Master
		WHERE CITY = @city AND WEB_ENABLED = '1' AND (DATEADD(dd,(DATEDIFF(dd,0,BEGIN_DATE)),0) >= @justdate OR DATEADD(dd,(DATEDIFF(dd,0,END_DATE)),0) >= @justdate)
		ORDER BY BEGIN_DATE;
	else if(@showAll = 1 AND @date <> '')
		SELECT *
		FROM Meet_Master
		WHERE BEGIN_DATE = @date AND WEB_ENABLED = '1' AND (DATEADD(dd,(DATEDIFF(dd,0,BEGIN_DATE)),0) >= @justdate OR DATEADD(dd,(DATEDIFF(dd,0,END_DATE)),0) >= @justdate)
		ORDER BY BEGIN_DATE;
	else if(@showAll = 1)
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND (DATEADD(dd,(DATEDIFF(dd,0,BEGIN_DATE)),0) >= @justdate OR DATEADD(dd,(DATEDIFF(dd,0,END_DATE)),0) >= @justdate)
		ORDER BY BEGIN_DATE;
	else if(@date <> ''  AND @city <> '')	
		SELECT *
		FROM Meet_Master
		WHERE WEB_ENABLED = '1' AND STATUS = 'A' AND CITY = @city AND BEGIN_DATE = @date  AND (DATEADD(dd,(DATEDIFF(dd,0,BEGIN_DATE)),0) >= @justdate OR DATEADD(dd,(DATEDIFF(dd,0,END_DATE)),0) >= @justdate)
		ORDER BY BEGIN_DATE;
	else if(@date <> '')
		SELECT *
		FROM Meet_Master
		WHERE WEB_ENABLED = '1' AND STATUS = 'A' AND BEGIN_DATE = @date  AND (DATEADD(dd,(DATEDIFF(dd,0,BEGIN_DATE)),0) >=@justdate OR DATEADD(dd,(DATEDIFF(dd,0,END_DATE)),0) >= @justdate)
		ORDER BY  BEGIN_DATE;
	else if(@city <> '')
		SELECT *
		FROM Meet_Master
		WHERE WEB_ENABLED = '1' AND STATUS = 'A' AND CITY = @city  AND (DATEADD(dd,(DATEDIFF(dd,0,BEGIN_DATE)),0) >= @justdate OR DATEADD(dd,(DATEDIFF(dd,0,END_DATE)),0) >= @justdate)
		ORDER BY BEGIN_DATE;
	else
		SELECT *
		FROM Meet_Master
		WHERE WEB_ENABLED = '1' AND STATUS = 'A'  AND (DATEADD(dd,(DATEDIFF(dd,0,BEGIN_DATE)),0) >= @justdate OR DATEADD(dd,(DATEDIFF(dd,0,END_DATE)),0) >= @justdate)
		ORDER BY BEGIN_DATE;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventGetRegistrant]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventGetRegistrant]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventGetRegistrant] @RegistrantID VARCHAR(30),
 	@EventCode VARCHAR(10) as
SELECT * 
FROM EventRegistrant
WHERE RegistrantID=@RegistrantID AND EventCode=@EventCode

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventGetRegistrantAnswer]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventGetRegistrantAnswer]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventGetRegistrantAnswer] @RegistrantID VARCHAR(16),
 	@EventCode VARCHAR(16),
 	@questionID int as
SELECT  *
	FROM EventRegistrationAnswer AS a
	WHERE a.QuestionID = @questionID AND
		a.RegistrantID = @RegistrantID AND
		a.EventCode = @EventCode

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventGetRegistrantAnswers]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventGetRegistrantAnswers]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventGetRegistrantAnswers] @RegistrantID VARCHAR(16),
 	@EventCode VARCHAR(16) as
SELECT QuestionID, Question, Answer
	FROM EventRegistrationAnswer AS a, EventSetupQuestion AS q
	WHERE q.EventCode = a.EventCode AND 
		q.EventSetupQuestionID = a.QuestionID AND
		a.RegistrantID = @RegistrantID AND
		a.EventCode = @EventCode

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventGetRegistrants]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventGetRegistrants]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventGetRegistrants] @userID VARCHAR(30),
 	@EventCode VARCHAR(10) as
SELECT * 
FROM EventRegistrant
WHERE RegistrantID=@userID AND EventCode=@EventCode

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventGetRegistrationAnswersByQuestionId]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventGetRegistrationAnswersByQuestionId]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[BAEEventGetRegistrationAnswersByQuestionId]
	@questionId as int
AS
	SELECT QuestionID, Question, Answer, q.EventCode, a.RegistrantID
	FROM EventRegistrationAnswer AS a, EventSetupQuestion AS q
	WHERE q.EventCode = a.EventCode AND 
		q.EventSetupQuestionID = a.QuestionID AND
		q.EventSetupQuestionID = @questionId;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSearch]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSearch]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure [dbo].[BAEEventSearch] @showAll int,
 	@start varchar(15),
 	@end varchar(15),
 	@state varchar(15),
 	@title varchar(60),
 	@city varchar(255) as
if(@showAll = 1 AND @start <> '' AND @end <> '' AND @state <> '' AND @title <> '' AND @city <> '')
		SELECT *
		FROM Meet_Master
		WHERE WEB_ENABLED = '1' AND ((BEGIN_DATE >= @start AND BEGIN_DATE <= @end))
			AND @state = STATE_PROVINCE AND UPPER(TITLE) LIKE '%' + @title + '%' AND CITY LIKE '%' + @city + '%' AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* 5C4 */
	/* Start, end, state AND title are provided */
	else if(@showAll = 1 AND @start <> '' AND @end <> '' AND @state <> '' AND @title <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND ((BEGIN_DATE >= @start AND BEGIN_DATE <= @end))
			AND @state = STATE_PROVINCE AND UPPER(TITLE) LIKE '%' + @title + '%' AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* Start, end, title AND city are provided */
	else if(@showAll=1 AND @start <> '' AND @end <> '' AND @title <> '' AND @city <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND ((BEGIN_DATE >= @start AND BEGIN_DATE <= @end))
			AND UPPER(TITLE) like '%' + @title + '%' AND CITY LIKE '%' + @city + '%' AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* Start, end, state AND city are provided */
	else if(@showAll = 1 AND @start <> '' AND @end <> '' AND @state <> '' AND @city <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND ((BEGIN_DATE >= @start AND BEGIN_DATE <= @end))
			AND @state = STATE_PROVINCE AND CITY like '%' + @city + '%'  AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* Start, state, title AND city are provided */
	else if(@showAll=1 AND @start <> '' AND @state <> '' AND @title <> '' AND @city <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND ((BEGIN_DATE >= @start))
			AND @state = STATE_PROVINCE AND UPPER(TITLE) like '%' + @title + '%' AND CITY like '%' + @city + '%'  AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* End, state, title AND city are provided */
	else if(@showAll=1 AND @end <> '' AND @state <> '' AND @title <> '' AND @city <> '')
		SELECT * 
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND ((BEGIN_DATE <= @end))
			AND @state = STATE_PROVINCE AND UPPER(TITLE) like '%' + @title + '%' AND CITY like '%' + @city + '%'  AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;
	
	/* 5C3 */
	/* Start, end AND state are provided */
	else if(@showAll = 1 AND @start <> '' AND @end <> '' AND @state <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND ((BEGIN_DATE <= @end AND BEGIN_DATE >= @start ))
			AND @state = STATE_PROVINCE  AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;
	
	/* Start, end AND title are provided */
	else if(@showAll = 1 AND @start <> '' AND @end <> '' AND @title <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND ((BEGIN_DATE <= @end AND BEGIN_DATE >= @start ))
			 AND UPPER(TITLE) LIKE '%'+@title+'%' AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;
	
	/* Start, end AND city are provided */
	else if(@showAll = 1 AND @start <> '' AND @end <> '' AND @city <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND ((BEGIN_DATE >= @start AND BEGIN_DATE <= @end))
			AND CITY LIKE '%' + @city + '%'  AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* Start, state AND title are provided */
	else if(@showAll = 1 AND @start <> '' AND @state <> '' AND @title <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND (BEGIN_DATE >= @start)
			AND @state = STATE_PROVINCE AND UPPER(TITLE) LIKE '%' + @title + '%' AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* Start, state AND city are provided */
	else if(@showAll = 1 AND @start <> '' AND @state <> '' AND @city <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND (BEGIN_DATE >= @start)
			AND @state = STATE_PROVINCE AND CITY like '%' + @city + '%'  AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* Start, title AND city are provided */
	else if(@showAll = 1 AND @start <> '' AND @title <> '' AND @city <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND (BEGIN_DATE >= @start)
			AND UPPER(TITLE) LIKE '%' + @title + '%' AND CITY LIKE '%' + @city + '%'  AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* End, state AND title are provided */
	else if(@showAll = 1 AND @end <> '' AND @state <> '' AND @title <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND (BEGIN_DATE <= @end)
			AND @state = STATE_PROVINCE AND UPPER(TITLE) like '%' + @title + '%' AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* End, state AND city are provided */
	else if(@showAll = 1 AND @end <> '' AND @state <> '' AND @city <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND ((BEGIN_DATE <= @end))
			AND @state = STATE_PROVINCE AND CITY like '%' + @city + '%'  AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* End, title AND city are provided */
	else if(@showAll = 1 AND @end <> '' AND @title <> '' AND @city <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND ((BEGIN_DATE <= @end))
			AND UPPER(TITLE) like '%'+@title+'%' AND CITY like '%'+@city+'%'  AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* State, title AND city are provided */
	else if(@showAll = 1 AND @state <> '' AND @title <> '' AND @city <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND @state = STATE_PROVINCE AND UPPER(TITLE) LIKE '%' + @title + '%' AND CITY LIKE '%' + @city + '%'
		AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* 5C2 */

	/* Start AND end are provided */
	else if( @showAll = 1 AND @start <> '' AND @end <> '' )
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND ((BEGIN_DATE >= @start AND BEGIN_DATE <= @end))
			 AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* Start AND state are provided */
	else if(@showAll = 1 AND @start <> '' AND @state <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND (BEGIN_DATE >= @start)
			AND @state = STATE_PROVINCE AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* Start AND title are provided */
	else if(@showAll = 1 AND @start <> '' AND @title <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND (BEGIN_DATE >= @start  )
			AND UPPER(TITLE) LIKE '%'+@title+'%'  AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* Start AND City are provided */
	else if(@showAll = 1 AND @start <> '' AND @city <> '')

		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND (BEGIN_DATE >= @start  )
			AND CITY LIKE '%' + @city + '%'  AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* End AND state are provided */
	else if(@showAll = 1 AND @end <> '' AND @state <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND (BEGIN_DATE <= @end)
			AND @state = STATE_PROVINCE AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* End AND title are provided */
	else if(@showAll = 1 AND @end <> '' AND @title <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND (BEGIN_DATE <= @end)
			AND UPPER(TITLE) LIKE '%'+@title+'%' AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* End AND city are provided */
	else if(@showAll = 1 AND @end <> '' AND @city <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND (BEGIN_DATE <= @end)
			AND CITY LIKE '%' + @city + '%' AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* State AND title are provided */
	else if(@showAll = 1 AND @state <> '' AND @title <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND @state = STATE_PROVINCE AND UPPER(TITLE) LIKE '%' + @title + '%'  AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;
	
	/* State AND city are provided */
	else if(@showAll = 1 AND @state <> '' AND @city <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND @state=STATE_PROVINCE AND CITY like '%'+@city+'%'  AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;	

	/*Title AND city are provided */
	else if(@showAll = 1 AND @title <> '' AND @city <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND UPPER(TITLE) LIKE  '%' + @title + '%' AND CITY LIKE '%' + @city + '%' AND STATUS = 'A' AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* Start only */
	else if(@showAll = 1 AND @start <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND (BEGIN_DATE >= @start) AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* End only */
	else if(@showAll = 1 AND @end <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND (BEGIN_DATE <= @end) AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;
	
	/* State only */
	else if(@showAll = 1 AND @state <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND @state = STATE_PROVINCE  AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;
	
	/* Title only */
	else if(@showAll = 1 AND @title <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND UPPER(TITLE) LIKE '%' + @title + '%' AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;
	
	/* City only */
	else if(@showAll = 1 AND @city <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND CITY LIKE '%' + @city + '%' AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

/* Non-Admin User */
	/* 5C5 */
	/* Start, end, state, title AND city are provided */
	else if(@showAll = 0 AND @start <> '' AND @end <> '' AND @state <> '' AND @title <> '' AND @city <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND ((BEGIN_DATE >= @start AND BEGIN_DATE <= @end))
			AND @state = STATE_PROVINCE AND UPPER(TITLE) LIKE '%' + @title + '%' AND CITY LIKE '%' + @city + '%' AND STATUS = 'A'
			 AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* 5C4 */
	/* Start, end, state AND title are provided */
	else if(@showAll = 0 AND @start <> '' AND @end <> '' AND @state <> '' AND @title <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND ((BEGIN_DATE >= @start AND BEGIN_DATE <= @end))
			AND @state = STATE_PROVINCE AND UPPER(TITLE) LIKE '%' + @title + '%' AND STATUS = 'A'  AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* Start, end, title AND city are provided */
	else if(@showAll = 0 AND @start <> '' AND @end <> '' AND @title <> '' AND @city <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND ((BEGIN_DATE >= @start AND BEGIN_DATE <= @end))
			AND UPPER(TITLE) like '%' + @title + '%' AND CITY LIKE '%' + @city + '%' AND STATUS = 'A'  AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* Start, end, state AND city are provided */
	else if(@showAll=0 AND @start <> '' AND @end <> '' AND @state <> '' AND @city <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND ((BEGIN_DATE >= @start AND BEGIN_DATE <= @end))
			AND @state = STATE_PROVINCE AND CITY LIKE '%' + @city + '%' AND STATUS = 'A'  AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* Start, state, title AND city are provided */
	else if(@showAll = 0 AND @start <> '' AND @state <> '' AND @title <> '' AND @city <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND ((BEGIN_DATE >=@start))
			AND @state = STATE_PROVINCE AND UPPER(TITLE) LIKE '%' + @title + '%' AND CITY LIKE '%' + @city + '%' AND STATUS = 'A'
			 AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* End, state, title AND city are provided */
	else if(@showAll = 0 AND @end <> '' AND @state <> '' AND @title <> '' AND @city <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND ((BEGIN_DATE <= @end))
			AND @state = STATE_PROVINCE AND UPPER(TITLE) LIKE '%' + @title + '%' AND CITY LIKE '%' + @city + '%' AND STATUS = 'A'
			 AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;
	
	/* 5C3 */
	/* Start, end AND state are provided */
	else if(@showAll = 0 AND @start <> '' AND @end <> '' AND @state <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND ((BEGIN_DATE <= @end AND BEGIN_DATE >= @start ))
			AND @state = STATE_PROVINCE AND STATUS = 'A'  AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;
	
	/* Start, end AND title are provided */
	else if(@showAll = 0 AND @start <> '' AND @end <> '' AND @title <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND ((BEGIN_DATE <= @end AND BEGIN_DATE >= @start ))
			 AND UPPER(TITLE) LIKE '%' + @title + '%' AND STATUS = 'A' AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;
	
	/* Start, end AND city are provided */
	else if(@showAll = 0 AND @start <> '' AND @end <> '' AND @city <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND ((BEGIN_DATE >= @start AND BEGIN_DATE <= @end))
			AND CITY LIKE '%' + @city + '%' AND STATUS = 'A' AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* Start, state AND title are provided */
	else if(@showAll = 0 AND @start <> '' AND @state <> '' AND @title <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND (BEGIN_DATE >= @start)
			AND @state = STATE_PROVINCE AND UPPER(TITLE) LIKE '%' + @title + '%' AND STATUS = 'A'  AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* Start, state AND city are provided */
	else if(@showAll = 0 AND @start <> '' AND @state <> '' AND @city <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND ((BEGIN_DATE >= @start))
			AND @state = STATE_PROVINCE AND CITY LIKE '%' + @city + '%' AND STATUS = 'A' AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* Start, title AND city are provided */
	else if(@showAll = 0 AND @start <> '' AND @title <> '' AND @city <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND ((BEGIN_DATE >= @start))
			AND UPPER(TITLE) LIKE '%' + @title + '%' AND CITY LIKE '%' + @city + '%' AND STATUS = 'A' AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* End, state AND title are provided */
	else if(@showAll = 0 AND @end <> '' AND @state <> '' AND @title <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND (BEGIN_DATE <= @end)
			AND @state = STATE_PROVINCE AND UPPER(TITLE) LIKE '%' + @title + '%' AND STATUS = 'A' AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* End, state AND city are provided */
	else if(@showAll = 0 AND @end <> '' AND @state <> '' AND @city <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND ((BEGIN_DATE <= @end))
			AND @state = STATE_PROVINCE AND CITY LIKE '%' + @city + '%' AND STATUS = 'A' AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* End, title AND city are provided */
	else if(@showAll = 0 AND @end <> '' AND @title <> '' AND @city <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND ((BEGIN_DATE <= @end))
			AND UPPER(TITLE) LIKE '%' + @title + '%' AND CITY LIKE '%' + @city + '%' AND STATUS = 'A'  AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* State, title AND city are provided */
	else if(@showAll = 0 AND @state <> '' AND @title <> '' AND @city <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND @state = STATE_PROVINCE AND UPPER(TITLE) LIKE '%' + @title + '%' AND CITY LIKE '%' + @city + '%' AND STATUS = 'A'
			 AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;
/* 5C2 */

	/* Start AND end are provided */
	else if( @showAll = 0 AND @start <> '' AND @end <> '' )
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND ((BEGIN_DATE <= @end AND BEGIN_DATE >= @start ))
		AND STATUS = 'A' AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* Start AND state are provided */
	else if(@showAll = 0 AND @start <> '' AND @state <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND (BEGIN_DATE >= @start  )
			AND @state = STATE_PROVINCE AND STATUS = 'A' AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* Start AND title are provided */
	else if(@showAll = 0 AND @start <> '' AND @title <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND (BEGIN_DATE >= @start  )
			AND UPPER(TITLE) LIKE '%' + @title + '%' AND STATUS = 'A'  AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* Start AND City are provided */
	else if(@showAll = 0 AND @start <> '' AND @city <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND (BEGIN_DATE >= @start  )
			AND CITY LIKE '%' + @city + '%' AND STATUS = 'A' AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* End AND state are provided */
	else if(@showAll = 0 AND @end <> '' AND @state <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND (BEGIN_DATE <= @end)
			AND @state = STATE_PROVINCE AND STATUS = 'A' AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())

		ORDER BY BEGIN_DATE;

	/* End AND title are provided */
	else if(@showAll = 0 AND @end <> '' AND @title <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND (BEGIN_DATE <= @end) AND STATUS = 'A'
			AND UPPER(TITLE) LIKE '%' + @title + '%'  AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* End AND city are provided */
	else if(@showAll = 0 AND @end <> '' AND @city <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND (BEGIN_DATE <= @end)
			AND CITY LIKE '%' + @city + '%' AND STATUS = 'A' AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* State AND title are provided */
	else if(@showAll = 0 AND @state <> '' AND @title <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND @state = STATE_PROVINCE AND UPPER(TITLE) LIKE '%' + @title + '%' AND STATUS = 'A' AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	
	/* State AND city are provided */
	else if(@showAll = 0 AND @state <> '' AND @city <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND @state = STATE_PROVINCE AND CITY LIKE '%' + @city + '%' AND STATUS = 'A' AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;	

	/*Title AND city are provided */
	else if(@showAll = 0 AND @title <> '' AND @city <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND UPPER(TITLE) LIKE '%' + @title + '%' AND CITY LIKE '%' + @city + '%' AND STATUS = 'A' AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	/* Start only */
	else if(@showAll = 0 AND @start <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND (BEGIN_DATE >= @start) AND STATUS = 'A'
			 AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	
	/* End only */
	else if(@showAll = 0 AND @end <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND(BEGIN_DATE <= @end ) AND STATUS = 'A'
			 AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;
	
	/* State only */
	else if(@showAll = 0 AND @state <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND @state = STATE_PROVINCE AND STATUS = 'A'  AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

	
	/* Title only */
	else if(@showAll = 0 AND @title <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND UPPER(TITLE) like '%'+@title+'%' AND STATUS='A'  AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;
	
	/* City only */
	else if(@showAll = 0 AND @city <> '')
		SELECT *
		FROM Meet_Master
		WHERE  WEB_ENABLED = '1' AND CITY LIKE '%' + @city + '%' AND STATUS = 'A'  AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
		ORDER BY BEGIN_DATE;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupAddFunctionGroup]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupAddFunctionGroup]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventSetupAddFunctionGroup] @eventCode varchar(15),
 	@functionCode varchar(15),
 	@groupName varchar(25),
 	@functionorder int as
SELECT * FROM EventSetupFunctionGroup 
	WHERE EventCode = @eventCode AND FunctionCode = @functionCode;
	IF (@@RowCount > 0)
		BEGIN
			UPDATE EventSetupFunctionGroup
			SET GroupName = @groupName, FunctionOrder = @functionorder
			WHERE EventCode = @eventCode AND FunctionCode = @functionCode;
		END
	ELSE
		BEGIN
			INSERT INTO EventSetupFunctionGroup(EventCode, FunctionCode, GroupName, FunctionOrder) 
				VALUES(@eventCode, @functionCode, @groupName, @functionorder)
		END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupAddGeneralInfo]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupAddGeneralInfo]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure [dbo].[BAEEventSetupAddGeneralInfo] @eventCode varchar(15),
     @cutOffDate datetime,
     @cutoffMessage varchar(256),
     @registrantClass varchar(24),
     @storedProc varchar(64),
     @RegisterSomeoneElse bit,
     @permanentChange bit as
SELECT * FROM EventSetupGeneral where EventCode = @eventCode;
      IF(@@RowCount > 0)
            BEGIN
                  UPDATE EventSetupGeneral 
                        SET OnlineCutOffDate = @cutOffDate, OnlineCutOffMessage = @cutoffMessage, RegistrantClassType = @registrantClass,
                              RegistrantClassStoredProcedure = @storedProc, RegisterSomeoneElseOption = @RegisterSomeoneElse, PermanentChange = @permanentChange      
                  WHERE EventCode = @eventCode;
            END
      ELSE
            BEGIN
                  IF(@storedProc = '')
                        BEGIN
                              INSERT INTO EventSetupGeneral(EventCode, OnlineCutOffDate, OnlineCutOffMessage, RegistrantClassType,
                                    RegistrantClassStoredProcedure, RegisterSomeoneElseOption, PermanentChange)
                              VALUES(@eventCode, @cutOffDate, @cutoffMessage, @registrantClass, NULL, @RegisterSomeoneElse, @permanentChange);
                        END
                  ELSE
                        BEGIN
                              INSERT INTO EventSetupGeneral(EventCode, OnlineCutOffDate, OnlineCutOffMessage, RegistrantClassType,
                                    RegistrantClassStoredProcedure, RegisterSomeoneElseOption, PermanentChange)
                              VALUES(@eventCode, @cutOffDate, @cutoffMessage, @registrantClass,@storedProc, @RegisterSomeoneElse, @permanentChange);
                        END
            END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupAddGroup]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupAddGroup]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventSetupAddGroup] @eventCode varchar(15),
 	@groupName varchar(10),
 	@groupLabel varchar(255) ,
 	@grouporder int,
 	@groupText varchar(255) as
SELECT * FROM EventSetupGroup
	WHERE EventCode = @eventCode AND GroupName = @groupName
	IF(@@RowCount > 0)
		BEGIN
			UPDATE EventSetupGroup 
				SET GroupLabel = @groupLabel, GroupOrder = @grouporder, GroupPageMessage = @groupText
			WHERE EventCode = @eventCode AND GroupName = @groupName
		END
	ELSE
		BEGIN
			INSERT INTO EventSetupGroup(EventCode, GroupName, GroupLabel, GroupOrder, GroupPageMessage)
			 VALUES (@eventCode, @groupName, @groupLabel, @grouporder, @groupText)
		END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupAddGuest]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupAddGuest]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure [dbo].[BAEEventSetupAddGuest] @EventCode varchar(15),
      @pageMessage varchar(255),
      @FirstName varchar(25) ,
      @FirstNameEnabled bit ,
      @FirstNameRequired bit ,
      @MiddleInitial varchar(25) ,
      @MiddleInitialEnabled bit ,
      @MiddleInitialRequired bit ,
      @LastName varchar(25) ,
      @LastNameEnabled bit ,
      @LastNameRequired bit ,
      @Address varchar(25) ,
      @AddressEnabled bit ,
      @AddressRequired bit ,
      @City varchar(25) ,
      @CityEnabled bit ,
      @CityRequired bit ,
      @State varchar(25) ,
      @StateEnabled bit ,
      @StateRequired bit,
      @PostalCode varchar(25),
      @PostalCodeEnabled bit,
      @PostalCodeRequired bit,
      @Country varchar(25),
      @CountryEnabled bit,
      @CountryRequired bit, 
      @Prefix varchar(25),
      @PrefixEnabled bit,
      @PrefixRequired bit, 
      @Suffix varchar(25),
      @SuffixEnabled bit,
      @SuffixRequired bit,
      @Nickname varchar(25),
      @NicknameEnabled bit,
      @NicknameRequired bit,      
	  @Designation varchar(25),
      @DesignationEnabled bit,
      @DesignationRequired bit,	  
	  @Title varchar(25),
      @TitleEnabled bit,
      @TitleRequired bit,  
	  @Company varchar(25),
      @CompanyEnabled bit,
      @CompanyRequired bit as

SELECT * FROM EventSetupGuest 
      WHERE EventCode = @EventCode;

      IF(@@RowCount > 0)
            BEGIN
                  UPDATE EventSetupGuest
                        SET GuestPageMessage = @pageMessage, FirstName = @FirstName, FirstNameEnabled = @FirstNameEnabled, FirstNameRequired = @FirstNameRequired, MiddleInitial = @MiddleInitial, MiddleInitialEnabled = @MiddleInitialEnabled, MiddleInitialRequired = @MiddleInitialRequired, LastName = @LastName, LastNameEnabled = @LastNameEnabled, LastNameRequired = @LastNameRequired, Address = @Address, AddressEnabled = @AddressEnabled, AddressRequired = @AddressRequired, City = @City, CityEnabled = @CityEnabled, CityRequired = @CityRequired, StateProvince = @State, StateEnabled = @StateEnabled, StateRequired = @StateRequired, PostalCode =@PostalCode, PostalCodeEnabled = @PostalCodeEnabled, @PostalCodeRequired = PostalCodeRequired, Country = @Country, CountryEnabled = @CountryEnabled, CountryRequired = @CountryRequired, Prefix = @Prefix, PrefixEnabled = @PrefixEnabled, PrefixRequired = @PrefixRequired, Suffix = @Suffix, SuffixEnabled = @SuffixEnabled, SuffixRequired = @SuffixRequired, Nickname = @Nickname, NicknameEnabled = @NicknameEnabled, NicknameRequired = @NicknameRequired, Designation = @Designation, DesignationEnabled = @DesignationEnabled, DesignationRequired = @DesignationRequired, Title = @Title, TitleEnabled = @TitleEnabled, TitleRequired = @TitleRequired, Company = @Company, CompanyEnabled = @CompanyEnabled, CompanyRequired = @CompanyRequired
                  WHERE EventCode = @EventCode;
            END
      ELSE
            BEGIN
                  INSERT INTO EventSetupGuest
                        VALUES(@EventCode, @pageMessage, @FirstName, @FirstNameEnabled, @FirstNameRequired, @MiddleInitial,@MiddleInitialEnabled, @MiddleInitialRequired, @LastName, @LastNameEnabled, @LastNameRequired, @Address, @AddressEnabled, @AddressRequired, @City, @CityEnabled, @CityRequired, @State, @StateEnabled, @StateRequired, @PostalCode, @PostalCodeEnabled , @PostalCodeRequired, @Country, @CountryEnabled, @CountryRequired, @Prefix, @PrefixEnabled, @PrefixRequired, @Suffix, @SuffixEnabled, @SuffixRequired, @Nickname, @NicknameEnabled, @NicknameRequired, @Designation, @DesignationEnabled, @DesignationRequired,	@Title, @TitleEnabled, @TitleRequired, @Company, @CompanyEnabled, @CompanyRequired)
            END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupAddLabel]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupAddLabel]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventSetupAddLabel] @eventCode varchar(255),
 	@start varchar(255),
 	@registrant varchar(255),
 	@functions varchar(255),
 	@guest varchar(255),
 	@question varchar(255),
 	@summary varchar(255),
 	@questionPageMessage varchar(255) as
SELECT * FROM EventSetupLabel
	WHERE EventCode = @eventCode;
	IF(@@RowCount > 0)
		BEGIN
			UPDATE EventSetupLabel
			SET StartRegistrationLabel = @start, RegistrantLabel = @registrant, FunctionsLabel = @functions, GuestLabel = @guest, QuestionLabel = @question,
			SummaryLabel = @summary, QuestionPageMessage = @questionPageMessage
			WHERE EventCode = @eventCode;
		END
	ELSE
		BEGIN
			INSERT INTO EventSetupLabel(EventCode, StartRegistrationLabel, RegistrantLabel, FunctionsLabel, GuestLabel, QuestionLabel, SummaryLabel, QuestionPageMessage)
			VALUES(@eventCode, @start, @registrant, @functions, @guest, @question,  @summary, @questionPageMessage)
		END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupAddQuestion]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupAddQuestion]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventSetupAddQuestion] @eventCode varchar(15),
 	@functionCode varchar(15),
 	@question varchar(255),
 	@questionType varchar(30),
 	@required bit,
 	@questionorder int as
INSERT INTO EventSetupQuestion(EventCode, FunctionCode, Question,  QuestionType, Required,  QuestionOrder)
	VALUES(@eventCode, @functionCode, @question,  @questionType, @required, @questionorder);

	SELECT CAST(@@IDENTITY AS INT);

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupRemoveQuestionChoice]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupRemoveQuestionChoice]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventSetupRemoveQuestionChoice] @questionID int,
 	@choiceID varchar(16) as
DELETE FROM EventSetupQuestionChoice WHERE EventSetupQuestionID = @questionID
	AND EventSetupQuestionChoiceID = @choiceID;

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupAddQuestionChoice]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupAddQuestionChoice]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventSetupAddQuestionChoice] @id int,
 	@answerID varchar(8),
 	@answer varchar(64) as
EXEC BAEEventSetupRemoveQuestionChoice @id, @answerID;

	INSERT INTO EventSetupQuestionChoice (EventSetupQuestionChoiceID, EventSetupQuestionID, Answer)
	VALUES (@answerID, @id, @answer);

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupAddRegistrant]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupAddRegistrant]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure [dbo].[BAEEventSetupAddRegistrant] @EventCode varchar(15),
      @pageMessage varchar(255),
      @FirstName varchar(25) ,
      @FirstNameEnabled bit ,
      @FirstNameRequired bit ,
      @MiddleInitial varchar(25) ,
      @MiddleInitialEnabled bit ,
      @MiddleInitialRequired bit ,
      @LastName varchar(25) ,
      @LastNameEnabled bit ,
      @LastNameRequired bit ,
      @Address varchar(25) ,
      @AddressEnabled bit ,
      @AddressRequired bit ,
      @City varchar(25) ,
      @CityEnabled bit ,
      @CityRequired bit ,
      @State varchar(25) ,
      @StateEnabled bit ,
      @StateRequired bit,
      @PostalCode varchar(25),
      @PostalCodeEnabled bit,
      @PostalCodeRequired bit,
      @Phone varchar(25) ,
      @PhoneEnabled bit ,
      @PhoneRequired bit,
      @Email varchar(25),
      @EmailEnabled bit,
      @EmailRequired bit,
      @Country varchar(25),
      @CountryEnabled bit,
      @CountryRequired bit as

SELECT * FROM EventSetupRegistrant 
      WHERE EventCode = @EventCode;
      IF(@@RowCount > 0)
            BEGIN
                  UPDATE EventSetupRegistrant
                        SET RegistrantPageMessage = @pageMessage, FirstName = @FirstName, FirstNameEnabled = @FirstNameEnabled, FirstNameRequired = @FirstNameRequired, MiddleInitial = @MiddleInitial, MiddleInitialEnabled = @MiddleInitialEnabled, MiddleInitialRequired = @MiddleInitialRequired, LastName = @LastName, LastNameEnabled = @LastNameEnabled, LastNameRequired = @LastNameRequired, Address = @Address, AddressEnabled = @AddressEnabled, AddressRequired = @AddressRequired, City = @City, CityEnabled = @CityEnabled, CityRequired = @CityRequired, StateProvince = @State, StateEnabled = @StateEnabled, StateRequired = @StateRequired, PostalCode =@PostalCode,  PostalCodeEnabled = @PostalCodeEnabled, PostalCodeRequired = @PostalCodeRequired, Phone = @Phone, PhoneEnabled = @PhoneEnabled, PhoneRequired = @PhoneRequired, Email = @Email, EmailEnabled = @EmailEnabled, EmailRequired = @EmailRequired, Country = @Country, CountryEnabled = @CountryEnabled, CountryRequired = @CountryRequired
                  WHERE EventCode = @EventCode;
            END
      ELSE
            BEGIN
                  INSERT INTO EventSetupRegistrant 
                  VALUES(@EventCode,@pageMessage, @FirstName, @FirstNameEnabled, @FirstNameRequired, @MiddleInitial, @MiddleInitialEnabled,@MiddleInitialRequired, @LastName, @LastNameEnabled, @LastNameRequired, @Address, @AddressEnabled,@AddressRequired, @City, @CityEnabled, @CityRequired, @State, @StateEnabled, @StateRequired, @PostalCode,@PostalCodeEnabled , @PostalCodeRequired, @Phone, @PhoneEnabled, @PhoneRequired, @Email, @EmailEnabled,    @EmailRequired, @Country, @CountryEnabled, @CountryRequired);
      END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupCheckMemberStatus]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupCheckMemberStatus]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventSetupCheckMemberStatus] @memberType varchar(5) as
SELECT mrc.REGISTRANT_CLASS, mrc.DESCRIPTION
	FROM Meet_Reg_Class mrc
	WHERE mrc.REGISTRANT_CLASS = @memberType;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupCheckMemberType]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupCheckMemberType]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventSetupCheckMemberType] as
SELECT MEMBER_TYPE, DESCRIPTION
	FROM Member_Types
	WHERE MEMBER_TYPE NOT IN (SELECT mrc.REGISTRANT_CLASS FROM Meet_Reg_Class mrc);

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupCheckRegistrantClasses]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupCheckRegistrantClasses]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventSetupCheckRegistrantClasses] as
SELECT mrc.REGISTRANT_CLASS, mrc.DESCRIPTION
	FROM Meet_Reg_Class mrc
	WHERE mrc.REGISTRANT_CLASS NOT IN (SELECT MEMBER_TYPE FROM Member_Types);

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupClone]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupClone]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure [dbo].[BAEEventSetupClone] @newEventCode as varchar(15),@oldEventCode as varchar(15) AS

BEGIN
      -- SET NOCOUNT ON added to prevent extra result sets from
      -- interfering with SELECT statements.
      SET NOCOUNT ON;

    -- Insert statements for procedure here
      Select * from EventSetupGeneral where UPPER(EventCode) = Upper(@newEventCode);

      If(@@rowcount = 0)
            BEGIN             
                  BEGIN TRANSACTION
                        Insert into EventSetupGeneral Select @newEventCode, OnlineCutOffDate, OnlineCutOffMessage, RegistrantClassType, RegistrantClassStoredProcedure, RegisterSomeoneElseOption, PermanentChange from EventSetupGeneral where Upper(EventCode) = Upper(@oldEventCode);

                        Insert into EventSetupLabel Select @newEventCode, StartRegistrationLabel, RegistrantLabel, FunctionsLabel, GuestLabel, QuestionLabel, SummaryLabel, QuestionPageMessage from EventSetupLabel where Upper(EventCode) = Upper(@oldEventCode);

                        Insert into EventSetupGuest Select @newEventCode, GuestPageMessage, FirstName, FirstNameEnabled, FirstNameRequired, MiddleInitial, MiddleInitialEnabled, MiddleInitialRequired, LastName, LastNameEnabled, LastNameRequired, Address, AddressEnabled, AddressRequired, City, CityEnabled, CityRequired, StateProvince, StateEnabled, StateRequired, PostalCode, PostalCodeEnabled, PostalCodeRequired, Country, CountryEnabled, CountryRequired, Prefix, PrefixEnabled, PrefixRequired, Suffix, SuffixEnabled, SuffixRequired, Nickname, NicknameEnabled, NicknameRequired, Designation, DesignationEnabled, DesignationRequired, Title, TitleEnabled, TitleRequired, Company, CompanyEnabled, CompanyRequired  from EventSetupGuest where Upper(EventCode) = Upper(@oldEventCode);

                        Insert into EventSetupRegistrant Select @newEventCode, RegistrantPageMessage, FirstName, FirstNameEnabled, FirstNameRequired, MiddleInitial, MiddleInitialEnabled, MiddleInitialRequired, LastName, LastNameEnabled, LastNameRequired, Address, AddressEnabled, AddressRequired, City, CityEnabled, CityRequired, StateProvince, StateEnabled, StateRequired, PostalCode, PostalCodeEnabled, PostalCodeRequired, Phone, PhoneEnabled, PhoneRequired, Email, EmailEnabled, EmailRequired, Country, CountryEnabled, CountryRequired from EventSetupRegistrant where Upper(EventCode) = Upper(@oldEventCode);

                        Insert into EventSetupGroup Select @newEventCode, GroupName, GroupLabel, GroupOrder, GroupPageMessage from EventSetupGroup where Upper(EventCode) = Upper(@oldEventCode);

                        Insert into EventSetupFunctionGroup Select @newEventCode, FunctionCode, GroupName, FunctionOrder from EventSetupFunctionGroup where Upper(EventCode) = Upper(@oldEventCode);

                        Insert into EventSetupQuestion Select @newEventCode, FunctionCode, Question, QuestionType, Required, QuestionOrder from EventSetupQuestion where Upper(EventCode) = Upper(@oldEventCode);

                        Insert into EventSetupQuestionChoice 
							Select EventSetupQuestionChoiceID, new.EventSetupQuestionID, Answer 
							from EventSetupQuestionChoice a, EventSetupQuestion new, EventSetupQuestion old
							where a.EventSetupQuestionID = old.EventSetupQuestionID and Upper(new.EventCode) = Upper(@newEventCode) 
							and Upper(old.EventCode) = Upper(@oldEventCode) and new.FunctionCode = old.FunctionCode 
							and new.QuestionOrder = old.QuestionOrder;
                  COMMIT
            END
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupCloneAlt]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupCloneAlt]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure [dbo].[BAEEventSetupCloneAlt] @newEventCode as varchar(30),@oldEventCode as varchar(30),@newCutOffDate as datetime AS
BEGIN
      -- SET NOCOUNT ON added to prevent extra result sets from
      -- interfering with SELECT statements.
      SET NOCOUNT ON;

    -- Insert statements for procedure here
      Select * from EventSetupGeneral where UPPER(EventCode) = Upper(@newEventCode);

      If(@@rowcount = 0)
            BEGIN             
                  BEGIN TRANSACTION

                        Insert into EventSetupGeneral Select @newEventCode, @newCutOffDate, OnlineCutOffMessage, RegistrantClassType, RegistrantClassStoredProcedure, RegisterSomeoneElseOption, PermanentChange from EventSetupGeneral where Upper(EventCode) = Upper(@oldEventCode);

                        Insert into EventSetupLabel Select @newEventCode, StartRegistrationLabel, RegistrantLabel, FunctionsLabel, GuestLabel, QuestionLabel, SummaryLabel, QuestionPageMessage from EventSetupLabel where Upper(EventCode) = Upper(@oldEventCode);

                        Insert into EventSetupGuest Select @newEventCode, GuestPageMessage, FirstName, FirstNameEnabled, FirstNameRequired, MiddleInitial, MiddleInitialEnabled, MiddleInitialRequired, LastName, LastNameEnabled, LastNameRequired, Address, AddressEnabled, AddressRequired, City, CityEnabled, CityRequired, StateProvince, StateEnabled, StateRequired, PostalCode, PostalCodeEnabled, PostalCodeRequired, Country, CountryEnabled, CountryRequired, Prefix, PrefixEnabled, PrefixRequired, Suffix, SuffixEnabled, SuffixRequired, Nickname, NicknameEnabled, NicknameRequired, Designation, DesignationEnabled, DesignationRequired, Title, TitleEnabled, TitleRequired, Company, CompanyEnabled, CompanyRequired from EventSetupGuest where Upper(EventCode) = Upper(@oldEventCode);

                        Insert into EventSetupRegistrant Select @newEventCode, RegistrantPageMessage, FirstName, FirstNameEnabled, FirstNameRequired, MiddleInitial, MiddleInitialEnabled, MiddleInitialRequired, LastName, LastNameEnabled, LastNameRequired, Address, AddressEnabled, AddressRequired, City, CityEnabled, CityRequired, StateProvince, StateEnabled, StateRequired, PostalCode, PostalCodeEnabled, PostalCodeRequired, Phone, PhoneEnabled, PhoneRequired, Email, EmailEnabled, EmailRequired, Country, CountryEnabled, CountryRequired from EventSetupRegistrant where Upper(EventCode) = Upper(@oldEventCode);

                        Insert into EventSetupGroup Select @newEventCode, GroupName, GroupLabel, GroupOrder, GroupPageMessage from EventSetupGroup where Upper(EventCode) = Upper(@oldEventCode);

                        Insert into EventSetupFunctionGroup Select @newEventCode, FunctionCode, GroupName, FunctionOrder from EventSetupFunctionGroup where Upper(EventCode) = Upper(@oldEventCode);

                        Insert into EventSetupQuestion Select @newEventCode, FunctionCode, Question, QuestionType, Required, QuestionOrder from EventSetupQuestion where Upper(EventCode) = Upper(@oldEventCode);

                        Insert into EventSetupQuestionChoice 
                                          Select EventSetupQuestionChoiceID, new.EventSetupQuestionID, Answer 
                                          from EventSetupQuestionChoice a, EventSetupQuestion new, EventSetupQuestion old
                                          where a.EventSetupQuestionID = old.EventSetupQuestionID and Upper(new.EventCode) = Upper(@newEventCode) 
                                                and Upper(old.EventCode) = Upper(@oldEventCode) and new.FunctionCode = old.FunctionCode 
                                                and new.QuestionOrder = old.QuestionOrder;
                  COMMIT
            END
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventSetupGetAll] AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	SELECT * From EventSetupGeneral;
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupGetAvailFunctions]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupGetAvailFunctions]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[BAEEventSetupGetAvailFunctions] @eventCode varchar(15) 
AS
SELECT p.[PRODUCT_CODE], p.[PRODUCT_MAJOR], p.[PRODUCT_MINOR], p.[PROD_TYPE], p.[CATEGORY], p.[TITLE_KEY], p.[TITLE], 
       p.[DESCRIPTION], p.[STATUS], p.[NOTE], p.[GROUP_1], p.[GROUP_2], p.[GROUP_3], p.[PRICE_RULES_EXIST], p.[LOT_SERIAL_EXIST], 
       p.[PAYMENT_PRIORITY], p.[RENEW_MONTHS], p.[PRORATE], p.[STOCK_ITEM], p.[UNIT_OF_MEASURE], p.[WEIGHT], p.[TAXABLE], 
       p.[COMMISIONABLE], p.[COMMISION_PERCENT], p.[DECIMAL_POINTS], p.[INCOME_ACCOUNT], p.[DEFERRED_INCOME_ACCOUNT], 
       p.[INVENTORY_ACCOUNT], p.[ADJUSTMENT_ACCOUNT], p.[COG_ACCOUNT], p.[INTENT_TO_EDIT], p.[PRICE_1], p.[PRICE_2], p.[PRICE_3], 
       p.[COMPLIMENTARY], p.[ATTRIBUTES], p.[PST_TAXABLE], p.[TAXABLE_VALUE], p.[ORG_CODE], p.[TAX_AUTHORITY], p.[WEB_OPTION], 
       p.[IMAGE_URL], p.[APPLY_IMAGE], p.[IS_KIT], p.[INFO_URL], p.[APPLY_INFO], p.[PLP_CODE], p.[PROMOTE], p.[THUMBNAIL_URL], 
       p.[APPLY_THUMBNAIL], p.[CATALOG_DESC], p.[WEB_DESC], p.[OTHER_DESC], p.[LOCATION], p.[PREMIUM], p.[FAIR_MARKET_VALUE], 
       p.[IS_FR_ITEM], p.[APPEAL_CODE], p.[CAMPAIGN_CODE], p.[TIME_STAMP], p.[ProductKey], 
       pf.[PRODUCT_CODE], pf.[FUNCTION_TYPE], pf.[BEGIN_DATE_TIME], pf.[END_DATE_TIME], pf.[SEQ], 
       pf.[MINIMUM_ATTENDANCE], pf.[EXPECTED_ATTENDANCE], pf.[GUARANTEED_ATTENDANCE], pf.[ACTUAL_ATTENDANCE], pf.[SETTINGS], 
       pf.[SETUP_DATE_TIME], pf.[POST_DATE_TIME], pf.[AUTO_ENROLL], pf.[PRINT_TICKET], pf.[LAST_TICKET], pf.[CEU_TYPE], 
       pf.[CEU_AMOUNT], pf.[COURSE_CODE], pf.[OTHER_TICKETS], pf.[CEU_ENTERED], pf.[MAXIMUM_ATTENDANCE], pf.[PARENT], 
       pf.[CONFLICT_CODE], pf.[WEB_ENABLED], pf.[WEB_MULTI_REG], pf.[SQUARE_FEET], pf.[IS_FR_ITEM], pf.[IS_GUEST_FUNCTION], 
       pf.[CREATE_DETAIL_ACTIVITY], pf.[TIME_STAMP]
  FROM [dbo].[Product] p 
       INNER JOIN [dbo].[Product_Function] pf ON p.PRODUCT_CODE COLLATE database_default = pf.PRODUCT_CODE COLLATE database_default
--    WHERE p.PRODUCT_CODE LIKE @eventCode + '%' AND LEN(p.PRODUCT_MINOR) > 1
-- DT:19473 Use PRODUCT_MAJOR for this
WHERE p.PRODUCT_MAJOR = @eventCode AND LEN(p.PRODUCT_MINOR) > 1
-- END DT:19473
      AND (pf.IS_GUEST_FUNCTION IS NULL OR pf.IS_GUEST_FUNCTION = 0)
      AND p.PRODUCT_MINOR COLLATE database_default NOT IN ( SELECT [FunctionCode] COLLATE database_default
                                                              FROM [dbo].[EventSetupFunctionGroup] 
                                                             WHERE EventCode = @eventCode )
      AND pf.WEB_ENABLED = '1'
ORDER BY TITLE_KEY

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupGetChosenFunctions]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupGetChosenFunctions]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventSetupGetChosenFunctions] @groupName varchar(40),
 	@eventCode varchar(15) as
IF(@groupName <> '')
		BEGIN
			SELECT p.* FROM EventSetupFunctionGroup, Product p
			WHERE FunctionCode COLLATE database_default = p.PRODUCT_MINOR COLLATE database_default
				AND GroupName = @groupName
				 AND EventCode = @eventCode
				AND EventCode COLLATE database_default = p.PRODUCT_MAJOR COLLATE database_default
			ORDER BY FunctionOrder
		END
	ELSE
		BEGIN
			SELECT p.* FROM EventSetupFunctionGroup, Product p
			WHERE FunctionCode COLLATE database_default = p.PRODUCT_MINOR COLLATE database_default
				AND EventCode = @eventCode
				AND EventCode COLLATE database_default = p.PRODUCT_MAJOR COLLATE database_default
			ORDER BY FunctionOrder
		END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupGetFunction]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupGetFunction]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventSetupGetFunction] @eventCode varchar(15),
 	@functionCode varchar(25) as
SELECT * FROM EventSetupFunctionGroup
	WHERE EventCode = @eventCode AND FunctionCode = @functionCode

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupGetFunctionQuestions]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupGetFunctionQuestions]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventSetupGetFunctionQuestions] @eventCode varchar(16),
 	@functionCode varchar(16) as
SELECT *, UPPER(FunctionCode) + '      ' + Question EventQuestion  FROM EventSetupQuestion
	WHERE UPPER(EventCode) = UPPER(@eventCode) AND UPPER(FunctionCode) = UPPER(@functionCode)
	ORDER BY QuestionOrder

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupGetFunctionsByGroupName]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupGetFunctionsByGroupName]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure [dbo].[BAEEventSetupGetFunctionsByGroupName] @eventCode varchar(15),
 	@groupName varchar(25) as
SELECT * FROM EventSetupFunctionGroup
	INNER JOIN Product_Function on PRODUCT_CODE COLLATE database_default = EventCode + '/' + FunctionCode COLLATE database_default
	WHERE EventCode = @eventCode AND GroupName = @groupName AND WEB_ENABLED = 1 AND IS_GUEST_FUNCTION = 0
	ORDER BY FunctionOrder

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupGetGeneralInfo]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupGetGeneralInfo]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventSetupGetGeneralInfo] @eventCode varchar(15) as
SELECT * FROM EventSetupGeneral
	WHERE EventCode = @eventCode;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupGetGroup]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupGetGroup]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventSetupGetGroup] @eventCode varchar(15),
 	@groupName varchar(10) as
SELECT * FROM EventSetupGroup
	WHERE EventCode = @eventCode AND GroupName = @groupName

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupGetGroups]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupGetGroups]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventSetupGetGroups] @eventCode varchar(15) as
SELECT * FROM EventSetupGroup
	WHERE EventCode = @eventCode 
	ORDER BY GroupOrder

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupGetGuest]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupGetGuest]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventSetupGetGuest] @EventCode varchar(15) as
SELECT * FROM EventSetupGuest
	WHERE EventCode = @EventCode

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupGetLabel]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupGetLabel]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventSetupGetLabel] @eventCode varchar(25) as
SELECT * FROM EventSetupLabel
	WHERE EventCode = @eventCode

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupGetQuestion]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupGetQuestion]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventSetupGetQuestion] @id int as
SELECT * FROM EventSetupQuestion
	WHERE EventSetupQuestionID = @id;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupGetQuestionChoice]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupGetQuestionChoice]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventSetupGetQuestionChoice] @QuestionID int,
 	@AnswerID varchar(8) as
SELECT Answer
	FROM EventSetupQuestionChoice
	WHERE EventSetupQuestionChoiceID = @AnswerID AND EventSetupQuestionID = @QuestionID

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupGetQuestionChoices]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupGetQuestionChoices]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventSetupGetQuestionChoices] @QuestionID int as
SELECT *
	FROM EventSetupQuestionChoice
	WHERE EventSetupQuestionID = @QuestionID

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupGetQuestions]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupGetQuestions]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventSetupGetQuestions] @eventCode varchar(16) as
SELECT *, 
		 UPPER(FunctionCode) + '      ' + Question EventQuestion 
	FROM EventSetupQuestion
	WHERE EventCode = @eventCode
	ORDER BY QuestionOrder

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupGetRegistrant]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupGetRegistrant]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventSetupGetRegistrant] @EventCode varchar(15) as
SELECT * FROM EventSetupRegistrant
	WHERE EventCode = @EventCode

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupMoveFunctionDown]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupMoveFunctionDown]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventSetupMoveFunctionDown] @eventCode varchar(16),
 	@functionCode varchar(16),
 	@groupName varchar(8) as
DECLARE @fO AS int;
	Declare @functionOrder AS int;

	SELECT @fO = MAX(FunctionOrder) FROM EventSetupFunctionGroup WHERE EventCode = @eventCode AND GroupName = @groupName;

	SELECT @functionOrder = FunctionOrder FROM EventSetupFunctionGroup WHERE EventCode = @eventCode AND GroupName = @groupName AND FunctionCode = @functionCode;
	
	IF (@functionOrder <@fO)
	BEGIN
		/* Move Function up */
		UPDATE EventSetupFunctionGroup
		SET FunctionOrder = FunctionOrder - 1
		WHERE EventCode = @eventCode AND GroupName = @groupName AND FunctionOrder = @functionOrder + 1;
	
		/* Move function Down */
		UPDATE EventSetupFunctionGroup
		SET FunctionOrder = FunctionOrder + 1
		WHERE EventCode = @eventCode AND FunctionCode = @functionCode;
	END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupMoveFunctionUp]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupMoveFunctionUp]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventSetupMoveFunctionUp] @eventCode varchar(16),
 	@functionCode varchar(16),
 	@groupName varchar(8) as
Declare @functionorder AS int;

	SELECT @functionorder =  FunctionOrder FROM EventSetupFunctionGroup WHERE EventCode = @eventCode AND GroupName = @groupName AND FunctionCode = @functionCode;
	
	if(@functionorder > 1)
	BEGIN
		/* Move Function Down */
		UPDATE EventSetupFunctionGroup
		SET FunctionOrder = FunctionOrder + 1
		WHERE EventCode = @eventCode  AND GroupName = @groupName AND FunctionOrder = @functionorder - 1;
		
		/* Move Function Up */
		UPDATE EventSetupFunctionGroup
		SET FunctionOrder = FunctionOrder - 1
		WHERE EventCode = @eventCode  AND FunctionCode = @functionCode
	END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupMoveQuestionDown]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupMoveQuestionDown]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventSetupMoveQuestionDown] @id int,
 	@eventCode varchar(15) as
DECLARE @qO AS int;
 	DECLARE @questionorder AS int;

	SELECT @qO = MAX(QuestionOrder) FROM EventSetupQuestion WHERE EventCode = @eventCode;

	SELECT @questionorder = QuestionOrder FROM EventSetupQuestion WHERE EventSetupQuestionID = @id;

	IF (@questionorder <@qO)
	BEGIN
		/* Move Question Up */
		UPDATE EventSetupQuestion
		SET QuestionOrder = QuestionOrder - 1
		WHERE EventCode = @eventCode AND QuestionOrder = @questionorder + 1;
	
		/* Move Question Down */
		UPDATE EventSetupQuestion
		SET QuestionOrder = QuestionOrder + 1
		WHERE EventSetupQuestionID = @id;
	END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupMoveQuestionUp]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupMoveQuestionUp]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventSetupMoveQuestionUp] @id int,
 	@eventCode varchar(15) as
DECLARE @questionorder AS int;

	SELECT @questionorder =  QuestionOrder FROM EventSetupQuestion WHERE EventSetupQuestionID = @id;

	if(@questionorder > 1)
	BEGIN
		/* Move Question Down */
		UPDATE EventSetupQuestion
		SET QuestionOrder = QuestionOrder + 1
		WHERE EventCode = @eventCode AND QuestionOrder = @questionorder - 1;
		/* Move Question Up */
		UPDATE EventSetupQuestion
		SET QuestionOrder = QuestionOrder - 1
		WHERE EventSetupQuestionID = @id;
	END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupRemoveFunctionGroup]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupRemoveFunctionGroup]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventSetupRemoveFunctionGroup] @functionCode varchar(16),
 	@eventCode varchar(16),
 	@groupName varchar(8) as
DECLARE @thisFunctionorder AS INT
	
	/* Get function order before delete */
	SELECT @thisFunctionorder = FunctionOrder 
	FROM EventSetupFunctionGroup 
	WHERE FunctionCode = @functionCode AND EventCode = @eventCode; 

	/*Update Function order */
	Update EventSetupFunctionGroup
	SET FunctionOrder = FunctionOrder - 1
	WHERE EventCode = @eventCode AND GroupName = @groupName AND FunctionOrder > @thisFunctionorder;

	/* Delete Function */	
	DELETE FROM EventSetupFunctionGroup
	WHERE FunctionCode = @functionCode AND EventCode = @eventCode;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupRemoveGeneralInfo]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupRemoveGeneralInfo]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventSetupRemoveGeneralInfo] @eventCode varchar(16) as
DELETE FROM EventSetupGeneral WHERE EventCode = @eventCode;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupRemoveGroup]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupRemoveGroup]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventSetupRemoveGroup] @eventCode varchar(15),
 	@groupName varchar(15) as
DELETE FROM EventSetupFunctionGroup
	WHERE EventCode = @eventCode AND GroupName = @groupName;
	DELETE FROM EventSetupGroup
	WHERE EventCode = @eventCode AND GroupName = @groupName;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupRemoveGuest]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupRemoveGuest]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventSetupRemoveGuest] @EventCode varchar(15) as
DELETE FROM EventSetupGuest
	WHERE EventCode = @EventCode

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupRemoveLabel]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupRemoveLabel]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventSetupRemoveLabel] @eventCode varchar(255) as
DELETE FROM EventSetupLabel
	WHERE EventCode = @eventCode;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupRemoveQuestion]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupRemoveQuestion]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventSetupRemoveQuestion] @id int,
 	@eventCode varchar(16) as
DECLARE @thisQuestionorder AS INT

	/* Get question order */		
	SELECT @thisQuestionorder = QuestionOrder
	FROM EventSetupQuestion
	WHERE EventSetupQuestionID=@id;

	/* Update other questions order */
	UPDATE EventSetupQuestion
	SET QuestionOrder = QuestionOrder - 1
	WHERE EventCode = @eventCode AND QuestionOrder > @thisQuestionorder;

	DELETE FROM EventSetupQuestionChoice WHERE EventSetupQuestionID = @id;
	DELETE FROM EventSetupQuestion WHERE EventSetupQuestionID = @id;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupRemoveRegistrant]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupRemoveRegistrant]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventSetupRemoveRegistrant] @EventCode varchar(15) as
DELETE FROM EventSetupRegistrant
	WHERE EventCode = @EventCode

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventSetupUpdateQuestion]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventSetupUpdateQuestion]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventSetupUpdateQuestion] @id int,
 	@eventCode varchar(15),
 	@functionCode varchar(15),
 	@question varchar(255),
 	@questionType varchar(30),
 	@required bit as
UPDATE EventSetupQuestion
	SET EventCode = @eventCode, FunctionCode = @functionCode, Question = @question, 
		QuestionType =  @questionType,  Required = @required
	WHERE EventSetupQuestionID = @id;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventValidateRegistrantFunctions]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventValidateRegistrantFunctions]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventValidateRegistrantFunctions] @RegistrationID varchar(50),
 	@EventCode varchar(50) as
DECLARE @Valid int, @ProductCode varchar(50), @FunctionCode varchar(30)
	SET @Valid = 0; -- 0 IS = to valid, 1 IS NOT valid

	SELECT @FunctionCode = FunctionCode
	FROM EventSetupFunctionGroup
	WHERE EventCode = @EventCode AND GroupName = 'G1'

	-- Double check to see if the user Selected at least one BAE auto enroll function
	IF @@ROWCOUNT > 0
	begin
		SELECT @FunctionCode = FunctionCode
		FROM EventSetupFunctionGroup
		WHERE EventCode = @EventCode AND GroupName = 'G1' AND FunctionCode COLLATE database_default IN(
			SELECT REPLACE(FunctionCode, @EventCode + '/','')
			FROM CartEventFunction
			WHERE CartEventID = (
				SELECT CartEventID
				FROM CartEvent
				WHERE EventCode = @EventCode AND RegistrantID = @RegistrationID
				)
			)

		IF @@ROWCOUNT = 0
			SET @Valid = 1
			
	end
	ELSE -- Double check to see if the user Selected the iMis auto enroll functions
	begin
		SELECT @ProductCode = PRODUCT_CODE FROM Product_Function
		WHERE AUTO_ENROLL = 1
			AND PRODUCT_CODE LIKE @EventCode + '%'
			AND PRODUCT_CODE COLLATE database_default IN(
				SELECT REPLACE(FunctionCode, @EventCode + '/','')
				FROM CartEventFunction
				WHERE CartEventID = (
					SELECT CartEventID
					FROM CartEvent
					WHERE EventCode = @EventCode AND RegistrantID = @RegistrationID
					)
			) --COLLATE database_default 

		IF @@ROWCOUNT > 0
			SET @Valid = 1
	end

	SELECT @Valid AS 'Validated'

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEEventValidateRegistrantQuestions]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEEventValidateRegistrantQuestions]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEEventValidateRegistrantQuestions] @RegistrationID varchar(50),
 	@EventCode varchar(50) as
DECLARE @Valid int, @QID int
	SET @Valid = 0;

	SELECT @QID = EventSetupQuestionID
	FROM EventSetupQuestion
	WHERE Required = 1 AND EventCode = @EventCode AND FunctionCode = 'General' AND EventSetupQuestionID NOT IN(
		SELECT QuestionID
		FROM EventRegistrationAnswer
		WHERE RegistrantID = @RegistrationID AND EventCode = @EventCode AND LEN(Answer) > 0)

	IF @@ROWCOUNT > 0
		SET @Valid = 1;

	SELECT @Valid AS 'Validated'

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEFieldDesignDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEFieldDesignDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEFieldDesignDelete] @TableName as
varchar(30),
		@FieldName AS varchar(30)
	AS
	DELETE
	FROM FieldDesign
	WHERE TableName = @TableName AND FieldName = @FieldName

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEFieldDesignGetAllByNoSection]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEFieldDesignGetAllByNoSection]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEFieldDesignGetAllByNoSection] as
SELECT *
FROM FieldDesign 
WHERE
FieldDesign.FieldName
NOT IN 
(SELECT FieldDesignSectionLookup.FieldName
FROM FieldDesignSectionLookup, FieldDesign
WHERE FieldDesignSectionLookup.TableName = FieldDesign.TableName)

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEFieldDesignGetAllBySectionName]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEFieldDesignGetAllBySectionName]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEFieldDesignGetAllBySectionName] @SectionName as
varchar(30)
	AS
	SELECT *
	FROM FieldDesign, FieldDesignSectionLookup, FieldSection
	WHERE FieldDesign.TableName = FieldDesignSectionLookup.TableName AND FieldDesign.FieldName = FieldDesignSectionLookup.FieldName AND FieldDesignSectionLookup.FieldSectionId = FieldSection.FieldSectionId AND FieldSection.SectionName = @SectionName
	ORDER BY FieldDesignSectionLookup.SortOrder asc

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEFieldDesignGetAllByTableName]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEFieldDesignGetAllByTableName]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEFieldDesignGetAllByTableName] @TableName as
varchar(30)
	AS
	SELECT * 
	FROM FieldDesign
	WHERE TableName = @TableName

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEFieldDesignLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEFieldDesignLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEFieldDesignLoad] @TableName as
varchar(30),
		@FieldName AS varchar(128)
	AS
	SELECT * 
	FROM FieldDesign
	WHERE TableName = @TableName AND FieldName = @FieldName

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEFieldDesignSectionLookupDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEFieldDesignSectionLookupDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEFieldDesignSectionLookupDelete] @TableName as
varchar(30),
	@FieldName AS varchar(30),
	@FieldSectionId AS int
AS
	DELETE
	FROM FieldDesignSectionLookup
	WHERE TableName = @TableName AND FieldName = @FieldName AND FieldSectionId = @FieldSectionId

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEFieldDesignSectionLookupGetAllByTable]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEFieldDesignSectionLookupGetAllByTable]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEFieldDesignSectionLookupGetAllByTable] @TableName as
varchar(30),
		@FieldName AS varchar(30)
	AS
	SELECT * 
	FROM FieldDesignSectionLookup
	WHERE TableName = @TableName AND FieldName = @FieldName

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEFieldDesignSectionLookupInsert]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEFieldDesignSectionLookupInsert]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEFieldDesignSectionLookupInsert] @TableName as
varchar(30),
	@FieldName AS varchar(30),
	@FieldSectionId AS int,
	@SortOrder AS int
AS
	INSERT INTO FieldDesignSectionLookup
	(
	TableName,
	FieldName,
	FieldSectionId,
	SortOrder
	)
	VALUES 
	(
	@TableName,
	@FieldName,
	@FieldSectionId,
	@SortOrder
	);

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEFieldDesignSectionLookupLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEFieldDesignSectionLookupLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEFieldDesignSectionLookupLoad] @TableName as
varchar(30),
		@FieldName AS varchar(30),
		@FieldSectionId AS Int
	AS
	SELECT * FROM FieldDesignSectionLookup WHERE TableName = @TableName AND FieldName = @FieldName AND FieldSectionId = @FieldSectionId
	/*SELECT fs.fieldsectionid, fdsl.TableName, fdsl.FieldName, fdsl.Sortorder FROM fieldsection fs
INNER JOIN FieldDesignSectionlookup fdsl on fs.fieldsectionid = fdsl.fieldsectionid
WHERE fdsl.tablename = @TableName AND fdsl.FieldName = @FieldName AND fs.sectionname = @SectionName
*/

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEFieldDesignSectionLookupUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEFieldDesignSectionLookupUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEFieldDesignSectionLookupUpdate] @TableName as
varchar(30),
	@FieldName AS varchar(30),
	@FieldSectionId AS int,
	@SortOrder AS int
AS
	UPDATE FieldDesignSectionLookup SET 
	SortOrder = @SortOrder
	WHERE TableName = @TableName AND
	FieldName = @FieldName AND
	FieldSectionId = @FieldSectionId

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEFieldDesignUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEFieldDesignUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[BAEFieldDesignUpdate]
		@FieldDesignId AS int,
		@TableName AS varchar(30),
		@FieldName AS varchar(128),
		@FieldState AS int,
		@RegularExpression AS varchar(255),
		@RegularExpressionExample AS varchar(255),
		@MemberTypes AS varchar(255)
	AS
	UPDATE FieldDesign SET 
	FieldState = @FieldState,
	RegularExpression = @RegularExpression,
	RegularExpressionExample = @RegularExpressionExample,
	MemberTypes = @MemberTypes
	WHERE FieldDesignId = @FieldDesignId AND TableName = @TableName AND
	FieldName = @FieldName

-------------------------------------------

set ANSI_NULLS OFF
set QUOTED_IDENTIFIER OFF

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEFieldSectionDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEFieldSectionDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEFieldSectionDelete] @FieldSectionId as
int
	AS
	DELETE
	FROM FieldSection
	WHERE FieldSectionId = @FieldSectionId
	
	DELETE
	FROM FieldDesignSectionLookup
	WHERE FieldSectionId = @FieldSectionId

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEFieldSectionGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEFieldSectionGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEFieldSectionGetAll] as
SELECT * FROM FieldSection
	ORDER BY SectionName asc

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEFieldSectionInsert]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEFieldSectionInsert]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEFieldSectionInsert] @SectionName as
varchar(128)
AS
	INSERT INTO FieldSection
	(
	SectionName	
	)
	VALUES 
	(
	@SectionName
	);
	SELECT CAST(@@IDENTITY AS int) AS 'FieldSectionId'

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEFieldSectionLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEFieldSectionLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEFieldSectionLoad] @FieldSectionId as
int
	AS
	SELECT * 
	FROM FieldSection
	WHERE FieldSectionId = @FieldSectionId

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEFieldSectionLoadSectionName]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEFieldSectionLoadSectionName]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEFieldSectionLoadSectionName] @SectionName as
varchar(128)
	AS
	SELECT * 
	FROM FieldSection
	WHERE SectionName = @SectionName

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEFieldSectionUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEFieldSectionUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEFieldSectionUpdate] @FieldSectionId as
int,
		@SectionName AS varchar(128)
	AS
	UPDATE FieldSection SET 
	SectionName = @SectionName
	WHERE FieldSectionId = @FieldSectionId

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEFinalizePOForOrder]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEFinalizePOForOrder]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEFinalizePOForOrder] @poVal varchar(48),
 	@orderNum int as
UPDATE Orders
		SET CUSTOMER_REFERENCE = @poVal, PAY_TYPE = '' 
		WHERE ORDER_NUMBER = @orderNum

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEFindProductsWithCategory]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEFindProductsWithCategory]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEFindProductsWithCategory] as
SELECT DISTINCT OrderProduct.OrderProductID, p.TITLE COLLATE database_default AS Title, (CAST(p.WEB_DESC AS varchar(4096))) Description, IsSuperProduct, ProductCode, p.WEB_OPTION AS SellOnWeb, p.IS_KIT AS IsKit, 
		(SELECT	TOP 1 OrderCategoryID FROM OrderProductCategoryLookup cat WHERE cat.OrderProductID = OrderProduct.OrderProductID) AS OrderCategoryID
	FROM 	OrderProduct INNER JOIN Product p 
		ON p.PRODUCT_CODE COLLATE database_default = OrderProduct.ProductCode COLLATE database_default
	WHERE 	((IsSuperProduct = 0 AND p.WEB_OPTION > 0))  AND (SELECT TOP 1 OrderCategoryID FROM OrderProductCategoryLookup cat WHERE cat.OrderProductID = OrderProduct.OrderProductID) IS NOT NULL--OR OrderProduct.OrderProductID NOT IN (SELECT OrderSuperProductChildProductID FROM OrderSuperProductChildProduct)
	UNION
	SELECT DISTINCT op.OrderProductID, op.Title  COLLATE database_default AS Title, op.Description  COLLATE database_default, op.IsSuperProduct, op.ProductCode, op.SellOnWeb, CAST('0' AS bit)  AS IsKit, 
		(SELECT TOP 1  OrderCategoryID FROM OrderProductCategoryLookup cat WHERE cat.OrderProductID = op.OrderProductID) AS OrderCategoryID
	FROM 	OrderProduct op 
	WHERE 	IsSuperProduct = 1 AND op.SellOnWeb > 0 AND (SELECT TOP 1  OrderCategoryID FROM OrderProductCategoryLookup cat WHERE cat.OrderProductID = op.OrderProductID) IS NOT NULL

	ORDER BY Title
/*	SELECT DISTINCT OrderProduct.OrderProductID, p.Title AS Title, (CAST(p.Web_desc AS varchar(4096))) DESCRIPTION, isSuperProduct, ProductCode, p.Web_Option AS SellOnWeb, 
		p.is_kit AS IsKit, (SELECT top 1 ordercategoryid FROM orderproductcategorylookup cat WHERE cat.orderproductid=OrderProduct.Orderproductid )  AS ordercategoryID
	FROM OrderProduct
	INNER JOIN Product p ON p.Product_Code = OrderProduct.ProductCode
	WHERE isSuperProduct = 0 AND OrderProduct.OrderProductID NOT IN (SELECT OrderSuperProductChildProductID FROM OrderSuperProductChildProduct) 
	UNION
	SELECT DISTINCT op.OrderProductID, op.Title AS Title, op.DESCRIPTION, op.isSuperProduct, op.ProductCode, op.SellOnWeb, Cast('0' AS bit)  AS IsKit, 
	(SELECT top 1 ordercategoryid FROM orderproductcategorylookup cat WHERE cat.orderproductid=op.Orderproductid )  AS ordercategoryID
	FROM OrderProduct op 
	WHERE isSuperProduct = 1
	ORDER BY title
*/

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEFixEventStatus]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEFixEventStatus]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEFixEventStatus] @orderID int as
UPDATE Orders
	SET STATUS = ''
	WHERE ORDER_NUMBER = @orderID

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEGetAddressPurpose]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEGetAddressPurpose]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEGetAddressPurpose] as
SELECT ShortValue FROM System_Params WHERE ParameterName = 'Member_Control.Addr2Prompt';

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEGetAllEvents]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEGetAllEvents]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEGetAllEvents] as
SELECT * FROM Meet_Master
	WHERE WEB_ENABLED = '1' AND STATUS = 'A'  AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())
	ORDER BY BEGIN_DATE;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEGetCommitteeMembers]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEGetCommitteeMembers]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure [dbo].[BAEGetCommitteeMembers] @committee varchar(32) as
SELECT     
	Name.ID, 
	Name.FULL_NAME AS FullName, 
	Name.TITLE AS Title, 
	Name.COMPANY AS Organization,
	Name.WORK_PHONE AS WorkPhone, 
	Name.HOME_PHONE AS HomePhone, 
	Name.FAX AS Fax, 
	Name.TOLL_FREE AS TollFreePhone, 
	Name.LAST_FIRST, 
	Name.EMAIL AS Email,
	NA_Bill.FULL_ADDRESS AS BillingAddress, 
	NA_Mail.FULL_ADDRESS AS MailingAddress, 
	Product.TITLE AS CommitteeName, 
	Product.DESCRIPTION AS CommitteeDescription, 
	Product.GROUP_3 AS CommitteeGroup, 
	Committee_Position.TITLE AS Position, 
	Committee_Position.RANK AS PositionRank, 
	Product.NOTE AS Note, 
	Activity.EFFECTIVE_DATE AS TermStart, 
	Activity.THRU_DATE AS TermEnd, 
	Activity.PRODUCT_CODE AS CommitteeProductCode
FROM    
	Activity INNER JOIN
        	Name ON Activity.ID = Name.ID INNER JOIN
                Product ON Activity.PRODUCT_CODE = Product.PRODUCT_CODE INNER JOIN
                Name_Address NA_Mail ON Name.MAIL_ADDRESS_NUM = NA_Mail.ADDRESS_NUM INNER JOIN
                Name_Address NA_Bill ON Name.BILL_ADDRESS_NUM = NA_Bill.ADDRESS_NUM INNER JOIN
                Committee_Position ON Activity.ACTION_CODES = Committee_Position.POSITION_CODE
WHERE     
	(Product.PROD_TYPE = 'COMMITTEE') 
	AND 
	(Activity.EFFECTIVE_DATE <= GETDATE()) 
	AND
	(Activity.THRU_DATE IS NULL OR (Activity.THRU_DATE >= GETDATE())) 
	AND
	Activity.PRODUCT_CODE = @committee
ORDER BY
	Committee_Position.RANK asc

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEGetCommittees]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEGetCommittees]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure [dbo].[BAEGetCommittees] as
SELECT PROD_TYPE AS CommitteeType, PRODUCT_CODE AS committee_product_code, TITLE AS CommitteeName, 
	   DESCRIPTION AS CommitteeDescription
  FROM Product
	WHERE
		PROD_TYPE = 'COMMITTEE' AND WEB_OPTION = 1
	ORDER BY
		CommitteeType,
		CommitteeName,
		PRODUCT_CODE

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEGetExistingLineTotal]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEGetExistingLineTotal]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEGetExistingLineTotal] @orderNum int as
SELECT LINE_TOTAL FROM Orders WHERE ORDER_NUMBER = @orderNum

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEGetExistingShippingCost]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEGetExistingShippingCost]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEGetExistingShippingCost] @orderNum int as
SELECT FREIGHT_1, FREIGHT_2 FROM Orders WHERE ORDER_NUMBER = @orderNum

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_FRDonations]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_FRDonations]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE procedure [dbo].[sp_asi_FRDonations]
@Id varchar(10),
@IncludeOutrightGifts bit=0,
@IncludePledges bit=0,
@IncludeSoftCredit bit=0,
@IncludeMatching bit=0,
@IncludeInKind bit=0,
@IncludeWrittenOff bit=0,
@IncludeFundRaising bit=0,
@IncludeEvents bit=0,
@IncludeDues bit=0,
@FundFilter varchar(255)='',
@CampaignFilter varchar(255)='',
@DistributionFilter varchar(255)='',
@FromDate datetime='',
@ThroughDate datetime='',
@FromAmount money=0.00,
@ThroughAmount money=0.00,
@SelectType varchar(40)='',
@DoSplits bit=0,
@TopLast int=0,
@TopWhat varchar(10)='',
@TopYears int=0,
@IncludeMidTerm bit=0,
@OnlyPaidPortion bit=0
as
set nocount on
declare
@TransNum int,
@Fund varchar(20),
@PrevTransNum int,
@PrevFund varchar(20),
@Source varchar(20),
@Product varchar(31),
@PrevProduct varchar(31),
@ProductMajor varchar(15),
@EventCode varchar(10),
@InvoiceRefNum int,
@Sql varchar(1000),
@Year varchar(4),
@PrevYear varchar(4),
@Amount money,
@PrevAmount money,
@RoundAmount money,
@YTD money,
@Lifetime money,
@Largest money,
@DateLargest datetime,
@DonorSince datetime,
@CurrentYear varchar(10),
@Campaign varchar(10),
@PrevCampaign varchar(10),
@Include int,
@MidTermAmount money,
@PledgeLifetime money,
@PledgeLargest money,
@DatePledgeLargest datetime,
@DateGiftLast datetime,
@DatePledgeLast datetime,
@PledgePaid money,
@PledgeBalance money,
@GiftType varchar(20), -- jf - dt17506
@HistoryRowCount int
create table #FRDonationTemp (
ID varchar(10),
OriginalTransNumber int,
TransactionNumber int,
InvoiceRefNum int,
SourceSystem varchar(20),
TransactionDate datetime,
Amount money,
AdjustmentAmount money,
PaymentAmount money,
Product varchar(31),
Appeal varchar(40),
Campaign varchar(10),
Fund varchar(10),
GiftType varchar(20),
MatchOrSoftCredit varchar(20),
PaymentType varchar(15),
AdjustmentFlag varchar(3),
ProductMajor varchar(15),
MemTribId varchar(10),
MemTribNameText varchar(100),
ListAs varchar(255),
SolicitorId varchar(10),
FiscalPeriod int,
Include int
)
create table #FRDonation (
ID varchar(10),
OriginalTransNumber int,
TransactionNumber int,
InvoiceRefNum int,
SourceSystem varchar(20),
TransactionDate datetime,
Amount money,
AdjustmentAmount money,
PaymentAmount money,
Product varchar(31),
Appeal varchar(40),
Campaign varchar(10),
Fund varchar(10),
GiftType varchar(20),
MatchOrSoftCredit varchar(20),
PaymentType varchar(15),
AdjustmentFlag varchar(3),
ProductMajor varchar(15),
MemTribId varchar(10),
MemTribNameText varchar(100),
ListAs varchar(255),
SolicitorId varchar(10),
FiscalPeriod int,
Include int
)
create table #Trends (
TransactionNumber int,
TheYear varchar(4),
Amount money,
Calc int
)
create table #FRPayment (
ID varchar(10),
OriginalTransNumber int,
TransactionNumber int,
DateReceived datetime,
InvoiceRefNum int,
PaymentAmount money,
GiftType varchar(20),
FiscalPeriod int
)
create table #FRDonationHistory (
TransactionNumber int,
InvoiceRefNum int,
SourceSystem varchar(20),
TransactionDate datetime,
Amount money,
PaymentAmount money,
Product varchar(31),
Campaign varchar(10),
Fund varchar(10),
GiftType varchar(20),
MatchOrSoftCredit varchar(20),
AdjustmentFlag varchar(3),
Include int
)
truncate table #FRDonationTemp
truncate table #FRDonation
truncate table #Trends
truncate table #FRPayment
truncate table #FRDonationHistory
if @IncludeEvents=1
BEGIN
insert into #FRDonation(ID,OriginalTransNumber,TransactionNumber,InvoiceRefNum,SourceSystem,
TransactionDate,Amount,AdjustmentAmount,PaymentAmount,Product,Appeal,Campaign,Fund,GiftType,
MatchOrSoftCredit,PaymentType,AdjustmentFlag,ProductMajor,MemTribId,MemTribNameText,ListAs,
SolicitorId,FiscalPeriod,Include)
select max(Trans.ST_ID)ID,
min(Trans.TRANS_NUMBER)as OriginalTransNum,
min(Trans.TRANS_NUMBER)TransactionNumber,
max(Trans.INVOICE_REFERENCE_NUM) InvoiceRefNum,
'Event' as SourceSystem,
max(Trans.TRANSACTION_DATE)TransactionDate,
(sum(Trans.AMOUNT) * -1) as Amount,
0 as AdjustmentAmount,
0 as PaymentAmount,
max(Trans.PRODUCT_CODE) Product,
max(Trans.SOURCE_CODE)Appeal,
max(Trans.CAMPAIGN_CODE)Campaign,
Max(Trans.GL_ACCT_ORG_CODE) Fund,
'Gift' as GiftType,
'' as MatchOrSoftCredit,
'' as PaymentType,
'' as AdjustmentFlag,
max(p.PRODUCT_MAJOR) ProductMajor,
'' as MemTribId,
'' as MemTribNameText,
'' as ListAs,
'' as SolicitorId,
max(Trans.FISCAL_PERIOD) FiscalPeriod,
0 as Include
from Trans
inner join Product p on p.PRODUCT_CODE=Trans.PRODUCT_CODE 
where Trans.SOURCE_SYSTEM = 'MEETING'
and  Trans.JOURNAL_TYPE = 'IN'  and  Trans.TRANSACTION_TYPE = 'DIST'
and  Trans.IS_FR_ITEM = 1 and Trans.POSTED >= 2  and Trans.ST_ID=@Id
group by Trans.ST_ID, Trans.INVOICE_REFERENCE_NUM, Trans.GL_ACCT_ORG_CODE, Trans.PRODUCT_CODE
END
delete #FRDonation where Amount=0.00
if @IncludeDues=1
BEGIN
insert into #FRDonation(ID,OriginalTransNumber,TransactionNumber,InvoiceRefNum,SourceSystem,
TransactionDate,Amount,AdjustmentAmount,PaymentAmount,Product,Appeal,Campaign,Fund,GiftType,
MatchOrSoftCredit,PaymentType,AdjustmentFlag,ProductMajor,MemTribId,MemTribNameText,ListAs,
SolicitorId,FiscalPeriod,Include)
select max(Trans.ST_ID)ID,
min(Trans.TRANS_NUMBER)as OriginalTransNum,
min(Trans.TRANS_NUMBER)TransactionNumber,
max(Trans.INVOICE_REFERENCE_NUM) InvoiceRefNum,
'Dues' as SourceSystem,
max(Trans.TRANSACTION_DATE)TransactionDate,
(sum(Trans.AMOUNT) * -1) as Amount,
0 as AdjustmentAmount,
0 as PaymentAmount,
max(Trans.PRODUCT_CODE) Product,
max(Trans.SOURCE_CODE)Appeal,
max(Trans.CAMPAIGN_CODE)Campaign,
Max(Trans.GL_ACCT_ORG_CODE) Fund,
'Pledge' as GiftType,
'' as MatchOrSoftCredit,
'' as PaymentType,
'' as AdjustmentFlag,
'' as ProductMajor,
'' as MemTribId,
'' as MemTribNameText,
'' as ListAs,
'' as SolicitorId,
max(Trans.FISCAL_PERIOD) FiscalPeriod,
0 as Include
from Trans
where Trans.SOURCE_SYSTEM = 'DUES'
and  Trans.JOURNAL_TYPE = 'IN'  and  Trans.TRANSACTION_TYPE = 'DIST'
and  Trans.IS_FR_ITEM = 1 and Trans.POSTED >= 2  and Trans.ST_ID=@Id
group by Trans.ST_ID, Trans.INVOICE_REFERENCE_NUM, Trans.GL_ACCT_ORG_CODE, Trans.PRODUCT_CODE
UNION ALL
select max(Trans.ST_ID)ID,
min(Trans.TRANS_NUMBER)as OriginalTransNum,
min(Trans.TRANS_NUMBER)TransactionNumber,
max(Trans.INVOICE_REFERENCE_NUM) InvoiceRefNum,
'Dues' as SourceSystem,
max(Trans.TRANSACTION_DATE)TransactionDate,
(sum(Trans.AMOUNT) * -1) as Amount,
0 as AdjustmentAmount,
0 as PaymentAmount,
max(Trans.PRODUCT_CODE) Product,
max(Trans.SOURCE_CODE)Appeal,
max(Trans.CAMPAIGN_CODE)Campaign,
Max(Trans.GL_ACCT_ORG_CODE) Fund,
'Gift' as GiftType,
'' as MatchOrSoftCredit,
'' as PaymentType,
'' as AdjustmentFlag,
'' as ProductMajor,
'' as MemTribId,
'' as MemTribNameText,
'' as ListAs,
'' as SolicitorId,
max(Trans.FISCAL_PERIOD) FiscalPeriod,
0 as Include
from Trans
where (Trans.SOURCE_SYSTEM = 'DUES' or Trans.SOURCE_SYSTEM = 'SC')
and  Trans.JOURNAL_TYPE = 'PAY'  and  Trans.TRANSACTION_TYPE = 'DIST'
and  Trans.IS_FR_ITEM = 1 and Trans.POSTED >= 2  and Trans.ST_ID=@Id
group by Trans.ST_ID, Trans.TRANS_NUMBER, Trans.GL_ACCT_ORG_CODE, Trans.PRODUCT_CODE
END
if @IncludeSoftCredit=1
BEGIN
     -- jb dt14899 22 may 06 
     -- updated so only original soft credit is included, adjustment lines from CM/DM are not returned
     -- CM/DM adjustments are applied to the original value
     insert into #FRDonation(ID,OriginalTransNumber,TransactionNumber,InvoiceRefNum,SourceSystem,
     TransactionDate,Amount,AdjustmentAmount,PaymentAmount,Product,Appeal,Campaign,Fund,GiftType,
     MatchOrSoftCredit,PaymentType,AdjustmentFlag,ProductMajor,MemTribId,MemTribNameText,ListAs,
     SolicitorId,FiscalPeriod,Include)
     select Max(Trans_SoftCredit.SOFT_CREDIT_ID) ID,
     max(Trans_SoftCredit.TRANS_NUMBER)OriginalTransNum,
     max(Trans_SoftCredit.TRANS_NUMBER)TransactionNumber,
     '' as InvoiceRefNum,
     'Fundraising' as SourceSystem,
     max(Activity.TRANSACTION_DATE) as TransactionDate,
     sum(Trans_SoftCredit.AMOUNT + dbo.fn_asi_SoftCreditCMDM_Amount(Trans_SoftCredit.TRANS_NUMBER,Trans_SoftCredit.ORIGINATING_ACTIVITY_SEQN,Trans_SoftCredit.SOFT_CREDIT_ID)) as Amount,
     0 as AdjustmentAmount,
     0 as PaymentAmount,
     max(Trans_SoftCredit.PRODUCT_CODE) as Product,
     max(Activity.SOURCE_CODE) as Appeal,
     max(Activity.CAMPAIGN_CODE) as Campaign,
     max(Activity.ORG_CODE) as Fund,
     (case when max(Activity.ACTIVITY_TYPE) = 'GIFT' then 'Gift' else 'Pledge' end) as GiftType,
     'Soft Credit' as MatchOrSoftCredit,
     case      when max(Cash_Accounts.ACCOUNT_TYPE) = 0 then 'Cash'  
          when max(Cash_Accounts.ACCOUNT_TYPE) = 1 then 'Credit Card'  
          when max(Cash_Accounts.ACCOUNT_TYPE) = 2 then 'In Kind'
          else ''
          end
     as PaymentType,
     max(case dbo.fn_asi_SoftCreditCMDM_Exists(Trans_SoftCredit.TRANS_NUMBER,Trans_SoftCredit.ORIGINATING_ACTIVITY_SEQN,Trans_SoftCredit.SOFT_CREDIT_ID)
          when 1 then 'Yes'
          else ''
     end) as AdjustmentFlag,
     '' as ProductMajor,
     '' as MemTribId,
     '' as MemTribNameText,
     '' as ListAs,
     '' as SolicitorId,
     max(Trans.FISCAL_PERIOD) FiscalPeriod,
     0 as Include
     from Trans_SoftCredit
     inner join Activity on Activity.SEQN = Trans_SoftCredit.ORIGINATING_ACTIVITY_SEQN
     inner join Trans on Trans.TRANS_NUMBER = Trans_SoftCredit.TRANS_NUMBER
     left outer join Cash_Accounts on Trans.CHECK_NUMBER = Cash_Accounts.CASH_ACCOUNT_CODE
     where Activity.SOURCE_SYSTEM='FR'
     and Trans.LINE_NUMBER = 1 AND Trans.SUB_LINE_NUMBER = 1
     and Trans.POSTED >= 2  and Trans_SoftCredit.SOFT_CREDIT_ID=@Id
     and Trans_SoftCredit.TRANS_NUMBER=Activity.ORIGINATING_TRANS_NUM       -- jb dt14899
     group by Trans_SoftCredit.SOFT_CREDIT_ID, Trans_SoftCredit.TRANS_NUMBER, Activity.ORG_CODE, Trans_SoftCredit.PRODUCT_CODE
END
if @IncludeFundRaising=1
BEGIN
insert into #FRDonationTemp(ID,OriginalTransNumber,TransactionNumber,InvoiceRefNum,SourceSystem,
TransactionDate,Amount,AdjustmentAmount,PaymentAmount,Product,Appeal,Campaign,Fund,GiftType,
MatchOrSoftCredit,PaymentType,AdjustmentFlag,ProductMajor,MemTribId,MemTribNameText,ListAs,
SolicitorId,FiscalPeriod,Include)
select max(P.BT_ID) ID,
(case when max(P.IS_MATCH_GIFT)=1 then max(P.MATCH_GIFT_TRANS_NUM) else max(P.TRANS_NUMBER) end) as OriginalTransNumber,
max(P.TRANS_NUMBER) TransactionNumber,
max(P.INVOICE_REFERENCE_NUM) InvoiceRefNum,
'Fundraising' as SourceSystem,
max(P.TRANSACTION_DATE) TransactionDate,
(sum(P.AMOUNT) * -1)  as Amount,
0 as AdjustmentAmount,
0 as PaymentAmount,
max(P.PRODUCT_CODE) Product,
max(P.SOURCE_CODE) Appeal,
max(P.CAMPAIGN_CODE) Campaign,
max(P.OWNER_ORG_CODE) Fund,
(case when max(P.INSTALL_BILL_DATE) is null then 'Gift' else 'Pledge' end) as GiftType,
(case when max(P.IS_MATCH_GIFT)= 1 then 'Matching' else '' end) as MatchOrSoftCredit,
case      when max(Cash_Accounts.ACCOUNT_TYPE) = 0 then 'Cash'  
     when max(Cash_Accounts.ACCOUNT_TYPE) = 1 then 'Credit Card'  
     when max(Cash_Accounts.ACCOUNT_TYPE) = 2 then 'In Kind'
     else ''
     end
as PaymentType,
'' as AdjustmentFlag,
'' as ProductMajor,
max(P.MEM_TRIB_ID) as MemTribId,
max(P.MEM_TRIB_NAME_TEXT) MemTribNameText,
max(P.ACTION_CODES) as ListAs,
max(P.SOLICITOR_ID) as SolicitorId,
max(P.FISCAL_PERIOD) FiscalPeriod,
0 as Include
from Trans P
inner join Invoice I on I.REFERENCE_NUM=P.INVOICE_REFERENCE_NUM
left outer join Cash_Accounts on P.CHECK_NUMBER = Cash_Accounts.CASH_ACCOUNT_CODE
where 
P.JOURNAL_TYPE = 'IN' and P.TRANSACTION_TYPE = 'DIST'
and P.SOURCE_SYSTEM='FR' and P.POSTED >= 2 and P.BT_ID=@Id
group by P.BT_ID, P.TRANS_NUMBER, P.OWNER_ORG_CODE, P.PRODUCT_CODE
UNION ALL
select max(C.BT_ID) ID,
'' as OriginalTransNumber,
max(Invoice.ORIGINATING_TRANS_NUM) TransactionNumber,
--'' as InvoiceRefNum, -- jf - 30 aug 06
max(C.INVOICE_REFERENCE_NUM) InvoiceRefNum,
'Fundraising' as SourceSystem,
'' as TransactionDate,
(sum(C.AMOUNT) * -1)  as Amount,
(sum(C.AMOUNT) * -1)  as AdjustmentAmount,
0 as PaymentAmount,
max(C.PRODUCT_CODE) Product,
'' as Appeal,
'' as Campaign,
max(C.OWNER_ORG_CODE) Fund,
'' as GiftType,
'' as MatchOrSoftCredit,
'' as PaymentType,
'Yes' as AdjustmentFlag,
'' as ProductMajor,
'' as MemTribId,
'' as MemTribNameText,
'' as ListAs,
'' as SolicitorId,
0 as FiscalPeriod,
0 as Include
from Trans C
inner join Invoice on Invoice.REFERENCE_NUM = C.INVOICE_REFERENCE_NUM
where Invoice.SOURCE_SYSTEM='FR'
and ((C.JOURNAL_TYPE = 'CM' and C.TRANSACTION_TYPE = 'DIST')
or  (C.JOURNAL_TYPE = 'DM' and C.TRANSACTION_TYPE = 'DIST'))
and C.POSTED >= 2 and C.BT_ID=@Id
group by C.BT_ID, C.TRANS_NUMBER, C.OWNER_ORG_CODE, C.PRODUCT_CODE
END
if @IncludeDues=1
BEGIN
insert into #FRDonationTemp(ID,OriginalTransNumber,TransactionNumber,InvoiceRefNum,SourceSystem,
TransactionDate,Amount,AdjustmentAmount,PaymentAmount,Product,Appeal,Campaign,Fund,GiftType,
MatchOrSoftCredit,PaymentType,AdjustmentFlag,ProductMajor,MemTribId,MemTribNameText,ListAs,
SolicitorId,FiscalPeriod,Include)
select max(T.BT_ID) ID,
'' as OriginalTransNumber,
max(Invoice.ORIGINATING_TRANS_NUM) TransactionNumber,
max(T.INVOICE_REFERENCE_NUM) as InvoiceRefNum,
'Dues' as SourceSystem,
max(T.TRANSACTION_DATE) as TransactionDate, -- jf - 4 dec 09 -- PBI 1316
(sum(T.AMOUNT) * -1)  as Amount,
(sum(T.AMOUNT) * -1)  as AdjustmentAmount,
0 as PaymentAmount,
max(T.PRODUCT_CODE) Product,
'' as Appeal,
'' as Campaign,
max(T.OWNER_ORG_CODE) Fund,
'Pledge' as GiftType,
'' as MatchOrSoftCredit,
'' as PaymentType,
'Yes' as AdjustmentFlag,
'' as ProductMajor,
'' as MemTribId,
'' as MemTribNameText,
'' as ListAs,
'' as SolicitorId,
0 as FiscalPeriod,
0 as Include
from Trans T
inner join Invoice on Invoice.REFERENCE_NUM = T.INVOICE_REFERENCE_NUM
where Invoice.SOURCE_SYSTEM='DUES'
and ((T.JOURNAL_TYPE = 'CM' and T.TRANSACTION_TYPE = 'DIST')
or  (T.JOURNAL_TYPE = 'DM' and T.TRANSACTION_TYPE = 'DIST'))
and T.IS_FR_ITEM=1 and T.POSTED >= 2 and T.BT_ID=@Id and T.BT_ID=T.ST_ID
group by T.BT_ID, T.TRANS_NUMBER, T.OWNER_ORG_CODE, T.PRODUCT_CODE
UNION ALL
select max(T.ST_ID) ID,
'' as OriginalTransNumber,
max(Invoice.ORIGINATING_TRANS_NUM) TransactionNumber,
max(T.INVOICE_REFERENCE_NUM) as InvoiceRefNum,
'Dues' as SourceSystem,
'' as TransactionDate,
(sum(T.AMOUNT) * -1)  as Amount,
(sum(T.AMOUNT) * -1)  as AdjustmentAmount,
0 as PaymentAmount,
max(T.PRODUCT_CODE) Product,
'' as Appeal,
'' as Campaign,
max(T.OWNER_ORG_CODE) Fund,
'Pledge' as GiftType,
'' as MatchOrSoftCredit,
'' as PaymentType,
'Yes' as AdjustmentFlag,
'' as ProductMajor,
'' as MemTribId,
'' as MemTribNameText,
'' as ListAs,
'' as SolicitorId,
0 as FiscalPeriod,
0 as Include
from Trans T
inner join Invoice on Invoice.REFERENCE_NUM = T.INVOICE_REFERENCE_NUM
where Invoice.SOURCE_SYSTEM='DUES'
and ((T.JOURNAL_TYPE = 'CM' and T.TRANSACTION_TYPE = 'DIST')
or  (T.JOURNAL_TYPE = 'DM' and T.TRANSACTION_TYPE = 'DIST'))
and T.IS_FR_ITEM=1 and T.POSTED >= 2 and T.ST_ID=@Id and T.BT_ID<>T.ST_ID
group by T.BT_ID, T.TRANS_NUMBER, T.OWNER_ORG_CODE, T.PRODUCT_CODE
END

if @SelectType in ('Donor History','SummaryData','Summary2','GiftPortfolio')
BEGIN
insert into #FRPayment(ID,OriginalTransNumber,TransactionNumber,DateReceived,InvoiceRefNum,PaymentAmount,GiftType,FiscalPeriod)
select C.ST_ID ID, 
max(P.TRANS_NUMBER) OriginalTransNumber, 
max(C.TRANS_NUMBER) TransactionNumber,
max(P.EFFECTIVE_DATE) DateReceived,
max(C.INVOICE_REFERENCE_NUM) InvoiceRefNum,
sum(C.AMOUNT) PaymentAmount, 
(case when max(Activity.ACTIVITY_TYPE) = 'GIFT'  then  'Gift' else 'Pledge Payment' end) as GiftType,
max(C.FISCAL_PERIOD) FiscalPeriod
from Trans C 
inner join Invoice on Invoice.REFERENCE_NUM = C.INVOICE_REFERENCE_NUM 
inner join Trans P on P.TRANS_NUMBER = Invoice.ORIGINATING_TRANS_NUM 
inner join Activity on Activity.SEQN = P.ACTIVITY_SEQN 
where P.LINE_NUMBER = 1 and      P.SUB_LINE_NUMBER = 1 and P.JOURNAL_TYPE = 'IN' and      
P.TRANSACTION_TYPE = 'DIST' and Invoice.SOURCE_SYSTEM='FR' and C.JOURNAL_TYPE = 'IN' and      
C.TRANSACTION_TYPE = 'PAY' and C.ST_ID=@Id
group by C.ST_ID, C.TRANS_NUMBER, C.INVOICE_REFERENCE_NUM
UNION ALL
select C.ST_ID ID, 
max(P.TRANS_NUMBER)OriginalTransNumber, 
max(P.TRANS_NUMBER)TransactionNumber,
max(C.TRANSACTION_DATE) DateReceived,
max(C.INVOICE_REFERENCE_NUM) InvoiceRefNum,
(sum(C.AMOUNT) * -1) PaymentAmount, 
(case when max(Activity.ACTIVITY_TYPE) = 'GIFT'  then  'Gift' else 'Pledge Payment' end) as GiftType,
max(C.FISCAL_PERIOD) FiscalPeriod
from Trans C 
inner join Invoice on Invoice.REFERENCE_NUM = C.INVOICE_REFERENCE_NUM 
inner join Trans P on P.TRANS_NUMBER = Invoice.ORIGINATING_TRANS_NUM 
inner join Activity on Activity.SEQN = P.ACTIVITY_SEQN 
where  P.LINE_NUMBER = 1  and      P.SUB_LINE_NUMBER = 1 and  P.JOURNAL_TYPE = 'IN'
and P.TRANSACTION_TYPE = 'DIST' and Invoice.SOURCE_SYSTEM='FR' 
and C.JOURNAL_TYPE = 'PAY' and C.TRANSACTION_TYPE = 'AR' and C.ST_ID=@Id
group by C.ST_ID,P.TRANS_NUMBER
UNION ALL
-- jf - 21 jun 06 dt16264
select P.ST_ID ID, 
max(P.TRANS_NUMBER) OriginalTransNumber, 
max(C.TRANS_NUMBER) TransactionNumber,
max(P.EFFECTIVE_DATE) DateReceived,
max(P.INVOICE_REFERENCE_NUM) InvoiceRefNum,
sum(C.INVOICE_CREDITS) PaymentAmount, 
(case when max(Activity.ACTIVITY_TYPE) = 'GIFT'  then  'Gift' else 'Pledge Payment' end) as GiftType,
max(C.FISCAL_PERIOD) FiscalPeriod
from Trans C 
inner join Invoice on Invoice.REFERENCE_NUM = C.INVOICE_REFERENCE_NUM 
inner join Trans P on P.TRANS_NUMBER = Invoice.ORIGINATING_TRANS_NUM 
inner join Activity on Activity.SEQN = P.ACTIVITY_SEQN 
where P.LINE_NUMBER = 1 and  P.SUB_LINE_NUMBER = 1 and P.JOURNAL_TYPE = 'IN' and      
P.TRANSACTION_TYPE = 'DIST' and Invoice.SOURCE_SYSTEM='FR' 
and ((C.JOURNAL_TYPE = 'PAY' and C.TRANSACTION_TYPE = 'PAY') or (C.JOURNAL_TYPE = 'IN' and C.TRANSACTION_TYPE = 'TR')) 
and P.ST_ID=@Id
group by P.ST_ID, P.TRANS_NUMBER, P.INVOICE_REFERENCE_NUM
if @IncludeDues=1
BEGIN
insert into #FRPayment(ID,OriginalTransNumber,TransactionNumber,DateReceived,InvoiceRefNum,PaymentAmount,GiftType,FiscalPeriod)
select C.BT_ID ID, 
max(P.TRANS_NUMBER) OriginalTransNumber, 
max(C.TRANS_NUMBER) TransactionNumber,
max(C.TRANSACTION_DATE) DateReceived,
max(C.INVOICE_REFERENCE_NUM) InvoiceRefNum,
sum(Activity.AMOUNT) PaymentAmount,  
'Gift' as GiftType,
max(C.FISCAL_PERIOD) FiscalPeriod
from Trans C 
inner join Trans P on P.TRANS_NUMBER = C.TRANS_NUMBER 
inner join Activity on Activity.ORIGINATING_TRANS_NUM = P.TRANS_NUMBER 
where Activity.ACTIVITY_TYPE='GIFT' and P.LINE_NUMBER = 1 and  
P.SUB_LINE_NUMBER = 1 and P.JOURNAL_TYPE = 'PAY' and      
P.TRANSACTION_TYPE = 'DIST' and P.IS_FR_ITEM=1 and C.JOURNAL_TYPE = 'PAY' and      
C.TRANSACTION_TYPE = 'PAY' and C.BT_ID=@Id
group by C.BT_ID, C.TRANS_NUMBER, C.INVOICE_REFERENCE_NUM
UNION ALL
select T.ST_ID ID,
max(I.ORIGINATING_TRANS_NUM) OriginalTransNumber,
max(T.TRANS_NUMBER) TransactionNumber, 
max(T.TRANSACTION_DATE) DateReceived,
max(T.INVOICE_REFERENCE_NUM) InvoiceRefNum,
sum(T.AMOUNT)*-1 PaymentAmount, 
'Pledge Payment' as GiftType,
max(T.FISCAL_PERIOD) FiscalPeriod
from Trans T 
inner join Invoice I on I.REFERENCE_NUM = T.INVOICE_REFERENCE_NUM
inner join Invoice_Lines IL on IL.REFERENCE_NUM = T.INVOICE_REFERENCE_NUM
where T.IS_FR_ITEM=1 and ((T.JOURNAL_TYPE = 'IN' and T.TRANSACTION_TYPE='PAY') 
or (T.JOURNAL_TYPE = 'PAY' and T.TRANSACTION_TYPE='AR')) 
and T.ST_ID=@Id and I.BT_ID=IL.ST_ID
and T.INVOICE_LINE_NUM=IL.LINE_NUM
and I.SOURCE_SYSTEM = 'DUES' -- jf - 1 dec 09 -- PBI 1316
group by T.ST_ID,I.ORIGINATING_TRANS_NUM
UNION ALL
select T.ST_ID ID,
max(I.ORIGINATING_TRANS_NUM) OriginalTransNumber,
max(T.TRANS_NUMBER) TransactionNumber, 
max(T.TRANSACTION_DATE) DateReceived,
max(T.INVOICE_REFERENCE_NUM) InvoiceRefNum,
sum(T.AMOUNT)*-1 PaymentAmount, 
'Pledge Payment' as GiftType,
max(T.FISCAL_PERIOD) FiscalPeriod
from Trans T 
inner join Invoice I on I.REFERENCE_NUM = T.INVOICE_REFERENCE_NUM
inner join Invoice_Lines IL on IL.REFERENCE_NUM = T.INVOICE_REFERENCE_NUM
where T.IS_FR_ITEM=1 and ((T.JOURNAL_TYPE = 'IN' and T.TRANSACTION_TYPE='PAY') 
or (T.JOURNAL_TYPE = 'PAY' and T.TRANSACTION_TYPE='AR'))
and IL.ST_ID=@Id 
and T.INVOICE_LINE_NUM=IL.LINE_NUM
and I.SOURCE_SYSTEM = 'DUES' -- jf - 1 dec 09 -- PBI 1316
group by T.ST_ID,I.ORIGINATING_TRANS_NUM
UNION
select A.ID,
A.ORIGINATING_TRANS_NUM OriginalTransNumber,
max(A.ORIGINATING_TRANS_NUM) TransactionNumber,
max(A.TRANSACTION_DATE) DateReceived,
max(T.INVOICE_REFERENCE_NUM) as InvoiceRefNum,
sum(A.AMOUNT) PaymentAmount,
'Gift' as GiftType,
max(T.FISCAL_PERIOD) FiscalPeriod
from Activity A
inner join Trans T on T.ACTIVITY_SEQN=A.SEQN
where A.ACTIVITY_TYPE in ('GIFT','DUES') and T.IS_FR_ITEM=1 and T.JOURNAL_TYPE = 'PAY' and
T.TRANSACTION_TYPE = 'DIST' and A.ID=@Id and T.BT_ID = @Id
and (A.SOURCE_SYSTEM = 'DUES' or A.SOURCE_SYSTEM = 'SC')
group by A.ID,A.ORIGINATING_TRANS_NUM
UNION
select A.ID,
A.ORIGINATING_TRANS_NUM OriginalTransNumber,
max(A.ORIGINATING_TRANS_NUM) TransactionNumber,
max(A.TRANSACTION_DATE) DateReceived,
max(T.INVOICE_REFERENCE_NUM) as InvoiceRefNum,
sum(A.AMOUNT) PaymentAmount,
'Gift' as GiftType,
max(T.FISCAL_PERIOD) FiscalPeriod
from Activity A
inner join Trans T on T.ACTIVITY_SEQN=A.SEQN
where A.ACTIVITY_TYPE in ('GIFT','DUES') and T.IS_FR_ITEM=1 and T.JOURNAL_TYPE = 'PAY' and
T.TRANSACTION_TYPE = 'DIST' and A.ID=@Id and T.ST_ID = @Id and T.ST_ID <> T.BT_ID
and (A.SOURCE_SYSTEM = 'DUES' or A.SOURCE_SYSTEM = 'SC')
group by A.ID,A.ORIGINATING_TRANS_NUM
END
END
insert into #FRDonation(ID,OriginalTransNumber,TransactionNumber,InvoiceRefNum,SourceSystem,
TransactionDate,Amount,AdjustmentAmount,PaymentAmount,Product,Appeal,Campaign,Fund,GiftType,
MatchOrSoftCredit,PaymentType,AdjustmentFlag,ProductMajor,MemTribId,MemTribNameText,ListAs,
SolicitorId,FiscalPeriod,Include)
select max(ID) ID,
max(OriginalTransNumber) OriginalTransNumber,
max(TransactionNumber) TransactionNumber,
max(InvoiceRefNum) as InvoiceRefNum,
max(SourceSystem) as SourceSystem,
max(TransactionDate) TransactionDate,
sum(Amount) Amount,
sum(AdjustmentAmount) AdjustmentAmount,
sum(PaymentAmount) PaymentAmount,
max(Product) Product,
max(Appeal) Appeal,
max(Campaign) Campaign,
max(Fund) Fund,
max(GiftType) GiftType,
max(MatchOrSoftCredit) MatchOrSoftCredit,
max(PaymentType) as PaymentType,
max(AdjustmentFlag) AdjustmentFlag,
max(ProductMajor) ProductMajor,
max(MemTribId) MemTribId,
max(MemTribNameText) MemTribNameText,
max(ListAs) ListAs,
max(SolicitorId) SolicitorId,
max(FiscalPeriod) FiscalPeriod,
max(Include) Include
from #FRDonationTemp
group by ID, TransactionNumber, Fund, Product
if @IncludeInKind=0
BEGIN
delete #FRDonation where PaymentType='In Kind'
END
if @IncludeMatching=0
BEGIN
delete #FRDonation where MatchOrSoftCredit='Matching'
END
if @SelectType='SummaryData'
BEGIN
select @CurrentYear=convert(char(4),datepart(year,getdate()))+'0101'
select sum(Amount) Amount,max(TransactionDate) TransactionDate into #MyTemp from #FRDonation
group by TransactionNumber,InvoiceRefNum
select @Largest=max(Amount),@DateLargest=max(TransactionDate) from #MyTemp group by Amount
if @OnlyPaidPortion=0
begin
select @Lifetime=sum(Amount) from #FRDonation
end
else
begin
select @Lifetime=isnull(sum(Amount),0) from #FRDonation where GiftType='Gift'
and MatchOrSoftCredit not in ('Matching','Soft Credit')
select @Lifetime=@Lifetime+isnull(sum(PaymentAmount),0) from #FRPayment 
where GiftType='Pledge Payment'
end
select @DonorSince=min(TransactionDate) from #FRDonation
if @OnlyPaidPortion=0
begin
select @YTD=sum(Amount) from #FRDonation where TransactionDate>=@CurrentYear
end
else
begin
select @YTD=isnull(sum(Amount),0) from #FRDonation where TransactionDate>=@CurrentYear and GiftType='Gift'
and MatchOrSoftCredit not in ('Matching','Soft Credit')
select @YTD=@YTD+isnull(sum(PaymentAmount),0) from #FRPayment 
where GiftType='Pledge Payment' and DateReceived>=@CurrentYear
end
select isnull(@Lifetime,0),isnull(@DonorSince,''),isnull(@Largest,0),isnull(@DateLargest,''),isnull(@YTD,0)
END
if @SelectType='GiftPortfolio'
BEGIN
select sum(Amount) Amount,max(TransactionDate) TransactionDate,max(GiftType) GiftType into #MyTemp2 from #FRDonation
group by TransactionNumber,InvoiceRefNum
select @Largest=max(Amount) from #MyTemp2 where GiftType='Gift' group by Amount
select @PledgeLargest=max(Amount) from #MyTemp2 where GiftType='Pledge' group by Amount
select @Lifetime=sum(Amount) from #FRDonation where GiftType='Gift'
if @OnlyPaidPortion=0
begin
select @PledgeLifetime=isnull(sum(Amount),0) from #FRDonation where GiftType='Pledge'
end
else
begin
select @PledgeLifetime=isnull(sum(PaymentAmount),0) from #FRPayment where GiftType='Pledge Payment'
end
select @DatePledgeLast=max(TransactionDate) from #FRDonation where GiftType='Pledge'
select @DateGiftLast=max(TransactionDate) from #FRDonation where GiftType='Gift'
select @PledgeBalance=isnull(sum(i.BALANCE),0) from Invoice i 
where i.BT_ID=@Id and i.SOURCE_SYSTEM = 'FR' and i.ORIGINATING_TRANS_NUM>0 and i.INSTALL_BILL_DATE is not null
select @PledgeBalance=@PledgeBalance+isnull(sum(BALANCE),0) from Invoice_Lines where ST_ID=@Id and IS_FR_ITEM=1
select isnull(@Lifetime,0),isnull(@PledgeLifetime,0),isnull(@Largest,0),isnull(@PledgeLargest,0),
isnull(@DatePledgeLast,''),isnull(@DateGiftLast,''),isnull(@PledgeBalance,0)
END
if @IncludeOutrightGifts=0
BEGIN
delete #FRDonation where GiftType='Gift' and MatchOrSoftCredit not in ('Matching','Soft Credit')
END
if @IncludePledges=0
BEGIN
delete #FRDonation where GiftType in ('Pledge','Pledge Payment') and MatchOrSoftCredit not in ('Matching','Soft Credit')
END
update #FRDonation set GiftType=GiftType+'*' where MatchOrSoftCredit<>''
if @IncludeInKind=1	-- jf - dt17507
BEGIN
update #FRDonation set GiftType=GiftType+char(134) where PaymentType='In Kind'
END
select @Include=0
if @FundFilter<>''
begin
update #FRDonation set Include=1 where charindex(Fund,@FundFilter)>0
select @Include=1
end
if @CampaignFilter<>''
BEGIN
if @FundFilter<>''
begin
update #FRDonation set Include=2 where charindex(Campaign,@CampaignFilter)>0 and Include=1
select @Include=2
end
else
begin
update #FRDonation set Include=1 where charindex(Campaign,@CampaignFilter)>0
select @Include=1
end
END
if @DistributionFilter<>''
BEGIN
if @FundFilter<>'' and @CampaignFilter<>''
begin
update #FRDonation set Include=3 where charindex(';'+Product+';',@DistributionFilter)>0 and Include=2
select @Include=3
end
if @FundFilter<>'' and @CampaignFilter=''
begin
update #FRDonation set Include=2 where charindex(';'+Product+';',@DistributionFilter)>0 and Include=1
select @Include=2
end
if @FundFilter='' and @CampaignFilter<>''
begin
update #FRDonation set Include=2 where charindex(';'+Product+';',@DistributionFilter)>0 and Include=1
select @Include=2
end
if @FundFilter='' and @CampaignFilter=''
begin
update #FRDonation set Include=1 where charindex(';'+Product+';',@DistributionFilter)>0 and Include=0
select @Include=1
end
END

if @DoSplits=1 --jf - 4 jul 07 - dt563 added Campaign for FR Dues.
BEGIN
declare TheCursor cursor for 
select TransactionNumber,Fund,SourceSystem,Product,Campaign
from #FRDonation where SourceSystem<>'Event' and GiftType<>'' order by TransactionNumber -- jf - dt17506
open TheCursor
fetch next from TheCursor into @TransNum,@Fund,@Source,@Product,@Campaign

WHILE @@FETCH_STATUS = 0
BEGIN
if @TransNum=@PrevTransNum and @Fund=@PrevFund and @Product<>@PrevProduct -- jf - 4 dec 09 -- PBI 1316
begin
update #FRDonation set Product='-Split-' where TransactionNumber=@TransNum
end
if @PrevFund<>''
begin
if @TransNum=@PrevTransNum and @Fund<>@PrevFund
begin
update #FRDonation set Fund='-Split-',Product='-Split-' where TransactionNumber=@TransNum
end
end
if @PrevCampaign<>''
begin
if @TransNum=@PrevTransNum and @Campaign<>@PrevCampaign and @Campaign<>''
begin
update #FRDonation set Campaign='-Split-' where TransactionNumber=@TransNum
end
end
begin
select @PrevTransNum=@TransNum
select @PrevFund=@Fund
select @PrevCampaign=@Campaign
select @PrevProduct=@Product
end
fetch next from TheCursor into @TransNum,@Fund,@Source,@Product,@Campaign
END
close TheCursor
deallocate TheCursor
END
select @PrevFund=''
if charindex(',',@FundFilter)=0
BEGIN
declare TheCursor cursor for 
select InvoiceRefNum,Fund,ProductMajor,Product,Campaign
from #FRDonation where SourceSystem='Event' order by InvoiceRefNum
open TheCursor
fetch next from TheCursor into @InvoiceRefNum,@Fund,@ProductMajor,@Product,@Campaign
WHILE @@FETCH_STATUS = 0
BEGIN
if @ProductMajor=@EventCode and @Fund=@PrevFund
begin
update #FRDonation set Product='-Split-', TransactionNumber=InvoiceRefNum where InvoiceRefNum=@InvoiceRefNum
end
if @PrevFund<>''
begin
if @ProductMajor=@EventCode and @Fund<>@PrevFund and @Fund<>''
begin
update #FRDonation set Fund='-Split-',Product='-Split-', TransactionNumber=InvoiceRefNum where InvoiceRefNum=@InvoiceRefNum
end
end
if @PrevCampaign<>''
begin
if @ProductMajor=@EventCode and @Campaign<>@PrevCampaign and @Campaign<>''
begin
update #FRDonation set Campaign='-Split-', TransactionNumber=InvoiceRefNum where InvoiceRefNum=@InvoiceRefNum
end
end
begin
select @EventCode=@ProductMajor
select @PrevFund=@Fund
select @PrevCampaign=@Campaign
end
fetch next from TheCursor into @InvoiceRefNum,@Fund,@ProductMajor,@Product,@Campaign
END
close TheCursor
deallocate TheCursor
END

-- jf - 23 oct 06 dt18031
--delete #FRDonation where OriginalTransNumber=0 and GiftType='' and AdjustmentFlag='Yes'

-- jf - 10 feb 10 -- Change to above dt18031 fix. SMR 204631 - PBI 6630 - only delete adjustment if original transaction not found
delete #FRDonation from #FRDonation f where f.OriginalTransNumber = 0 and f.AdjustmentFlag = 'Yes' 
and NOT EXISTS(select 1 from Trans t where t.JOURNAL_TYPE = 'IN' and t.TRANSACTION_TYPE = 'DIST' 
and (t.ACTIVITY_TYPE = 'PLEDGE' or t.ACTIVITY_TYPE = 'GIFT') and t.INVOICE_REFERENCE_NUM = f.InvoiceRefNum)

if @SelectType='Summary1'
BEGIN
select @Sql='select TOP '+convert(varchar(3),@TopLast)+' max(TransactionDate) Date,
sum(Amount) Amount,max(GiftType) Type,max(SourceSystem) Source
from #FRDonation group by TransactionNumber,InvoiceRefNum'
if @TopWhat<>'Donations'
begin
select @Sql=@Sql+' having max(GiftType)='+''''+convert(varchar(10),@TopWhat)+''''
end
select @Sql=@Sql+' order by max(TransactionDate) Desc,TransactionNumber'
exec (@Sql)
END
if @SelectType='Summary2'
BEGIN
if @OnlyPaidPortion=0
begin
insert into #Trends select TransactionNumber,max(substring(convert(char(6),FiscalPeriod),1,4)),
sum(Amount),0 from #FRDonation group by TransactionNumber,InvoiceRefNum --,Product -- jf 30 aug 06
end
else
begin
insert into #Trends select TransactionNumber,max(substring(convert(char(6),FiscalPeriod),1,4)),
sum(Amount),0 from #FRDonation where GiftType in ('Gift','Gift*','Pledge*') group by TransactionNumber,InvoiceRefNum --,Product -- jf 31 aug 06
insert into #Trends select TransactionNumber,max(substring(convert(char(6),FiscalPeriod),1,4)),
sum(PaymentAmount),0 from #FRPayment where GiftType='Pledge Payment' group by TransactionNumber
end
declare TheCursor cursor for 
select max(TheYear),sum(Amount) from #Trends
group by TheYear order by max(TheYear) Asc
open TheCursor
fetch next from TheCursor into @Year,@Amount
WHILE @@FETCH_STATUS = 0
BEGIN
if @PrevYear<>''
begin
--select @RoundAmount=((@Amount-@PrevAmount)/@PrevAmount)*100
select @RoundAmount=((@Amount-@PrevAmount)/case when @PrevAmount = 0 then 1 else @PrevAmount end)*100 -- 9/5/2012 cv replaced code above due to divide by zero error pbi 30575
update #Trends set Calc=ROUND(@RoundAmount,0) where TheYear=@Year
end
select @PrevYear=@Year
select @PrevAmount=@Amount
fetch next from TheCursor into @Year,@Amount
END
close TheCursor
deallocate TheCursor
select @Sql='select TOP '+convert(varchar(2),@TopYears)+' max(TheYear) Year,
sum(Amount) Amount,sum(Amount)/count(TransactionNumber) as Average,convert(varchar(25),max(Calc))+''%'' Calc from #Trends
group by TheYear order by max(TheYear) Desc'
exec (@Sql)
END
if @SelectType='Donor History'
BEGIN
select @Sql='insert into #FRDonationHistory (TransactionNumber,InvoiceRefNum,TransactionDate,GiftType,MatchOrSoftCredit,
SourceSystem,Campaign,Fund,Product,Amount,PaymentAmount,AdjustmentFlag,Include) 
select TransactionNumber,InvoiceRefNum,max(TransactionDate) TransactionDate,max(GiftType) GiftType,
max(MatchOrSoftCredit) MatchOrSoftCredit,max(SourceSystem) SourceSystem,max(Campaign) Campaign,max(Fund) Fund,max(Product) Product,
sum(Amount) Amount,sum(PaymentAmount) PaymentAmount,max(AdjustmentFlag) AdjustmentFlag,max(Include) Include
from #FRDonation group by TransactionNumber,InvoiceRefNum,Product'
exec (@Sql)
select max(ID) ID,OriginalTransNumber,max(TransactionNumber) TransactionNumber,
max(DateReceived) DateReceived,max(InvoiceRefNum) InvoiceRefNum,sum(PaymentAmount) PaymentAmount,
max(GiftType) GiftType,max(FiscalPeriod) FiscalPeriod into #TempPayments from #FRPayment group by OriginalTransNumber
delete #FRPayment
insert #FRPayment select * from #TempPayments
update #FRDonationHistory set #FRDonationHistory.PaymentAmount=#FRPayment.PaymentAmount from #FRDonationHistory
join #FRPayment on #FRPayment.OriginalTransNumber=#FRDonationHistory.TransactionNumber
where #FRPayment.OriginalTransNumber=#FRDonationHistory.TransactionNumber and #FRDonationHistory.GiftType<>''
update #FRDonationHistory set Product='' where GiftType='' -- jf - dt17506
if @FromDate<>''
BEGIN
delete #FRDonationHistory where TransactionDate<@FromDate
END
if @ThroughDate<>''
BEGIN
delete #FRDonationHistory where TransactionDate>@ThroughDate
END
select @MidTermAmount=0.00
if @IncludeMidTerm=1
begin
select @MidTermAmount=isnull(sum(PaymentAmount),0) from #FRPayment where GiftType='Pledge Payment'
and TransactionNumber not in (select TransactionNumber from #FRDonationHistory)
end

select @HistoryRowCount=0
select @HistoryRowCount=count(*) from #FRDonationHistory

if @HistoryRowCount>0 -- jf - 23 jan 07 -- dt18065
		      -- this ensures we get the midterm amount if there are no history rows..
BEGIN
select @Sql='select TransactionNumber,max(InvoiceRefNum),max(TransactionDate) Date,max(GiftType) Type,SourceSystem Source,
max(Campaign) Campaign,max(Fund) Fund,max(Product) Distribution_Product_Function,
sum(Amount) Total_Donation,sum(PaymentAmount) Amount_Paid,max(AdjustmentFlag) Adj,
case
when max(SourceSystem)=''Event'' then 0 
when max(MatchOrSoftCredit)=''Soft Credit'' then 0
else sum(Amount)-sum(PaymentAmount) end as Balance,'
+convert(varchar(10),@MidTermAmount)+' as MidTermAmount 
from #FRDonationHistory'
if @Include>0
begin
select @Sql=@Sql+' where Include='+convert(varchar(1),@Include)+' group by TransactionNumber,SourceSystem'
end
else
begin
select @Sql=@Sql+' group by TransactionNumber,SourceSystem'
end 
if @FromAmount>0 and @ThroughAmount>0
BEGIN
select @Sql=@Sql+' having sum(Amount)>='+convert(varchar(10),@FromAmount)
+' and sum(Amount)<='+convert(varchar(10),@ThroughAmount)
END
if @FromAmount>0 and @ThroughAmount=0
BEGIN
select @Sql=@Sql+' having sum(Amount)>='+convert(varchar(10),@FromAmount)
END
if @FromAmount=0 and @ThroughAmount>0
BEGIN
select @Sql=@Sql+' having isnull(sum(Amount),0)<='+convert(varchar(10),@ThroughAmount)
END
if @IncludeWrittenOff=0
BEGIN
select @Sql=@Sql+
case 
when @FromAmount>0 or @ThroughAmount>0
then ' and sum(Amount)>0.00'
else ' having sum(Amount)>0.00'
end
END
END -- if row count
ELSE
BEGIN
select @Sql='select 0 TransactionNumber,0 InvoiceRefNum,'''' Date,'''' Type,'''' Source,
'''' Campaign,'''' Fund,'''' Distribution_Product_Function,0.00 Total_Donation,0.00 Amount_Paid,0 Adj,0 Balance,
' +convert(varchar(10),@MidTermAmount)+' MidTermAmount'
END
exec (@Sql)
END



GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEGetFundraisingSources]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEGetFundraisingSources]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[BAEGetFundraisingSources] 
	-- Add the parameters for the stored procedure here
	@Id varchar(10)
AS
BEGIN
exec sp_asi_FRDonations @Id,1,1,1,1,1,1,1,1,1,'','','','','',0,0,'Summary1',0,30, 'Donations'
END



-----------------------------------
--  Fixes orders so that it goes --
--  by BT_ID not ST_ID           --
-----------------------------------
set ANSI_NULLS ON
set QUOTED_IDENTIFIER ON

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEGetImisLoginInformation]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEGetImisLoginInformation]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEGetImisLoginInformation] @pUsername as
varchar(60)
AS
	SELECT * FROM
	Name_Security
	WHERE
	WEB_LOGIN = @pUsername;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEGetPrefixLabels]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEGetPrefixLabels]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[BAEGetPrefixLabels]
AS
	DECLARE @prefixDescription varchar(255)
	DECLARE @prefix table(code varchar(60), description varchar(255))

	DECLARE PrefixCursor CURSOR	-- Declare the cursor and get all of the distinct description values
	READ_ONLY
	FOR 
	SELECT DISTINCT DESCRIPTION 
	FROM Gen_Tables
	WHERE TABLE_NAME = 'PREFIX' AND (LEN(RTRIM(LTRIM(DESCRIPTION))) > 0) 

	OPEN 	PrefixCursor	-- Open the cursor

	FETCH NEXT FROM PrefixCursor INTO @prefixDescription
	WHILE (@@fetch_status <> -1)	-- Loop through results
	BEGIN
		
		-- Select the first code in the table based on the description and store that in the table variable @suffix
		INSERT INTO @prefix(code, description)
		SELECT TOP 1 CODE, @prefixDescription
		FROM Gen_Tables g
		WHERE TABLE_NAME = 'PREFIX' and DESCRIPTION = @prefixDescription


		FETCH NEXT FROM PrefixCursor INTO @prefixDescription	--Get the next record/description
	END

	-- get rid of the cursor
	CLOSE PrefixCursor
	DEALLOCATE PrefixCursor

	-- Return all of the values from the suffix table variable which will include distinct descriptions and the associated codes
	SELECT * FROM @prefix


---------------------------------------
---------------------------------------
-- FIX FOR ORDER CATEGORIES.         --
--                                   --
-- THERE MUST BE A CATEGORY WITH THE --
-- ID OF 1                           --
---------------------------------------
---------------------------------------

SET IDENTITY_INSERT [dbo].[OrderCategory] ON

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEGetSuffixLabels]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEGetSuffixLabels]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure [dbo].[BAEGetSuffixLabels] as
	DECLARE @suffixDescription varchar(255)
	DECLARE @suffix table(code varchar(60), description varchar(255))

	DECLARE SuffixCursor CURSOR -- Declare the cursor and get all of the distinct description values
	READ_ONLY
	FOR 
	SELECT DISTINCT DESCRIPTION 
	FROM Gen_Tables
	WHERE TABLE_NAME = 'SUFFIX' AND (LEN(RTRIM(LTRIM(DESCRIPTION))) > 0) 

	OPEN 	SuffixCursor	-- Open the cursor

	FETCH NEXT FROM SuffixCursor INTO @suffixDescription	-- Get the first record
	WHILE (@@fetch_status <> -1)	-- Loop through results
	BEGIN
		
		-- Select the first code in the table based on the description and store that in the table variable @suffix
		INSERT INTO @suffix(code, description)
		SELECT TOP 1 CODE, @suffixDescription
		FROM Gen_Tables g
		WHERE TABLE_NAME = 'SUFFIX' and DESCRIPTION = @suffixDescription

		FETCH NEXT FROM SuffixCursor INTO @suffixDescription	--Get the next record/description
	END

	-- get rid of the cursor
	CLOSE SuffixCursor
	DEALLOCATE SuffixCursor

	-- Return all of the values from the suffix table variable which will include distinct descriptions and the associated codes
	SELECT * FROM @suffix
---------------------------------
set ANSI_NULLS ON
set QUOTED_IDENTIFIER ON

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEGetSuperProductAttributes]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEGetSuperProductAttributes]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEGetSuperProductAttributes] @SuperProductID int as
SELECT b.OrderSuperProductAttributeID, b.Title, b.Code, a.SortOrder
	FROM OrderSuperProductAttributeLookup AS a
	INNER JOIN OrderSuperProductAttribute AS b ON a.OrderSuperProductAttributeID = b.OrderSuperProductAttributeID
	WHERE a.OrderProductID = @SuperProductID
	ORDER BY a.SortOrder ASC

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEGetSuperProductAttributeValueForProductViewFromCartView]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEGetSuperProductAttributeValueForProductViewFromCartView]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEGetSuperProductAttributeValueForProductViewFromCartView] @pCode varchar(24),
 	@pID int,
 	@attributeID int as
SELECT 	DISTINCT OrderSuperProductAttributeValue.OrderSuperProductAttributeValueID
FROM	OrderSuperProductChildProduct INNER JOIN
	OrderSuperProductChildProductAttribute ON 
	OrderSuperProductChildProduct.OrderSuperProductChildProductID = OrderSuperProductChildProductAttribute.OrderSuperProductChildProductID INNER JOIN
	OrderSuperProductAttributeValue ON 
	OrderSuperProductChildProductAttribute.OrderSuperProductAttributeValueID = OrderSuperProductAttributeValue.OrderSuperProductAttributeValueID INNER JOIN
	OrderSuperProductAttributeLookup ON OrderSuperProductChildProduct.OrderProductID = OrderSuperProductAttributeLookup.OrderProductID
WHERE	(OrderSuperProductChildProduct.OrderProductID = @pID) AND (OrderSuperProductAttributeValue.OrderSuperProductAttributeID = @attributeID) AND 
	(OrderSuperProductChildProduct.ProductCode = @pCode)

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEGetSuperProductAttributeValuesForProductView]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEGetSuperProductAttributeValuesForProductView]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEGetSuperProductAttributeValuesForProductView] @PID int,
 	@PAID int as
SELECT DISTINCT av.Title, av.OrderSuperProductAttributeValueID
	FROM OrderSuperProductAttributeValue AS av INNER JOIN
		OrderSuperProductAttributeLookup AS al ON av.OrderSuperProductAttributeID = al.OrderSuperProductAttributeID INNER JOIN
		OrderSuperProductChildProduct AS cp ON al.OrderProductID = cp.OrderProductID INNER JOIN
		OrderSuperProductChildProductAttribute AS cpa ON av.OrderSuperProductAttributeValueID = cpa.OrderSuperProductAttributeValueID AND 
		cp.OrderSuperProductChildProductID = cpa.OrderSuperProductChildProductID
		INNER JOIN Product_Inventory pinv ON pinv.PRODUCT_CODE COLLATE database_default = cp.ProductCode COLLATE database_default
	WHERE al.OrderProductID = @PID 
	AND (pinv.QUANTITY_AVAILABLE > 0) 
	AND av.OrderSuperProductAttributeID = @PAID

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEGetUserAccessRights]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEGetUserAccessRights]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEGetUserAccessRights] @UID varchar(8) as
--SELECT 1 Granted
SELECT 	*
FROM		Name_Security_Groups
WHERE	ID = @UID AND SECURITY_GROUP = 'administrator';

IF @@rowcount > 0
BEGIN
	SELECT 1 GRANTED;
END
ELSE
BEGIN
	SELECT 0 GRANTED;
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEGetUserBasic]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEGetUserBasic]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEGetUserBasic] @Id varchar(10) as
SELECT * 
	FROM Name
	WHERE ID = @Id

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEHistoryAdd]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEHistoryAdd]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEHistoryAdd] @ip as
varchar(128),
	@description AS varchar(1024),
	@eventType AS varchar(256)
AS
	INSERT INTO History
	(History.EventDate, History.IP, History.[Description], History.EventType)
	VALUES
	(GETDATE(), @ip, @description, @eventType);

	SELECT (CAST (@@IDENTITY AS int)) AS 'HistoryId'

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEHistoryDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEHistoryDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEHistoryDelete] @historyId int as
DELETE FROM History WHERE HistoryID = @historyId

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEHistoryGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEHistoryGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEHistoryGetAll] as
SELECT *
	FROM History
	ORDER BY HistoryID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEHistoryInsert]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEHistoryInsert]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEHistoryInsert] @IP as
varchar(128),
	@Description AS varchar(1024),
	@EventType AS varchar(256)
AS
	INSERT INTO History
	(History.EventDate, History.IP, History.[Description], History.EventType)
	VALUES
	(GETDATE(), @IP, @Description, @EventType);

	SELECT (CAST (@@IDENTITY AS int)) AS 'HistoryId'

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEHistoryLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEHistoryLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEHistoryLoad] @historyId int as
SELECT * FROM History WHERE HistoryID = @historyId

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEHistoryUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEHistoryUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEHistoryUpdate] @HistoryID as
int,
	@EventDate AS datetime,
	@IP AS varchar(128),
	@Description AS varchar(1024),
	@EventType AS varchar(256)
AS
	UPDATE History
	SET 
	EventDate = 		@EventDate,			
	IP = 	@IP,			
	Description = @Description,				
	EventType = @EventType			

	WHERE HistoryID = @HistoryID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisActivityGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisActivityGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisActivityGetAll] as
SELECT * FROM Activity
	ORDER BY SEQN

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisActivityGetAllByUserIdActivityType]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisActivityGetAllByUserIdActivityType]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisActivityGetAllByUserIdActivityType] @UserId as
varchar(10),
	@ActivityType	AS	varchar(10)
AS
	SELECT * FROM Activity
	WHERE ID = @UserId AND ACTIVITY_TYPE = @ActivityType
	ORDER BY SEQN

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisActivityGetAllByUserIdActivityTypeDate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisActivityGetAllByUserIdActivityTypeDate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisActivityGetAllByUserIdActivityTypeDate] @UserId as
varchar(10),
	@ActivityType	AS	varchar(10),
	@StartDate 	AS	DateTime,
	@EndDate	AS	DateTime
AS
	SELECT * FROM Activity
	WHERE ID = @UserId AND ACTIVITY_TYPE = @ActivityType AND TRANSACTION_DATE BETWEEN @StartDate AND @EndDate
	ORDER BY SEQN DESC

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisActivityLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisActivityLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisActivityLoad] @SEQN as
int
AS
	SELECT * 
	FROM Activity 
	WHERE SEQN = @SEQN;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisCashAccountsGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisCashAccountsGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisCashAccountsGetAll] as
SELECT * FROM Cash_Accounts
	ORDER BY CASH_ACCOUNT_CODE

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisCashAccountsLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisCashAccountsLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisCashAccountsLoad] @CASH_ACCOUNT_CODE as
varchar(10)
AS
	SELECT * 
	FROM Cash_Accounts 
	WHERE CASH_ACCOUNT_CODE = @CASH_ACCOUNT_CODE;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisCCAuthAcctGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisCCAuthAcctGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisCCAuthAcctGetAll] as
SELECT * FROM CCAuthAcct
	ORDER BY CCAuthAcctCode

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisCCAuthAcctGetByCashAccount]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisCCAuthAcctGetByCashAccount]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisCCAuthAcctGetByCashAccount] @CAC varchar(10) as
SELECT *
	FROM CCAuthAcct
	WHERE CCAuthAcctCode = (
		SELECT CCAuthAcctCode 
		FROM Cash_Accounts 
		WHERE CASH_ACCOUNT_CODE = @CAC)

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisCCAuthAcctLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisCCAuthAcctLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisCCAuthAcctLoad] @CCAuthAcctCode as
varchar
AS
	SELECT * 
	FROM CCAuthAcct 
	WHERE CCAuthAcctCode = @CCAuthAcctCode;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisCountry_NamesGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisCountry_NamesGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisCountry_NamesGetAll] as
SELECT * 
	FROM Country_Names
	ORDER BY COUNTRY;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisCountry_NamesLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisCountry_NamesLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisCountry_NamesLoad] @COUNTRY as
varchar(25)
	AS
	SELECT * 
	FROM Country_Names
	WHERE 
		COUNTRY	=	@COUNTRY;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisDuesProductGetSourceFieldFromNameAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisDuesProductGetSourceFieldFromNameAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[BAEImisDuesProductGetSourceFieldFromNameAll] 
      -- Add the parameters for the stored procedure here
      @field varchar(4000),
      @ID varchar(10)
AS
BEGIN
      -- SET NOCOUNT ON added to prevent extra result sets from
      -- interfering with SELECT statements.
      SET NOCOUNT ON;
	Declare @imisTableName as varchar(56);
	SET @imisTableName = 'Name_All';

   Declare @sql nvarchar(4000);
      SET @sql = 'SELECT ' + REPLACE(@field, 'Name_All' ,@imisTableName) + ' FROM Name_All where Name_All.ID = ''' + @ID + ''';'

      exec sp_executesql @sql;
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisDuesUpdatePrice]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisDuesUpdatePrice]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [dbo].[BAEImisDuesUpdatePrice]
	-- Add the parameters for the stored procedure here
	@Id as varchar(10),
	@ProductCode as varchar(31),
	@Price as money
	
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	UPDATE Subscriptions 
	SET BILL_AMOUNT = @Price, BALANCE = @Price, BEGIN_DATE = null, 
		PAID_THRU = null, FIRST_SUBSCRIBED = null
	WHERE ID = @Id and PRODUCT_CODE = @ProductCode;

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisExchangeRateLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisExchangeRateLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[BAEImisExchangeRateLoad]
	@CurrencyCode varchar(3)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	SELECT * from Exchange_Rate where @CurrencyCode = CurrencyCode
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisGetCustomTableColumn]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisGetCustomTableColumn]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisGetCustomTableColumn] @TableName as
varchar(30),
	@FieldName AS varchar(30),
	@UserId AS varchar(10)
AS
	DECLARE @SQLString 	AS	NVARCHAR(1000)
	SET @SQLString = N'SELECT ' + @FieldName + ' FROM ' + @TableName + ' WHERE ID = ' + @UserId + ';'
	EXECUTE sp_executesql @SQLString

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisGetMeetMaster]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisGetMeetMaster]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisGetMeetMaster] @meetingId varchar(10) as
SELECT * FROM Meet_Master WHERE MEETING = @meetingId

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisGetMemberType]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisGetMemberType]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisGetMemberType] @memberType varchar(5) as
SELECT * FROM Member_Types WHERE MEMBER_TYPE = @memberType

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisGetNameAddress]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisGetNameAddress]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisGetNameAddress] @userId varchar(10),
 	@addressNum int as
SELECT * FROM Name_Address WHERE ID = @userId AND ADDRESS_NUM = @addressNum

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisGetProduct]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisGetProduct]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisGetProduct] @productCode varchar(31) as
SELECT * FROM Product WHERE PRODUCT_CODE = @productCode

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisGetProductFunction]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisGetProductFunction]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisGetProductFunction] @productCode varchar(31) as
SELECT * FROM Product_Function WHERE PRODUCT_CODE = @productCode

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisGetProductFunctions]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisGetProductFunctions]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[BAEImisGetProductFunctions] @eventCode varchar(31)
AS
SELECT Product_Function.* FROM [dbo].[Product_Function] 
	LEFT OUTER JOIN [dbo].[Product] ON Product_Function.[PRODUCT_CODE] = Product.[PRODUCT_CODE]
	WHERE Product.[PRODUCT_MAJOR] = @eventCode
	ORDER BY Product.[PRODUCT_CODE]

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisGetProductPrice]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisGetProductPrice]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisGetProductPrice] @productCode varchar(31),
 	@customerType varchar(10) as
SELECT * FROM Product_Price WHERE PRODUCT_CODE = @productCode AND CUSTOMER_TYPE = @customerType

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisIsoCurrencyCodesGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisIsoCurrencyCodesGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[BAEImisIsoCurrencyCodesGetAll]
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	SELECT * from Iso_Currency_Codes
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisIsoCurrencyCodesGetAllWithExchangeRate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisIsoCurrencyCodesGetAllWithExchangeRate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[BAEImisIsoCurrencyCodesGetAllWithExchangeRate]
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	SELECT * from Iso_Currency_Codes where CurrencyCode IN (Select CurrencyCode from Exchange_Rate)
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisMemberTypesGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisMemberTypesGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [dbo].[BAEImisMemberTypesGetAll]
	-- Add the parameters for the stored procedure here
AS
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	SELECT * FROM Member_Types;


-----------------------------------


SET ANSI_NULLS OFF

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisNameAddressGet]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisNameAddressGet]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisNameAddressGet] @Id varchar(10),
 	@addressnum int as
SELECT * FROM Name_Address WHERE ADDRESS_NUM = @addressnum AND ID = @Id

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisNameAddressGetAllForUser]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisNameAddressGetAllForUser]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisNameAddressGetAllForUser] @Id varchar(10) as
SELECT ADDRESS_NUM
	FROM Name_Address
	WHERE ID = @Id

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisNameAddressGetByPurpose]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisNameAddressGetByPurpose]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisNameAddressGetByPurpose] @Id varchar(10),
 	@addressPurpose varchar(20) as
SELECT ADDRESS_NUM
	FROM Name_Address
	WHERE ID = @Id AND PURPOSE = @addressPurpose

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisNameAddressGetPreferredBill]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisNameAddressGetPreferredBill]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisNameAddressGetPreferredBill] @Id varchar(10) as
SELECT DISTINCT ADDRESS_NUM
	FROM Name_Address
	WHERE ID = @Id AND PREFERRED_BILL = 1

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisNameAddressGetPreferredMail]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisNameAddressGetPreferredMail]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisNameAddressGetPreferredMail] @Id varchar(10) as
SELECT DISTINCT ADDRESS_NUM
	FROM Name_Address
	WHERE ID = @Id AND PREFERRED_MAIL = 1

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisNameAddressGetPurposes]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisNameAddressGetPurposes]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisNameAddressGetPurposes] as
SELECT ShortValue AS 'Purpose'
	FROM System_Params
	WHERE ParameterName LIKE 'Member_Control.Addr_Prompt'

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisNameAddressGetPurposesForUser]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisNameAddressGetPurposesForUser]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisNameAddressGetPurposesForUser] @Id varchar(10) as
SELECT DISTINCT ADDRESS_NUM
	FROM Name_Address
	WHERE ID = @Id

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisNameFinGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisNameFinGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisNameFinGetAll] AS
BEGIN
	SELECT * from Name_Fin;
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisNameFinGetTaxAuthor]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisNameFinGetTaxAuthor]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisNameFinGetTaxAuthor] @UserId varchar(64) as
SELECT TAX_AUTHOR_DEFAULT
	FROM Name_Fin
	WHERE ID = @UserId

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisNameFinGetTaxExemption]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisNameFinGetTaxExemption]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisNameFinGetTaxExemption] @UserID varchar(64) as
SELECT TAX_EXEMPT
	FROM Name_Fin
	WHERE ID = @UserID

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisNameFinLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisNameFinLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisNameFinLoad] @ID varchar(255) AS
BEGIN

    -- Insert statements for procedure here
	SELECT * from Name_Fin where ID = @ID;
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisNameGet]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisNameGet]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisNameGet] @Id varchar(10) as
SELECT * 
	FROM Name
	WHERE ID = @Id

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisNameGetAddressNumAndPurposeForUser]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisNameGetAddressNumAndPurposeForUser]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[BAEImisNameGetAddressNumAndPurposeForUser] 
@Id varchar(10) AS
SELECT ADDRESS_NUM, PURPOSE
	FROM Name_Address
	WHERE ID = @Id

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisNameGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisNameGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisNameGetAll] as
SELECT ID
	FROM Name

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisNameGetAllByCompanyId]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisNameGetAllByCompanyId]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisNameGetAllByCompanyId] @companyId varchar(5) as
SELECT ID
	FROM Name
	WHERE CO_ID = @companyId

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisNameGetAllByMemberType]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisNameGetAllByMemberType]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisNameGetAllByMemberType] @memberType varchar(5) as
SELECT ID
	FROM Name
	WHERE MEMBER_TYPE = @memberType

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisNameLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisNameLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisNameLoad] @userID varchar(64) as
SELECT * 
	FROM Name 
	WHERE ID = @userID

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisNameSecurityAdd]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisNameSecurityAdd]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisNameSecurityAdd] @Id varchar(10),
 	@loginDisabled bit,
 	@expirationDate datetime,
 	@lastlogin datetime,
 	@previousLogin datetime,
 	@webLogin varchar(60),
 	@password varchar(100) as
INSERT INTO Name_Security(ID, LOGIN_DISABLED, EXPIRATION_DATE, LAST_LOGIN, PREVIOUS_LOGIN, WEB_LOGIN, [PASSWORD])
	Values(@Id, @loginDisabled, @expirationDate, @lastlogin, @previousLogin, @webLogin,@password)

	SELECT @@Identity AS 'Id'

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisNameSecurityGet]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisNameSecurityGet]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisNameSecurityGet] @Id varchar(10) as
SELECT *
	FROM Name_Security
	WHERE ID = @Id

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisNameSecurityGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisNameSecurityGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisNameSecurityGetAll] as
SELECT *
	FROM Name_Security

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisNameSecurityGetByWebLogin]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisNameSecurityGetByWebLogin]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisNameSecurityGetByWebLogin] @Id varchar(60) as
SELECT *
	FROM Name_Security
	WHERE WEB_LOGIN = @Id

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisNameSecurityGroupsAdd]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisNameSecurityGroupsAdd]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisNameSecurityGroupsAdd] @Id varchar(10),
 	@securityGroup varchar(30) as
INSERT INTO Name_Security_Groups([ID], SECURITY_GROUP)
	VALUES(@Id, @securityGroup)

	SELECT @@Identity AS 'Id'

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisNameSecurityGroupsDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisNameSecurityGroupsDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisNameSecurityGroupsDelete] @Id varchar(10) as
DELETE FROM Name_Security_Groups
	WHERE ID = @Id

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisNameSecurityGroupsGet]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisNameSecurityGroupsGet]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisNameSecurityGroupsGet] @Id varchar(10) as
SELECT *
	FROM Name_Security_Groups
	WHERE ID = @Id

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisNameSecurityGroupsGetAllBySecurityGroup]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisNameSecurityGroupsGetAllBySecurityGroup]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisNameSecurityGroupsGetAllBySecurityGroup] @securityGroup varchar(30) as
SELECT ID
	FROM Name_Security_Groups
	WHERE SECURITY_GROUP = @securityGroup

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisNameSecurityGroupsSave]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisNameSecurityGroupsSave]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisNameSecurityGroupsSave] @Id varchar(10),
 	@securityGroup varchar(30) as
UPDATE Name_Security_Groups
	SET SECURITY_GROUP = @securityGroup
	WHERE ID = @Id

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisNameSecuritySave]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisNameSecuritySave]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisNameSecuritySave] @Id varchar(10),
 	@loginDisabled bit,
 	@expirationDate datetime,
 	@lastlogin datetime,
 	@previousLogin datetime,
 	@webLogin varchar(60),
 	@password varchar(100) as
UPDATE Name_Security
	SET LOGIN_DISABLED = @loginDisabled, 
		EXPIRATION_DATE = @expirationDate, 
		LAST_LOGIN = @lastlogin, 
		PREVIOUS_LOGIN = @previousLogin, 
		WEB_LOGIN = @webLogin,
		[PASSWORD] = @password
	WHERE ID = @Id

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisOrderbadgeInsert]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisOrderbadgeInsert]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisOrderbadgeInsert] @ORDER_NUMBER as
float,
	@BADGE_NUMBER AS int,
	@BADGE_TYPE AS varchar(10),
	@FULL_NAME AS varchar(60),
	@TITLE AS varchar(80),
	@COMPANY AS varchar(80),
	@FULL_ADDRESS AS varchar(255),
	@PREFIX AS varchar(10),
	@FIRST_NAME AS varchar(20),
	@MIDDLE_NAME AS varchar(20),
	@LAST_NAME AS varchar(30),
	@SUFFIX AS varchar(10),
	@DESIGNATION AS varchar(20),
	@INFORMAL AS varchar(20),
	@ADDRESS_1 AS varchar(40),
	@ADDRESS_2 AS varchar(40),
	@CITY AS varchar(40),
	@STATE_PROVINCE AS varchar(15),
	@ZIP AS varchar(10),
	@COUNTRY AS varchar(25),
	@BAR_CODE AS varchar(14),
	@DELEGATE AS varchar(10),
	@ST_PRINT_COMPANY AS bit,
	@ST_PRINT_TITLE AS bit
AS
	INSERT INTO Order_Badge
	(
	ORDER_NUMBER,
	BADGE_NUMBER,
	BADGE_TYPE,
	FULL_NAME,
	TITLE,
	COMPANY,
	FULL_ADDRESS,
	PREFIX,
	FIRST_NAME,
	MIDDLE_NAME,
	LAST_NAME,
	SUFFIX,
	DESIGNATION,
	INFORMAL,
	ADDRESS_1,
	ADDRESS_2,
	CITY,
	STATE_PROVINCE,
	ZIP,
	COUNTRY,
	BAR_CODE,
	DELEGATE,
	ST_PRINT_COMPANY,
	ST_PRINT_TITLE
	)
	VALUES 
	(
	@ORDER_NUMBER,
	@BADGE_NUMBER,
	@BADGE_TYPE,
	@FULL_NAME,
	@TITLE,
	@COMPANY,
	@FULL_ADDRESS,
	@PREFIX,
	@FIRST_NAME,
	@MIDDLE_NAME,
	@LAST_NAME,
	@SUFFIX,
	@DESIGNATION,
	@INFORMAL,
	@ADDRESS_1,
	@ADDRESS_2,
	@CITY,
	@STATE_PROVINCE,
	@ZIP,
	@COUNTRY,
	@BAR_CODE,
	@DELEGATE,
	@ST_PRINT_COMPANY,
	@ST_PRINT_TITLE
	
);

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisOrderbadgeUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisOrderbadgeUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisOrderbadgeUpdate] @ORDER_NUMBER as
float,
	@BADGE_NUMBER AS int,
	@BADGE_TYPE AS varchar(10),
	@FULL_NAME AS varchar(60),
	@TITLE AS varchar(80),
	@COMPANY AS varchar(80),
	@FULL_ADDRESS AS varchar(255),
	@PREFIX AS varchar(10),
	@FIRST_NAME AS varchar(20),
	@MIDDLE_NAME AS varchar(20),
	@LAST_NAME AS varchar(30),
	@SUFFIX AS varchar(10),
	@DESIGNATION AS varchar(20),
	@INFORMAL AS varchar(20),
	@ADDRESS_1 AS varchar(40),
	@ADDRESS_2 AS varchar(40),
	@CITY AS varchar(40),
	@STATE_PROVINCE AS varchar(15),
	@ZIP AS varchar(10),
	@COUNTRY AS varchar(25),
	@BAR_CODE AS varchar(14),
	@DELEGATE AS varchar(10),
	@ST_PRINT_COMPANY AS bit,
	@ST_PRINT_TITLE AS bit
AS
	SELECT * FROM Order_Badge WHERE ORDER_NUMBER = @ORDER_NUMBER AND BADGE_NUMBER = @BADGE_NUMBER
	if(@@ROWCOUNT > 0)
		BEGIN
			UPDATE Order_Badge
			SET
			BADGE_TYPE	=	@BADGE_TYPE,
			FULL_NAME	=	@FULL_NAME,
			TITLE	=	@TITLE,
			COMPANY	=	@COMPANY,
			FULL_ADDRESS	=	@FULL_ADDRESS,
			PREFIX	=	@PREFIX,
			FIRST_NAME	=	@FIRST_NAME,
			MIDDLE_NAME	=	@MIDDLE_NAME,
			LAST_NAME	=	@LAST_NAME,
			SUFFIX	=	@SUFFIX,
			DESIGNATION	=	@DESIGNATION,
			INFORMAL	=	@INFORMAL,
			ADDRESS_1	=	@ADDRESS_1,
			ADDRESS_2	=	@ADDRESS_2,
			CITY	=	@CITY,
			STATE_PROVINCE	=	@STATE_PROVINCE,
			ZIP	=	@ZIP,
			COUNTRY	=	@COUNTRY,
			BAR_CODE	=	@BAR_CODE,
			DELEGATE	=	@DELEGATE,
			ST_PRINT_COMPANY	=	@ST_PRINT_COMPANY,
			ST_PRINT_TITLE	=	@ST_PRINT_TITLE
			WHERE ORDER_NUMBER = @ORDER_NUMBER AND BADGE_NUMBER = @BADGE_NUMBER
		END
	ELSE
		BEGIN
 			INSERT INTO Order_Badge
	(
	BADGE_NUMBER,
	BADGE_TYPE,
	FULL_NAME,
	TITLE,
	COMPANY,
	FULL_ADDRESS,
	PREFIX,
	FIRST_NAME,
	MIDDLE_NAME,
	LAST_NAME,
	SUFFIX,
	DESIGNATION,
	INFORMAL,
	ADDRESS_1,
	ADDRESS_2,
	CITY,
	STATE_PROVINCE,
	ZIP,
	COUNTRY,
	BAR_CODE,
	DELEGATE,
	ST_PRINT_COMPANY,
	ST_PRINT_TITLE
	)
	VALUES 
	(
	@BADGE_NUMBER,
	@BADGE_TYPE,
	@FULL_NAME,
	@TITLE,
	@COMPANY,
	@FULL_ADDRESS,
	@PREFIX,
	@FIRST_NAME,
	@MIDDLE_NAME,
	@LAST_NAME,
	@SUFFIX,
	@DESIGNATION,
	@INFORMAL,
	@ADDRESS_1,
	@ADDRESS_2,
	@CITY,
	@STATE_PROVINCE,
	@ZIP,
	@COUNTRY,
	@BAR_CODE,
	@DELEGATE,
	@ST_PRINT_COMPANY,
	@ST_PRINT_TITLE
	
);
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisOrderEventGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisOrderEventGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisOrderEventGetAll] @ORDER_NUMBER as
float
AS
	SELECT * 
	FROM Order_Meet
	WHERE ORDER_NUMBER	=	@ORDER_NUMBER
	ORDER BY ORDER_NUMBER;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisOrderEventLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisOrderEventLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisOrderEventLoad] @ORDER_NUMBER as
float
AS
	SELECT * 
	FROM Order_Meet
	WHERE 
		ORDER_NUMBER	=	@ORDER_NUMBER;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisOrderGuestGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisOrderGuestGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisOrderGuestGetAll] @ORDER_NUMBER as
float
AS
	SELECT * 
	FROM Order_Badge
	WHERE ORDER_NUMBER	=	@ORDER_NUMBER
	ORDER BY ORDER_NUMBER;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisOrderGuestLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisOrderGuestLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisOrderGuestLoad] @ORDER_NUMBER as
float,
		@BADGE_NUMBER 	AS	int
AS
	SELECT * 
	FROM Order_Badge
	WHERE 
		ORDER_NUMBER	=	@ORDER_NUMBER AND
		BADGE_NUMBER 	=	@BADGE_NUMBER;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisOrderLineGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisOrderLineGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisOrderLineGetAll] @ORDER_NUMBER as
float
AS
	SELECT * 
	FROM Order_Lines
	WHERE ORDER_NUMBER	=	@ORDER_NUMBER
	ORDER BY LINE_NUMBER;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisOrderLineLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisOrderLineLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisOrderLineLoad] @ORDER_NUMBER as
float,
		@LINE_NUMBER 	AS	float
AS
	SELECT * 
	FROM Order_Lines
	WHERE 
		ORDER_NUMBER	=	@ORDER_NUMBER AND
		LINE_NUMBER 	=	@LINE_NUMBER;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisOrdersGet]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisOrdersGet]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisOrdersGet] @orderNumber int as
SELECT * 
	FROM Orders
	WHERE ORDER_NUMBER = @orderNumber;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisOrdersGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisOrdersGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisOrdersGetAll] as
SELECT * 
	FROM Orders
	ORDER BY ORDER_NUMBER;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisOrdersGetAllByUser]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisOrdersGetAllByUser]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisOrdersGetAllByUser] @USER_ID as
varchar(16)
AS
	SELECT * 
	FROM Orders
	WHERE ST_ID 		=	@USER_ID
	ORDER BY ORDER_NUMBER DESC;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisOrdersGetAllUsersByDateRange]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisOrdersGetAllUsersByDateRange]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure [dbo].[BAEImisOrdersGetAllUsersByDateRange] @USERID as
varchar(10),
		@START_DATE 	AS 	datetime,
		@END_DATE		AS	datetime
AS
	SELECT * 
	FROM Orders
	WHERE BT_ID = @USERID AND ORDER_DATE BETWEEN @START_DATE AND @END_DATE
	ORDER BY ORDER_NUMBER DESC;


----------------------------------


set ANSI_NULLS ON
set QUOTED_IDENTIFIER ON

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisOrdersLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisOrdersLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisOrdersLoad] @ORDER_NUMBER as
float
AS
	SELECT * 
	FROM Orders
	WHERE 
		ORDER_NUMBER	=	@ORDER_NUMBER;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisOrdersSearch]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisOrdersSearch]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisOrdersSearch] @USER_ID as
varchar(10),
		@LAST_NAME AS varchar(50),
		@COMPANY AS varchar(50)
AS
	SELECT * FROM Orders 
	WHERE ST_ID LIKE (@USER_ID + '%') AND (LAST_NAME LIKE (@LAST_NAME + '%') AND COMPANY LIKE (@COMPANY + '%'))
	ORDER BY ORDER_DATE DESC

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisProductFunctionGetRegistrationCount]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisProductFunctionGetRegistrationCount]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisProductFunctionGetRegistrationCount] @productCode varchar(64) as
SELECT CONVERT(int, LTD_QUANTITY) AS 'NumberRegistered'
	FROM Product_Inventory 
	WHERE PRODUCT_CODE = @productCode

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisProductGetAllBilling]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisProductGetAllBilling]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[BAEImisProductGetAllBilling] 
AS
    SELECT p.[PRODUCT_CODE], p.[PRODUCT_MAJOR], p.[PRODUCT_MINOR], p.[PROD_TYPE], p.[CATEGORY], p.[TITLE_KEY], p.[TITLE], 
           p.[DESCRIPTION], p.[STATUS], p.[NOTE], p.[GROUP_1], p.[GROUP_2], p.[GROUP_3], p.[PRICE_RULES_EXIST], p.[LOT_SERIAL_EXIST], 
           p.[PAYMENT_PRIORITY], p.[RENEW_MONTHS], p.[PRORATE], p.[STOCK_ITEM], p.[UNIT_OF_MEASURE], p.[WEIGHT], p.[TAXABLE], 
           p.[COMMISIONABLE], p.[COMMISION_PERCENT], p.[DECIMAL_POINTS], p.[INCOME_ACCOUNT], p.[DEFERRED_INCOME_ACCOUNT], 
           p.[INVENTORY_ACCOUNT], p.[ADJUSTMENT_ACCOUNT], p.[COG_ACCOUNT], p.[INTENT_TO_EDIT], p.[PRICE_1], p.[PRICE_2], p.[PRICE_3], 
           p.[COMPLIMENTARY], p.[ATTRIBUTES], p.[PST_TAXABLE], p.[TAXABLE_VALUE], p.[ORG_CODE], p.[TAX_AUTHORITY], p.[WEB_OPTION], 
           p.[IMAGE_URL], p.[APPLY_IMAGE], p.[IS_KIT], p.[INFO_URL], p.[APPLY_INFO], p.[PLP_CODE], p.[PROMOTE], p.[THUMBNAIL_URL], 
           p.[APPLY_THUMBNAIL], p.[CATALOG_DESC], p.[WEB_DESC], p.[OTHER_DESC], p.[LOCATION], p.[PREMIUM], p.[FAIR_MARKET_VALUE], 
           p.[IS_FR_ITEM], p.[APPEAL_CODE], p.[CAMPAIGN_CODE], p.[TIME_STAMP], p.[ProductKey]
      FROM [dbo].[Product] p
     WHERE p.[PROD_TYPE] IN ('DUES', 'MISC', 'CHAPT', 'SEC', 'SUB', 'VOL')


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisProductGetAllByType]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisProductGetAllByType]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisProductGetAllByType] @ProductType as
varchar(10)
AS
	SELECT * FROM Product
	WHERE PROD_TYPE = @ProductType

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisProductGetProductTaxExemption]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisProductGetProductTaxExemption]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisProductGetProductTaxExemption] @ProductCode varchar(48) as
SELECT TAXABLE 
	FROM Product 
	WHERE PRODUCT_CODE = @ProductCode

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisProductKitGetAllChildren]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisProductKitGetAllChildren]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisProductKitGetAllChildren] @ParentProductCode as
varchar(31)
AS
	SELECT *
	FROM OrderProduct AS op JOIN Product_Kit AS pk ON op.ProductCode COLLATE database_default = pk.ITEM_PRODUCT_CODE COLLATE database_default
	WHERE pk.PRODUCT_CODE = @ParentProductCode;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisProductKitLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisProductKitLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisProductKitLoad] @ProductKitCode as
varchar(31)
AS
	SELECT * 
	FROM Product_Kit AS pk JOIN OrderProduct AS op ON pk.ITEM_PRODUCT_CODE COLLATE database_default = op.ProductCode COLLATE database_default
	WHERE pk.ITEM_PRODUCT_CODE = @ProductKitCode;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisProductLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisProductLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisProductLoad] @ProductCode varchar(64) as
SELECT * 
	FROM Product 
	WHERE PRODUCT_CODE = @ProductCode

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisProductPriceLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisProductPriceLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisProductPriceLoad] @ProductCode varchar(64) as
SELECT * 
	FROM Product_Price 
	WHERE PRODUCT_CODE = @ProductCode

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisProductTaxGetTaxRatio]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisProductTaxGetTaxRatio]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisProductTaxGetTaxRatio] @taxAuth varchar(48) as
SELECT * 
	FROM Product_Tax 
	WHERE PRODUCT_CODE = @taxAuth

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisSecurityGroupsDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisSecurityGroupsDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisSecurityGroupsDelete] @SECURITY_GROUP as
varchar(30)
AS
	DELETE FROM Security_Groups
	WHERE SECURITY_GROUP = @SECURITY_GROUP;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisSecurityGroupsGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisSecurityGroupsGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisSecurityGroupsGetAll] as
SELECT * 
	FROM Security_Groups

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisSecurityGroupsInsert]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisSecurityGroupsInsert]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisSecurityGroupsInsert] @SECURITY_GROUP as
varchar(255),
	@SECURITY_GROUP_DESCR AS varchar(255),
	@WEBKITENABLED	AS 	bit,
	@ADHOCENABLED	AS 	bit,
	@MEMBERSHIPLEVEL	AS 	bit,
	@MEETINGSLEVEL	AS 	bit,
	@SYSTEMLEVEL	AS 	bit,
	@DUESLEVEL	AS 	bit,
	@CASHARLEVEL	AS 	bit,
	@ORDERENTRYLEVEL	AS 	bit,
	@REFERRALLEVEL	AS 	bit,
	@CERTLEVEL	AS 	bit,
	@FRLEVEL	AS 	bit,
	@SECURITY_SEQ	AS 	tinyint,
	@COMMUNITIESLEVEL	AS 	bit
AS
	INSERT INTO Security_Groups
	(
	SECURITY_GROUP,
	SECURITY_GROUP_DESCR,
	WEBKITENABLED,
	ADHOCENABLED,
	MEMBERSHIPLEVEL,
	MEETINGSLEVEL,
	SYSTEMLEVEL,
	DUESLEVEL,
	CASHARLEVEL,
	ORDERENTRYLEVEL,
	REFERRALLEVEL,
	CERTLEVEL,
	FRLEVEL,
	SECURITY_SEQ,
	COMMUNITIESLEVEL)
	VALUES (
	@SECURITY_GROUP,
	@SECURITY_GROUP_DESCR,
	@WEBKITENABLED,
	@ADHOCENABLED,
	@MEMBERSHIPLEVEL,
	@MEETINGSLEVEL,	
	@SYSTEMLEVEL,	
	@DUESLEVEL,	
	@CASHARLEVEL,	
	@ORDERENTRYLEVEL,	
	@REFERRALLEVEL,	
	@CERTLEVEL,	
	@FRLEVEL,
	@SECURITY_SEQ,
	@COMMUNITIESLEVEL
);

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisSecurityGroupsLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisSecurityGroupsLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisSecurityGroupsLoad] @SECURITY_GROUP as
varchar(30)
AS
	SELECT *
	FROM Security_Groups
	WHERE SECURITY_GROUP = @SECURITY_GROUP;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisState_CodesGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisState_CodesGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure [dbo].[BAEImisState_CodesGetAll] as
SELECT * 
	FROM State_Codes
	ORDER BY TITLE;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisState_CodesLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisState_CodesLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisState_CodesLoad] @STATE_PROVINCE as
varchar(15)
AS
	SELECT * 
	FROM State_Codes
	WHERE 
		STATE_PROVINCE	=	@STATE_PROVINCE;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisSubscriptionsGetAllByUser]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisSubscriptionsGetAllByUser]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


CREATE PROCEDURE [dbo].[BAEImisSubscriptionsGetAllByUser] @UserId AS
varchar(10)
AS
    -- Retrieve accrual dues billed to the ID (checking that sys config option 'BillingEnableAccrualOnWeb' is enabled)
    SELECT s.[ID], s.[PRODUCT_CODE], s.[BT_ID], s.[PROD_TYPE], s.[STATUS], s.[BEGIN_DATE], s.[PAID_THRU], s.[COPIES], 
           s.[SOURCE_CODE], s.[FIRST_SUBSCRIBED], s.[CONTINUOUS_SINCE], s.[PRIOR_YEARS], s.[FUTURE_COPIES], 
           s.[FUTURE_COPIES_DATE], s.[PREF_MAIL], s.[PREF_BILL], s.[RENEW_MONTHS], s.[MAIL_CODE], s.[PREVIOUS_BALANCE], 
           s.[BILL_DATE], s.[REMINDER_DATE], s.[REMINDER_COUNT], s.[BILL_BEGIN], s.[BILL_THRU], s.[BILL_AMOUNT], 
           s.[BILL_COPIES], s.[PAYMENT_AMOUNT], s.[PAYMENT_DATE], s.[PAID_BEGIN], s.[LAST_PAID_THRU], s.[COPIES_PAID], 
           s.[ADJUSTMENT_AMOUNT], s.[LTD_PAYMENTS], s.[ISSUES_PRINTED], s.[CANCEL_REASON], s.[YEARS_ACTIVE_STRING], 
           s.[LAST_ISSUE], s.[LAST_ISSUE_DATE], s.[DATE_ADDED], s.[LAST_UPDATED], s.[UPDATED_BY], s.[INTENT_TO_EDIT], 
           s.[FLAG], s.[BILL_TYPE], s.[COMPLIMENTARY], s.[FUTURE_CREDITS], s.[INVOICE_REFERENCE_NUM], s.[INVOICE_LINE_NUM], 
           s.[CAMPAIGN_CODE], s.[APPEAL_CODE], s.[ORG_CODE], s.[IS_FR_ITEM], s.[FAIR_MARKET_VALUE], s.[TIME_STAMP], 
           il.[BALANCE], il.[CHARGES], il.[CREDITS], CAST(1 AS BIT) AS [IsAccrual] 
      FROM dbo.[Subscriptions] s 
           INNER JOIN dbo.[Invoice] i ON s.[INVOICE_REFERENCE_NUM] = i.[REFERENCE_NUM] 
           INNER JOIN dbo.[Invoice_Lines] il ON s.[INVOICE_REFERENCE_NUM] = il.[REFERENCE_NUM] AND s.[INVOICE_LINE_NUM] = il.[LINE_NUM]
     WHERE s.INVOICE_LINE_NUM != 0 
           AND i.BT_ID = @UserId 
           AND 'True' = (SELECT sc.[ParameterValue] 
                           FROM dbo.[SystemConfig] sc
                          WHERE sc.[SystemConfigKey] = 'EF92F6C4-7D6F-4EC9-B656-1AFD7D17442D')
    
    UNION
    
    -- Retrieve cash dues for the ID (regardless of who it's billed to)
    SELECT s.[ID], s.[PRODUCT_CODE], s.[BT_ID], s.[PROD_TYPE], s.[STATUS], s.[BEGIN_DATE], s.[PAID_THRU], s.[COPIES], 
           s.[SOURCE_CODE], s.[FIRST_SUBSCRIBED], s.[CONTINUOUS_SINCE], s.[PRIOR_YEARS], s.[FUTURE_COPIES], 
           s.[FUTURE_COPIES_DATE], s.[PREF_MAIL], s.[PREF_BILL], s.[RENEW_MONTHS], s.[MAIL_CODE], s.[PREVIOUS_BALANCE], 
           s.[BILL_DATE], s.[REMINDER_DATE], s.[REMINDER_COUNT], s.[BILL_BEGIN], s.[BILL_THRU], s.[BILL_AMOUNT], 
           s.[BILL_COPIES], s.[PAYMENT_AMOUNT], s.[PAYMENT_DATE], s.[PAID_BEGIN], s.[LAST_PAID_THRU], s.[COPIES_PAID], 
           s.[ADJUSTMENT_AMOUNT], s.[LTD_PAYMENTS], s.[ISSUES_PRINTED], s.[CANCEL_REASON], s.[YEARS_ACTIVE_STRING], 
           s.[LAST_ISSUE], s.[LAST_ISSUE_DATE], s.[DATE_ADDED], s.[LAST_UPDATED], s.[UPDATED_BY], s.[INTENT_TO_EDIT], 
           s.[FLAG], s.[BILL_TYPE], s.[COMPLIMENTARY], s.[FUTURE_CREDITS], s.[INVOICE_REFERENCE_NUM], s.[INVOICE_LINE_NUM], 
           s.[CAMPAIGN_CODE], s.[APPEAL_CODE], s.[ORG_CODE], s.[IS_FR_ITEM], s.[FAIR_MARKET_VALUE], s.[TIME_STAMP], 
           s.[BALANCE], 0, 0, CAST(0 AS BIT) AS [IsAccrual]  
      FROM dbo.[Subscriptions] s
           INNER JOIN dbo.[Product] p ON s.[PRODUCT_CODE] = p.[PRODUCT_CODE]
     WHERE s.[INVOICE_LINE_NUM] = 0 
           AND s.[ID] = @UserId
           AND p.[WEB_OPTION] = 1



GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisSubscriptionsGetSubscription]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisSubscriptionsGetSubscription]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


CREATE PROCEDURE [dbo].[BAEImisSubscriptionsGetSubscription] @UserId AS
varchar(10),
	@ProductType 	AS	varchar(31)
AS	
    -- Retrieve accrual dues billed to the ID (checking that sys config option 'BillingEnableAccrualOnWeb' is enabled)
    SELECT s.[ID], s.[PRODUCT_CODE], s.[BT_ID], s.[PROD_TYPE], s.[STATUS], s.[BEGIN_DATE], s.[PAID_THRU], s.[COPIES], 
           s.[SOURCE_CODE], s.[FIRST_SUBSCRIBED], s.[CONTINUOUS_SINCE], s.[PRIOR_YEARS], s.[FUTURE_COPIES], 
           s.[FUTURE_COPIES_DATE], s.[PREF_MAIL], s.[PREF_BILL], s.[RENEW_MONTHS], s.[MAIL_CODE], s.[PREVIOUS_BALANCE], 
           s.[BILL_DATE], s.[REMINDER_DATE], s.[REMINDER_COUNT], s.[BILL_BEGIN], s.[BILL_THRU], s.[BILL_AMOUNT], 
           s.[BILL_COPIES], s.[PAYMENT_AMOUNT], s.[PAYMENT_DATE], s.[PAID_BEGIN], s.[LAST_PAID_THRU], s.[COPIES_PAID], 
           s.[ADJUSTMENT_AMOUNT], s.[LTD_PAYMENTS], s.[ISSUES_PRINTED], s.[CANCEL_REASON], s.[YEARS_ACTIVE_STRING], 
           s.[LAST_ISSUE], s.[LAST_ISSUE_DATE], s.[DATE_ADDED], s.[LAST_UPDATED], s.[UPDATED_BY], s.[INTENT_TO_EDIT], 
           s.[FLAG], s.[BILL_TYPE], s.[COMPLIMENTARY], s.[FUTURE_CREDITS], s.[INVOICE_REFERENCE_NUM], s.[INVOICE_LINE_NUM], 
           s.[CAMPAIGN_CODE], s.[APPEAL_CODE], s.[ORG_CODE], s.[IS_FR_ITEM], s.[FAIR_MARKET_VALUE], s.[TIME_STAMP], 
           il.[BALANCE], il.[CHARGES], il.[CREDITS], CAST(1 AS BIT) AS [IsAccrual] 
      FROM dbo.[Subscriptions] s 
           INNER JOIN dbo.[Invoice] i ON s.[INVOICE_REFERENCE_NUM] = i.[REFERENCE_NUM] 
           INNER JOIN dbo.[Invoice_Lines] il ON s.[INVOICE_REFERENCE_NUM] = il.[REFERENCE_NUM] AND s.[INVOICE_LINE_NUM] = il.[LINE_NUM]
     WHERE s.[INVOICE_LINE_NUM] != 0 
           AND i.[BT_ID] = @UserId 
           AND s.[PROD_TYPE] = @ProductType 
           AND 'True' = (SELECT sc.[ParameterValue] 
                           FROM dbo.[SystemConfig] sc
                          WHERE sc.[SystemConfigKey] = 'EF92F6C4-7D6F-4EC9-B656-1AFD7D17442D')
    
    UNION
    
    -- Retrieve cash dues for the ID (regardless of who it's billed to)
    SELECT s.[ID], s.[PRODUCT_CODE], s.[BT_ID], s.[PROD_TYPE], s.[STATUS], s.[BEGIN_DATE], s.[PAID_THRU], s.[COPIES], 
           s.[SOURCE_CODE], s.[FIRST_SUBSCRIBED], s.[CONTINUOUS_SINCE], s.[PRIOR_YEARS], s.[FUTURE_COPIES], 
           s.[FUTURE_COPIES_DATE], s.[PREF_MAIL], s.[PREF_BILL], s.[RENEW_MONTHS], s.[MAIL_CODE], s.[PREVIOUS_BALANCE], 
           s.[BILL_DATE], s.[REMINDER_DATE], s.[REMINDER_COUNT], s.[BILL_BEGIN], s.[BILL_THRU], s.[BILL_AMOUNT], 
           s.[BILL_COPIES], s.[PAYMENT_AMOUNT], s.[PAYMENT_DATE], s.[PAID_BEGIN], s.[LAST_PAID_THRU], s.[COPIES_PAID], 
           s.[ADJUSTMENT_AMOUNT], s.[LTD_PAYMENTS], s.[ISSUES_PRINTED], s.[CANCEL_REASON], s.[YEARS_ACTIVE_STRING], 
           s.[LAST_ISSUE], s.[LAST_ISSUE_DATE], s.[DATE_ADDED], s.[LAST_UPDATED], s.[UPDATED_BY], s.[INTENT_TO_EDIT], 
           s.[FLAG], s.[BILL_TYPE], s.[COMPLIMENTARY], s.[FUTURE_CREDITS], s.[INVOICE_REFERENCE_NUM], s.[INVOICE_LINE_NUM], 
           s.[CAMPAIGN_CODE], s.[APPEAL_CODE], s.[ORG_CODE], s.[IS_FR_ITEM], s.[FAIR_MARKET_VALUE], s.[TIME_STAMP], 
           s.[BALANCE], 0, 0, CAST(0 AS BIT) AS [IsAccrual] 
      FROM dbo.[Subscriptions] s
           INNER JOIN dbo.[Product] p ON s.[PRODUCT_CODE] = p.[PRODUCT_CODE]
     WHERE s.[INVOICE_LINE_NUM] = 0 
           AND s.[ID] = @UserId 
           AND s.[PROD_TYPE] = @ProductType
           AND p.[WEB_OPTION] = 1



GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisSubscriptionsGetSubscriptionByMemberType]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisSubscriptionsGetSubscriptionByMemberType]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/*
	NOTE:

	This stored procedure handles which dues products appear for each member type during the membership
	signup process.  Dues products include the following in iMIS:

	DUES (normal dues)
	CHAPT (chapter dues)
	SEC (section dues)
	VOL (voluntary dues)
	SUB (subscription dues)

	The User ID is passed into this stored proc should there be a need to implement some business logic
	based on the user's information.
*/
CREATE PROCEDURE [dbo].[BAEImisSubscriptionsGetSubscriptionByMemberType]
	@UserID			AS	varchar(10),
	@MemberType 	AS	varchar(5)
	--@ProductType 	AS	varchar(31)
AS
	SELECT prod.* 
	FROM Member_Types AS mt, Product AS prod
	WHERE mt.MEMBER_TYPE = @MemberType AND 
		prod.PROD_TYPE IN ('DUES', 'CHAPT', 'SEC', 'VOL', 'SUB') AND
		(prod.PRODUCT_CODE IN(mt.DUES_CODE_1, mt.DUES_CODE_2, mt.DUES_CODE_3, mt.DUES_CODE_4, mt.DUES_CODE_5,
		mt.DUES_CODE_6, mt.DUES_CODE_7, mt.DUES_CODE_8, mt.DUES_CODE_9, mt.DUES_CODE_10) OR prod.PROD_TYPE = 'SUB')
	AND prod.PRODUCT_CODE NOT IN (select sub.PRODUCT_CODE from Subscriptions as sub where prod.PRODUCT_CODE = sub.PRODUCT_CODE AND ID = @UserID);

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisSystemParamsGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisSystemParamsGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisSystemParamsGetAll] as
SELECT * FROM System_Params
   ORDER BY ParameterName

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisSystemParamsGetTaxToFreight]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisSystemParamsGetTaxToFreight]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisSystemParamsGetTaxToFreight] as
SELECT ShortValue FROM System_Params WHERE ParameterName = 'Order_Control.TaxFreight'

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisSystemParamsGetTaxToHandling]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisSystemParamsGetTaxToHandling]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisSystemParamsGetTaxToHandling] as
SELECT ShortValue FROM System_Params WHERE ParameterName = 'Order_Control.TaxHandling'

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisSystemParamsLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisSystemParamsLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisSystemParamsLoad] @ParameterName as
varchar(50)
AS
   SELECT *
   FROM System_Params
   WHERE ParameterName = @ParameterName;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisSystemParamsWebSalesCityAndState]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisSystemParamsWebSalesCityAndState]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisSystemParamsWebSalesCityAndState] as
Declare @city AS varchar(128);
	Declare @state AS varchar(128);
	Declare @defaultTax AS varchar(128);
	Declare @cityTaxCode AS varchar(128);
	Declare @stateTaxCode AS varchar(128);
		
	SELECT @city = ShortValue FROM System_Params
	WHERE ParameterName = 'Order_Control.TaxAuthorityCity';

	SELECT @state = ShortValue FROM System_Params
	WHERE ParameterName = 'Order_Control.TaxAuthorityStateProvince';

	SELECT @defaultTax = ShortValue FROM System_Params
	WHERE ParameterName = 'Order_Control.UseCustomerDefaultTaxAuthority';

	SELECT @cityTaxCode = ShortValue FROM System_Params
	WHERE ParameterName = 'Order_Control.TaxAuthorityCityCode';

	SELECT @stateTaxCode = ShortValue FROM System_Params
	WHERE ParameterName = 'Order_Control.TaxAuthorityStateProvinceCode';

	SELECT @city AS City, @state AS State, @defaultTax AS DefaultTaxAuth, @cityTaxCode AS CityTaxCode, @stateTaxCode AS StateTaxCode;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisTransGetAllByShipToId]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisTransGetAllByShipToId]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[BAEImisTransGetAllByShipToId] @ShipToId as varchar(10)
AS 
     SELECT * 
       FROM [dbo].[Trans]
      WHERE ST_ID = @ShipToId

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisTransGetAllByTransNumber]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisTransGetAllByTransNumber]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisTransGetAllByTransNumber] @TransNumber as
int
AS
	SELECT * FROM Trans
	WHERE TRANS_NUMBER = @TransNumber;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisTransGetAllByUserId]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisTransGetAllByUserId]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisTransGetAllByUserId] @UserId as
varchar(10)
AS
	SELECT * FROM Trans
	WHERE BT_ID = @UserId;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisTransGetAllByUserIdAndProductCode]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisTransGetAllByUserIdAndProductCode]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisTransGetAllByUserIdAndProductCode] @UserId as
varchar(10),
	@ProductCode AS varchar(31)
AS
	SELECT * FROM Trans
	WHERE ST_ID = @UserId AND PRODUCT_CODE = @ProductCode;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisTransGetAllByUserIdAndSourceSystem]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisTransGetAllByUserIdAndSourceSystem]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisTransGetAllByUserIdAndSourceSystem] @UserId as
varchar(10),
	@SourceSystem AS varchar(31),
	@StartDate AS DateTime,
	@EndDate AS DateTime
AS
	SELECT *  FROM Trans
	WHERE BT_ID = @UserId AND SOURCE_SYSTEM = @SourceSystem AND TRANSACTION_DATE BETWEEN @StartDate AND @EndDate
	AND (TRANSACTION_TYPE = 'PAY' OR TRANSACTION_TYPE = 'AR')
	ORDER BY TRANSACTION_DATE DESC;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisUdFieldGetAllByTableName]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisUdFieldGetAllByTableName]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisUdFieldGetAllByTableName] @TableName as
varchar(30)
AS
	SELECT DISTINCT * 
	FROM UD_Field udf, UD_WindowFields udwf
	WHERE udf.TABLE_NAME = @TableName AND udwf.TABLE_NAME = @TableName AND udf.FIELD_NAME = udwf.FIELD_NAME

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisUdFieldGetMultiSelectValues]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisUdFieldGetMultiSelectValues]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisUdFieldGetMultiSelectValues] @TableName as
varchar(30)
AS
	SELECT * FROM Gen_Tables WHERE TABLE_NAME = @TableName

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisUDFieldLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisUDFieldLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisUDFieldLoad] @TableName as
varchar(30),
		@FieldName	AS	varchar(30)
	AS
SELECT * 
	FROM UD_Field udf
LEFT JOIN UD_WindowFields odw ON udf.TABLE_NAME = odw.TABLE_NAME AND udf.FIELD_NAME = odw.FIELD_NAME
WHERE
	udf.TABLE_NAME = @TableName AND udf.FIELD_NAME = @FieldName

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisUDTableGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisUDTableGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisUDTableGetAll] as
SELECT * 
	FROM UD_Table

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisUDTableLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisUDTableLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisUDTableLoad] @TABLE_NAME as
varchar(30)
	AS
	SELECT * 
	FROM UD_Table WHERE
	TABLE_NAME = @TABLE_NAME;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEImisZipCodeGetUserCounty]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEImisZipCodeGetUserCounty]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEImisZipCodeGetUserCounty] @Zip varchar(5) as
SELECT	CITY, COUNTY, STATE
	FROM		Zip_Code
	WHERE	ZIP = @Zip;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEInsertError]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEInsertError]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEInsertError] @pStackTrace varchar(2048),
 	@pFriendlyErrorMessage as
varchar(1024),
	@pErrorType AS varchar(1024),
	@pHttpRefer AS varchar(256),
	@pHttpPath AS varchar(512),
	@pHttpHost AS varchar(128),
	@pHttpAll AS varchar(2048),
	@pUserID AS varchar(64),
	@pCookieData AS varchar(2048)
AS
	INSERT into Error (StackTrace, FriendlyErrorMessage, ErrorType, ErrorDate, HttpRefer, HttpPath, HttpHost,
	HttpAll, UserID, CookieData) values (@pStackTrace, @pFriendlyErrorMessage, @pErrorType, GETDATE(), @pHttpRefer, @pHttpPath, @pHttpHost, @pHttpAll, @pUserID, @pCookieData);

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEMember_TypesLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEMember_TypesLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/*
	Purpose: Gets the member Type info.
*/
CREATE PROCEDURE [dbo].[BAEMember_TypesLoad]
	@Member_Type varchar(5)
AS
	SELECT *
	FROM Member_Types
	WHERE MEMBER_TYPE = @Member_Type;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAENCookieValues]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAENCookieValues]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAENCookieValues] @pUserID as
varchar(10)
AS
	SELECT * FROM [Name] AS NM
	WHERE NM.[ID] = @pUserID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAENSGCookieValues]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAENSGCookieValues]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAENSGCookieValues] @pUserID as
varchar(10)
AS
	SELECT * FROM Name_Security_Groups AS NSG
	WHERE NSG.[ID] = @pUserID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderAnswerDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderAnswerDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderAnswerDelete] @OrderNumber as
float,
	@QuestionID AS int
AS
	DELETE
	FROM OrderAnswer
	WHERE OrderNumber = @OrderNumber AND
	QuestionID = @QuestionID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderAnswerGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderAnswerGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderAnswerGetAll] as
SELECT *
	FROM OrderAnswer

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderAnswerInsert]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderAnswerInsert]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderAnswerInsert] @OrderNumber as
money,
	@QuestionID AS int,
	@Answer AS varchar(512)
AS
	INSERT INTO OrderAnswer
	(	
	OrderNumber,			
	QuestionID,			
	Answer		
	)
	VALUES 
	(	
	@OrderNumber,			
	@QuestionID,			
	@Answer																	
	);

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderAnswerLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderAnswerLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderAnswerLoad] @OrderNumber as
float,
	@QuestionID AS int
AS
	SELECT * 
	FROM OrderAnswer
	WHERE OrderNumber = @OrderNumber AND
	QuestionID = @QuestionID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderAnswerUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderAnswerUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderAnswerUpdate] @OrderNumber as
float,
	@OldOrderNumber AS float,
	@QuestionID AS int,
	@OldQuestionID AS int,
	@Answer AS varchar(512)
AS
	UPDATE OrderAnswer
	SET 
	OrderNumber = 	@OrderNumber,
	QuestionID = 	@QuestionID,
	Answer = 		@Answer		
			
	WHERE OrderNumber = @OldOrderNumber AND
	QuestionID = @OldQuestionID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderAttributeCheckForChildProducts]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderAttributeCheckForChildProducts]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderAttributeCheckForChildProducts] @OrderAttributeId int as
DECLARE 	@dummy int

	SELECT	@dummy = CPA.OrderSuperProductChildProductID
	FROM		OrderSuperProductAttribute SPA INNER JOIN OrderSuperProductAttributeValue SPAV ON
			(SPA.OrderSuperProductAttributeID = SPAV.OrderSuperProductAttributeID) INNER JOIN OrderSuperProductChildProductAttribute CPA ON
			(SPAV.OrderSuperProductAttributeValueID = CPA.OrderSuperProductAttributeValueID)
	WHERE	SPA.OrderSuperProductAttributeID = @OrderAttributeId

	IF @@ROWCOUNT > 0
		BEGIN
			SELECT 0 'DELETE'
		END
	ELSE
		BEGIN
			SELECT 1 'DELETE'
		END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderAttributeDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderAttributeDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderAttributeDelete] @OrderAttributeID as
int
AS
	DELETE FROM OrderSuperProductAttribute WHERE OrderSuperProductAttributeID = @OrderAttributeID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderAttributeGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderAttributeGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderAttributeGetAll] as
SELECT *
	FROM OrderSuperProductAttribute AS ospa
	ORDER BY ospa.OrderSuperProductAttributeID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderAttributeGetAllForProduct]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderAttributeGetAllForProduct]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderAttributeGetAllForProduct] @OrderProductID as
int
AS
	SELECT *
	FROM OrderSuperProductAttribute AS ospa JOIN OrderSuperProductAttributeLookup AS ospal ON 
	ospa.OrderSuperProductAttributeID = ospal.OrderSuperProductAttributeID
	WHERE ospal.OrderProductID = @OrderProductID
	ORDER BY ospal.SortOrder;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderAttributeGetAllForProductCount]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderAttributeGetAllForProductCount]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderAttributeGetAllForProductCount] @OrderProductID as
int
AS
	SELECT Count(ospa.OrderSuperProductAttributeID) AS Count
	FROM OrderSuperProductAttribute AS ospa JOIN OrderSuperProductAttributeLookup AS ospal ON 
	ospa.OrderSuperProductAttributeID = ospal.OrderSuperProductAttributeID
	WHERE ospal.OrderProductID = @OrderProductID

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderAttributeGetLastSortOrderFromLookup]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderAttributeGetLastSortOrderFromLookup]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderAttributeGetLastSortOrderFromLookup] @OrderProductID int as
SELECT	MAX(SortOrder) SortOrder
	FROM	OrderSuperProductAttributeLookup
	WHERE	OrderProductID = @OrderProductID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderAttributeInsert]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderAttributeInsert]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderAttributeInsert] @Code as
varchar(128),
	@Title AS varchar(128),
	@Description AS varchar(1024)
AS
	INSERT INTO OrderSuperProductAttribute
	(
	Code,
	Title,
	Description)

	VALUES (
	@Code,
	@Title,
	@Description);

	SELECT CAST(@@IDENTITY AS int) AS 'InsertedOrderAttribute';

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderAttributeLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderAttributeLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderAttributeLoad] @OrderAttributeID as
int
AS
	SELECT * 
	FROM OrderSuperProductAttribute
	WHERE OrderSuperProductAttributeID = @OrderAttributeID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderAttributeLoadValues]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderAttributeLoadValues]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderAttributeLoadValues] @OrderAttributeID as
int
AS
	SELECT ospav.Title AS 'Value' FROM OrderSuperProductAttribute AS ospa 
	JOIN OrderSuperProductAttributeValue AS ospav 
	ON ospa.OrderSuperProductAttributeID = ospav.OrderSuperProductAttributeID 
	WHERE ospa.OrderSuperProductAttributeID = @OrderAttributeID ORDER BY ospav.SortOrder

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderAttributeUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderAttributeUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderAttributeUpdate] @OrderAttributeId as
int,
	@Code AS varchar(128),
	@Title AS varchar(128),
	@Description AS varchar(1024)
AS
	UPDATE OrderSuperProductAttribute
	SET
	Code = @Code, Title = @Title, Description = @Description
	WHERE OrderSuperProductAttributeID = @OrderAttributeId;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderAttributeValuesForSuperProduct]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderAttributeValuesForSuperProduct]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderAttributeValuesForSuperProduct] @OrderProductID as
int,
	@OrderSuperProductAttributeID AS int
AS
	SELECT DISTINCT av.* FROM OrderSuperProductAttributeValue AS av
	JOIN OrderSuperProductChildProductAttribute pa ON
	pa.OrderSuperProductAttributeValueID = av.OrderSuperProductAttributeValueID
	JOIN OrderSuperProductChildProduct cp ON
	cp.OrderSuperProductChildProductID = pa.OrderSuperProductChildProductID
	WHERE cp.OrderProductID = @OrderProductID AND av.OrderSuperProductAttributeID = @OrderSuperProductAttributeID

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderCategoryDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderCategoryDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderCategoryDelete] @OrderCategoryID as
int
AS
	Declare @count AS int;
	SET @count = 1;
	
	if(@OrderCategoryID <> 1)
	BEGIN
		DELETE FROM OrderCategory WHERE OrderCategoryID = @OrderCategoryID;
		
		while(@count > 0)
			BEGIN
				DELETE FROM OrderCategory WHERE OrderCategoryID in (SELECT OrderCategoryID FROM OrderCategoryParentLookup WHERE OrderCategoryParentID NOT IN (SELECT OrderCategoryID FROM OrderCategory))
				SELECT @count = @@rowcount;
			END
	END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderCategoryGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderCategoryGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderCategoryGetAll] as
SELECT *
	FROM OrderCategory
	ORDER BY OrderCategoryID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderCategoryGetAllChildren]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderCategoryGetAllChildren]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderCategoryGetAllChildren] @OrderCategoryID as
int
AS
	SELECT *
	FROM OrderCategory AS oc JOIN OrderCategoryParentLookup AS ocpl ON oc.OrderCategoryID = ocpl.OrderCategoryID
	WHERE ocpl.OrderCategoryParentID = @OrderCategoryID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderCategoryInsert]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderCategoryInsert]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderCategoryInsert] @Title as
varchar(64),
	@Description AS varchar(1024),
	@Active AS bit,
	@Header AS varchar(512),
	@Footer AS varchar(512),
	@Image AS varchar(1024),
	@SecurityKey AS varchar(64)
AS
	INSERT INTO OrderCategory
	(	
	Title,			
	Description,			
	Active,				
	Header,			
	Footer,			
	Image,
	SecurityKey		
	)
	VALUES 
	(	
	@Title,			
	@Description,			
	@Active,				
	@Header,			
	@Footer,			
	@Image,
	@SecurityKey																		
	);

	SELECT CAST(@@IDENTITY AS int) AS 'InsertedOrderCategory';

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderCategoryLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderCategoryLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderCategoryLoad] @OrderCategoryID as
int
AS
	SELECT * 
	FROM OrderCategory
	WHERE OrderCategoryID = @OrderCategoryID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderCategoryLoadParent]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderCategoryLoadParent]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderCategoryLoadParent] @OrderCategoryID as
int
AS
	SELECT * FROM OrderCategory WHERE OrderCategoryID = 
		(SELECT OrderCategoryParentID FROM OrderCategory AS oc JOIN OrderCategoryParentLookup AS ocpl ON
		oc.OrderCategoryID = ocpl.OrderCategoryID WHERE oc.OrderCategoryID = @OrderCategoryID);

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderCategoryParentLookupDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderCategoryParentLookupDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderCategoryParentLookupDelete] @OrderCategoryID as
int,
	@OrderCategoryParentID AS int
AS
	DELETE
	FROM OrderCategoryParentLookup
	WHERE OrderCategoryID = @OrderCategoryID AND
	OrderCategoryParentID = @OrderCategoryParentID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderCategoryParentLookupGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderCategoryParentLookupGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderCategoryParentLookupGetAll] as
SELECT *
	FROM OrderCategoryParentLookup
	ORDER BY OrderCategoryID, OrderCategoryParentID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderCategoryParentLookupGetorderCategoryParentId]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderCategoryParentLookupGetorderCategoryParentId]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderCategoryParentLookupGetorderCategoryParentId] @oCatID int as
SELECT	ocpl.OrderCategoryID, ocpl.OrderCategoryParentID, oc.Title 
	FROM	OrderCategoryParentLookup AS ocpl 
		INNER JOIN OrderCategory AS oc on oc.OrderCategoryID = ocpl.OrderCategoryID 
	WHERE	ocpl.OrderCategoryID = @oCatID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderCategoryParentLookupInsert]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderCategoryParentLookupInsert]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderCategoryParentLookupInsert] @OrderCategoryID as
int,
	@OrderCategoryParentID AS int
AS
	INSERT INTO OrderCategoryParentLookup
	(	
	OrderCategoryID,			
	OrderCategoryParentID		
	)
	VALUES 
	(	
	@OrderCategoryID,			
	@OrderCategoryParentID																	
	);

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderCategoryParentLookupLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderCategoryParentLookupLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderCategoryParentLookupLoad] @OrderCategoryID as
int,
	@OrderCategoryParentID AS int
AS
	SELECT * 
	FROM OrderCategoryParentLookup
	WHERE OrderCategoryID = @OrderCategoryID AND
	OrderCategoryParentID = @OrderCategoryParentID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderCategoryParentLookupUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderCategoryParentLookupUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderCategoryParentLookupUpdate] @OrderCategoryID as
int,
	@OrderCategoryParentID AS int
AS
	UPDATE OrderCategoryParentLookup
	SET 
	OrderCategoryID = @OrderCategoryID,	
	OrderCategoryParentID = @OrderCategoryParentID		
			
	WHERE OrderCategoryID = @OrderCategoryID AND
	OrderCategoryParentID = @OrderCategoryParentID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderCategoryUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderCategoryUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderCategoryUpdate] @OrderCategoryID as
int,
	@Title AS varchar(64),
	@Description AS varchar(1024),
	@Active AS bit,
	@Header AS varchar(512),
	@Footer AS varchar(512),
	@Image AS varchar(1024),
	@SecurityKey AS varchar(64)
AS
	UPDATE OrderCategory
	SET 
	Title = 			@Title,			
	Description = 		@Description,			
	Active = 			@Active,				
	Header = 			@Header,			
	Footer = 			@Footer,			
	Image = 			@Image,			
	SecurityKey = 		@SecurityKey		
 
	WHERE OrderCategoryID = @OrderCategoryID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderCheckoutDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderCheckoutDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderCheckoutDelete] @OrderCheckoutID as
int
AS
	DELETE
	FROM OrderCheckout
	WHERE OrderCheckoutID = @OrderCheckoutID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderCheckoutGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderCheckoutGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderCheckoutGetAll] as
SELECT *
	FROM OrderCheckout
	ORDER BY OrderCheckoutID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderCheckoutInsert]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderCheckoutInsert]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure [dbo].[BAEOrderCheckoutInsert] 
	@UserID as varchar(64),
	@Address1 AS varchar(40),
	@Address2 AS varchar(40),
	@Address3 AS varchar(40),
	@City AS varchar(40),
	@State AS varchar(15),
	@PostalCode AS varchar(10),
	@CreditCardType AS varchar(10),
	@CreditCardNumber AS varchar(100),
	@CreditCardExpiration AS varchar(24),
	@CreditCardAuthCode AS varchar(24),
	@CreditCardName AS varchar(40),
	@CreditCardAddress AS varchar(40),
	@CreditCardAddress2 AS varchar(40),
	@CreditCardAddress3 AS varchar(40),
	@CreditCardCity AS varchar(40),
	@CreditCardState AS varchar(15),
	@CreditCardPostalCode AS varchar(10),
	@CreditCardCountry AS varchar(25),
	@ReadyForCheckout AS bit,
	@Country AS varchar(25),
	@ShipMethod AS varchar(10),
	@PurchaseOrder AS varchar(128),
	@Email AS varchar(100),
	@AddressPurpose AS varchar(20),
	@Name AS varchar(70),
	@Issue_Date AS varchar(10),
	@Issue_Number AS varchar(2),
	@MemberType AS varchar(5),
	@BillingCategory AS varchar(60)
AS
	INSERT INTO OrderCheckout
	(	
	UserID,
	Address1,
	Address2,
	Address3,
	City,
	StateProvince,
	PostalCode,
	CreditCardType,
	CreditCardNumber,
	CreditCardExpiration,
	CreditCardAuthCode,
	CreditCardName,
	CreditCardAddress,
	CreditCardAddress2,
	CreditCardAddress3,
	CreditCardCity,
	CreditCardState,
	CreditCardPostalCode,
	CreditCardCountry,
	ReadyForCheckout,
	Country,
	ShipMethod,
	PurchaseOrder,
	Email,
	AddressPurpose,
	ISSUE_DATE,
	ISSUE_NUMBER,
	MemberType,
	BillingCategory,
	[Name]
	)
	VALUES 
	(	
	@UserID,
	@Address1,
	@Address2,
	@Address3,
	@City,
	@State,
	@PostalCode,
	@CreditCardType,
	@CreditCardNumber,
	@CreditCardExpiration,
	@CreditCardAuthCode,
	@CreditCardName,
	@CreditCardAddress,
	@CreditCardAddress2,
	@CreditCardAddress3,
	@CreditCardCity,
	@CreditCardState,
	@CreditCardPostalCode,
	@CreditCardCountry,
	@ReadyForCheckout,
	@Country,
	@ShipMethod,
	@PurchaseOrder,
	@Email,
	@AddressPurpose,
	@Issue_Date,
	@Issue_Number,
	@MemberType,
	@BillingCategory,
	@Name				
	);

SELECT CAST(@@IDENTITY AS int) AS 'OrderCheckoutID';

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderCheckoutLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderCheckoutLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderCheckoutLoad] @UserID as
varchar(64)
AS
	SELECT * 
	FROM OrderCheckout WHERE UserID = @UserID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderCheckoutUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderCheckoutUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure [dbo].[BAEOrderCheckoutUpdate] @OrderCheckoutID as
int,
	@UserID AS varchar(64),
	@Address1 AS varchar(40),
	@Address2 AS varchar(40),
	@Address3 AS varchar(40),
	@City AS varchar(40),
	@State AS varchar(15),
	@PostalCode AS varchar(10),
	@CreditCardType AS varchar(10),
	@CreditCardNumber AS varchar(100),
	@CreditCardExpiration AS varchar(24),
	@CreditCardAuthCode AS varchar(24),
	@CreditCardName AS varchar(40),
	@CreditCardAddress AS varchar(40),
	@CreditCardAddress2 AS varchar(40),
	@CreditCardAddress3 AS varchar(40),
	@CreditCardCity AS varchar(40),
	@CreditCardState AS varchar(15),
	@CreditCardPostalCode AS varchar(10),
	@CreditCardCountry AS varchar(25),
	@ReadyForCheckout AS bit,
	@Country AS varchar(25),
	@ShipMethod AS varchar(10),
	@PurchaseOrder AS varchar(128),
	@Email AS varchar(100),
	@AddressPurpose AS varchar(20),
	@Name AS varchar(70),
	@Issue_Date AS varchar(10),
	@Issue_Number AS varchar(2),
	@MemberType AS varchar(5),
	@BillingCategory AS varchar(60)
AS
	UPDATE OrderCheckout
	SET 
	UserID = 			@UserID,			
	Address1 = 			@Address1,			
	Address2 = 			@Address2,				
	Address3 = 			@Address3,
	City = 				@City,			
	StateProvince = 	@State,			
	PostalCode = 		@PostalCode,			
	CreditCardType = 	@CreditCardType,	
	CreditCardNumber = 	@CreditCardNumber,			
	CreditCardExpiration = 	@CreditCardExpiration,			
	CreditCardAuthCode = @CreditCardAuthCode,				
	CreditCardName = @CreditCardName,			
	CreditCardAddress = @CreditCardAddress,			
	CreditCardAddress2 = @CreditCardAddress2,
	CreditCardAddress3 = @CreditCardAddress3,
	CreditCardCity = 	@CreditCardCity,
	CreditCardState = 	@CreditCardState,	
	CreditCardPostalCode = 		@CreditCardPostalCode,			
	CreditCardCountry = 	@CreditCardCountry,			
	ReadyForCheckout = @ReadyForCheckout,				
	Country = @Country,			
	ShipMethod = @ShipMethod,
	PurchaseOrder = @PurchaseOrder,
	Email = @Email,
	AddressPurpose = @AddressPurpose,
	ISSUE_DATE = @Issue_Date,
	ISSUE_NUMBER = @Issue_Number,
	BillingCategory = @BillingCategory,
	MemberType = @MemberType,
	[Name] = @Name
 
	WHERE OrderCheckoutID = @OrderCheckoutID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderProductAddCrossSell]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderProductAddCrossSell]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderProductAddCrossSell] @OrderProductID int,
 	@OrderProductCrossSellID int as
INSERT INTO OrderProductCrossSellLookup(OrderProductID, CrossSellOrderProductID) VALUES(@OrderProductID, @OrderProductCrossSellID);

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderProductCategoryLookupDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderProductCategoryLookupDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderProductCategoryLookupDelete] @OrderProductID as
int,
	@OrderCategoryID AS int
AS
	DELETE
	FROM OrderProductCategoryLookup
	WHERE OrderProductID = @OrderProductID AND
	OrderCategoryID = @OrderCategoryID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderProductCategoryLookupGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderProductCategoryLookupGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderProductCategoryLookupGetAll] as
SELECT *
	FROM OrderProductCategoryLookup
	ORDER BY OrderProductID, OrderCategoryID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderProductCategoryLookupInsert]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderProductCategoryLookupInsert]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderProductCategoryLookupInsert] @OrderProductID as
int,
	@OrderCategoryID AS int,
	@IsFeatured AS bit,
	@SortOrder AS int
AS
	INSERT INTO OrderProductCategoryLookup
	(	
	OrderProductID,			
	OrderCategoryID,			
	IsFeatured,				
	SortOrder		
	)
	VALUES 
	(	
	@OrderProductID,			
	@OrderCategoryID,			
	@IsFeatured,				
	@SortOrder
	);

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderProductCategoryLookupLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderProductCategoryLookupLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderProductCategoryLookupLoad] @OrderProductID as
int,
	@OrderCategoryID AS int
AS
	SELECT * 
	FROM OrderProductCategoryLookup
	WHERE OrderProductID = @OrderProductID AND
	OrderCategoryID = @OrderCategoryID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderProductCategoryLookupUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderProductCategoryLookupUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderProductCategoryLookupUpdate] @OrderProductID as
int,
	@OrderCategoryID AS int,
	@IsFeatured AS bit,
	@SortOrder AS int
AS
	UPDATE OrderProductCategoryLookup
	SET 	
	OrderCategoryID = @OrderCategoryID,			
	IsFeatured = @IsFeatured,			
	SortOrder = @SortOrder		
 
	WHERE OrderProductID = @OrderProductID AND
	OrderCategoryID = @OrderCategoryID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderProductCrossSellLookupDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderProductCrossSellLookupDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderProductCrossSellLookupDelete] @OrderProductID as
int,
	@OrderProductCrossSellID AS int
AS
	DELETE
	FROM OrderProductCrossSellLookup
	WHERE OrderProductID = @OrderProductID AND
	CrossSellOrderProductID = @OrderProductCrossSellID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderProductCrossSellLookupGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderProductCrossSellLookupGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderProductCrossSellLookupGetAll] as
SELECT *
	FROM OrderProductCrossSellLookup
	ORDER BY OrderProductID, CrossSellOrderProductID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderProductCrossSellLookupInsert]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderProductCrossSellLookupInsert]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderProductCrossSellLookupInsert] @OrderProductID as
int,
	@OrderProductCrossSellID AS int
AS
	INSERT INTO OrderProductCrossSellLookup
	(	
	OrderProductID,			
	CrossSellOrderProductID		
	)
	VALUES 
	(	
	@OrderProductID,			
	@OrderProductCrossSellID																
	);

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderProductCrossSellLookupLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderProductCrossSellLookupLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderProductCrossSellLookupLoad] @OrderProductID as
int,
	@OrderProductCrossSellID AS int
AS
	SELECT * 
	FROM OrderProductCrossSellLookup
	WHERE OrderProductID = @OrderProductID AND
	CrossSellOrderProductID = @OrderProductCrossSellID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderProductCrossSellLookupUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderProductCrossSellLookupUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderProductCrossSellLookupUpdate] @OrderProductID as
int,
	@OrderProductCrossSellID AS int
AS
	UPDATE OrderProductCrossSellLookup
	SET 
	OrderProductID = @OrderProductID,	
	CrossSellOrderProductID = @OrderProductCrossSellID

	WHERE OrderProductID = @OrderProductID AND
	CrossSellOrderProductID = @OrderProductCrossSellID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderProductDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderProductDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderProductDelete] @OrderProductID as
int
AS
	DELETE
	FROM OrderProduct
	WHERE OrderProductID = @OrderProductID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderProductGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderProductGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderProductGetAll] as
SELECT *
	FROM OrderProduct AS op JOIN Product AS p ON op.ProductCode COLLATE database_default = p.PRODUCT_CODE COLLATE database_default WHERE p.PROD_TYPE = 'SALES'

	ORDER BY OrderProductID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderProductGetAllByCategory]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderProductGetAllByCategory]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderProductGetAllByCategory] @OrderCategoryID as
int
AS
	(
		SELECT op.OrderProductID, op.Title, op.IsSuperProduct, op.ProductCode, op.SellOnWeb, opcl.IsFeatured, opcl.SortOrder
		FROM OrderProduct op, OrderProductCategoryLookup opcl
		WHERE opcl.OrderProductID = op.OrderProductID AND opcl.OrderCategoryID = @OrderCategoryID AND op.IsSuperProduct = 1
		UNION
		SELECT op.OrderProductID, imisp.TITLE COLLATE database_default, op.IsSuperProduct, imisp.PRODUCT_CODE COLLATE database_default AS ProductCode, WEB_OPTION AS SellOnWeb, opcl.IsFeatured, opcl.SortOrder
		FROM OrderProduct op
		INNER JOIN Product imisp ON op.ProductCode COLLATE database_default = imisp.PRODUCT_CODE COLLATE database_default
		INNER JOIN OrderProductCategoryLookup opcl ON op.OrderProductID = opcl.OrderProductID
		WHERE op.IsSuperProduct = 0 AND imisp.PROD_TYPE = 'SALES' AND opcl.OrderCategoryID = @OrderCategoryID
	)
	ORDER BY opcl.SortOrder;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderProductGetAllChildren]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderProductGetAllChildren]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderProductGetAllChildren] @OrderProductID as
int
AS
	SELECT OrderSuperProductChildProduct.*
	FROM OrderProduct JOIN OrderSuperProductChildProduct ON OrderSuperProductChildProduct.OrderProductID = OrderProduct.OrderProductID
	WHERE OrderProduct.OrderProductID = @OrderProductID
	ORDER BY OrderProduct.OrderProductID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderProductGetAllChildrenCount]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderProductGetAllChildrenCount]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderProductGetAllChildrenCount] @OrderProductID as
int
AS
	SELECT COUNT(OrderSuperProductChildProduct.OrderSuperProductChildProductID) AS Count
	FROM OrderProduct JOIN OrderSuperProductChildProduct ON OrderSuperProductChildProduct.OrderProductID = OrderProduct.OrderProductID
	WHERE OrderProduct.OrderProductID = @OrderProductID

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderProductGetAllInCategory]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderProductGetAllInCategory]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderProductGetAllInCategory] @OrderCategoryID as
int
AS
	(
		SELECT op.OrderProductID, op.Title, op.IsSuperProduct, op.ProductCode, op.SellOnWeb, opcl.IsFeatured, opcl.SortOrder
		FROM OrderProduct op, OrderProductCategoryLookup opcl
		WHERE opcl.OrderProductID = op.OrderProductID AND opcl.OrderCategoryID = @OrderCategoryID AND op.IsSuperProduct = 1
		UNION
		SELECT op.OrderProductID, imisp.TITLE COLLATE database_default, op.IsSuperProduct, imisp.PRODUCT_CODE COLLATE database_default AS ProductCode, WEB_OPTION AS SellOnWeb, opcl.IsFeatured, opcl.SortOrder
		FROM OrderProduct op
		INNER JOIN Product imisp ON op.ProductCode COLLATE database_default = imisp.PRODUCT_CODE COLLATE database_default
		INNER JOIN OrderProductCategoryLookup opcl ON op.OrderProductID = opcl.OrderProductID
		WHERE op.IsSuperProduct = 0 AND imisp.PROD_TYPE = 'SALES' AND opcl.OrderCategoryID = @OrderCategoryID
	)
	ORDER BY opcl.SortOrder;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderProductGetAllNotInCategory]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderProductGetAllNotInCategory]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderProductGetAllNotInCategory] @OrderCategoryID as
int
AS
	INSERT INTO OrderProduct
	(IsSuperProduct, ProductCode)
		SELECT 0 AS IsSuperProduct, PRODUCT_CODE
		FROM Product
		WHERE PROD_TYPE = 'SALES' AND STATUS = 'A' AND PRODUCT_CODE COLLATE database_default NOT IN
		(SELECT ProductCode FROM OrderProduct WHERE ProductCode IS NOT NULL);

	(
		SELECT op.OrderProductID, imisp.TITLE COLLATE database_default AS Title, op.IsSuperProduct, imisp.PRODUCT_CODE COLLATE database_default AS ProductCode, WEB_OPTION AS SellOnWeb--op.SellOnWeb
		FROM OrderProduct op
		INNER JOIN Product imisp ON op.ProductCode COLLATE database_default = imisp.PRODUCT_CODE COLLATE database_default
		WHERE op.IsSuperProduct = 0 AND imisp.PROD_TYPE = 'SALES' AND op.OrderProductID NOT IN (SELECT OrderProductID FROM OrderProductCategoryLookup WHERE OrderCategoryID = @OrderCategoryID)
			AND op.ProductCode NOT IN (SELECT ProductCode FROM OrderSuperProductChildProduct)
		UNION
		SELECT op.OrderProductID, op.Title COLLATE database_default AS Title, op.IsSuperProduct, op.ProductCode, op.SellOnWeb
		FROM OrderProduct op
		WHERE op.IsSuperProduct = 1 AND op.OrderProductID NOT IN (SELECT OrderProductID FROM OrderProductCategoryLookup WHERE OrderCategoryID = @OrderCategoryID)
	)
	ORDER BY Title

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderProductGetAllSuperProducts]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderProductGetAllSuperProducts]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderProductGetAllSuperProducts] as
SELECT *
	FROM OrderProduct op
	WHERE op.IsSuperProduct = 1
	ORDER BY op.Title

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderProductGetAllSuperProductsCount]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderProductGetAllSuperProductsCount]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderProductGetAllSuperProductsCount] as
SELECT COUNT(OrderProductID) AS Count
	FROM OrderProduct op
	WHERE op.IsSuperProduct = 1

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderProductGetAvailableInventory]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderProductGetAvailableInventory]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderProductGetAvailableInventory] @ProductCode varchar(50) as
SELECT QUANTITY_AVAILABLE  AS 'QuantityAvailable'
	FROM Product_Inventory
	WHERE PRODUCT_CODE = @ProductCode

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderProductGetCrossSellAvail]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderProductGetCrossSellAvail]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderProductGetCrossSellAvail] @OrderProductID int as
SELECT op.OrderProductID, op.Title, op.[Description], op.IsSuperProduct, op.ProductCode, op.SellOnWeb
	FROM OrderProduct AS op INNER JOIN Product p ON p.PRODUCT_CODE COLLATE database_default = op.ProductCode COLLATE database_default
	WHERE op.IsSuperProduct = 0 AND op.OrderProductID <> @OrderProductID AND
		op.OrderProductID NOT IN (SELECT CrossSellOrderProductID FROM OrderProductCrossSellLookup
 						WHERE OrderProductID = @OrderProductID)
		AND op.ProductCode NOT IN (SELECT ProductCode FROM OrderSuperProductChildProduct)
	UNION
	SELECT op1.OrderProductID, op1.Title, op1.[Description], op1.IsSuperProduct, op1.ProductCode, op1.SellOnWeb FROM OrderProduct AS op1
	WHERE op1.IsSuperProduct = 1 AND op1.OrderProductID <> @OrderProductID AND
		op1.OrderProductID NOT IN (SELECT CrossSellOrderProductID FROM OrderProductCrossSellLookup
 						WHERE OrderProductID = @OrderProductID)

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderProductGetCrossSellSelected]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderProductGetCrossSellSelected]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderProductGetCrossSellSelected] @OrderProductID int as
SELECT op.OrderProductID, op.Title, op.[Description], op.IsSuperProduct, op.ProductCode, op.SellOnWeb
	FROM OrderProduct AS op INNER JOIN Product p ON p.PRODUCT_CODE COLLATE database_default = op.ProductCode COLLATE database_default
	WHERE op.IsSuperProduct = 0 AND op.OrderProductID <> @OrderProductID AND
		op.OrderProductID IN (SELECT CrossSellOrderProductID FROM OrderProductCrossSellLookup
 						WHERE OrderProductID = @OrderProductID)
	UNION
	SELECT op1.OrderProductID, op1.Title, op1.[Description], op1.IsSuperProduct, op1.ProductCode, op1.SellOnWeb FROM OrderProduct AS op1
	WHERE op1.IsSuperProduct = 1 AND op1.OrderProductID <> @OrderProductID AND
		op1.OrderProductID IN (SELECT CrossSellOrderProductID FROM OrderProductCrossSellLookup
 						WHERE OrderProductID = @OrderProductID)

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderProductGetCrossSellSelectedToDisplay]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderProductGetCrossSellSelectedToDisplay]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderProductGetCrossSellSelectedToDisplay] @OrderProductID int as
SELECT op.OrderProductID, op.Title, op.[Description], op.IsSuperProduct, op.ProductCode, op.SellOnWeb
	FROM OrderProduct AS op INNER JOIN Product p ON p.PRODUCT_CODE COLLATE database_default = op.ProductCode COLLATE database_default
	WHERE op.IsSuperProduct = 0 AND op.OrderProductID <> @OrderProductID AND WEB_OPTION != 0 AND
		op.OrderProductID IN (SELECT CrossSellOrderProductID FROM OrderProductCrossSellLookup
 						WHERE OrderProductID = @OrderProductID)
	UNION
	SELECT op1.OrderProductID, op1.Title, op1.[Description], op1.IsSuperProduct, op1.ProductCode, op1.SellOnWeb FROM OrderProduct AS op1
	WHERE op1.IsSuperProduct = 1 AND op1.OrderProductID <> @OrderProductID AND op1.SellOnWeb != 0 AND
		op1.OrderProductID IN (SELECT CrossSellOrderProductID FROM OrderProductCrossSellLookup
 						WHERE OrderProductID = @OrderProductID)

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderProductGetFeaturedProductsByCategory]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderProductGetFeaturedProductsByCategory]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderProductGetFeaturedProductsByCategory] @IsFeatured int,
 	@OrderCategoryID int as
IF @IsFeatured = 1
	BEGIN
		SELECT	opcl.OrderProductID, op.Title, op.Description, op.IsSuperProduct, op.ProductCode, op.SellOnWeb, SortOrder
		FROM	OrderProductCategoryLookup opcl, OrderProduct op
		WHERE	opcl.OrderCategoryID = @OrderCategoryID AND 
			opcl.IsFeatured = 1 AND 
			op.OrderProductID = opcl.OrderProductID AND
			op.SellOnWeb != 0 AND
			IsSuperProduct = 1
		UNION		
		SELECT	opcl.OrderProductID, op.Title, op.Description, op.IsSuperProduct, op.ProductCode, op.SellOnWeb, SortOrder
		FROM	OrderProductCategoryLookup opcl, OrderProduct op, Product p
		WHERE	opcl.OrderCategoryID = @OrderCategoryID AND 
			opcl.IsFeatured = 1 AND 
			op.OrderProductID = opcl.OrderProductID AND
			p.WEB_OPTION  != 0 AND
			IsSuperProduct = 0 AND
			p.PRODUCT_CODE COLLATE database_default = op.ProductCode COLLATE database_default
		ORDER BY SortOrder;
	END
	ELSE
	BEGIN
		SELECT	opcl.OrderProductID, op.Title, op.Description, op.IsSuperProduct, op.ProductCode, op.SellOnWeb, SortOrder
		FROM	OrderProductCategoryLookup opcl, OrderProduct op
		WHERE	opcl.OrderCategoryID = @OrderCategoryID AND 
			opcl.IsFeatured = 0 AND 
			op.OrderProductID = opcl.OrderProductID AND
			op.SellOnWeb != 0
		UNION		
		SELECT	opcl.OrderProductID, op.Title, op.Description, op.IsSuperProduct, op.ProductCode, op.SellOnWeb, SortOrder
		FROM		OrderProductCategoryLookup opcl, OrderProduct op, Product p
		WHERE	opcl.OrderCategoryID = @OrderCategoryID AND 
			opcl.IsFeatured = 0 AND 
			op.OrderProductID = opcl.OrderProductID AND
			p.WEB_OPTION  != 0 AND
			IsSuperProduct = 0 AND
			p.PRODUCT_CODE COLLATE database_default = op.ProductCode COLLATE database_default
		ORDER BY SortOrder
	END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderProductGetQuantityOnHand]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderProductGetQuantityOnHand]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/*
	Change the iWC BAEOrderProductGetQuantityOnHand to match the requirements communicated
	by Edie in the discussion of DT 199.
*/
CREATE procedure [dbo].[BAEOrderProductGetQuantityOnHand] @ProductCode varchar(64) AS
DECLARE @avail decimal(24)
DECLARE @isKit bit
DECLARE @stockType varchar(20)
-- the string constants must match StockType enum in OrderProduct:
-- NotAKit, KitWithStockItems, and KitWithNoStockItems
SELECT TOP 1 @isKit = [IS_KIT] FROM [dbo].[Product] WHERE [PRODUCT_CODE] = @ProductCode
IF @isKit = 1
BEGIN
	SELECT @avail = MIN((inv.[QUANTITY_ON_HAND]-inv.[QUANTITY_RESERVED])/kit.[ITEM_QUANTITY])
		FROM [dbo].[Product_Kit] kit
		INNER JOIN [dbo].[Product] prod ON kit.[ITEM_PRODUCT_CODE] = prod.[PRODUCT_CODE]
		INNER JOIN [dbo].[Product_Inventory] inv ON prod.[PRODUCT_CODE] = inv.[PRODUCT_CODE] 
			AND inv.[LOCATION] = prod.[LOCATION] 
		WHERE kit.[PRODUCT_CODE] = @ProductCode 
			AND prod.[STOCK_ITEM] = 1  
			AND kit.[ITEM_QUANTITY]>0
	IF EXISTS (SELECT TOP 1 prod.[STOCK_ITEM]
		FROM [dbo].[Product_Kit] kit
			INNER JOIN [dbo].[Product] prod ON kit.[ITEM_PRODUCT_CODE] = prod.[PRODUCT_CODE] 
			WHERE kit.[PRODUCT_CODE] = @ProductCode
			AND prod.[STOCK_ITEM] = 1 ) 
		SET @stockType = 'KitWithStockItems'
		ELSE SET @stockType = 'KitWithNoStockItems'

END
ELSE
BEGIN
	SELECT @avail = ISNULL(inv.[QUANTITY_ON_HAND]-inv.[QUANTITY_RESERVED], 0) 
		FROM [dbo].[Product] prod
		INNER JOIN [dbo].[Product_Inventory] inv ON prod.[PRODUCT_CODE] = inv.[PRODUCT_CODE] 
			AND inv.[LOCATION] = prod.[LOCATION] 
		WHERE  prod.[PRODUCT_CODE] = @ProductCode
			AND prod.[STOCK_ITEM] = 1
	SET @stockType = 'NotAKit'
END
SELECT (@avail) AS 'Available', @stockType as 'StockType'

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderProductInsert]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderProductInsert]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderProductInsert] @Title as
varchar(128),
	@Description AS varchar(1024),
	@IsSuperProduct AS bit,
	@ProductCode AS varchar(64),
	@SellOnWeb AS int
AS
	INSERT INTO OrderProduct
	(	
	Title,			
	Description,			
	IsSuperProduct,				
	ProductCode,			
	SellOnWeb		
	)
	VALUES 
	(	
	@Title,			
	@Description,			
	@IsSuperProduct,				
	@ProductCode,			
	@SellOnWeb																	
	);

	SELECT CAST(@@IDENTITY AS int) AS 'InsertedOrderProduct';

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderProductLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderProductLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderProductLoad] @OrderProductID as
int
AS
	SELECT * 
	FROM OrderProduct
	WHERE OrderProductID = @OrderProductID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderProductRemoveCrossSell]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderProductRemoveCrossSell]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderProductRemoveCrossSell] @OrderProductID int,
 	@OrderProductCrossSellID int as
DELETE FROM OrderProductCrossSellLookup
	WHERE OrderProductID = @OrderProductID AND CrossSellOrderProductID = @OrderProductCrossSellID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderProductUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderProductUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderProductUpdate] @OrderProductID as
int,
	@Title AS varchar(128),
	@Description AS varchar(1024),
	@IsSuperProduct AS bit,
	@ProductCode AS varchar(64),
	@SellOnWeb AS int
AS
	UPDATE OrderProduct
	SET
	Title = @Title,
	Description = @Description,
	IsSuperProduct = @IsSuperProduct,
	ProductCode = @ProductCode,
	SellOnWeb = @SellOnWeb			
 
	WHERE OrderProductID = @OrderProductID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderSuperProductAttributeDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderSuperProductAttributeDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderSuperProductAttributeDelete] @OrderSuperProductAttributeID as
int
AS
	DELETE
	FROM OrderSuperProductAttribute
	WHERE OrderSuperProductAttributeID = @OrderSuperProductAttributeID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderSuperProductAttributeGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderSuperProductAttributeGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderSuperProductAttributeGetAll] as
SELECT *
	FROM OrderSuperProductAttribute
	ORDER BY OrderSuperProductAttributeID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderSuperProductAttributeInsert]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderSuperProductAttributeInsert]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderSuperProductAttributeInsert] @Code as
varchar(128),
	@Title AS varchar(128),
	@Description AS varchar(1024)
AS
	INSERT INTO OrderSuperProductAttribute
	(			
	Code,			
	Title,				
	Description	
	)
	VALUES 
	(			
	@Code,			
	@Title,				
	@Description																
	);

	SELECT CAST(@@IDENTITY AS int) AS 'InsertedorderSuperProductAttribute';

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderSuperProductAttributeLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderSuperProductAttributeLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderSuperProductAttributeLoad] @OrderSuperProductAttributeID as
int
AS
	SELECT * 
	FROM OrderSuperProductAttribute
	WHERE OrderSuperProductAttributeID = @OrderSuperProductAttributeID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderSuperProductAttributeLookupDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderSuperProductAttributeLookupDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderSuperProductAttributeLookupDelete] @OrderProductID as
int,
	@OrderSuperProductAttributeID AS int
AS
	DELETE
	FROM OrderSuperProductAttributeLookup
	WHERE OrderProductID = @OrderProductID AND
	OrderSuperProductAttributeID = @OrderSuperProductAttributeID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderSuperProductAttributeLookupGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderSuperProductAttributeLookupGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderSuperProductAttributeLookupGetAll] as
SELECT *
	FROM OrderSuperProductAttributeLookup
	ORDER BY OrderProductID, OrderSuperProductAttributeID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderSuperProductAttributeLookupInsert]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderSuperProductAttributeLookupInsert]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderSuperProductAttributeLookupInsert] @OrderProductID as
int,
	@OrderSuperProductAttributeID AS int,
	@SortOrder AS int
AS
	INSERT INTO OrderSuperProductAttributeLookup
	(	
	OrderProductID,			
	OrderSuperProductAttributeID,			
	SortOrder		
	)
	VALUES 
	(	
	@OrderProductID,			
	@OrderSuperProductAttributeID,			
	@SortOrder																	
	);

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderSuperProductAttributeLookupLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderSuperProductAttributeLookupLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderSuperProductAttributeLookupLoad] @OrderProductID as
int,
	@OrderSuperProductAttributeID AS int
AS
	SELECT * 
	FROM OrderSuperProductAttributeLookup
	WHERE OrderProductID = @OrderProductID AND
	OrderSuperProductAttributeID = @OrderSuperProductAttributeID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderSuperProductAttributeLookupUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderSuperProductAttributeLookupUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderSuperProductAttributeLookupUpdate] @OrderProductID as
int,
	@OrderSuperProductAttributeID AS int,
	@SortOrder AS int
AS
	UPDATE OrderSuperProductAttributeLookup
	SET 
	OrderProductID = @OrderProductID,	
	OrderSuperProductAttributeID = 	@OrderSuperProductAttributeID,			
	SortOrder = @SortOrder			
 
	WHERE OrderProductID = @OrderProductID AND
	OrderSuperProductAttributeID = @OrderSuperProductAttributeID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderSuperProductAttributeUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderSuperProductAttributeUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderSuperProductAttributeUpdate] @OrderSuperProductAttributeID as
int,
	@Code AS varchar(128),
	@Title AS varchar(128),
	@Description AS varchar(1024)
AS
	UPDATE OrderSuperProductAttribute
	SET 
	Code = 		@Code,			
	Title = 	@Title,			
	Description = @Description		
 
	WHERE OrderSuperProductAttributeID = @OrderSuperProductAttributeID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderSuperProductAttributeValueDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderSuperProductAttributeValueDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderSuperProductAttributeValueDelete] @OrderSuperProductAttributeValueID as
int
AS
	UPDATE OrderSuperProductAttributeValue SET SortOrder = SortOrder - 1 WHERE SortOrder > (SELECT SortOrder FROM OrderSuperProductAttributeValue
	WHERE OrderSuperProductAttributeValueID = @OrderSuperProductAttributeValueID);
	DELETE
	FROM OrderSuperProductAttributeValue
	WHERE OrderSuperProductAttributeValueID = @OrderSuperProductAttributeValueID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderSuperProductAttributeValueDeleteFromId]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderSuperProductAttributeValueDeleteFromId]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderSuperProductAttributeValueDeleteFromId] @OrderAttributeID as
int,
	@Value AS varchar(128)
AS
	DELETE
	FROM OrderSuperProductAttributeValue
	WHERE OrderSuperProductAttributeID = @OrderAttributeID AND Title = @Value;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderSuperProductAttributeValueGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderSuperProductAttributeValueGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderSuperProductAttributeValueGetAll] as
SELECT *
	FROM OrderSuperProductAttributeValue
	ORDER BY SortOrder

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderSuperProductAttributeValueGetAllByOrderAttributeId]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderSuperProductAttributeValueGetAllByOrderAttributeId]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderSuperProductAttributeValueGetAllByOrderAttributeId] @OrderAttributeId as
int
AS
	SELECT *
	FROM OrderSuperProductAttributeValue
	WHERE OrderSuperProductAttributeID = @OrderAttributeId
	ORDER BY SortOrder

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderSuperProductAttributeValueInsert]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderSuperProductAttributeValueInsert]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderSuperProductAttributeValueInsert] @OrderSuperProductAttributeID as
int,
	@Title AS varchar(128),
	@SortOrder AS int
AS
	INSERT INTO OrderSuperProductAttributeValue
	(	
	OrderSuperProductAttributeID,			
	Title,			
	SortOrder		
	)
	VALUES 
	(	
	@OrderSuperProductAttributeID,			
	@Title,			
	@SortOrder																
	);

	SELECT CAST(@@IDENTITY AS int) AS 'InsertedOrderSuperProductAttributeValue';

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderSuperProductAttributeValueLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderSuperProductAttributeValueLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderSuperProductAttributeValueLoad] @OrderSuperProductAttributeValueID as
int
AS
	SELECT * 
	FROM OrderSuperProductAttributeValue
	WHERE OrderSuperProductAttributeValueID = @OrderSuperProductAttributeValueID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderSuperProductAttributeValueLoadForProduct]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderSuperProductAttributeValueLoadForProduct]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderSuperProductAttributeValueLoadForProduct] @OrderChildProductId as
int,
	@OrderProductAttributeId AS int
AS
	SELECT av.*
	FROM OrderSuperProductAttributeValue AS av JOIN OrderSuperProductChildProductAttribute AS pa ON
	av.OrderSuperProductAttributeValueID = pa.OrderSuperProductAttributeValueID
	WHERE av.OrderSuperProductAttributeID = @OrderProductAttributeId AND pa.OrderSuperProductChildProductID = @OrderChildProductId;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderSuperProductAttributeValueUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderSuperProductAttributeValueUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderSuperProductAttributeValueUpdate] @OrderSuperProductAttributeValueID as
int,
	@OrderSuperProductAttributeID AS int,
	@Title AS varchar(128),
	@SortOrder AS int

AS
	UPDATE OrderSuperProductAttributeValue
	SET 
	OrderSuperProductAttributeID = 	@OrderSuperProductAttributeID,			
	Title = @Title,			
	SortOrder = @SortOrder			
 
	WHERE OrderSuperProductAttributeValueID = @OrderSuperProductAttributeValueID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderSuperProductChildProductAttributeDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderSuperProductChildProductAttributeDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderSuperProductChildProductAttributeDelete] @OrderSuperProductChildProductID as
int,
	@OrderSuperProductAttributeValueID AS int
AS
	DELETE
	FROM OrderSuperProductChildProductAttribute
	WHERE OrderSuperProductChildProductID = @OrderSuperProductChildProductID AND
	OrderSuperProductAttributeValueID = @OrderSuperProductAttributeValueID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderSuperProductChildProductAttributeGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderSuperProductChildProductAttributeGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderSuperProductChildProductAttributeGetAll] as
SELECT *
	FROM OrderSuperProductChildProductAttribute
	ORDER BY OrderSuperProductChildProductID, OrderSuperProductAttributeValueID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderSuperProductChildProductAttributeInsert]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderSuperProductChildProductAttributeInsert]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderSuperProductChildProductAttributeInsert] @OrderSuperProductChildProductID as
int,
	@OrderSuperProductAttributeValueID AS int
AS
	INSERT INTO OrderSuperProductChildProductAttribute
	(	
	OrderSuperProductChildProductID,			
	OrderSuperProductAttributeValueID		
	)
	VALUES 
	(	
	@OrderSuperProductChildProductID,			
	@OrderSuperProductAttributeValueID																	
	);

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderSuperProductChildProductAttributeLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderSuperProductChildProductAttributeLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderSuperProductChildProductAttributeLoad] @OrderSuperProductChildProductID as
int,
	@OrderSuperProductAttributeValueID AS int
AS
	SELECT * 
	FROM OrderSuperProductChildProductAttribute
	WHERE OrderSuperProductChildProductID = @OrderSuperProductChildProductID AND
	OrderSuperProductAttributeValueID = @OrderSuperProductAttributeValueID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderSuperProductChildProductAttributeUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderSuperProductChildProductAttributeUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderSuperProductChildProductAttributeUpdate] @OrderSuperProductChildProductID as
int,
	@OrderSuperProductAttributeValueIDNew AS int,
	@OrderSuperProductAttributeValueIDOld AS int
AS
	DELETE FROM OrderSuperProductChildProductAttribute
	WHERE OrderSuperProductChildProductID = @OrderSuperProductChildProductID AND
		OrderSuperProductAttributeValueID = @OrderSuperProductAttributeValueIDOld
	INSERT INTO OrderSuperProductChildProductAttribute
	(	
	OrderSuperProductChildProductID,			
	OrderSuperProductAttributeValueID		
	)
	VALUES 
	(	
	@OrderSuperProductChildProductID,			
	@OrderSuperProductAttributeValueIDNew																	
	);

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderSuperProductChildProductDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderSuperProductChildProductDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderSuperProductChildProductDelete] @OrderSuperProductChildProductID as
int
AS
	DELETE
	FROM OrderSuperProductChildProduct
	WHERE OrderSuperProductChildProductID = @OrderSuperProductChildProductID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderSuperProductChildProductGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderSuperProductChildProductGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderSuperProductChildProductGetAll] as
SELECT *
	FROM OrderSuperProductChildProduct
	ORDER BY OrderSuperProductChildProductID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderSuperProductChildProductGetDefaultChildProductID]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderSuperProductChildProductGetDefaultChildProductID]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderSuperProductChildProductGetDefaultChildProductID] @OrderProductID int as
SELECT cp.OrderSuperProductChildProductID
	FROM OrderSuperProductChildProduct AS cp
	WHERE cp.OrderProductID = @OrderProductID AND cp.DefaultForPrice = 1

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderSuperProductChildProductInsert]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderSuperProductChildProductInsert]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderSuperProductChildProductInsert] @OrderProductID as
int,
	@ProductCode AS varchar(64),
	@DefaultForPrice AS bit,
	@Title AS varchar(128)
AS
	INSERT INTO OrderSuperProductChildProduct
	(	
	OrderProductID,			
	ProductCode,			
	DefaultForPrice,				
	Title		
	)
	VALUES 
	(	
	@OrderProductID,			
	@ProductCode,			
	@DefaultForPrice,				
	@Title																	
	);

	SELECT CAST(@@IDENTITY AS int) AS 'InsertedorderSuperProductChildProduct';

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderSuperProductChildProductLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderSuperProductChildProductLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderSuperProductChildProductLoad] @OrderSuperProductChildProductID as
int
AS
	SELECT op.OrderProductID AS 'ChildProductID', i.TITLE, osp.OrderSuperProductChildProductID,osp.OrderProductID,osp.ProductCode,osp.DefaultForPrice
	FROM OrderProduct AS op JOIN OrderSuperProductChildProduct AS osp 
	ON op.ProductCode COLLATE database_default = osp.ProductCode COLLATE database_default JOIN Product AS i ON i.PRODUCT_CODE COLLATE database_default = op.ProductCode COLLATE database_default WHERE osp.OrderSuperProductChildProductID = @OrderSuperProductChildProductID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderSuperProductChildProductUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderSuperProductChildProductUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderSuperProductChildProductUpdate] @OrderSuperProductChildProductID as
int,
	@OrderProductID AS int,
	@ProductCode AS varchar(64),
	@DefaultForPrice AS bit,
	@Title AS varchar(128)
AS
	UPDATE OrderSuperProductChildProduct
	SET 
	OrderProductID = 		@OrderProductID,			
	ProductCode = 	@ProductCode,			
	DefaultForPrice = @DefaultForPrice,				
	Title = @Title			
 
	WHERE OrderSuperProductChildProductID = @OrderSuperProductChildProductID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEOrderSuperProductChildProductUpdateDefaultForPrice]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEOrderSuperProductChildProductUpdateDefaultForPrice]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEOrderSuperProductChildProductUpdateDefaultForPrice] @OrderSuperProductChildProductID int as
DECLARE 	@productID int
	SET		@productID = 0

	SELECT	@productID = OrderProductID
	FROM		OrderSuperProductChildProduct
	WHERE	OrderSuperProductChildProductID = @OrderSuperProductChildProductID

	IF @productID != 0
	BEGIN
		UPDATE	OrderSuperProductChildProduct
		SET		DefaultForPrice = 0
		WHERE 	OrderSuperProductChildProductID <> @OrderSuperProductChildProductID AND OrderProductID = @productID

		UPDATE	OrderSuperProductChildProduct
		SET		DefaultForPrice = 1
		WHERE 	OrderSuperProductChildProductID = @OrderSuperProductChildProductID
	END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEPostCreateCleanup]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEPostCreateCleanup]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEPostCreateCleanup] @userID varchar(10),
 	@birthDate varchar(20),
 	@excludeMail bit,
 	@SICCode varchar(10) as
IF(@birthDate  <> '')
		BEGIN
			UPDATE Name
			SET BIRTH_DATE = @birthDate, EXCLUDE_MAIL = @excludeMail, SIC_CODE = @SICCode, 
				MEMBER_STATUS = '', MEMBER_STATUS_DATE  = NULL
			WHERE ID = @userID;
		END
	ELSE
		BEGIN
			UPDATE Name
			SET BIRTH_DATE = NULL, EXCLUDE_MAIL = @excludeMail, SIC_CODE = @SICCode, 
				MEMBER_STATUS = '', MEMBER_STATUS_DATE  = NULL
			WHERE ID = @userID;
		END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEPostUpdateWrapup]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEPostUpdateWrapup]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEPostUpdateWrapup] @userID varchar(10),
 	@birthDate varchar(20),
 	@excludeMail bit,
 	@SICCode varchar(10) as
IF(@birthDate  <> '')
		BEGIN
			UPDATE Name
			SET BIRTH_DATE = @birthDate, EXCLUDE_MAIL = @excludeMail, SIC_CODE = @SICCode
			WHERE ID = @userID;
		END
	ELSE
		BEGIN
			UPDATE Name
			SET BIRTH_DATE = NULL, EXCLUDE_MAIL = @excludeMail, SIC_CODE = @SICCode
			WHERE ID = @userID;
		END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEProductGetByType]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEProductGetByType]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure [dbo].[BAEProductGetByType] @ActivityType as varchar(500)
AS
IF @ActivityType = '' 
      BEGIN 
      SELECT *
      FROM Product_Type;
      END
ELSE

Begin
      SELECT *
      FROM Product_Type
      WHERE Upper(PROD_TYPE) IN (Select Element from asi_SplitString(@ActivityType, ','))
End

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAERosterManagementAvailableRecords]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAERosterManagementAvailableRecords]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/*
	Procedure:
	Check to see if STATUS = 'A' for valid records.

	DIRECTIONS:  The site pulls the column data dynamically from the metadata. 
	It requires the ID as "dbid" column in there; the other columns are at the 
	discretion of the stored procedure programmer.
*/
CREATE PROCEDURE [dbo].[BAERosterManagementAvailableRecords]
      @UID VARCHAR(10),
      @sortColumn VARCHAR(300),
      @isAsc tinyint
AS
      DECLARE @COID VARCHAR(50);
      DECLARE @columnSortDirection VARCHAR(30);
      DECLARE @sql NVARCHAR(1000);

      SET @COID = (SELECT CO_ID FROM Name WHERE ID = @UID);
      IF (@COID = '')
      BEGIN
      	    SET @COID = (SELECT ID FROM Name WHERE ID = @UID);
      END

      IF (@isAsc = 1)
      BEGIN
            SET @columnSortDirection = 'ASC';
      END 
      ELSE
      BEGIN 
            SET @columnSortDirection = 'DESC';
      END

      SET @sql = 'SELECT ID as "dbid", FIRST_NAME as "First Name", LAST_NAME as "Last Name",  MTT.DESCRIPTION as "Member Type", CITY as "City", STATE_PROVINCE as "State" FROM Name as NT JOIN Member_Types as MTT ON NT.MEMBER_TYPE = MTT.MEMBER_TYPE WHERE CO_ID = ' + @COID + ' AND STATUS = ''A'' AND NT.COMPANY_RECORD != 1 ORDER BY ' + @sortColumn + ' ' + @columnSortDirection;

      EXEC sp_executesql @sql













GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAERosterManagementAvailableRecordsDefault]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAERosterManagementAvailableRecordsDefault]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/*
      Procedure:
      Check to see if STATUS = 'A' for valid records.

      DIRECTIONS:  The site pulls the column data dynamically from the metadata. 
      It requires the ID as "dbid" column in there; the other columns are at the 
      discretion of the stored procedure programmer.

	This is the default stored procedure.  Please do not edit this and edit 
	BAERosterManagementAvailableRecords and reflect the stored procedure in 
	the admin configuration.
*/
CREATE PROCEDURE [dbo].[BAERosterManagementAvailableRecordsDefault]
      @UID VARCHAR(10),
      @sortColumn VARCHAR(300),
      @isAsc tinyint
AS
      DECLARE @COID VARCHAR(50);
      DECLARE @columnSortDirection VARCHAR(30);
      DECLARE @sql NVARCHAR(1000);

	  SET @COID = ISNULL((SELECT ID FROM Name WHERE ID = @UID and COMPANY_RECORD = 1),0);
      IF (@COID = 0)
      BEGIN
      	    SET @COID = ISNULL((SELECT CO_ID FROM Name WHERE ID = @UID),0);
      END
      IF (@COID = 0)
      BEGIN
      	    SET @COID = (SELECT ID FROM Name WHERE ID = @UID);
      END

      IF (@isAsc = 1)
      BEGIN
            SET @columnSortDirection = 'ASC';
      END 
      ELSE
      BEGIN 
            SET @columnSortDirection = 'DESC';
      END

      SET @sql = 'SELECT ID as "dbid", FIRST_NAME as "First Name", LAST_NAME as "Last Name",  MTT.DESCRIPTION as "Member Type", CITY as "City", STATE_PROVINCE as "State" FROM Name as NT JOIN Member_Types as MTT ON NT.MEMBER_TYPE = MTT.MEMBER_TYPE WHERE CO_ID = ' + @COID + ' AND STATUS = ''A'' AND NT.COMPANY_RECORD != 1 ORDER BY ' + @sortColumn + ' ' + @columnSortDirection;

      EXEC sp_executesql @sql
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAERosterManagementCompanyContact]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAERosterManagementCompanyContact]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[BAERosterManagementCompanyContact]
	@UserID as varchar(10)
AS
	/* General Notes:
	
		Ideally, you would want this procedure to only return one row in order to maximize efficiency.
		Regardless of how it determines who has access, it absolutely must return the ID field from the
		iMIS Name table in some fashion.

		The member type has to be 'CM' in order for the user to have permission to edit the roster.
		This can be changed however, in order to better suit a specific site.  For example, if you wanted
		to add any user with the member type "HOTEL" to have permission to edit the roster, you would
		have to add after the MEMBER_TYPE check: 

			OR MEMBER_TYPE IN('HOTEL')

		Furthermore, suppose you have a user that has a certain membership status, but you do not want
		them to have access to roster management.  You can find their user-id, and put at the end of this statement:
		
			AND ID <> '400'

		You must also pass in the User ID of the logged in user, regardless of whether or not it is
		actually used in the procedure.
	*/
	--SELECT ID FROM Name WHERE MEMBER_TYPE IN('CM') AND CO_ID <> '' AND ID = @UserID;
	SELECT ID FROM Name WHERE MEMBER_TYPE IN('ROST') AND CO_ID <> '' AND ID = @UserID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAERosterManagementGetRemovalReasonCodes]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAERosterManagementGetRemovalReasonCodes]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/*
  Gets the removal reason codes.  Should not be changed.
*/
CREATE PROC [dbo].[BAERosterManagementGetRemovalReasonCodes]
AS
SELECT CODE, DESCRIPTION FROM Gen_Tables WHERE TABLE_NAME = 'ROSTER_REMOVAL_REASON_CODE';

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAERosterManagementMemberTypes]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAERosterManagementMemberTypes]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/*
	Gets the member types from the general lookup table.  This should not be changed.
*/
CREATE PROCEDURE [dbo].[BAERosterManagementMemberTypes] 
AS
	SELECT MEMBER_TYPE, DESCRIPTION FROM Member_Types

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAERosterManagementRecordDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAERosterManagementRecordDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/* LOGIC:
	This also has to be logged in the iMIS Name_Log table.

	This stored procedure is responsible for changing a user's status so that they are removed from the roster.
	This procedure may be edited to suit the needs of the organization.  This is to be used in junction with
	the results given in RosterManagementGetRemovalReasonCodes.  The reason codes have a removal_id and 
	description with each record. This procedure is meant to be manually edited to handle each of these reasons 
	separately.  For example, if an organization had two options for reasons for removal, they may want to completely 
	remove the member from the roster entirely from one choice, and want to just change a member status type for the other choice. 

	A simple case:  
		RosterManagementGetRemovalReasonCodes returns:
		----------------------------------------------------
		| REMOVAL_ID | DESCRIPTION                         |
		----------------------------------------------------
		| 1	         | Retired                             |
		| 2          | Voluntarily Left                    |
        | 3          | Other                               |
        ----------------------------------------------------

	Could yield: 
	
	IF (@RemovalCode = 1)
		BEGIN
			UPDATE imisDB..Name SET MEMBER_TYPE = 'RET', CO_ID = '' WHERE ID = @UID;
		END

	IF (@RemovalCode = 2)
		BEGIN
			UPDATE imisDB..Name SET MEMBER_TYPE = 'VOL', CO_ID = '' WHERE ID = @UID;
		END

	IF (@RemovalCode = 3)
		BEGIN
			UPDATE imisDB..Name SET WHERE ID = @UID;
		END

	Keep in mind that that the records returned are determined by the stored procedure that is
	represented by the RosterManagementAvailableRecordsStoredProc config variable.

	Parameters: 
		@UID - User's ID to be updated.
		@RemovalCode - the removal code that the user is going to be changed to
		@managerID - the ID of the user that performs this action.  Will be a roster manager.
*/
CREATE PROCEDURE [dbo].[BAERosterManagementRecordDelete]
	@UID VARCHAR(10),
	@RemovalCode VARCHAR(60),
	@managerID VARCHAR(10)
AS
	DECLARE @removalReason varchar(128);
	DECLARE @removalDescription varchar(500);

	--GENERAL--
	/*Explanation of general: 
		NOTE: This example is supposed to be here as an EXAMPLE ONLY.  While this code will 
		work and work as intended, it is STRONGLY ADVISED to be edited to better suit your
		website.

		This function dictates that a person's member type stays the same when any removal code
		is given, except if the selection is 'deceased'.  If a member is deceased, the member type
		will be changed to 'D'.  

		Once again, this example is for demonstration purposes only.  It is inteded to work, but 
		it is advised to be changed on a per-site basis.
	*/
	DECLARE @currentMemberType varchar(5);

	SET @currentMemberType = (SELECT MEMBER_TYPE FROM Name WHERE ID = @UID);
	
	BEGIN
		UPDATE Name SET CO_ID = '' WHERE ID = @UID;
	END
	
	---------------------	

	--LEAVE THESE THREE LINES IN.  THEY PUT THE DATA INTO THE NAME LOG
	SET @removalReason = (SELECT DESCRIPTION FROM Gen_Tables WHERE CODE = @RemovalCode AND TABLE_NAME = 'ROSTER_REMOVAL_REASON_CODE');
	
	SET @removalDescription = 'REMOVAL_DESCRIPTION: ' + @removalReason + ' (' + CAST(@RemovalCode as varchar(60)) + ')';
	
	INSERT INTO Name_Log (DATE_TIME, LOG_TYPE, SUB_TYPE, USER_ID, ID, LOG_TEXT) VALUES(GETDATE(), 'CHANGE', 'CHANGE', @managerID, @UID, @removalDescription);

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAERosterManagementSetUserActive]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAERosterManagementSetUserActive]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/*
sets the status when a roster manager sets a user to active.
*/
CREATE PROC [dbo].[BAERosterManagementSetUserActive]
@uid VARCHAR(10)
AS 
UPDATE Name SET STATUS = 'A' WHERE ID = @uid;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAESearchEvents]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAESearchEvents]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[BAESearchEvents]
@SearchString VARCHAR(200),
@MatchType INT

AS

-- SeachString:  String of 1 or more search terms, all separated by spaces
-- MatchType: 0=match any, 1 =match all, 2 = exact match of entire expression only
-- Results are returned in order of relevance

DECLARE @i1 INT;
DECLARE @i2 INT;
DECLARE @Word VARCHAR(100);
DECLARE @Words TABLE (Word VARCHAR(100) NOT NULL);
DECLARE @Events TABLE (
	Meeting	VARCHAR(10),
	Title VARCHAR(60),
	Description text
)

INSERT INTO @Events
SELECT MEETING, TITLE, DESCRIPTION FROM Meet_Master
	WHERE WEB_ENABLED = '1' AND STATUS = 'A'  AND (BEGIN_DATE > GETDATE() OR END_DATE >= GETDATE())

DECLARE @WordCount AS integer;

SET NOCOUNT ON

-- Parse the SearchString to extract all words:

IF (@MatchType != 2)
	BEGIN
		SET @SearchString = ' ' + @SearchString  + ' ';
		SET @i1 = 1;

		WHILE (@i1 != 0)
			BEGIN
				SET @i2=CHARINDEX(' ', @SearchString, @i1+1)
				IF (@i2 != 0)
					BEGIN
					  SET @Word = RTRIM(LTRIM(SUBSTRING(@SearchString, @i1+1, @i2-@i1)))
					  IF @Word != '' INSERT INTO @Words SELECT @Word
					END
				SET @i1 = @i2
			END
		END
ELSE
	INSERT INTO @Words SELECT LTRIM(RTRIM(@SearchString))

 -- Get the total # of words:

set @WordCount = (select count(*) from @Words)

-- Return Results in order of relevance:

SELECT a.MatchPct, T.*
FROM @Events AS T
INNER JOIN
(
	SELECT T.Meeting, COUNT(*) * 1.0 / @WordCount AS MatchPct
	FROM @Events T
	INNER JOIN
		@Words W on (' ' + LOWER(T.Title) + ' ' LIKE '%[^a-z]' + LOWER(Word) + '[^a-z]%')
		OR (' ' + Lower(Substring(T.Description,1,DATALENGTH(T.Description))) + ' ' LIKE '%[^a-z]' + LOWER(Word) + '[^a-z]%')
	GROUP BY T.Meeting
 ) a ON T.Meeting = a.Meeting
WHERE
	MatchPct = 1 or @MatchType <>1
ORDER BY
	MatchPct desc

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAESearchProductsWithCategory]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAESearchProductsWithCategory]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[BAESearchProductsWithCategory]
@SearchString VARCHAR(200),
@MatchType INT

AS

-- SeachString:  String of 1 or more search terms, all separated by spaces
-- MatchType: 0=match any, 1 =match all, 2 = exact match of entire expression only
-- Results are returned in order of relevance

DECLARE @i1 INT;
DECLARE @i2 INT;
DECLARE @Word VARCHAR(100);
DECLARE @Words TABLE (Word VARCHAR(100) NOT NULL);
DECLARE @ProductsWithCategory TABLE (
	OrderProductID	INT,
	Title			VARCHAR(60),
	Description		VARCHAR(4096),
	IsSuperProduct	BIT,
	ProductCode		VARCHAR(31),
	SellOnWeb		INT,
	IsKit			BIT,
	OrderCategoryID	INT
)

INSERT INTO @ProductsWithCategory
SELECT DISTINCT OrderProduct.OrderProductID, p.TITLE COLLATE database_default AS Title, (CAST(p.WEB_DESC AS varchar(4096))) Description, IsSuperProduct, ProductCode, p.WEB_OPTION AS SellOnWeb, p.IS_KIT AS IsKit, 
		(SELECT	TOP 1 OrderCategoryID FROM OrderProductCategoryLookup cat WHERE cat.OrderProductID = OrderProduct.OrderProductID) AS OrderCategoryID
	FROM 	OrderProduct INNER JOIN Product p 
		ON p.PRODUCT_CODE COLLATE database_default = OrderProduct.ProductCode COLLATE database_default
	WHERE 	((IsSuperProduct = 0 AND p.WEB_OPTION > 0))  AND (SELECT TOP 1 OrderCategoryID FROM OrderProductCategoryLookup cat WHERE cat.OrderProductID = OrderProduct.OrderProductID) IS NOT NULL
	UNION
	SELECT DISTINCT op.OrderProductID, op.Title  COLLATE database_default AS Title, op.Description  COLLATE database_default, op.IsSuperProduct, op.ProductCode, op.SellOnWeb, CAST('0' AS bit)  AS IsKit, 
		(SELECT TOP 1  OrderCategoryID FROM OrderProductCategoryLookup cat WHERE cat.OrderProductID = op.OrderProductID) AS OrderCategoryID
	FROM 	OrderProduct op 
	WHERE 	IsSuperProduct = 1 AND op.SellOnWeb > 0 AND (SELECT TOP 1  OrderCategoryID FROM OrderProductCategoryLookup cat WHERE cat.OrderProductID = op.OrderProductID) IS NOT NULL

DECLARE @WordCount AS integer;

SET NOCOUNT ON

-- Parse the SearchString to extract all words:

IF (@MatchType != 2)
	BEGIN
		SET @SearchString = ' ' + @SearchString  + ' ';
		SET @i1 = 1;

		WHILE (@i1 != 0)
			BEGIN
				SET @i2=CHARINDEX(' ', @SearchString, @i1+1)
				IF (@i2 != 0)
					BEGIN
					  SET @Word = RTRIM(LTRIM(SUBSTRING(@SearchString, @i1+1, @i2-@i1)))
					  IF @Word != '' INSERT INTO @Words SELECT @Word
					END
				SET @i1 = @i2
			END
		END
ELSE

	INSERT INTO @Words SELECT LTRIM(RTRIM(@SearchString))

 -- Get the total # of words:

set @WordCount = (select count(*) from @Words)

-- Return Results in order of relevance:

SELECT a.MatchPct, T.*
FROM @ProductsWithCategory T
INNER JOIN
(
	SELECT T.OrderProductID, COUNT(*)  * 1.0 / @WordCount AS MatchPct
	FROM @ProductsWithCategory T
	INNER JOIN
		@Words W on ' ' + LOWER(T.Title) + ' ' LIKE '%[^a-z]' + LOWER(Word) + '[^a-z]%'
		OR ' ' + LOWER(T.Description) + ' ' LIKE '%[^a-z]' + LOWER(Word) + '[^a-z]%'
		OR dbo.SearchForSuperProduct(T.OrderProductID, T.IsSuperProduct, @SearchString, @MatchType) = 1
	GROUP BY T.OrderProductID
 ) a ON T.OrderProductID = a.OrderProductID
WHERE
	MatchPct = 1 or @MatchType <>1
ORDER BY
	T.Title

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAESyncImisUserDefinedTables]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAESyncImisUserDefinedTables]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/*
	Description: Updates the FieldDesign table with default VALUES FROM the Imis.UD_Field 
	The table needs to be in sync so you dont have to query both datasets.
*/
CREATE PROCEDURE [dbo].[BAESyncImisUserDefinedTables] AS
INSERT INTO FieldDesign
SELECT UD_Field.TABLE_NAME, UD_Field.FIELD_NAME, 0, '', '', '' FROM UD_Field 
WHERE FIELD_NAME COLLATE database_default NOT IN (SELECT DISTINCT FieldDesign.FieldName FROM FieldDesign WHERE TableName COLLATE database_default = TABLE_NAME COLLATE database_default)

DELETE FROM FieldDesign WHERE FieldDesign.FieldName COLLATE database_default 
	NOT IN (SELECT udf.FIELD_NAME FROM UD_Field udf WHERE FieldDesign.TableName COLLATE database_default = udf.TABLE_NAME COLLATE database_default);

DELETE FROM FieldDesignSectionLookup WHERE FieldDesignSectionLookup.FieldName 
	NOT IN (SELECT fd.FieldName FROM FieldDesign fd WHERE FieldDesignSectionLookup.TableName COLLATE database_default = fd.TableName COLLATE database_default);
/*
DELETE FROM FieldSection WHERE FieldSection.FieldSectionID 
	NOT IN (SELECT fdsl.FieldSectionID FROM FieldDesignSectionLookup fdsl)
*/


-----------------------------------
set ANSI_NULLS OFF
set QUOTED_IDENTIFIER OFF

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEUpdateBatchInformation]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEUpdateBatchInformation]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEUpdateBatchInformation] @orderNum float,
 	@taxDifferenceAmount MONEY as
DECLARE	@batchNum VARCHAR(16)

SELECT	@batchNum = BATCH_NUM
FROM		Orders
WHERE	ORDER_NUMBER = @orderNum;

UPDATE	Batch
SET		CONTROL_CASH = ( CONTROL_CASH + @taxDifferenceAmount ), 
		TRANS_CASH = ( TRANS_CASH + @taxDifferenceAmount)
WHERE	BATCH_NUM = @batchNum;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEUpdateCreditCardStatus]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEUpdateCreditCardStatus]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEUpdateCreditCardStatus] @oNum decimal,
 	@payTransDescription varchar(255) as
UPDATE	Trans
	SET		CC_STATUS = 'C', DESCRIPTION = @payTransDescription
	FROM		Trans trans
	WHERE	(SELECT	Orders.INVOICE_REFERENCE_NUM
		 	 FROM		Orders Orders 
	 		 WHERE 	@oNum = Orders.ORDER_NUMBER) = trans.INVOICE_REFERENCE_NUM AND 
			trans.TRANSACTION_TYPE = 'PAY'

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEUpdateEventPOPurchase]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEUpdateEventPOPurchase]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEUpdateEventPOPurchase] @OrderNum	integer,
 	@PONum		varchar(40) as
SET NOCOUNT ON

	DECLARE @BatchNum	varchar(10)
	DECLARE @TransNum	integer
	DECLARE @InvRefNum 	integer
	DECLARE @TransAmount	money
	DECLARE @OwnerOrg	varchar(5)
	DECLARE @OwnerARAcct	varchar(50)
	DECLARE @BatchCashAcct	varchar(50)
	DECLARE @btId varchar(10)
	DECLARE @stId varchar(10)
	DECLARE @title varchar(60)

	SELECT @title = TITLE FROM Meet_Master WHERE MEETING = (SELECT MEETING FROM  Order_Meet WHERE ORDER_NUMBER = @OrderNum);

	SELECT @InvRefNum = INVOICE_REFERENCE_NUM,
		@BatchNum = BATCH_NUM,
		@btId = BT_ID,
		@stId = ST_ID
	FROM Orders
	WHERE ORDER_NUMBER = @OrderNum
	
	SELECT  @OwnerOrg = t.OWNER_ORG_CODE,
		@TransNum = t.TRANS_NUMBER
	FROM Trans t
	WHERE t.INVOICE_REFERENCE_NUM = @InvRefNum
		and t.LINE_NUMBER = 1
		and t.TRANSACTION_TYPE = 'DIST' 

	SELECT 	@TransAmount = t.AMOUNT
	FROM Trans t
	WHERE t.TRANS_NUMBER = @TransNum
		and t.TRANSACTION_TYPE = 'PAY'

	SELECT @OwnerARAcct = DefaultArAccount
	FROM Org_Control 
	WHERE OrgCode = @OwnerOrg


	UPDATE Trans
	SET TRANSACTION_TYPE = 'AR',
            CUSTOMER_REFERENCE = @PONum,   
            PSEUDO_ACCOUNT = OWNER_ORG_CODE + '-MEETING-AR',
            GL_ACCT_ORG_CODE = OWNER_ORG_CODE,
            GL_ACCOUNT = isnull(@OwnerARAcct,''),      
	    INVOICE_CREDITS = 0,
            PAYMENT_TYPE = '',
            CHECK_NUMBER = '',
            CC_NUMBER = '',
            CC_EXPIRE = '',
            CC_NAME = '',
            CC_STATUS = '',
            ENCRYPT_CC_NUMBER = '',
            ENCRYPT_CC_EXPIRE = ''
	WHERE TRANS_NUMBER = @TransNum and TRANSACTION_TYPE = 'PAY'

	UPDATE Trans
	SET CUSTOMER_REFERENCE = @PONum,   
            CHECK_NUMBER = '',
            CC_NUMBER = '',
            CC_EXPIRE = '',
            CC_NAME = '',
            CC_STATUS = '',
            ENCRYPT_CC_NUMBER = '',
            ENCRYPT_CC_EXPIRE = ''
	WHERE TRANS_NUMBER = @TransNum and TRANSACTION_TYPE = 'DIST'

	UPDATE Orders
	SET TOTAL_PAYMENTS = 0,
            BALANCE = isnull(@TransAmount,0),
	    OTHER_PAY = 0,
            RECOGNIZED_CASH_AMOUNT = 0, 
            CUSTOMER_REFERENCE = @PONum,
            PAY_TYPE = '',
            PAY_NUMBER = '',
            CREDIT_CARD_EXPIRES = '',
            CREDIT_CARD_NAME = '',
            CASH_GL_ACCT = '',
            ENCRYPT_PAY_NUMBER = '',
            ENCRYPT_CREDIT_CARD_EXPIRES = ''
	WHERE ORDER_NUMBER = @OrderNum  

	UPDATE Batch
	SET TRANS_CASH = TRANS_CASH - isnull(@TransAmount,0),
	    CONTROL_CASH = CONTROL_CASH - isnull(@TransAmount,0),
	    TRANS_COUNT = case when TRANS_COUNT > 0 then TRANS_COUNT - 1 else TRANS_COUNT end, 
	    CONTROL_COUNT = case when CONTROL_COUNT > 0 then CONTROL_COUNT - 1 else CONTROL_COUNT end 
	WHERE BATCH_NUM = @BatchNum  

	SET NOCOUNT OFF

	--INSERT INTO Invoice (BT_ID, ST_ID, REFERENCE_NUM, INVOICE_NUM, INVOICE_DATE, EFFECTIVE_DATE, ORG_CODE, SOURCE_SYSTEM, DESCRIPTION, CUSTOMER_REFERENCE, TERMS_CODE, AR_ACCOUNT, SOURCE_CODE, BATCH_NUM, CHARGES, CREDITS, BALANCE, INVOICE_TYPE ,INSTALL_BILL_DATE,ORIGINATING_TRANS_NUM , NUM_LINES, IS_MULTI_ORG, BILL_TO_CC) 
	--values (@btId, @stId, @InvRefNum, 0,GetDate(),GetDate(), @OwnerOrg, 'MEETING', @title, @PONum, '', isnull(@OwnerARAcct,''),'',@BatchNum, @TransAmount,0.00,@TransAmount,'', NULL, @TransNum , 0 , 0 ,0 )

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEUpdateIMISShipMethod]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEUpdateIMISShipMethod]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEUpdateIMISShipMethod] @orderID varchar(64),
 	@shipMethod varchar(64) as
begin
		UPDATE Orders
			SET SHIP_METHOD = @shipMethod
		WHERE ORDER_NUMBER = @orderID
	end

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEUpdateLoginTime]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEUpdateLoginTime]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEUpdateLoginTime] @userID varchar(10) as
UPDATE Name_Security
	SET PREVIOUS_LOGIN = LAST_LOGIN
	WHERE ID = @userID;
	
	UPDATE Name_Security
	SET LAST_LOGIN = GETDATE()
	WHERE ID = @userID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEUpdateOrderEnteredBy]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEUpdateOrderEnteredBy]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[BAEUpdateOrderEnteredBy] @OrderNum decimal(18,2), @UID varchar(50) 
AS
BEGIN
    -- UPDATE the orders table
    UPDATE [dbo].[Orders]
    SET ENTERED_BY = @UID 
    WHERE ORDER_NUMBER = @OrderNum;

    -- UPDATE the trans table
    UPDATE [dbo].[Trans] 
    SET ENTERED_BY = @UID 
    WHERE INVOICE_REFERENCE_NUM <> 0 
    AND INVOICE_REFERENCE_NUM = (SELECT INVOICE_REFERENCE_NUM 
                                 FROM [dbo].[Orders]
                                 WHERE ORDER_NUMBER = @OrderNum)
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEUpdateOrderInformation]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEUpdateOrderInformation]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEUpdateOrderInformation] @totalCharges money,
 	@totalPayments money,
 	@balance money,
 	@linetaxable money,
 	@freight money,
 	@handling money,
 	@tax money,
 	@orderNum int as
Declare @trans AS int;
	Declare @diff AS decimal(18,2);
	Declare @batchNum VARCHAR(16);

	--Get transaction number
	SELECT @trans = TRANS_NUMBER, @batchNum = t.BATCH_NUM FROM Trans t, Orders o
	WHERE t.BT_ID = o.BT_ID AND t.ST_ID = o.BT_ID AND t.INVOICE_REFERENCE_NUM = o.PREPAID_INVOICE_REFERENCE_NUM AND o.ORDER_NUMBER = @orderNum;

	--Get difference
	SELECT @diff = (@totalCharges - AMOUNT) FROM Trans WHERE TRANS_NUMBER = @trans AND TRANSACTION_TYPE = 'PAY';

	UPDATE Orders
	SET 
		TOTAL_CHARGES = @totalCharges,
		TOTAL_PAYMENTS = @totalPayments,
		BALANCE = @balance,
		LINE_TAXABLE = @linetaxable,
		FREIGHT_1 = 0.0,
		FREIGHT_2 = @freight,
		HANDLING_1 = 0.0,
		HANDLING_2 = @handling,
		TAX_1 = @tax,
		TAX_2 = 0.0,
		TAX_3 = 0.0
	WHERE ORDER_NUMBER = @orderNum

	--UPDATE PAY line. SET Amount, Invoice_credits = total_charges
	UPDATE Trans SET AMOUNT = @totalCharges, INVOICE_CREDITS = @totalPayments WHERE TRANS_NUMBER = @trans AND TRANSACTION_TYPE = 'PAY';
	
	--UPDATE PP line. SET Amount = -total_charges
	UPDATE Trans SET AMOUNT = (@totalPayments * -1) WHERE TRANS_NUMBER = @trans AND TRANSACTION_TYPE = 'PP';

	--UPDATE batch control. SET Control_Cash = control_cash + difference, trans_cash = trans_cash + difference
	UPDATE  Batch  SET CONTROL_CASH = (CONTROL_CASH + @diff), TRANS_CASH = (TRANS_CASH + @diff) WHERE BATCH_NUM = @batchNum;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEUpdateOrderProductInfo]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEUpdateOrderProductInfo]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEUpdateOrderProductInfo] @ProductCode varchar(31),
 	@Title varchar(60),
 	@Description varchar(4096),
 	@WebOption tinyint,
 	@ImageURL varchar(100),
 	@ThumbnailURL varchar(100) as
UPDATE Product
	SET TITLE = @Title,
	 WEB_DESC = @Description, 
	WEB_OPTION = @WebOption,
	 IMAGE_URL = @ImageURL, 
	THUMBNAIL_URL = @ThumbnailURL
	WHERE PRODUCT_CODE = @ProductCode;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEUpdateOrderShipping]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEUpdateOrderShipping]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEUpdateOrderShipping] @shipUsing varchar(64),
 	@orderNum int as
UPDATE Orders
	SET SHIP_METHOD = @shipUsing
	WHERE ORDER_NUMBER = @orderNum

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEUpdateOrderTransactionsByOrderNumber]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEUpdateOrderTransactionsByOrderNumber]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEUpdateOrderTransactionsByOrderNumber] @orderNum decimal(18,2),
 	@amount money as
UPDATE	Trans
	SET		AMOUNT = -(@amount)
	WHERE	TRANS_NUMBER IN (
			SELECT	trans.TRANS_NUMBER
			FROM		Trans trans INNER JOIN
					Orders orders ON trans.BATCH_NUM = orders.BATCH_NUM INNER JOIN
					Order_Lines olines ON olines.ORDER_NUMBER = orders.ORDER_NUMBER
			WHERE	orders.ORDER_NUMBER = @orderNum AND
					orders.PREPAID_INVOICE_REFERENCE_NUM = trans.INVOICE_REFERENCE_NUM AND 
					trans.LINE_NUMBER = 1 AND
					trans.TRANSACTION_TYPE = 'PP')  AND
		LINE_NUMBER = 1;

	UPDATE	Trans
	SET		AMOUNT = @amount,
			INVOICE_CREDITS = @amount
	WHERE	TRANS_NUMBER IN (
			SELECT	trans.TRANS_NUMBER
			FROM		Trans trans INNER JOIN
					Orders orders ON trans.BATCH_NUM = orders.BATCH_NUM INNER JOIN
					Order_Lines olines ON olines.ORDER_NUMBER = orders.ORDER_NUMBER
			WHERE	orders.ORDER_NUMBER = @orderNum AND
					orders.PREPAID_INVOICE_REFERENCE_NUM = trans.INVOICE_REFERENCE_NUM AND 
					trans.LINE_NUMBER = 2 AND
					trans.TRANSACTION_TYPE = 'PAY') AND
		LINE_NUMBER = 2;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEUpdateRegistrantEventOrderInfo]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEUpdateRegistrantEventOrderInfo]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEUpdateRegistrantEventOrderInfo] @orderNumber float,
 	@eventCode as
varchar(10),
	@regID AS varchar(10)
AS
	UPDATE Orders
	SET FIRST_NAME = ev.FirstName, LAST_NAME = ev.LastName, MIDDLE_NAME = ev.MiddleInitial, ADDRESS_1 = ev.Address1,
		ADDRESS_2 = ev.Address2, ADDRESS_3 = ev.Address3, CITY = ev.City, STATE_PROVINCE = ev.StateProvince, ZIP = ev.PostalCode, 
		EMAIL = ev.Email, PHONE = ev.Phone
	FROM EventRegistrant ev
	WHERE ORDER_NUMBER = @orderNumber AND ev.RegistrantID = @regID AND ev.EventCode = @eventCode

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEUpdateWebLogin]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEUpdateWebLogin]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEUpdateWebLogin] @webLogin varchar(60),
 	@userID varchar(10) as
UPDATE Name_Security 
	SET WEB_LOGIN = @webLogin
	WHERE ID = @userID

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEValidateLogin]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEValidateLogin]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEValidateLogin] @pUsername as
varchar(60),
	@pPassword AS varchar(100)
AS
	SELECT * FROM
	Name_Security
	WHERE
	WEB_LOGIN = @pUsername AND [PASSWORD] = @pPassword;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEValidateWebLogin]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEValidateWebLogin]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEValidateWebLogin] @login varchar(60) as
SELECT * FROM Name_Security
	WHERE WEB_LOGIN = @login

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEVerifyUserAdded]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEVerifyUserAdded]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEVerifyUserAdded] @userID varchar(10) as
Select * from  Name where ID = @userID;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEWriteHistory]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEWriteHistory]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEWriteHistory] @pIP as
varchar(128),
	@pDescription as varchar(1024),
	@pEventType as varchar(256)
AS
	INSERT INTO History
	(History.EventDate, History.IP, History.[Description], History.EventType)
	VALUES
	(GETDATE(), @pIP, @pDescription, @pEventType)

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEZipCodesDelete]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEZipCodesDelete]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEZipCodesDelete] @ZipCode as
int
AS
	DELETE
	FROM Zip_Code
	WHERE ZIP = @ZipCode;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEZipCodesGetAll]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEZipCodesGetAll]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEZipCodesGetAll] as
SELECT *
	FROM Zip_Code
	ORDER BY ZIP;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BAEZipCodesLoad]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[BAEZipCodesLoad]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[BAEZipCodesLoad] @ZipCode as
int
AS
	SELECT * 
	FROM Zip_Code
	WHERE ZIP = @ZipCode;

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CopyIDRow]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[CopyIDRow]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
-- This procedure takes a table name and an ID type (identity) key value in as
-- arguments and copies the row with that ID to a new row with a new ID.  The
-- new ID is returned.

CREATE  PROCEDURE CopyIDRow @TableName varchar(40), @KeyValue numeric AS
  DECLARE GetColumns CURSOR LOCAL READ_ONLY FOR
  SELECT b.name, b.autoval
    FROM sysobjects a, syscolumns b
   WHERE a.id = b.id
     AND a.name = @TableName
   ORDER By b.autoval
  BEGIN
    DECLARE
    @AutoVal varbinary,
    @ColumnName varchar(50),
    @KeyColumn varchar(50),
    @ColumnList varchar(2000),
    @InsertQuery nvarchar(4000)
    
    SET @ColumnList = ''
    OPEN GetColumns
     
    FETCH NEXT FROM GetColumns
     INTO @ColumnName, @AutoVal
    
    WHILE @@FETCH_STATUS = 0
    	BEGIN
         IF @AutoVal IS NULL
           BEGIN
             SET @ColumnList = @ColumnList + @ColumnName + ','
           END
         ELSE
           BEGIN
             SET @KeyColumn = @ColumnName
           END
      FETCH NEXT FROM GetColumns
       INTO @ColumnName, @AutoVal
      END
      
    CLOSE GetColumns
    DEALLOCATE GetColumns
    
    SET @ColumnList = Left(@ColumnList,Len(@ColumnList) - 1)
     
    SET @InsertQuery = 'INSERT INTO ' + @TableName + '(' + @ColumnList + ')' + 'SELECT ' + @ColumnList + ' FROM ' + @TableName + ' WHERE ' + @KeyColumn + ' = ' + CAST(@KeyValue AS varchar)
    
    EXECUTE sp_executesql @InsertQuery
  END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_AddressUpdate]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_AddressUpdate]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE  sp_asi_AddressUpdate
 as
 declare
 @addrnum int,
 @ADDRESS_1 varchar(40),
 @ADDRESS_2 varchar(40),
 @ADDRESS_3 varchar(40),
 @CITY varchar(40),
 @STATE_PROVINCE varchar(15),
 @ZIP varchar(10),
 @COUNTRY varchar(25),
 @code int,
 @full_address varchar(255),
 @formula varchar(255),
 @addrlen integer,
 @ID varchar(10),
 @Preferred_Mail integer
 set nocount on
 DECLARE Get_Addrs cursor for 
 select ID,PREFERRED_MAIL,ADDRESS_NUM,ADDRESS_1,ADDRESS_2,ADDRESS_3,CITY,STATE_PROVINCE,ZIP,COUNTRY from Name_Address
 where datalength(ADDRESS_1)>1
 open Get_Addrs
 fetch next from Get_Addrs into @ID,@Preferred_Mail,@addrnum,@ADDRESS_1,@ADDRESS_2,@ADDRESS_3,@CITY,@STATE_PROVINCE,@ZIP,@COUNTRY
 While @@FETCH_STATUS<>-1
 BEGIN
 if  @@FETCH_STATUS <> -2
 BEGIN
 select @code=NULL
 select @code=ADDRESS_FORMAT from Country_Names  where COUNTRY=@COUNTRY
 select @code=isnull(@code,0)
 if @code=0  
 begin  
 if (not exists (select * from Country_Addr_Layouts where ADDRESS_FORMAT=0)) 
 insert into Country_Addr_Layouts (ADDRESS_FORMAT, ADDRESS_LAYOUT, FORMULA) 
 values (0, 'ADDRESS_1[N]ADDRESS_2[N]ADDRESS_3[N]CITY[C][S]STATE_PROVINCE[S]ZIP[N][U]COUNTRY', 
 'ADDRESS_1[N]ADDRESS_2[N]CITY[C][S]STATE_PROVINCE[S]ZIP[N][U]COUNTRY') 
 end 
 begin
 select @formula=FORMULA from Country_Addr_Layouts where ADDRESS_FORMAT=@code
 while charindex('[N]',@formula)>0
 begin
 select @formula=stuff(@formula,charindex('[N]',@formula),3,char(13))
 end
 while charindex('[S]',@formula)>0
 begin
 select @formula=stuff(@formula,charindex('[S]',@formula),3,' ')
 end
 while charindex('[C]',@formula)>0
 begin
 select @formula=stuff(@formula,charindex('[C]',@formula),3,',')
 end
 if charindex('CITY',@formula)>0
 select @formula=stuff(@formula,charindex('CITY',@formula),4,'_CITY') 
 if charindex('ZIP',@formula)>0
 select @formula=stuff(@formula,charindex('ZIP',@formula),3,'_ZIP') 
 if charindex('COUNTRY',@formula)>0
 select @formula=stuff(@formula,charindex('COUNTRY',@formula),7,'_COUNTRY') 
 if charindex('[U]ADDRESS_1',@formula)>0 
 select @formula=stuff(@formula,charindex('[U]ADDRESS_1',@formula),12,upper(@ADDRESS_1)) 
 if charindex('[U]ADDRESS_2',@formula)>0 
 select @formula=stuff(@formula,charindex('[U]ADDRESS_2',@formula),12,upper(@ADDRESS_2)) 
 if charindex('[U]ADDRESS_3',@formula)>0 
 select @formula=stuff(@formula,charindex('[U]ADDRESS_3',@formula),12,upper(@ADDRESS_3))
 if charindex('[U]_CITY',@formula)>0 
   begin
   if charindex('[U]_CITY,',@formula)>0
     begin
     if datalength (@STATE_PROVINCE) = 0  
       select @formula=stuff(@formula,charindex('[U]_CITY,',@formula),9,'[U]_CITY') 
     end
   select @formula=stuff(@formula,charindex('[U]_CITY',@formula),8,upper(@CITY))
   end
 if charindex('[U]STATE_PROVINCE',@formula)>0 
 select @formula=stuff(@formula,charindex('[U]STATE_PROVINCE',@formula),17,upper(@STATE_PROVINCE)) 
 if charindex('[U]_ZIP',@formula)>0 
 select @formula=stuff(@formula,charindex('[U]_ZIP',@formula),7,upper(@ZIP)) 
 if charindex('[U]_COUNTRY',@formula)>0 
 select @formula=stuff(@formula,charindex('[U]_COUNTRY',@formula),11,upper(@COUNTRY)) 
 if charindex('ADDRESS_1',@formula)>0 
   select @formula=stuff(@formula,charindex('ADDRESS_1',@formula),9,@ADDRESS_1) 
 if charindex('ADDRESS_2',@formula)>0 
   select @formula=stuff(@formula,charindex('ADDRESS_2',@formula),9,@ADDRESS_2) 
 if charindex('ADDRESS_3',@formula)>0 
   select @formula=stuff(@formula,charindex('ADDRESS_3',@formula),9,@ADDRESS_3)
 if charindex('_CITY',@formula)>0 
   begin
   if charindex('_CITY,',@formula)>0
     begin
     if datalength (@STATE_PROVINCE) = 0  
       select @formula=stuff(@formula,charindex('_CITY,',@formula),6,'_CITY') 
     end
   select @formula=stuff(@formula,charindex('_CITY',@formula),5,@CITY) 
   end
 if charindex('STATE_PROVINCE',@formula)>0 
 select @formula=stuff(@formula,charindex('STATE_PROVINCE',@formula),14,@STATE_PROVINCE) 
 if charindex('_ZIP',@formula)>0 
 select @formula=stuff(@formula,charindex('_ZIP',@formula),4,@ZIP) 
 if charindex('_COUNTRY',@formula)>0 
 select @formula=stuff(@formula,charindex('_COUNTRY',@formula),8,@COUNTRY) 
 if charindex('US1',@formula)>0 
 select @formula=stuff(@formula,charindex('US1',@formula),3,'') 
 if charindex('US2',@formula)>0 
 select @formula=stuff(@formula,charindex('US2',@formula),3,'') 
 while charindex(char(13)+' ',@formula)>0      
 begin        
 select @formula=stuff(@formula,charindex(char(13)+' ',@formula),2,char(13))      
 end
 while charindex(char(13)+',',@formula)>0      
 begin        
 select @formula=stuff(@formula,charindex(char(13)+',',@formula),2,char(13))      
 end 
 while charindex(char(13)+char(13),@formula)>0      
 begin        
 select @formula=stuff(@formula,charindex(char(13)+char(13),@formula),2,char(13))      
 end    
 while charindex(char(13)+' '+char(13),@formula)>0      
 begin        
 select @formula=stuff(@formula,charindex(char(13)+' '+char(13),@formula),3,char(13))      
 end
 select @addrlen=datalength (@formula)
 while substring (@formula, @addrlen, 1)=char(13)
          select @formula=substring(@formula, 1, @addrlen-1)
 select @full_address=@formula
 if datalength(@full_address)>1
 begin
 update Name_Address set FULL_ADDRESS=@full_address,ADDRESS_FORMAT=@code where ADDRESS_NUM=@addrnum
     if @Preferred_Mail = 1
        begin
              update Name set FULL_ADDRESS = @full_address where ID = @ID
       end
 end
 end
 END
 fetch next from Get_Addrs into @ID, @Preferred_Mail,@addrnum,@ADDRESS_1,@ADDRESS_2,@ADDRESS_3,@CITY,@STATE_PROVINCE,@ZIP,@COUNTRY
 END
 close Get_Addrs
 deallocate Get_Addrs

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_AdvancedFlowdown]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_AdvancedFlowdown]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure [dbo].[sp_asi_AdvancedFlowdown]
 as
 set nocount on
 declare
 @Short varchar(8000),
 @Str varchar(255),
 @Pos int,
 @Len int,
 @Cmd varchar(8000),
 @TableName varchar(30),
 @FieldName varchar(30)
 update Name set Name.MEMBER_RECORD = Member_Types.MEMBER_RECORD
 from Name, Member_Types 
 where Name.MEMBER_TYPE = Member_Types.MEMBER_TYPE
 and Name.MEMBER_RECORD <> Member_Types.MEMBER_RECORD 
 update Name set Name.COMPANY_RECORD = Member_Types.COMPANY_RECORD 
 from Name, Member_Types 
 where Name.MEMBER_TYPE=Member_Types.MEMBER_TYPE
 and Name.COMPANY_RECORD <> Member_Types.COMPANY_RECORD 
 create table 
 #TableNames (TABLE_NAME varchar(30) not null default '')
 create table
 #TablesAndFields (TABLE_NAME varchar(30) not null default 'Name',
 FIELD_NAME varchar(30) not null default '')
 select @Short = ShortValue from System_Params where ParameterName = 'Member_Control.FlowDownFields'
 select @Len = datalength(@Short)
 if @Len=0
 BEGIN
 select @Short = LongValue from System_Params where ParameterName = 'Member_Control.FlowDownFields'
 END
 select @Pos = charindex(',',@Short)
 while @Pos > 0
 BEGIN
 select @Str = substring(@Short,1,@Pos - 1)
 select @Short = substring(@Short,@Pos + 1,datalength(@Short) - @Pos)
 select @Pos = charindex('.',@Str)
 if @Pos > 0
 BEGIN
 insert #TablesAndFields
 select substring(@Str,1,@Pos-1),substring(@Str,@Pos+1,datalength(@Str)-@Pos)
 END
 else
 BEGIN
 insert #TablesAndFields(FIELD_NAME)
 select @Str
 END
 select @Pos = charindex(',',@Short)
 END
 select @Pos = charindex('.',@Short)
 if @Pos > 0
 BEGIN
 insert #TablesAndFields
 select substring(@Short,1,@Pos - 1),substring(@Short,@Pos + 1,datalength(@Short) - @Pos)
 END
 else
 BEGIN
 insert #TablesAndFields(FIELD_NAME)
 select @Short
 END
 insert #TableNames
 select distinct TABLE_NAME
 from #TablesAndFields
 declare GetTables cursor for
 select TABLE_NAME
 from #TableNames
 open GetTables
 fetch next from GetTables into @TableName
 while @@fetch_status = 0
 BEGIN
 select @Cmd = 'update ' + @TableName + ' set ' 
 declare GetFields cursor for 
 select FIELD_NAME
 from #TablesAndFields
 where TABLE_NAME = @TableName
 open GetFields
 fetch next from GetFields into @FieldName
 while @@fetch_status = 0
 BEGIN
 select @Cmd = @Cmd + @FieldName + '=xxx.' + @FieldName + ',' 
 fetch next from GetFields into @FieldName
 END
 close GetFields
 deallocate GetFields
 select @Cmd = substring(@Cmd,1,datalength(@Cmd)-1)
 if @TableName = 'Name'
 BEGIN
 select @Cmd = @Cmd + ' from ' + @TableName + ' ' + @TableName + ',' + @TableName + ' xxx'
 select @Cmd = @Cmd + ' where Name.CO_ID = xxx.ID and Name.COMPANY_RECORD=0'
 END
 else
 BEGIN
 select @Cmd = @Cmd + ' from ' + @TableName + ' ' + @TableName + ',' + @TableName + ' xxx,Name Name,Name n2'
 select @Cmd = @Cmd + ' where Name.CO_ID = n2.ID and Name.ID = ' + @TableName + '.ID and n2.ID = xxx.ID'
 select @Cmd = @Cmd + ' and Name.COMPANY_RECORD=0'
 END
 set nocount off
 exec(@Cmd)
 set nocount on
 fetch next from GetTables into @TableName
 END
 close GetTables
 deallocate GetTables

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_ARPayment]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_ARPayment]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE procedure sp_asi_ARPayment
@inv_num int = 0,
@pmt_amt_tot money = 0,
@trans_counter int = 0,
@GLOrg varchar(5) = '', 
@GLAcct varchar(50) = '', 
@CashOrg varchar(5) = '',
@CashAcct varchar(50) = '',
@PseudoAcctAR varchar(50) = '',
@PseudoAcctPay varchar(50) = '',
@pay_type varchar(10) = '',
@checknum varchar(10) = '', 
@CCnum varchar(25) = '', 
@CCexpire varchar(10) = '', 
@CCauthorize varchar(10) = '', 
@CCname varchar(40) = '',
@CCnum_encrypted varchar(100) = '', 
@CCexpire_encrypted varchar(100) = '',  
@entered_by varchar(15) = '', 
@payment_batch varchar(10) = '',
@posted_flag int = 2,
@transaction_date datetime,
@fiscal_period int = 0

as 


set nocount on



if exists (select * from sysobjects where name = '#Inv_Line_Temp' and xtype = 'U')
         truncate table #Inv_Line_Temp
else
begin
         create table #Inv_Line_Temp (  
                 LINE_NUM int NOT NULL DEFAULT 0, 
                 INVOICE_NUM int NOT NULL DEFAULT 0,
                 CHARGES money NOT NULL DEFAULT 0,
                 CREDITS money NOT NULL DEFAULT 0,
                 BALANCE money NOT NULL DEFAULT 0,
                 ADJUSTMENTS money NOT NULL DEFAULT 0,
                 INVLINES_BILL_THRU datetime NULL DEFAULT NULL,
                 BATCH_NUM varchar(10) NOT NULL DEFAULT '',
                 ORG_CODE varchar(5) NOT NULL DEFAULT '',
                 TRANS_NUMBER int NOT NULL DEFAULT 0,
                 OWNER_ORG_CODE varchar(10) NOT NULL DEFAULT '',
                 SOURCE_SYSTEM varchar(10) NOT NULL DEFAULT '',
                 TRANSACTION_DATE datetime NULL DEFAULT NULL,
                 BT_ID varchar(10) NOT NULL DEFAULT '',
                 ST_ID varchar(10) NOT NULL DEFAULT '',
                 DESCRIPTION varchar(255) NOT NULL DEFAULT '',
                 PRODUCT_CODE varchar(31) NOT NULL DEFAULT '',
                 EFFECTIVE_DATE datetime NULL DEFAULT NULL,
                 QUANTITY numeric (17,4) NOT NULL DEFAULT 0,
                 PROD_TYPE varchar(5) NOT NULL DEFAULT '',
                 SUBSC_BILL_THRU datetime NULL DEFAULT NULL,
                 MEMBER_TYPE varchar(5) NOT NULL DEFAULT '',
                 STATUS varchar(5) NOT NULL DEFAULT '',
                 MEMBER_STATUS varchar(5) NOT NULL DEFAULT '',
                 MEMBER_STATUS_DATE datetime NULL DEFAULT NULL,
                 PAID_THRU datetime NULL DEFAULT NULL,
                 MEMBER_RECORD bit NOT NULL default 0,
                 JOIN_DATE datetime NULL DEFAULT NULL,
                 CO_ID varchar(10) NOT NULL DEFAULT '',
                 COMPANY_RECORD bit NOT NULL default 0,
                 ACTIVITY_SEQN int NOT NULL DEFAULT 0,
                 AMT_PAID money NOT NULL DEFAULT 0
                 )
create unique index invlinenum_idx on #Inv_Line_Temp (LINE_NUM) 

end


declare @ret_value int 
declare @error_hold int

set @ret_value = 1
set @error_hold = 1

declare @application_type int
select @application_type = count(*) from System_Params where ParameterName = 'Dues_Control.ARPaymentApplication'

if @inv_num = 0 
         goto error_handler

if @pmt_amt_tot = 0
         goto error_handler

declare @ref_num int

declare @line_num int
declare @charges money
declare @credits money
declare @balance money
declare @adjustments money
declare @invoice_balance money
declare @inv_lines_total money


declare @BT_ID varchar(10)
declare @ST_ID varchar(10)

select @ref_num = REFERENCE_NUM from Invoice where INVOICE_NUM = @inv_num
select @BT_ID = BT_ID from Invoice where INVOICE_NUM = @inv_num
select @ST_ID = ST_ID from Invoice where INVOICE_NUM = @inv_num
select @invoice_balance = BALANCE from Invoice where INVOICE_NUM = @inv_num

declare @pmt_amt money
declare @pmt_amt_tot_no_overpay    money
declare @proportional_amt money

if @pmt_amt_tot > @invoice_balance
         begin
         select @pmt_amt = @invoice_balance 
         select @pmt_amt_tot_no_overpay = @invoice_balance
         end
else
         begin
         select @pmt_amt = @pmt_amt_tot
         select @pmt_amt_tot_no_overpay = @pmt_amt_tot
         end

insert into #Inv_Line_Temp (LINE_NUM, INVOICE_NUM, CHARGES, CREDITS, BALANCE, ADJUSTMENTS, INVLINES_BILL_THRU)  
         select LINE_NUM, @inv_num, CHARGES, CREDITS, BALANCE, ADJUSTMENTS, BILL_THRU from Invoice_Lines where REFERENCE_NUM = @ref_num

update #Inv_Line_Temp set 
         #Inv_Line_Temp.BATCH_NUM = Invoice.BATCH_NUM,
         #Inv_Line_Temp.ORG_CODE = Invoice.ORG_CODE
from Invoice where REFERENCE_NUM = @ref_num

update #Inv_Line_Temp set 
         #Inv_Line_Temp.TRANS_NUMBER = Trans.TRANS_NUMBER, 
         #Inv_Line_Temp.OWNER_ORG_CODE = Trans.OWNER_ORG_CODE, 
         #Inv_Line_Temp.SOURCE_SYSTEM = Trans.SOURCE_SYSTEM,
         #Inv_Line_Temp.TRANSACTION_DATE = Trans.TRANSACTION_DATE, 
         #Inv_Line_Temp.BT_ID = Trans.BT_ID, 
         #Inv_Line_Temp.ST_ID = Trans.ST_ID, 
         #Inv_Line_Temp.DESCRIPTION = Trans.DESCRIPTION, 
         #Inv_Line_Temp.PRODUCT_CODE = Trans.PRODUCT_CODE, 
         #Inv_Line_Temp.EFFECTIVE_DATE = Trans.EFFECTIVE_DATE, 
         #Inv_Line_Temp.QUANTITY = Trans.QUANTITY, 
         #Inv_Line_Temp.PROD_TYPE = Trans.PROD_TYPE 
         from Trans where Trans.INVOICE_REFERENCE_NUM = @ref_num 
                 and Trans.INVOICE_LINE_NUM = #Inv_Line_Temp.LINE_NUM and JOURNAL_TYPE = 'IN'

update #Inv_Line_Temp set 
         #Inv_Line_Temp.SUBSC_BILL_THRU = Subscriptions.BILL_THRU
         from Subscriptions where Subscriptions.INVOICE_REFERENCE_NUM = @ref_num 
                 and INVOICE_LINE_NUM = #Inv_Line_Temp.LINE_NUM

update #Inv_Line_Temp set 
                 #Inv_Line_Temp.MEMBER_TYPE = Name.MEMBER_TYPE,
                 #Inv_Line_Temp.STATUS = Name.STATUS,        
                 #Inv_Line_Temp.MEMBER_STATUS = Name.MEMBER_STATUS,
                 #Inv_Line_Temp.MEMBER_STATUS_DATE = Name.MEMBER_STATUS_DATE,
                 #Inv_Line_Temp.PAID_THRU = Name.PAID_THRU,
                 #Inv_Line_Temp.MEMBER_RECORD = Name.MEMBER_RECORD,
                 #Inv_Line_Temp.JOIN_DATE = Name.JOIN_DATE,
                 #Inv_Line_Temp.CO_ID = Name.CO_ID,
                 #Inv_Line_Temp.COMPANY_RECORD = Name.COMPANY_RECORD
         from Name where Name.ID = #Inv_Line_Temp.ST_ID

select @inv_lines_total = sum (CHARGES) from #Inv_Line_Temp

declare @pmt_tots_proportional money
set @pmt_tots_proportional = 0


declare line_cursor cursor for 
         select LINE_NUM, CHARGES, CREDITS, BALANCE, ADJUSTMENTS      
         from #Inv_Line_Temp where CHARGES <> 0 order by LINE_NUM
open line_cursor

fetch next from line_cursor into @line_num, @charges, @credits, @balance, @adjustments
while @@FETCH_STATUS = 0 and abs(@pmt_amt) > 0 
begin
         if @application_type = 0
                 begin
                 if @balance >= @pmt_amt 
                          begin
                          update #Inv_Line_Temp set
                                   CREDITS = CREDITS + @pmt_amt,
                                   BALANCE = BALANCE - @pmt_amt,
                                   AMT_PAID = @pmt_amt
                          where current of line_cursor
                          set @pmt_amt = 0 
                          end
                 else if @pmt_amt > @balance
                          begin
                          update #Inv_Line_Temp set 
                                   CREDITS = CREDITS + @balance,
                                   BALANCE = 0,
                                   AMT_PAID = AMT_PAID + @balance
                          where current of line_cursor
                          set @pmt_amt = @pmt_amt - @balance
                          end
                 end
         else if @application_type = 1 
                 begin
                          if @charges <> 0 
                                   begin
                                   if @pmt_amt_tot < @inv_lines_total          
                                            begin
                                                     set @proportional_amt = round (@pmt_amt_tot_no_overpay * @charges / @inv_lines_total, 2)
                                                    update #Inv_Line_Temp set
                                                             CREDITS = CREDITS + @proportional_amt,
                                                             BALANCE = BALANCE - @proportional_amt,
                                                             AMT_PAID = @proportional_amt
                                                    where current of line_cursor
                                                     set @pmt_tots_proportional = @pmt_tots_proportional + @proportional_amt
                                                    set @pmt_amt = @pmt_amt - @proportional_amt
                                            end
                                   else 
                                            begin
                                                    update #Inv_Line_Temp set 
                                                             CREDITS = CREDITS + @balance,
                                                             BALANCE = 0,
                                                             AMT_PAID = AMT_PAID + @balance
                                                    where current of line_cursor
                                                    set @pmt_amt = @pmt_amt - @balance
                                            end
                                   end
                 end

         fetch next from line_cursor into @line_num, @charges, @credits, @balance, @adjustments
end

close line_cursor
deallocate line_cursor

if @application_type = 1 and abs(@pmt_amt_tot) < @inv_lines_total  
         begin
                 declare @pmt_amt_diff money
                 set @pmt_amt_diff = @pmt_amt_tot - @pmt_tots_proportional

                 if @pmt_amt_diff <> 0
                          update #Inv_Line_Temp set 
                                   CREDITS = CREDITS + @pmt_amt_diff,
                                   BALANCE = BALANCE - @pmt_amt_diff
                                   where BALANCE = (select max (BALANCE) from #Inv_Line_Temp)
         end

declare @activity_count int
select @activity_count = count(*) from #Inv_Line_Temp where AMT_PAID <> 0

declare @activity_counter int

if not exists (select COUNTER_NAME from Counter where COUNTER_NAME='Activity')        
         insert Counter (COUNTER_NAME, LAST_VALUE) values ('Activity',0)  

update Counter set 
                 LAST_VALUE=LAST_VALUE +@activity_count ,               
                 LAST_UPDATED=getdate(), 
                 UPDATED_BY=user_name()         
         where COUNTER_NAME= 'Activity' 

select @activity_counter = LAST_VALUE from Counter where COUNTER_NAME = 'Activity'


create table #tmp_seqn (
         LINE_NUM int NOT NULL DEFAULT 0,
         SEQN_TMP int NOT NULL DEFAULT 0,
         SEQN_TMP_IDENT int IDENTITY (1, 1) 
         )
create unique index invlinenum_idx on #tmp_seqn (LINE_NUM)

insert #tmp_seqn (LINE_NUM) 
         select #Inv_Line_Temp.LINE_NUM 
         from #Inv_Line_Temp 
         where AMT_PAID <> 0
update #tmp_seqn set SEQN_TMP = SEQN_TMP_IDENT + @activity_counter - @activity_count

update #Inv_Line_Temp set 
         ACTIVITY_SEQN = #tmp_seqn.SEQN_TMP
         from #tmp_seqn
         where #Inv_Line_Temp.LINE_NUM = #tmp_seqn.LINE_NUM

update Invoice set
         CREDITS = CREDITS + @pmt_amt_tot_no_overpay,
         BALANCE = BALANCE - @pmt_amt_tot_no_overpay
where REFERENCE_NUM = @ref_num
if @@error <> 0
         begin
         set @error_hold = @@error
         goto error_handler
         end

update Invoice_Lines set 
         Invoice_Lines.CREDITS =   Invoice_Lines.CREDITS + #Inv_Line_Temp.AMT_PAID,
         Invoice_Lines.BALANCE = Invoice_Lines.BALANCE - #Inv_Line_Temp.AMT_PAID
         from Invoice_Lines, #Inv_Line_Temp
         where Invoice_Lines.REFERENCE_NUM = @ref_num and
                 Invoice_Lines.LINE_NUM = #Inv_Line_Temp.LINE_NUM
if @@error <> 0
         begin
         set @error_hold = @@error
         goto error_handler
         end

update Subscriptions set 
         PAID_THRU = #Inv_Line_Temp.SUBSC_BILL_THRU, 
         Subscriptions.BALANCE = Subscriptions.BALANCE - #Inv_Line_Temp.AMT_PAID, 
         PAYMENT_AMOUNT = PAYMENT_AMOUNT + #Inv_Line_Temp.AMT_PAID, 
         BEGIN_DATE = #Inv_Line_Temp.EFFECTIVE_DATE, 
         CONTINUOUS_SINCE = #Inv_Line_Temp.EFFECTIVE_DATE, 
         PAYMENT_DATE = @transaction_date, 
         LAST_PAID_THRU = #Inv_Line_Temp.SUBSC_BILL_THRU, 
         COPIES_PAID = BILL_COPIES, 
         LTD_PAYMENTS = LTD_PAYMENTS + #Inv_Line_Temp.AMT_PAID
         from #Inv_Line_Temp 
         where Subscriptions.INVOICE_REFERENCE_NUM = @ref_num 
                 and Subscriptions.INVOICE_LINE_NUM=#Inv_Line_Temp.LINE_NUM
if @@error <> 0
         begin
         set @error_hold = @@error
         goto error_handler
         end

insert into Activity 
                 (SEQN, ID,ACTIVITY_TYPE, PRODUCT_CODE, 
                 OTHER_CODE, 
                 TRANSACTION_DATE, DESCRIPTION, 
                  EFFECTIVE_DATE, THRU_DATE, AMOUNT, SOURCE_SYSTEM, QUANTITY, ORIGINATING_TRANS_NUM, ORG_CODE, 
                 OTHER_ID,CO_ID,MEMBER_TYPE)
         select ACTIVITY_SEQN, BT_ID,'DUES', PRODUCT_CODE, 
                 (select PROD_TYPE from Product where Product.PRODUCT_CODE = #Inv_Line_Temp.PRODUCT_CODE),
                 TRANSACTION_DATE, DESCRIPTION, 
                  EFFECTIVE_DATE, SUBSC_BILL_THRU, AMT_PAID, 'AR', QUANTITY, TRANS_NUMBER, OWNER_ORG_CODE, 
                 ST_ID, CO_ID,MEMBER_TYPE 
                 from #Inv_Line_Temp 
                 where ACTIVITY_SEQN <> 0
if @@error <> 0
         begin
         set @error_hold = @@error
         goto error_handler
         end

update Batch set TRANS_COUNT = TRANS_COUNT + 1, TRANS_CASH = TRANS_CASH + @pmt_amt_tot  
         where BATCH_NUM = @payment_batch
if @@error <> 0
         begin
         set @error_hold = @@error
         goto error_handler
         end

update Name set 
         PAID_THRU = #Inv_Line_Temp.SUBSC_BILL_THRU
         from #Inv_Line_Temp 
         where Name.ID=#Inv_Line_Temp.ST_ID
if @@error <> 0
         begin
         set @error_hold = @@error
         goto error_handler
         end


declare @trans_line_ctr int
select @trans_line_ctr = 1


if @pmt_amt_tot > @invoice_balance
         begin

                 declare @invoice_ref_num int
                  if not exists (select COUNTER_NAME from Counter where COUNTER_NAME='Invoice_Ref')        
                          insert Counter (COUNTER_NAME, LAST_VALUE) values ('Invoice_Ref',0)  
                 update Counter set 
                                   LAST_VALUE=LAST_VALUE + 1,               
                                   LAST_UPDATED=getdate(), 
                                   UPDATED_BY=user_name()         
                          where COUNTER_NAME= 'Invoice_Ref' 
                 select @invoice_ref_num = LAST_VALUE from Counter where COUNTER_NAME = 'Invoice_Ref'

                 declare @overpay_amt money
                 select @overpay_amt = @pmt_amt_tot - @invoice_balance
                 
                 declare @prepay_desc varchar(100)
                  select @prepay_desc = 'Dues Overpayment: ' + convert (varchar(2),datepart (mm, getdate())) + '/'  
                                            + convert (varchar(2),datepart (dd, getdate())) + '/'  
                                            + convert (varchar(4),datepart (yyyy, getdate()))
                                            + ' -- ' + convert (varchar(20), @invoice_ref_num)

                 declare @AR_acct varchar(100)
                 select @AR_acct = AR_ACCOUNT from Invoice where INVOICE_NUM = @inv_num

                 insert into Invoice 
                          (BT_ID, ST_ID, REFERENCE_NUM, INVOICE_NUM, INVOICE_DATE, EFFECTIVE_DATE, ORG_CODE, SOURCE_SYSTEM, 
                          DESCRIPTION, CUSTOMER_REFERENCE, TERMS_CODE, AR_ACCOUNT, SOURCE_CODE, BATCH_NUM, INVOICE_TYPE,
                          CREDITS, BALANCE) 
                  values ( @BT_ID, @ST_ID, @invoice_ref_num, 0, @transaction_date, @transaction_date, @CashOrg, 'AR',
                          @prepay_desc, '', '', @AR_acct, '', @payment_batch, '',
                          @overpay_amt, 0.00 - @overpay_amt )

                 insert into Trans 
                          (TRANS_NUMBER, LINE_NUMBER, SUB_LINE_NUMBER, BATCH_NUM, OWNER_ORG_CODE, SOURCE_SYSTEM, JOURNAL_TYPE, 
                          TRANSACTION_TYPE, TRANSACTION_DATE, BT_ID, ST_ID, INVOICE_REFERENCE_NUM, 
                          DESCRIPTION, CUSTOMER_NAME, CUSTOMER_REFERENCE, REFERENCE_1, SOURCE_CODE, PRODUCT_CODE, 
                          EFFECTIVE_DATE, PAID_THRU, MONTHS_PAID, 
                          FISCAL_PERIOD, DEFERRAL_MONTHS, AMOUNT, ADJUSTMENT_AMOUNT, 
                          PSEUDO_ACCOUNT, GL_ACCT_ORG_CODE, GL_ACCOUNT, DEFERRED_GL_ACCOUNT, 
                          INVOICE_CHARGES, INVOICE_CREDITS, 
                          QUANTITY, UNIT_PRICE, PAYMENT_TYPE, CHECK_NUMBER, CC_NUMBER, CC_EXPIRE, CC_AUTHORIZE, 
                          CC_NAME, TERMS_CODE, ACTIVITY_SEQN, POSTED, PROD_TYPE, ACTIVITY_TYPE, ACTION_CODES, TICKLER_DATE, 
                          DATE_ENTERED, ENTERED_BY, INSTALL_BILL_DATE, TAXABLE_VALUE, SOLICITOR_ID, MERGE_CODE, 
                          SALUTATION_CODE, SENDER_CODE, IS_MATCH_GIFT, MATCH_GIFT_TRANS_NUM, 
                           INVOICE_LINE_NUM,MATCH_ACTIVITY_SEQN,MEM_TRIB_ID,RECEIPT_ID,DO_NOT_RECEIPT,ENCRYPT_CC_NUMBER,ENCRYPT_CC_EXPIRE) 
                 select 
                          @trans_counter, @trans_line_ctr, 1, @payment_batch, @CashOrg, 'AR','PAY',
                          'AR', @transaction_date, @BT_ID, @ST_ID, @invoice_ref_num, 
                          @prepay_desc, '', '', 'Inv# R0', '', '', 
                          NULL, NULL, 0, 
                          @fiscal_period, 0, -@overpay_amt, 0,
                          @PseudoAcctAR, @GLOrg, @GLAcct, '', 
                          0, @overpay_amt, 
                          0.0000, 0.00, '', @checknum, @CCnum, @CCexpire, @CCauthorize, 
                          @CCname, '', 0, @posted_flag,'', '', '', NULL, 
                          getdate (),@entered_by, NULL, 0.00,'','',
                          '','', 0, 0, 
                          1, 0, '', 0, 0,@CCnum_encrypted, @CCexpire_encrypted 

                 if @@error <> 0
                          begin
                          set @error_hold = @@error
                          goto error_handler
                          end

                 select @trans_line_ctr = @trans_line_ctr + 1
         end


insert into Trans 
         (TRANS_NUMBER, LINE_NUMBER, SUB_LINE_NUMBER, BATCH_NUM, OWNER_ORG_CODE, SOURCE_SYSTEM, JOURNAL_TYPE, 
         TRANSACTION_TYPE, TRANSACTION_DATE, BT_ID, ST_ID, INVOICE_REFERENCE_NUM, DESCRIPTION, CUSTOMER_NAME, CUSTOMER_REFERENCE, 
         REFERENCE_1, SOURCE_CODE, PRODUCT_CODE, EFFECTIVE_DATE, PAID_THRU, MONTHS_PAID, 
         FISCAL_PERIOD, DEFERRAL_MONTHS, AMOUNT, ADJUSTMENT_AMOUNT, 
         PSEUDO_ACCOUNT, GL_ACCT_ORG_CODE, GL_ACCOUNT, DEFERRED_GL_ACCOUNT, 
         INVOICE_CHARGES, INVOICE_CREDITS, QUANTITY, UNIT_PRICE, PAYMENT_TYPE, CHECK_NUMBER, CC_NUMBER, CC_EXPIRE, CC_AUTHORIZE, CC_NAME, TERMS_CODE, ACTIVITY_SEQN, 
         POSTED, PROD_TYPE, ACTIVITY_TYPE, ACTION_CODES, TICKLER_DATE, DATE_ENTERED, ENTERED_BY, INSTALL_BILL_DATE, TAXABLE_VALUE, 
         SOLICITOR_ID, MERGE_CODE, SALUTATION_CODE, SENDER_CODE, IS_MATCH_GIFT, MATCH_GIFT_TRANS_NUM, 
         INVOICE_LINE_NUM,MATCH_ACTIVITY_SEQN,MEM_TRIB_ID,RECEIPT_ID,DO_NOT_RECEIPT,ENCRYPT_CC_NUMBER,ENCRYPT_CC_EXPIRE) 
         select 
         @trans_counter, @trans_line_ctr, #Inv_Line_Temp.LINE_NUM, @payment_batch, #Inv_Line_Temp.OWNER_ORG_CODE, 
         'AR','PAY','AR',@transaction_date, #Inv_Line_Temp.BT_ID,#Inv_Line_Temp.ST_ID, @ref_num, '','','',
         'Inv# ' + convert (varchar(20), @ref_num), '','',NULL,#Inv_Line_Temp.INVLINES_BILL_THRU,0, 
         @fiscal_period, 0, -(#Inv_Line_Temp.AMT_PAID), 0,
         @PseudoAcctAR, @GLOrg, @GLAcct,'', 
         0, #Inv_Line_Temp.AMT_PAID, 
         0.0000, 0.00,'', @checknum, @CCnum, @CCexpire, @CCauthorize, 
         @CCname, '', #Inv_Line_Temp.ACTIVITY_SEQN, @posted_flag,'', '', '', NULL, getdate (),@entered_by, 
         NULL, 0.00,'','','','', 0, 0, #Inv_Line_Temp.LINE_NUM, 0, '', 0, 0,@CCnum_encrypted, @CCexpire_encrypted 
         from #Inv_Line_Temp 
         where #Inv_Line_Temp.AMT_PAID <> 0

if @@error <> 0
         begin
         set @error_hold = @@error
         goto error_handler
         end

select @trans_line_ctr = @trans_line_ctr + 1

insert into Trans 
         (TRANS_NUMBER, LINE_NUMBER, SUB_LINE_NUMBER, BATCH_NUM, OWNER_ORG_CODE, SOURCE_SYSTEM, JOURNAL_TYPE, TRANSACTION_TYPE, TRANSACTION_DATE, BT_ID, ST_ID, INVOICE_REFERENCE_NUM, DESCRIPTION, CUSTOMER_NAME, 
         CUSTOMER_REFERENCE, REFERENCE_1, SOURCE_CODE, PRODUCT_CODE, EFFECTIVE_DATE, PAID_THRU, MONTHS_PAID, 
         FISCAL_PERIOD, DEFERRAL_MONTHS, AMOUNT, ADJUSTMENT_AMOUNT, 
         PSEUDO_ACCOUNT, GL_ACCT_ORG_CODE, GL_ACCOUNT, DEFERRED_GL_ACCOUNT, 
         INVOICE_CHARGES, INVOICE_CREDITS, QUANTITY, UNIT_PRICE, PAYMENT_TYPE, CHECK_NUMBER, CC_NUMBER, CC_EXPIRE, CC_AUTHORIZE, CC_NAME, TERMS_CODE, 
         ACTIVITY_SEQN, POSTED, PROD_TYPE, ACTIVITY_TYPE, ACTION_CODES, TICKLER_DATE, DATE_ENTERED, ENTERED_BY, 
         INSTALL_BILL_DATE, TAXABLE_VALUE, SOLICITOR_ID, MERGE_CODE, SALUTATION_CODE, SENDER_CODE, IS_MATCH_GIFT, 
         MATCH_GIFT_TRANS_NUM, INVOICE_LINE_NUM,MATCH_ACTIVITY_SEQN,MEM_TRIB_ID,RECEIPT_ID,DO_NOT_RECEIPT,
         ENCRYPT_CC_NUMBER,ENCRYPT_CC_EXPIRE) 
         select 
         @trans_counter, @trans_line_ctr, 1, @payment_batch, @CashOrg, 
         'AR','PAY','PAY',@transaction_date, @BT_ID, @ST_ID, 0, '','','',
         '', '','',NULL, NULL,0, @fiscal_period, 0, @pmt_amt_tot, 0,
         @PseudoAcctPay, @CashOrg, @CashAcct,'', 
         0, 0, 
         0.0000, 0.00,'', @checknum, @CCnum, @CCexpire, @CCauthorize, 
         @CCname, '', 0, @posted_flag,'', '', '', NULL, getdate (),@entered_by, 
         NULL, 0.00,'','','','', 0, 0, 0, 0, '', 0, 0,@CCnum_encrypted, @CCexpire_encrypted 
if @@error <> 0
         begin
         set @error_hold = @@error
         goto error_handler
         end

set @ret_value = 0
goto endit

error_handler:
set @ret_value = @error_hold

endit:
select @ret_value

set nocount off
return


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_iboGetCounter]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_iboGetCounter]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE sp_iboGetCounter 
  @CounterName varchar(30) = '' , @IncrementBy   int = 1 , @FirstUnique int OUTPUT
  /* version 10/7/03 */ 
  /***   sp_iboGetCounter  For a given CounterName, returns the next value. (Guaranteed unique). 
  	If you supply the optional second param "incrementBy", then you receive the additional guarantee that    
  	you can use that many consecutive numbers, all with a uniqueness guarantee.  
  Sample use:  ----------------------------------------------------------------    
  	exec sp_iboGetCounter  'MyCounterName', 3  
  	returns     101  Now you know that 101, 102, 103 are all usable unique numbers   
  Revisions: ------------------------------------------------------------------- x/x/xx    
  Initial version 1/8/97   mw added optional second param IncrementBy  
  Revision 4/24/01   scd added Transaction and locking, output parm rather than recordset   
  Revision 10/7/2003 Change to update first, only insert if fails to remove contention and reduce deadlocks********/
  AS 
  BEGIN TRANSACTION 
  SET TRANSACTION ISOLATION LEVEL SERIALIZABLE
  declare @id varchar(10),@NewId varchar(10), @LastValue int,@checksum int,@strChecksum varchar(1),
  @digit int,@weight int,@subpos int,@sum int,@weights varchar(9),@pos int
  if @CounterName in ('Name','Prospect') and 
  (select ShortValue from System_Params where ParameterName='Member_Control.UseChecksumForId')='YES'
  BEGIN
   select @weights='2345672345'
   select @LastValue=LAST_VALUE from Counter where COUNTER_NAME=@CounterName
   if (select HAS_CHECKSUM from Counter where COUNTER_NAME=@CounterName)=1
 	  BEGIN
 	   select @id=convert(varchar(10),@LastValue)
 	   select @id=substring(@id,1,datalength(@id)-1)
 	   select @LastValue=convert(int,@id)+1
 	   select @id=convert(varchar(10),@LastValue)
 	  END
   ELSE
 	  BEGIN
 	   select @LastValue=@LastValue+1
 	   select @id=convert(varchar(10),@LastValue)
 	  END
 	  select @subpos=datalength(@id)+1
 	  select @pos=0
 	  while @pos<datalength(@id)
 	  BEGIN
 	   select @pos=@pos+1
 	   select @weight=convert(int,(substring(@weights,@pos,1)))
 	   select @digit=convert(int,(substring(@id,@subpos-@pos,1)))
 	   select @sum=isnull(@sum,0)+(@weight*@digit)
 	  END
 	  select @checksum=@sum%11
 	  if @checksum=0
 	  BEGIN
 	   select @checksum=1
 	  END
 	  select @checksum=(11-@checksum)%10
 	  select @strChecksum=convert(varchar(1),@checksum)
 	  select @NewId=@id+@strChecksum
 	   update Counter 
 	   set LAST_VALUE=convert(int,@NewId) , LAST_UPDATED=getdate(), UPDATED_BY=user_name(),HAS_CHECKSUM=1,@FirstUnique = convert(int,@NewId) 
 	   where COUNTER_NAME= @CounterName
 	   if @@ROWCOUNT = 0
 	   BEGIN
 	 	insert into Counter(COUNTER_NAME, LAST_VALUE) select @CounterName,0 
 		where not exists (select * from Counter where COUNTER_NAME = @CounterName)
 		update Counter 
 		   set LAST_VALUE=convert(int,@NewId) , LAST_UPDATED=getdate(), UPDATED_BY=user_name(),HAS_CHECKSUM=1,@FirstUnique = convert(int,@NewId) 
 		 where COUNTER_NAME= @CounterName   
 	   END
 	 END 
  ELSE
  BEGIN
    update Counter         
   	set LAST_VALUE=LAST_VALUE +@IncrementBy ,               
   		LAST_UPDATED=getdate(), 
   		UPDATED_BY=user_name(),
 		@FirstUnique = LAST_VALUE + 1                  
   	where COUNTER_NAME= @CounterName 
    if @@ROWCOUNT = 0
    BEGIN
  	insert into Counter(COUNTER_NAME, LAST_VALUE) select @CounterName,0 
 	where not exists (select * from Counter where COUNTER_NAME = @CounterName)
 	update Counter 
   	set LAST_VALUE=LAST_VALUE + @IncrementBy ,               
   		LAST_UPDATED=getdate(), 
   		UPDATED_BY=user_name(),
 		@FirstUnique = LAST_VALUE + 1                 
 	 where COUNTER_NAME= @CounterName   
    END	
  END  
   COMMIT TRANSACTION

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_Cert_Completion]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_Cert_Completion]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure  [dbo].[sp_asi_Cert_Completion] 
@ProgID varchar (31),
@NotifyBoard bit=0,
@NotifyStudent bit=0,
@ActUF1 varchar(255)='',
@ActUF2 varchar(255)='',
@ActUF3 varchar(255)='',
@ActUF4 float=0,
@ActUF5 float=0,
@ActUF6 datetime=null,
@ActUF7 datetime=null,
@AllowGracePeriods bit=0,
@UpdateGoodThruForGracePeriod bit=0,
@CurrentLocalDate varchar (50)=''
as
set nocount on
declare
@RowsAffected integer,
@Seqn int,
@StudentID varchar (10),
@RegistrationItem varchar (31),
@Status varchar (1),
@EnrolledDate datetime,
@Deadline datetime,
@CompletionDate datetime,
@BoardNotified bit,
@StudentNotified bit,
@GoodThruDate datetime,
@RequirementType int,
@InGracePeriod bit,
@ActivitySeqn int,
@GracePeriodMonths int,
@GracePeriodForInit bit,
@GracePeriodForMaint bit,
@Designation1 varchar (20),
@Designation2 varchar (20),
@Designation3 varchar (20),
@JointProgram varchar (31), 
@RotateDateRule int, 
@RotateBeginDate datetime,
@RotateCompletionMonths int,
@FullName varchar (60),
@Company varchar (80),
@City varchar (40),
@StateProvince varchar (15),
@Country varchar (25),
@ProgramID varchar (31),
@Title varchar (50),
@AutoEnrollForMaint bit,
@ProgramType int,
@CurrentProgramID varchar (31),
@JointProgramProof bit,
@CurrentProgramProof bit,
@Seqn1 int,
@Seqn2 int,
@SuperCategory bit,
@SubcategoryNames varchar(8000),
@CplProgramID varchar (31),
@CplComponentCode varchar (31),
@CplComponentCategory varchar (31),
@CplLineNumber int,
@CplLineType  varchar (10),
@CplUnitsRequiredForCredit numeric(15,2), 
@CplRequirementType int,
@ProductCertParent bit,
@CertRegUnitsEarned numeric(15,2),
@CertRegSeqn int,
@CertRegRegType varchar (1),
@CertRegProgID varchar(31),
@TotalUnits numeric(15,2),
@UnitsFromCPL numeric(15,2),
@UnitsFromComponents numeric(15,2),
@UnitsFromSubComponents numeric(15,2),
@UnitsFromSubCategories numeric(15,2),
@CompProdCode varchar(31),
@SubcategoryNamesItem varchar (31),
@SubCompProdCode varchar (31),
@SubCompLineNumber int,
@SubCompChildProdCode varchar (31),
@SubCompRequired bit,
@Abort bit,
@Result int,
@NewProgSeqn int,
@NewActSeqn int,
@CoID varchar (10),
@MemberType varchar (5),
@TotCharges money,
@CRNotes varchar(8000),
@ActString varchar (255),
@TreatDeadline bit,
@TotalUnitsRequiredForCredit numeric(15,2)
create table #ProgramLinesList (
PROGRAM_ID varchar (31),
COMPONENT_CODE varchar (31),
COMPONENT_CATEGORY varchar (31),
LINE_NUMBER int,
LINE_TYPE  varchar (10),
UNITS_REQUIRED_FOR_CREDIT numeric(15,2), 
REQUIREMENT_TYPE int
)
create table #ComponentList (
PRODUCT_CODE varchar (31)
)
create table #SubcomponentList (
PRODUCT_CODE varchar (31),
LINE_NUMBER int,
CHILD_PRODUCT_CODE varchar (31),
REQUIRED bit,
SubcomponentCompleted bit
)
create table #TTPList (
TTPComponentRegSeqn int
)
create table #CompletedList (
STUDENT_ID varchar (10),
COMPLETION_DATE datetime,
PROGRAM varchar (31),
FULLNAME varchar (60),
COMPANY varchar (80),
CITY varchar (40),
STATE_PROVINCE varchar (15),
COUNTRY varchar (25),
SEQN int,
ACTIVITY_SEQN int,
InGracePeriod bit,
AutoEnrollForMaint bit,
ProgramType int,
RotateDateRule int, 
RotateBeginDate datetime,
RotateCompletionMonths int,
Designation1 varchar (20),
Designation2 varchar (20),
Designation3 varchar (20),
GracePeriodForInit bit,
GracePeriodForMaint bit,
Deadline datetime,
GoodThruDate datetime,
CoID varchar (10),
MemberType varchar (5),
TotCharges money,
CRNotes varchar(8000),
RequirementType int,
Title varchar (50)
)
truncate table #CompletedList
if @ProgID='ALL'
  declare get_rows cursor for
  select cr.SEQN,cr.STUDENT_ID,cr.REGISTRATION_ITEM,cr.STATUS,cr.ENROLLED_DATE,cr.TOTAL_CHARGES,cr.NOTES,
  cr.DEADLINE,cr.COMPLETION_DATE,cr.BOARD_NOTIFIED,cr.GOOD_THRU_DATE,cr.REQUIREMENT_TYPE,
  cr.IN_GRACE_PERIOD,cr.ACTIVITY_SEQN,cp.GRACE_PERIOD_MONTHS,cp.GRACE_PERIOD_FOR_INIT,
  cp.GRACE_PERIOD_FOR_MAINT,cp.DESIGNATION_1,cp.DESIGNATION_2,cp.DESIGNATION_3,cp.JOINT_PROGRAM,
  cp.AUTO_ENROLL_FOR_MAINT, cp.ROTATE_DATE_RULE,cp.ROTATE_BEGIN_DATE, cp.ROTATE_COMPLETION_MONTHS,
  n.FULL_NAME,n.COMPANY,n.CITY,n.STATE_PROVINCE,n.COUNTRY,n.CO_ID,n.MEMBER_TYPE,cp.ID,cp.TITLE,cp.PROGRAM_TYPE 
  from Cert_Register cr,Cert_Program cp,Name n
  where cr.SEQN in (select cr2.SEQN from Cert_Register cr2,Cert_Program cp2 where cr2.REGISTRATION_ITEM = cp2.ID)
  and cr.STUDENT_ID=n.ID and cr.REGISTRATION_ITEM=cp.ID and cr.STATUS='E' 
  and cr.ENROLLED_DATE is not null and cr.CANCELED_DATE is null order by cp.ID
else
  declare get_rows cursor for
  select cr.SEQN,cr.STUDENT_ID,cr.REGISTRATION_ITEM,cr.STATUS,cr.ENROLLED_DATE,cr.TOTAL_CHARGES,cr.NOTES,
  cr.DEADLINE,cr.COMPLETION_DATE,cr.BOARD_NOTIFIED,cr.GOOD_THRU_DATE,cr.REQUIREMENT_TYPE,
  cr.IN_GRACE_PERIOD,cr.ACTIVITY_SEQN,cp.GRACE_PERIOD_MONTHS,cp.GRACE_PERIOD_FOR_INIT,
  cp.GRACE_PERIOD_FOR_MAINT,cp.DESIGNATION_1,cp.DESIGNATION_2,cp.DESIGNATION_3,cp.JOINT_PROGRAM,
  cp.AUTO_ENROLL_FOR_MAINT, cp.ROTATE_DATE_RULE,cp.ROTATE_BEGIN_DATE, cp.ROTATE_COMPLETION_MONTHS,
  n.FULL_NAME,n.COMPANY,n.CITY,n.STATE_PROVINCE,n.COUNTRY,n.CO_ID,n.MEMBER_TYPE,cp.ID,cp.TITLE,cp.PROGRAM_TYPE 
  from Cert_Register cr,Cert_Program cp,Name n
  where cr.SEQN in (select cr2.SEQN from Cert_Register cr2,Cert_Program cp2 where cr2.REGISTRATION_ITEM = cp2.ID and cp2.ID=@ProgID)
  and cr.STUDENT_ID=n.ID and cr.REGISTRATION_ITEM=cp.ID and cr.STATUS='E' and cp.ID=@ProgID 
  and cr.ENROLLED_DATE is not null and cr.CANCELED_DATE is null
open get_rows
fetch next from get_rows into
@Seqn,
@StudentID,
@RegistrationItem,
@Status,
@EnrolledDate,
@TotCharges,
@CRNotes,
@Deadline,
@CompletionDate,
@BoardNotified,
@GoodThruDate,
@RequirementType,
@InGracePeriod,
@ActivitySeqn,
@GracePeriodMonths,
@GracePeriodForInit,
@GracePeriodForMaint,
@Designation1,
@Designation2,
@Designation3,
@JointProgram, 
@AutoEnrollForMaint,
@RotateDateRule, 
@RotateBeginDate,
@RotateCompletionMonths,
@FullName,
@Company,
@City,
@StateProvince,
@Country,
@CoID,
@MemberType,
@ProgramID,
@Title,
@ProgramType
While (@@FETCH_STATUS <> -1)
BEGIN
 if  @@FETCH_STATUS <> -2
 BEGIN
  truncate table #ProgramLinesList
  truncate table #SubcomponentList
  truncate table #ComponentList
  truncate table #TTPList
  select @TotalUnits=0
  select @Abort=0
  select @TotalUnitsRequiredForCredit=0
  if datalength(isnull(@JointProgram,''))>0
  BEGIN
  select @Seqn1=0
  select @Seqn2=0
  select @Seqn1=SEQN from Cert_Register where STUDENT_ID=@StudentID 
  and REG_TYPE='P' and REGISTRATION_ITEM=@JointProgram and STATUS='P' and GOOD_THRU_DATE>=getdate()
   if isnull(@Seqn1,0)=0
   BEGIN
   select @Seqn1=SEQN from Cert_Register where STUDENT_ID=@StudentID 
   and REG_TYPE='P' and REGISTRATION_ITEM=@JointProgram and STATUS='P'
   select @Seqn2=SEQN from Cert_Register where STUDENT_ID=@StudentID 
   and REG_TYPE='P' and REGISTRATION_ITEM=@JointProgram and STATUS='E' and GOOD_THRU_DATE>=getdate()
   END
   if isnull(@Seqn1,0)>0 and isnull(@Seqn2,0)>0
   BEGIN
   select @Seqn1=SEQN from Cert_Register where STUDENT_ID=@StudentID 
   and REG_TYPE='P' and REGISTRATION_ITEM=@RegistrationItem and STATUS='P' and GOOD_THRU_DATE>=getdate()
    if isnull(@Seqn1,0)=0
    BEGIN
    select @Seqn1=SEQN from Cert_Register where STUDENT_ID=@StudentID 
    and REG_TYPE='P' and REGISTRATION_ITEM=@RegistrationItem and STATUS='P'
    select @Seqn2=SEQN from Cert_Register where STUDENT_ID=@StudentID 
    and REG_TYPE='P' and REGISTRATION_ITEM=@RegistrationItem and STATUS='E' and GOOD_THRU_DATE>=getdate()
    END
    if isnull(@Seqn1,0)>0 and isnull(@Seqn2,0)>0
    BEGIN
    select @RequirementType=3
    END
   END
  END
  insert into #ProgramLinesList
  select  PROGRAM_ID,COMPONENT_CODE,COMPONENT_CATEGORY,LINE_NUMBER,LINE_TYPE,
  UNITS_REQUIRED_FOR_CREDIT,REQUIREMENT_TYPE from Cert_Prog_Lines  
  where PROGRAM_ID=@ProgramID and REQUIREMENT_TYPE=@RequirementType
  declare get_requirements cursor for
  select * from #ProgramLinesList
  open get_requirements
  fetch next from get_requirements into
  @CplProgramID,
  @CplComponentCode,
  @CplComponentCategory,
  @CplLineNumber,
  @CplLineType,
  @CplUnitsRequiredForCredit, 
  @CplRequirementType
  While (@@FETCH_STATUS <> -1) and @Abort=0
  BEGIN
   if  @@FETCH_STATUS <> -2
   BEGIN
   if @CplUnitsRequiredForCredit>0
   select @TotalUnitsRequiredForCredit=@TotalUnitsRequiredForCredit+@CplUnitsRequiredForCredit
    if isnull(@CplLineType,'')='COMPONENT'
    BEGIN
    select @UnitsFromCPL=0
    select @ProductCertParent=0
    select @CertRegUnitsEarned=0
    select @CertRegSeqn=0
    select @CertRegRegType=''
    select @CertRegProgID=''
    select @ProductCertParent=pc.PARENT,@CertRegUnitsEarned=cr.UNITS_EARNED,
    @CertRegSeqn=cr.SEQN,@CertRegRegType=cr.REG_TYPE,@CertRegProgID=cr.PROGRAM_ID 
/*    from Cert_Register cr,Product_Cert pc where pc.PRODUCT_CODE*=cr.REGISTRATION_ITEM */
    from Product_Cert pc LEFT OUTER JOIN Cert_Register cr on pc.PRODUCT_CODE=cr.REGISTRATION_ITEM
    where pc.PRODUCT_CODE=@CplComponentCode and cr.STUDENT_ID=@StudentID and ((cr.REG_TYPE='C' or cr.REG_TYPE='B') 
    and (cr.PROGRAM_ID='' or cr.PROGRAM_ID=@ProgramID) 
    and (cr.PROGRAM_REG_SEQN=0 or cr.PROGRAM_REG_SEQN=@Seqn)) and cr.STATUS='P'   
     if isnull(@CertRegSeqn,0)>0
     BEGIN
      if isnull(@CertRegUnitsEarned,0)>0
      BEGIN
      select @UnitsFromCPL=@UnitsFromCPL+@CertRegUnitsEarned
      select @CertRegUnitsEarned=0
      END
      if isnull(@CertRegRegType,'')='B'
      BEGIN
      insert into #TTPList select @CertRegSeqn
      END
      if isnull(@UnitsFromCPL,0)>0
      BEGIN
      select @TotalUnits=@TotalUnits+@UnitsFromCPL
      select @UnitsFromCPL=0
      END
     END
     ELSE
     BEGIN
      select @Abort=1
     END
    END
    if isnull(@CplLineType,'')='CATEGORY'
    BEGIN
    select @SuperCategory=0
    select @SubcategoryNames=''
    select @SuperCategory=SUPER_CATEGORY,@SubcategoryNames=SUBCATEGORY_NAMES 
    from Cert_Comp_Cat where CATEGORY=@CplComponentCategory
     if isnull(@SuperCategory,0)=1
     BEGIN
     select @UnitsFromSubCategories=0
      if datalength(isnull(@SubcategoryNames,''))>0
      BEGIN
       if charindex(',',@SubcategoryNames)=0 
       BEGIN 
       select @SubcategoryNamesItem=@SubcategoryNames
       truncate table #ComponentList
       insert into #ComponentList
       select p.PRODUCT_CODE from Cert_Register cr,Product_Cert pc,Product p where p.PRODUCT_CODE = pc.PRODUCT_CODE 
       and pc.PRODUCT_CODE=cr.REGISTRATION_ITEM and p.CATEGORY=@SubcategoryNamesItem and p.PROD_TYPE='CERTIFY' 
       and pc.SUBCOMPONENT=0 and cr.STUDENT_ID=@StudentID and ((cr.REG_TYPE='C' or cr.REG_TYPE='B') 
       and (cr.PROGRAM_ID='' or cr.PROGRAM_ID=@ProgramID) and (cr.PROGRAM_REG_SEQN=0 or cr.PROGRAM_REG_SEQN=@Seqn))
       group by p.PRODUCT_CODE
       declare get_subcategories cursor for
       select PRODUCT_CODE from #ComponentList
       open get_subcategories
       fetch next from get_subcategories into @CompProdCode
        WHILE @@FETCH_STATUS = 0
        BEGIN
        select @ProductCertParent=0
        select @CertRegUnitsEarned=0
        select @CertRegSeqn=0
        select @CertRegRegType=''
        select @CertRegProgID=''
        select @ProductCertParent=pc.PARENT,@CertRegUnitsEarned=cr.UNITS_EARNED,@CertRegSeqn=cr.SEQN,
        @CertRegRegType=cr.REG_TYPE,@CertRegProgID=cr.PROGRAM_ID 
       /* from Cert_Register cr,Product_Cert pc */
        from Product_Cert pc LEFT OUTER JOIN Cert_Register cr on pc.PRODUCT_CODE=cr.REGISTRATION_ITEM
        where pc.PRODUCT_CODE=@CompProdCode and cr.STUDENT_ID=@StudentID        
        and ((cr.REG_TYPE='C' or cr.REG_TYPE='B') and (cr.PROGRAM_ID='' or cr.PROGRAM_ID=@ProgramID) 
        and (cr.PROGRAM_REG_SEQN=0 or cr.PROGRAM_REG_SEQN=@Seqn)) and cr.STATUS='P'
         if isnull(@CertRegSeqn,0)>0
         BEGIN
          if isnull(@CertRegUnitsEarned,0)>0
          BEGIN
          select @UnitsFromSubCategories=@UnitsFromSubCategories+@CertRegUnitsEarned
          select @CertRegUnitsEarned=0
          END
         END
        if isnull(@CertRegSeqn,0)>0 and isnull(@CertRegRegType,'')='B'
        BEGIN
        insert into #TTPList select @CertRegSeqn
        END
        fetch next from get_subcategories into @CompProdCode   
        END
        close get_subcategories
        deallocate get_subcategories
      END
       if charindex(',',@SubcategoryNames)>0
       BEGIN
       while charindex(',',@SubcategoryNames)>0
        BEGIN       
        select @SubcategoryNamesItem=substring(@SubcategoryNames,1,charindex(',',@SubcategoryNames)-1)
        select @SubcategoryNames=substring(@SubcategoryNames,charindex(',',@SubcategoryNames)+1,datalength(@SubcategoryNames))
        truncate table #ComponentList
        insert into #ComponentList
        select p.PRODUCT_CODE from Cert_Register cr,Product_Cert pc,Product p where p.PRODUCT_CODE = pc.PRODUCT_CODE 
        and pc.PRODUCT_CODE=cr.REGISTRATION_ITEM and p.CATEGORY=@SubcategoryNamesItem and p.PROD_TYPE='CERTIFY' 
        and pc.SUBCOMPONENT=0 and cr.STUDENT_ID=@StudentID and ((cr.REG_TYPE='C' or cr.REG_TYPE='B') 
        and (cr.PROGRAM_ID='' or cr.PROGRAM_ID=@ProgramID) and (cr.PROGRAM_REG_SEQN=0 or cr.PROGRAM_REG_SEQN=@Seqn))
        group by p.PRODUCT_CODE
        declare get_subcategories cursor for
        select PRODUCT_CODE from #ComponentList
        open get_subcategories
        fetch next from get_subcategories into @CompProdCode
         WHILE @@FETCH_STATUS = 0
         BEGIN
         select @ProductCertParent=0
         select @CertRegUnitsEarned=0
         select @CertRegSeqn=0
         select @CertRegRegType=''
         select @CertRegProgID=''
         select @ProductCertParent=pc.PARENT,@CertRegUnitsEarned=cr.UNITS_EARNED,@CertRegSeqn=cr.SEQN,
         @CertRegRegType=cr.REG_TYPE,@CertRegProgID=cr.PROGRAM_ID 
         /*from Cert_Register cr,Product_Cert pc */
         from Product_Cert pc LEFT OUTER JOIN Cert_Register cr on pc.PRODUCT_CODE=cr.REGISTRATION_ITEM
         where pc.PRODUCT_CODE=@CompProdCode and cr.STUDENT_ID=@StudentID 
         and ((cr.REG_TYPE='C' or cr.REG_TYPE='B') and (cr.PROGRAM_ID='' or cr.PROGRAM_ID=@ProgramID) 
         and (cr.PROGRAM_REG_SEQN=0 or cr.PROGRAM_REG_SEQN=@Seqn)) and cr.STATUS='P'
          if isnull(@CertRegSeqn,0)>0
          BEGIN
           if isnull(@CertRegUnitsEarned,0)>0
           BEGIN
           select @UnitsFromSubCategories=@UnitsFromSubCategories+@CertRegUnitsEarned
           select @CertRegUnitsEarned=0
           END
          END
         if isnull(@CertRegSeqn,0)>0 and isnull(@CertRegRegType,'')='B'
         BEGIN
         insert into #TTPList select @CertRegSeqn
         END
         fetch next from get_subcategories into @CompProdCode   
         END
         close get_subcategories
         deallocate get_subcategories
        END
        select @SubcategoryNamesItem=@SubcategoryNames
        truncate table #ComponentList
        insert into #ComponentList
        select p.PRODUCT_CODE from Cert_Register cr,Product_Cert pc,Product p where p.PRODUCT_CODE = pc.PRODUCT_CODE 
        and pc.PRODUCT_CODE=cr.REGISTRATION_ITEM and p.CATEGORY=@SubcategoryNamesItem and p.PROD_TYPE='CERTIFY' 
        and pc.SUBCOMPONENT=0 and cr.STUDENT_ID=@StudentID and ((cr.REG_TYPE='C' or cr.REG_TYPE='B') 
        and (cr.PROGRAM_ID='' or cr.PROGRAM_ID=@ProgramID) and (cr.PROGRAM_REG_SEQN=0 or cr.PROGRAM_REG_SEQN=@Seqn))
        group by p.PRODUCT_CODE
        declare get_subcategories cursor for
        select PRODUCT_CODE from #ComponentList
        open get_subcategories
        fetch next from get_subcategories into @CompProdCode
         WHILE @@FETCH_STATUS = 0
         BEGIN
         select @ProductCertParent=0
         select @CertRegUnitsEarned=0
         select @CertRegSeqn=0
         select @CertRegRegType=''
         select @CertRegProgID=''
         select @ProductCertParent=pc.PARENT,@CertRegUnitsEarned=cr.UNITS_EARNED,@CertRegSeqn=cr.SEQN,
         @CertRegRegType=cr.REG_TYPE,@CertRegProgID=cr.PROGRAM_ID 
         /*from Cert_Register cr,Product_Cert pc */
         from Product_Cert pc LEFT OUTER JOIN Cert_Register cr on pc.PRODUCT_CODE=cr.REGISTRATION_ITEM
         where pc.PRODUCT_CODE=@CompProdCode and cr.STUDENT_ID=@StudentID 
         and ((cr.REG_TYPE='C' or cr.REG_TYPE='B') and (cr.PROGRAM_ID='' or cr.PROGRAM_ID=@ProgramID) 
         and (cr.PROGRAM_REG_SEQN=0 or cr.PROGRAM_REG_SEQN=@Seqn)) and cr.STATUS='P'
          if isnull(@CertRegSeqn,0)>0
          BEGIN
           if isnull(@CertRegUnitsEarned,0)>0
           BEGIN
           select @UnitsFromSubCategories=@UnitsFromSubCategories+@CertRegUnitsEarned
           select @CertRegUnitsEarned=0
           END
          END
         if isnull(@CertRegSeqn,0)>0 and isnull(@CertRegRegType,'')='B'
         BEGIN
         insert into #TTPList select @CertRegSeqn
         END
         fetch next from get_subcategories into @CompProdCode   
         END
         close get_subcategories
         deallocate get_subcategories
       END
      END
     if isnull(@UnitsFromSubCategories,0)<isnull(@CplUnitsRequiredForCredit,0)
     BEGIN
      select @Abort=1
     END
     if isnull(@UnitsFromSubCategories,0)>0
     BEGIN
      select @TotalUnits=@TotalUnits+@UnitsFromSubCategories
      select @UnitsFromSubCategories=0
     END
     END
     ELSE 
     BEGIN
     truncate table #ComponentList
     select @UnitsFromComponents=0
     select @UnitsFromSubComponents=0
     insert into #ComponentList
     select p.PRODUCT_CODE from Cert_Register cr,Product_Cert pc,Product p where p.PRODUCT_CODE = pc.PRODUCT_CODE 
     and pc.PRODUCT_CODE=cr.REGISTRATION_ITEM and p.CATEGORY=@CplComponentCategory and p.PROD_TYPE='CERTIFY' 
     and pc.SUBCOMPONENT=0 and cr.STUDENT_ID=@StudentID and ((cr.REG_TYPE='C' or cr.REG_TYPE='B') 
     and (cr.PROGRAM_ID='' or cr.PROGRAM_ID=@ProgramID) and (cr.PROGRAM_REG_SEQN=0 or cr.PROGRAM_REG_SEQN=@Seqn))
     group by p.PRODUCT_CODE
     declare get_components cursor for
     select PRODUCT_CODE from #ComponentList
     open get_components
     fetch next from get_components into @CompProdCode
     if @@FETCH_STATUS<>0
     BEGIN
     select @Abort=1
     END
      WHILE @@FETCH_STATUS = 0
      BEGIN
      select @ProductCertParent=0
      select @CertRegUnitsEarned=0
      select @CertRegSeqn=0
      select @CertRegRegType=''
      select @CertRegProgID=''
      select @ProductCertParent=pc.PARENT,@CertRegUnitsEarned=cr.UNITS_EARNED,@CertRegSeqn=cr.SEQN,
      @CertRegRegType=cr.REG_TYPE,@CertRegProgID=cr.PROGRAM_ID 
      /*from Cert_Register cr,Product_Cert pc */
      from Product_Cert pc LEFT OUTER JOIN Cert_Register cr on pc.PRODUCT_CODE=cr.REGISTRATION_ITEM
      where pc.PRODUCT_CODE=@CompProdCode and cr.STUDENT_ID=@StudentID 
      and ((cr.REG_TYPE='C' or cr.REG_TYPE='B') and (cr.PROGRAM_ID='' or cr.PROGRAM_ID=@ProgramID) 
      and (cr.PROGRAM_REG_SEQN=0 or cr.PROGRAM_REG_SEQN=@Seqn)) and cr.STATUS='P'
       if isnull(@CertRegSeqn,0)>0
       BEGIN
        if isnull(@CertRegUnitsEarned,0)>0
        BEGIN
        select @UnitsFromComponents=@UnitsFromComponents+@CertRegUnitsEarned
        select @CertRegUnitsEarned=0
        END
        if isnull(@ProductCertParent,0)<>0
        BEGIN
        truncate table #SubcomponentList
        insert into #SubcomponentList
        select PRODUCT_CODE,LINE_NUMBER,CHILD_PRODUCT_CODE,REQUIRED,0
        from Product_Sub where Product_Sub.PRODUCT_CODE=@CompProdCode 
        declare get_subcomponents cursor for
        select @SubCompChildProdCode from #SubcomponentList
        open get_subcomponents
        fetch next from get_subcomponents into @SubCompChildProdCode
         WHILE @@FETCH_STATUS = 0
         BEGIN
         select @CertRegUnitsEarned=0
         select @CertRegUnitsEarned=cr.UNITS_EARNED from Cert_Register cr 
         where cr.REGISTRATION_ITEM=@SubCompChildProdCode 
         and cr.STUDENT_ID=@StudentID and ((cr.REG_TYPE='C' or cr.REG_TYPE='B')      
         and (cr.PROGRAM_ID='' or cr.PROGRAM_ID=@ProgramID)     
         and (cr.PROGRAM_REG_SEQN=0 or cr.PROGRAM_REG_SEQN=@Seqn)) and cr.STATUS='P'
         if isnull(@CertRegUnitsEarned,0)>0
         BEGIN
         update #SubcomponentList set SubcomponentCompleted=1 where current of get_subcomponents
         select @UnitsFromSubComponents=@UnitsFromSubComponents+@CertRegUnitsEarned
         select @CertRegUnitsEarned=0
         END
         fetch next from get_subcomponents into @SubCompChildProdCode   
         END
         close get_subcomponents
         deallocate get_subcomponents
         select @UnitsFromComponents=@UnitsFromComponents+@UnitsFromSubComponents            
        END
        if isnull(@CertRegRegType,'')='B' 
        BEGIN
        insert into #TTPList select @CertRegSeqn
        END
       END
      fetch next from get_components into @CompProdCode   
      END
      close get_components
      deallocate get_components
      if isnull(@UnitsFromComponents,0)>0 and (isnull(@UnitsFromComponents,0)>=isnull(@CplUnitsRequiredForCredit,0))
       BEGIN  
       select @TotalUnits=@TotalUnits+@UnitsFromComponents
       select @UnitsFromComponents=0
       select @UnitsFromSubComponents=0
       END
      ELSE
       BEGIN
        select @Abort=1
       END
     END
    END
   END
   fetch next from get_requirements into
   @CplProgramID,
   @CplComponentCode,
   @CplComponentCategory,
   @CplLineNumber,
   @CplLineType,
   @CplUnitsRequiredForCredit, 
   @CplRequirementType
  END
  close get_requirements
  deallocate get_requirements
  if isnull(@InGracePeriod,0)<>0 and @Abort=0
  BEGIN
  select @RequirementType=2
  truncate table #ProgramLinesList
  insert into #ProgramLinesList
  select  PROGRAM_ID,COMPONENT_CODE,COMPONENT_CATEGORY,LINE_NUMBER,LINE_TYPE,
  UNITS_REQUIRED_FOR_CREDIT,REQUIREMENT_TYPE from Cert_Prog_Lines  
  where PROGRAM_ID=@ProgramID and REQUIREMENT_TYPE=@RequirementType
  declare get_requirements cursor for
  select * from #ProgramLinesList
  open get_requirements
  fetch next from get_requirements into
  @CplProgramID,
  @CplComponentCode,
  @CplComponentCategory,
  @CplLineNumber,
  @CplLineType,
  @CplUnitsRequiredForCredit, 
  @CplRequirementType
  While (@@FETCH_STATUS <> -1)
  BEGIN
   if  @@FETCH_STATUS <> -2
   BEGIN 
    if isnull(@CplLineType,'')='COMPONENT'
    BEGIN
    select @UnitsFromCPL=0
    select @ProductCertParent=0
    select @CertRegUnitsEarned=0
    select @CertRegSeqn=0
    select @CertRegRegType=''
    select @CertRegProgID=''
    select @ProductCertParent=pc.PARENT,@CertRegUnitsEarned=cr.UNITS_EARNED,
    @CertRegSeqn=cr.SEQN,@CertRegRegType=cr.REG_TYPE,@CertRegProgID=cr.PROGRAM_ID 
    from Product_Cert pc LEFT OUTER JOIN Cert_Register cr on pc.PRODUCT_CODE=cr.REGISTRATION_ITEM
    where pc.PRODUCT_CODE=@CplComponentCode and cr.STUDENT_ID=@StudentID and ((cr.REG_TYPE='C' or cr.REG_TYPE='B') 
    and (cr.PROGRAM_ID='' or cr.PROGRAM_ID=@ProgramID) 
    and (cr.PROGRAM_REG_SEQN=0 or cr.PROGRAM_REG_SEQN=@Seqn)) and cr.STATUS='P'   
     if isnull(@CertRegSeqn,0)>0
     BEGIN
      if isnull(@CertRegUnitsEarned,0)>0
      BEGIN
      select @UnitsFromCPL=@UnitsFromCPL+@CertRegUnitsEarned
      select @CertRegUnitsEarned=0
      END
      if isnull(@CertRegRegType,'')='B' 
      BEGIN
      insert into #TTPList select @CertRegSeqn
      END
      if isnull(@UnitsFromCPL,0)>0
      BEGIN
      select @TotalUnits=@TotalUnits+@UnitsFromCPL
      select @UnitsFromCPL=0
      END
     END
     ELSE
     BEGIN
      select @Abort=1
     END
    END
    if isnull(@CplLineType,'')='CATEGORY'
    BEGIN
    select @SuperCategory=0
    select @SubcategoryNames=''
    select @SuperCategory=SUPER_CATEGORY,@SubcategoryNames=SUBCATEGORY_NAMES 
    from Cert_Comp_Cat where CATEGORY=@CplComponentCategory
     if isnull(@SuperCategory,0)=1
     BEGIN
     select @UnitsFromSubCategories=0
      if datalength(isnull(@SubcategoryNames,''))>0
      BEGIN
       if charindex(',',@SubcategoryNames)=0
       BEGIN 
       select @SubcategoryNamesItem=@SubcategoryNames
       truncate table #ComponentList
       insert into #ComponentList
       select p.PRODUCT_CODE from Cert_Register cr,Product_Cert pc,Product p where p.PRODUCT_CODE = pc.PRODUCT_CODE 
       and pc.PRODUCT_CODE=cr.REGISTRATION_ITEM and p.CATEGORY=@SubcategoryNamesItem and p.PROD_TYPE='CERTIFY' 
       and pc.SUBCOMPONENT=0 and cr.STUDENT_ID=@StudentID and ((cr.REG_TYPE='C' or cr.REG_TYPE='B') 
       and (cr.PROGRAM_ID='' or cr.PROGRAM_ID=@ProgramID) and (cr.PROGRAM_REG_SEQN=0 or cr.PROGRAM_REG_SEQN=@Seqn))
       group by p.PRODUCT_CODE 
       declare get_subcategories cursor for
       select PRODUCT_CODE from #ComponentList
       open get_subcategories
       fetch next from get_subcategories into @CompProdCode
        WHILE @@FETCH_STATUS = 0
        BEGIN
        select @ProductCertParent=0
        select @CertRegUnitsEarned=0
        select @CertRegSeqn=0
        select @CertRegRegType=''
        select @CertRegProgID=''
        select @ProductCertParent=pc.PARENT,@CertRegUnitsEarned=cr.UNITS_EARNED,@CertRegSeqn=cr.SEQN,
        @CertRegRegType=cr.REG_TYPE,@CertRegProgID=cr.PROGRAM_ID 
        from Product_Cert pc LEFT OUTER JOIN Cert_Register cr on pc.PRODUCT_CODE=cr.REGISTRATION_ITEM
        where pc.PRODUCT_CODE=@CompProdCode and cr.STUDENT_ID=@StudentID 
        and ((cr.REG_TYPE='C' or cr.REG_TYPE='B') and (cr.PROGRAM_ID='' or cr.PROGRAM_ID=@ProgramID) 
        and (cr.PROGRAM_REG_SEQN=0 or cr.PROGRAM_REG_SEQN=@Seqn)) and cr.STATUS='P'
         if isnull(@CertRegSeqn,0)>0
         BEGIN
          if isnull(@CertRegUnitsEarned,0)>0
          BEGIN
          select @UnitsFromSubCategories=@UnitsFromSubCategories+@CertRegUnitsEarned
          select @CertRegUnitsEarned=0
          END
         END
        if isnull(@CertRegSeqn,0)>0 and isnull(@CertRegRegType,'')='B'
        BEGIN
        insert into #TTPList select @CertRegSeqn
        END
        fetch next from get_subcategories into @CompProdCode   
        END
        close get_subcategories
        deallocate get_subcategories
      END
       if charindex(',',@SubcategoryNames)>0 
       BEGIN
       while charindex(',',@SubcategoryNames)>0
        BEGIN       
        select @SubcategoryNamesItem=substring(@SubcategoryNames,1,charindex(',',@SubcategoryNames)-1)
        select @SubcategoryNames=substring(@SubcategoryNames,charindex(',',@SubcategoryNames)+1,datalength(@SubcategoryNames))
        truncate table #ComponentList
        insert into #ComponentList
        select p.PRODUCT_CODE from Cert_Register cr,Product_Cert pc,Product p where p.PRODUCT_CODE = pc.PRODUCT_CODE 
        and pc.PRODUCT_CODE=cr.REGISTRATION_ITEM and p.CATEGORY=@SubcategoryNamesItem and p.PROD_TYPE='CERTIFY' 
        and pc.SUBCOMPONENT=0 and cr.STUDENT_ID=@StudentID and ((cr.REG_TYPE='C' or cr.REG_TYPE='B') 
        and (cr.PROGRAM_ID='' or cr.PROGRAM_ID=@ProgramID) and (cr.PROGRAM_REG_SEQN=0 or cr.PROGRAM_REG_SEQN=@Seqn))
        group by p.PRODUCT_CODE
        declare get_subcategories cursor for
        select PRODUCT_CODE from #ComponentList
        open get_subcategories
        fetch next from get_subcategories into @CompProdCode
         WHILE @@FETCH_STATUS = 0
         BEGIN
         select @ProductCertParent=0
         select @CertRegUnitsEarned=0
         select @CertRegSeqn=0
         select @CertRegRegType=''
         select @CertRegProgID=''
         select @ProductCertParent=pc.PARENT,@CertRegUnitsEarned=cr.UNITS_EARNED,@CertRegSeqn=cr.SEQN,
         @CertRegRegType=cr.REG_TYPE,@CertRegProgID=cr.PROGRAM_ID 
         from Product_Cert pc LEFT OUTER JOIN Cert_Register cr on pc.PRODUCT_CODE=cr.REGISTRATION_ITEM
         where pc.PRODUCT_CODE=@CompProdCode and cr.STUDENT_ID=@StudentID 
         and ((cr.REG_TYPE='C' or cr.REG_TYPE='B') and (cr.PROGRAM_ID='' or cr.PROGRAM_ID=@ProgramID) 
         and (cr.PROGRAM_REG_SEQN=0 or cr.PROGRAM_REG_SEQN=@Seqn)) and cr.STATUS='P'
          if isnull(@CertRegSeqn,0)>0
          BEGIN
           if isnull(@CertRegUnitsEarned,0)>0
           BEGIN
           select @UnitsFromSubCategories=@UnitsFromSubCategories+@CertRegUnitsEarned
           select @CertRegUnitsEarned=0
           END
          END
         if isnull(@CertRegSeqn,0)>0 and isnull(@CertRegRegType,'')='B'
         BEGIN
         insert into #TTPList select @CertRegSeqn
         END
         fetch next from get_subcategories into @CompProdCode   
         END
         close get_subcategories
         deallocate get_subcategories
        END
        select @SubcategoryNamesItem=@SubcategoryNames
        truncate table #ComponentList
        insert into #ComponentList
        select p.PRODUCT_CODE from Cert_Register cr,Product_Cert pc,Product p where p.PRODUCT_CODE = pc.PRODUCT_CODE 
        and pc.PRODUCT_CODE=cr.REGISTRATION_ITEM and p.CATEGORY=@SubcategoryNamesItem and p.PROD_TYPE='CERTIFY' 
        and pc.SUBCOMPONENT=0 and cr.STUDENT_ID=@StudentID and ((cr.REG_TYPE='C' or cr.REG_TYPE='B') 
        and (cr.PROGRAM_ID='' or cr.PROGRAM_ID=@ProgramID) and (cr.PROGRAM_REG_SEQN=0 or cr.PROGRAM_REG_SEQN=@Seqn))
        group by p.PRODUCT_CODE
        declare get_subcategories cursor for
        select PRODUCT_CODE from #ComponentList
        open get_subcategories
        fetch next from get_subcategories into @CompProdCode
         WHILE @@FETCH_STATUS = 0
         BEGIN
         select @ProductCertParent=0
         select @CertRegUnitsEarned=0
         select @CertRegSeqn=0
         select @CertRegRegType=''
         select @CertRegProgID=''
         select @ProductCertParent=pc.PARENT,@CertRegUnitsEarned=cr.UNITS_EARNED,@CertRegSeqn=cr.SEQN,
         @CertRegRegType=cr.REG_TYPE,@CertRegProgID=cr.PROGRAM_ID 
         from Product_Cert pc LEFT OUTER JOIN Cert_Register cr on pc.PRODUCT_CODE=cr.REGISTRATION_ITEM
         where pc.PRODUCT_CODE=@CompProdCode and cr.STUDENT_ID=@StudentID 
         and ((cr.REG_TYPE='C' or cr.REG_TYPE='B') and (cr.PROGRAM_ID='' or cr.PROGRAM_ID=@ProgramID) 
         and (cr.PROGRAM_REG_SEQN=0 or cr.PROGRAM_REG_SEQN=@Seqn)) and cr.STATUS='P'
          if isnull(@CertRegSeqn,0)>0
          BEGIN
           if isnull(@CertRegUnitsEarned,0)>0
           BEGIN
           select @UnitsFromSubCategories=@UnitsFromSubCategories+@CertRegUnitsEarned
           select @CertRegUnitsEarned=0
           END
          END
         if isnull(@CertRegSeqn,0)>0 and isnull(@CertRegRegType,'')='B'
         BEGIN
         insert into #TTPList select @CertRegSeqn
         END
         fetch next from get_subcategories into @CompProdCode   
         END
         close get_subcategories
         deallocate get_subcategories
       END
      END
     if isnull(@UnitsFromSubCategories,0)>0
     BEGIN
     select @TotalUnits=@TotalUnits+@UnitsFromSubCategories
     select @UnitsFromSubCategories=0
     END
     ELSE
     if @UnitsFromSubCategories<@CplUnitsRequiredForCredit
     BEGIN
      select @Abort=1
     END
     END
     ELSE
     BEGIN
     truncate table #ComponentList
     select @UnitsFromComponents=0
     select @UnitsFromSubComponents=0
     insert into #ComponentList
     select p.PRODUCT_CODE from Cert_Register cr,Product_Cert pc,Product p where p.PRODUCT_CODE = pc.PRODUCT_CODE 
     and pc.PRODUCT_CODE=cr.REGISTRATION_ITEM and p.CATEGORY=@CplComponentCategory and p.PROD_TYPE='CERTIFY' 
     and pc.SUBCOMPONENT=0 and cr.STUDENT_ID=@StudentID and ((cr.REG_TYPE='C' or cr.REG_TYPE='B') 
     and (cr.PROGRAM_ID='' or cr.PROGRAM_ID=@ProgramID) and (cr.PROGRAM_REG_SEQN=0 or cr.PROGRAM_REG_SEQN=@Seqn))
     group by p.PRODUCT_CODE
     declare get_components cursor for
     select PRODUCT_CODE from #ComponentList
     open get_components
     fetch next from get_components into @CompProdCode
     if @@FETCH_STATUS<>0
     BEGIN
     select @Abort=1
     END
      WHILE @@FETCH_STATUS = 0
      BEGIN
      select @ProductCertParent=0
      select @CertRegUnitsEarned=0
      select @CertRegSeqn=0
      select @CertRegRegType=''
      select @CertRegProgID=''
      select @ProductCertParent=pc.PARENT,@CertRegUnitsEarned=cr.UNITS_EARNED,@CertRegSeqn=cr.SEQN,
      @CertRegRegType=cr.REG_TYPE,@CertRegProgID=cr.PROGRAM_ID 
      from Product_Cert pc LEFT OUTER JOIN Cert_Register cr on pc.PRODUCT_CODE=cr.REGISTRATION_ITEM
      where pc.PRODUCT_CODE=@CompProdCode and cr.STUDENT_ID=@StudentID 
      and ((cr.REG_TYPE='C' or cr.REG_TYPE='B') and (cr.PROGRAM_ID='' or cr.PROGRAM_ID=@ProgramID) 
      and (cr.PROGRAM_REG_SEQN=0 or cr.PROGRAM_REG_SEQN=@Seqn)) and cr.STATUS='P'
       if isnull(@CertRegSeqn,0)>0
       BEGIN
        if isnull(@CertRegUnitsEarned,0)>0
        BEGIN
        select @UnitsFromComponents=@UnitsFromComponents+@CertRegUnitsEarned
        select @CertRegUnitsEarned=0
        END
        if isnull(@ProductCertParent,0)<>0
        BEGIN
        truncate table #SubcomponentList
        insert into #SubcomponentList
        select PRODUCT_CODE,LINE_NUMBER,CHILD_PRODUCT_CODE,REQUIRED,0
        from Product_Sub where Product_Sub.PRODUCT_CODE=@CompProdCode 
        declare get_subcomponents cursor for
        select @SubCompChildProdCode from #SubcomponentList
        open get_subcomponents
        fetch next from get_subcomponents into @SubCompChildProdCode
         WHILE @@FETCH_STATUS = 0
         BEGIN
         select @CertRegUnitsEarned=0
         select @CertRegUnitsEarned=cr.UNITS_EARNED from Cert_Register cr 
         where cr.REGISTRATION_ITEM=@SubCompChildProdCode 
         and cr.STUDENT_ID=@StudentID and ((cr.REG_TYPE='C' or cr.REG_TYPE='B')      
         and (cr.PROGRAM_ID='' or cr.PROGRAM_ID=@ProgramID)     
         and (cr.PROGRAM_REG_SEQN=0 or cr.PROGRAM_REG_SEQN=@Seqn)) and cr.STATUS='P'
         if isnull(@CertRegUnitsEarned,0)>0
         BEGIN
         update #SubcomponentList set SubcomponentCompleted=1 where current of get_subcomponents
         select @UnitsFromSubComponents=@UnitsFromSubComponents+@CertRegUnitsEarned
         select @CertRegUnitsEarned=0
         END
         fetch next from get_subcomponents into @SubCompChildProdCode   
         END
         close get_subcomponents
         deallocate get_subcomponents
         select @UnitsFromComponents=@UnitsFromComponents+@UnitsFromSubComponents            
        END
        if isnull(@CertRegRegType,'')='B' 
        BEGIN
        insert into #TTPList select @CertRegSeqn
        END
       END
      fetch next from get_components into @CompProdCode   
      END
      close get_components
      deallocate get_components
      if isnull(@UnitsFromComponents,0)>0 and (isnull(@UnitsFromComponents,0)>=isnull(@CplUnitsRequiredForCredit,0))
       BEGIN  
       select @TotalUnits=@TotalUnits+@UnitsFromComponents
       select @UnitsFromComponents=0
       select @UnitsFromSubComponents=0
       END
      ELSE
       BEGIN
        select @Abort=1
       END
     END
    END
   END
   fetch next from get_requirements into
   @CplProgramID,
   @CplComponentCode,
   @CplComponentCategory,
   @CplLineNumber,
   @CplLineType,
   @CplUnitsRequiredForCredit, 
   @CplRequirementType
  END
  close get_requirements
  deallocate get_requirements
  END
  if @Abort=1
  BEGIN
  select @TotalUnits=0
  select @Abort=0 
  END
  if (@TotalUnits>0 and @TotalUnitsRequiredForCredit>0 and @TotalUnits>=@TotalUnitsRequiredForCredit) or (@TotalUnits=0 and @TotalUnitsRequiredForCredit=0) and @CertRegSeqn>0
  /* jf - 19 oct 07 -- check @CertRegSeqn>0*/
  BEGIN
  select @CompletionDate=getdate()
  insert into #CompletedList
  select @StudentID,@CompletionDate,@ProgramID,@FullName,@Company,@City,@StateProvince,@Country,
  @Seqn,@ActivitySeqn,@InGracePeriod,@AutoEnrollForMaint,@ProgramType,@RotateDateRule,@RotateBeginDate,
  @RotateCompletionMonths,@Designation1,@Designation2,@Designation3,@GracePeriodForInit,@GracePeriodForMaint,
  @Deadline,@GoodThruDate,@CoID,@MemberType,@TotCharges,@CRNotes,@RequirementType,@Title
  update Cert_Register set PROGRAM_ID=@ProgramID,PROGRAM_REG_SEQN=@Seqn 
  from Cert_Register,#TTPList where SEQN=TTPComponentRegSeqn
   if isnull(@NotifyBoard,0)=0 and isnull(@NotifyStudent,0)=0
   BEGIN
   update Cert_Register set COMPLETION_DATE=getdate(), STATUS='P' where SEQN=@Seqn
   END
   if isnull(@NotifyBoard,0)=0 and isnull(@NotifyStudent,0)<>0
   BEGIN
   update Cert_Register set COMPLETION_DATE=getdate(), STATUS='P', STUDENT_NOTIFIED_DATE=getdate(),
   STUDENT_NOTIFIED=1,REQUIREMENT_TYPE=@RequirementType where SEQN=@Seqn
   END
   if isnull(@NotifyBoard,0)<>0 and isnull(@NotifyStudent,0)=0
   BEGIN
   update Cert_Register set COMPLETION_DATE=getdate(), STATUS='P', BOARD_NOTIFIED_DATE=getdate(),
   BOARD_NOTIFIED=1,REQUIREMENT_TYPE=@RequirementType where SEQN=@Seqn
   END
   if isnull(@NotifyBoard,0)<>0 and isnull(@NotifyStudent,0)<>0
   BEGIN
   update Cert_Register set COMPLETION_DATE=getdate(), STATUS='P', BOARD_NOTIFIED_DATE=getdate(),
   STUDENT_NOTIFIED_DATE=getdate(),STUDENT_NOTIFIED=1,BOARD_NOTIFIED=1,REQUIREMENT_TYPE=@RequirementType where SEQN=@Seqn
   END
  select @ActString=''
  if isnull(@NotifyBoard,0)<>0
  BEGIN
  select @ActString='Board notified: '+@CurrentLocalDate
  END
  if isnull(@NotifyStudent,0)<>0
  BEGIN
   if datalength(@ActString)>0
   BEGIN
   select @ActString=@ActString+' Student notified: '+@CurrentLocalDate
   END
   ELSE
   BEGIN
   select @ActString='Student notified: '+@CurrentLocalDate
   END
  END
  update Activity set AMOUNT=@TotCharges,EFFECTIVE_DATE=getdate(),ACTION_CODES='Passed',  
  UNITS=@TotalUnits,NOTE_2=@ActString where SEQN=@ActivitySeqn
  select @TotalUnits=0
  END
  ELSE
  BEGIN
  select @TreatDeadline=1
  END
  if isnull(@TreatDeadline,0)=1
  BEGIN
  select @TreatDeadline=0
  if DATEDIFF(day,@Deadline,getdate())>0
  BEGIN
   if (@AllowGracePeriods>0 and ((@RequirementType=0 and @GracePeriodForInit=1) 
   or (@RequirementType=1 and @GracePeriodForMaint=1)))
   and isnull(@InGracePeriod,0)=0
   BEGIN
    if @UpdateGoodThruForGracePeriod>0
    BEGIN
    update Cert_Register set IN_GRACE_PERIOD=1,GOOD_THRU_DATE=dateadd(month,@GracePeriodMonths,@GoodThruDate)-1,
    DEADLINE=dateadd(month,@GracePeriodMonths,@Deadline)-1 where SEQN=@Seqn
    END
    ELSE
    BEGIN
    update Cert_Register set IN_GRACE_PERIOD=1,DEADLINE=dateadd(month,@GracePeriodMonths,@Deadline)-1 where SEQN=@Seqn
    END
   END
  END
  END
 END
 fetch next from get_rows into
 @Seqn,
 @StudentID,
 @RegistrationItem,
 @Status,
 @EnrolledDate,
 @TotCharges,
 @CRNotes,
 @Deadline,
 @CompletionDate,
 @BoardNotified,
 @GoodThruDate,
 @RequirementType,
 @InGracePeriod,
 @ActivitySeqn,
 @GracePeriodMonths,
 @GracePeriodForInit,
 @GracePeriodForMaint,
 @Designation1,
 @Designation2,
 @Designation3,
 @JointProgram, 
 @AutoEnrollForMaint,
 @RotateDateRule, 
 @RotateBeginDate,
 @RotateCompletionMonths,
 @FullName,
 @Company,
 @City,
 @StateProvince,
 @Country,
 @CoID,
 @MemberType,
 @ProgramID,
 @Title,
 @ProgramType
END
close get_rows
deallocate get_rows
declare treat_results cursor for
select * from #CompletedList order by PROGRAM
open treat_results
fetch next from treat_results into @StudentID,@CompletionDate,@ProgramID,@FullName,@Company,@City,
@StateProvince,@Country,@Seqn,@ActivitySeqn,@InGracePeriod,@AutoEnrollForMaint,@ProgramType,
@RotateDateRule,@RotateBeginDate,@RotateCompletionMonths,@Designation1,@Designation2,@Designation3,
@GracePeriodForInit,@GracePeriodForMaint,@Deadline,@GoodThruDate,@CoID,@MemberType,@TotCharges,@CRNotes,
@RequirementType,@Title
 WHILE @@FETCH_STATUS = 0
 BEGIN
  if isnull(@AutoEnrollForMaint,0)<>0 and isnull(@ProgramType,0)<>0
  BEGIN 
  exec @Result=sp_iboGetCounter 'Activity',1,@NewActSeqn output
  exec @Result=sp_iboGetCounter 'Cert_Register',1,@NewProgSeqn output
   if @GoodThruDate is not null
   BEGIN
   select @EnrolledDate=@GoodThruDate+1
   END
   If @RequirementType=0
   BEGIN
    if @RotateDateRule=0
    BEGIN
    select @Deadline=@RotateBeginDate
    END 
    If @RotateDateRule=1
    BEGIN
    select @Deadline=dateadd(month,@RotateCompletionMonths,@EnrolledDate)-1
    END
    If @RotateDateRule>1
    BEGIN
    select @Deadline=null 
    END
   END
   If @RequirementType<>0
   BEGIN
    if @RotateDateRule=0
    BEGIN
    select @Deadline=dateadd(month,@RotateCompletionMonths,@RotateBeginDate)-1
     WHILE @Deadline<=@EnrolledDate and @RotateCompletionMonths>0
     BEGIN
     select @Deadline= dateadd(month,@RotateCompletionMonths,@Deadline)
     END
    END
    if @RotateDateRule=1
    BEGIN
    select @Deadline=dateadd(month,@RotateCompletionMonths,@EnrolledDate)-1
    END
    if @RotateDateRule>1
    BEGIN
    select @Deadline=null 
    END
   END
   if @Deadline is not null
   BEGIN
   select @GoodThruDate=@Deadline
   END
  begin transaction
  insert into Cert_Register (SEQN,ENROLLED_DATE,STATUS,REG_TYPE,STUDENT_ID,BT_ID,REGISTRATION_ITEM,
  REQUIREMENT_TYPE,DESCRIPTION,DEADLINE,GOOD_THRU_DATE,ACTIVITY_SEQN) 
  values(@NewProgSeqn,@EnrolledDate,'E', 'P',@StudentID,@StudentID,@RegistrationItem,1,
  @Title+' - Maintenance',@Deadline,@GoodThruDate,@NewActSeqn)
  insert into Activity (SEQN,ID,NOTE,ACTIVITY_TYPE,SOURCE_SYSTEM,PRODUCT_CODE,TRANSACTION_DATE, 
  DESCRIPTION,AMOUNT,MEMBER_TYPE,UF_1,UF_2,UF_3,UF_4,UF_5,UF_6,UF_7,CO_ID,EFFECTIVE_DATE,THRU_DATE,
  ACTION_CODES,CATEGORY) 
  values (@NewActSeqn,@StudentID,@CRNotes,'CERTIFICAT','CERTIFICAT',@ProgramID,@EnrolledDate,
  @Title+' - Maintenance',@TotCharges,@MemberType,@ActUF1,@ActUF2,@ActUF3,@ActUF4,@ActUF5,@ActUF6,@ActUF7,
  @CoID,NULL,@GoodThruDate,'Enrolled','Maint')
  commit transaction
  END
 fetch next from treat_results into @StudentID,@CompletionDate,@ProgramID,@FullName,@Company,@City,
 @StateProvince,@Country,@Seqn,@ActivitySeqn,@InGracePeriod,@AutoEnrollForMaint,@ProgramType,
 @RotateDateRule,@RotateBeginDate,@RotateCompletionMonths,@Designation1,@Designation2,@Designation3,
 @GracePeriodForInit,@GracePeriodForMaint,@Deadline,@GoodThruDate,@CoID,@MemberType,@TotCharges,@CRNotes,
 @RequirementType,@Title
 END
 close treat_results
 deallocate treat_results
select
STUDENT_ID,
COMPLETION_DATE,
PROGRAM,
FULLNAME,
COMPANY,
CITY,
STATE_PROVINCE,
COUNTRY,
Designation1,
Designation2,
Designation3
from #CompletedList
order by PROGRAM

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_ClearOldQueryResults]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_ClearOldQueryResults]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE dbo.sp_asi_ClearOldQueryResults
 	@LastTime datetime = NULL
 AS 
 DECLARE @DeleteTime datetime
 SELECT @DeleteTime = CASE WHEN @LastTime IS NULL THEN DateAdd(d, -2, getDate()) ELSE @LastTime END
 WHILE (@@ROWCOUNT > 0)
 BEGIN
 	DELETE
 	QueryResultItem FROM
 	(
 		SELECT TOP 500 QueryResultItem.QueryResultKey
 			FROM QueryResultItem
 			LEFT OUTER JOIN QueryResultMain ON
 				QueryResultItem.QueryResultKey = QueryResultMain.QueryResultKey
 		WHERE QueryResultMain.CreatedOn < @DeleteTime
 	) q1
 	WHERE QueryResultItem.QueryResultKey = q1.QueryResultKey
 END
 SELECT @DeleteTime = @DeleteTime   --Reset rowcount counter
 WHILE (@@ROWCOUNT > 0)
 BEGIN
 	DELETE
 	QueryResultMain FROM
 	(
 		SELECT TOP 500 QueryResultMain.QueryResultKey
 			FROM QueryResultMain
 		WHERE QueryResultMain.CreatedOn < @DeleteTime
 	) q1
 	WHERE QueryResultMain.QueryResultKey = q1.QueryResultKey
 END
 SELECT @DeleteTime = @DeleteTime --Reset rowcount counter
 WHILE (@@ROWCOUNT > 0)
 BEGIN
 	DELETE
 	QueryResultItem FROM
 	(	
 		SELECT TOP 500 QueryResultItem.QueryResultKey
 			FROM QueryResultItem
 			LEFT OUTER JOIN QueryResultMain ON
 				QueryResultItem.QueryResultKey = QueryResultMain.QueryResultKey
 		WHERE QueryResultMain.QueryResultKey IS NULL
 	) q1
 	WHERE QueryResultItem.QueryResultKey = q1.QueryResultKey
 END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_ClientUpgrade]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_ClientUpgrade]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE sp_asi_ClientUpgrade AS 
DECLARE 	@machinename varchar(255),
		@MACaddress varchar(20),
		@installerpath varchar(255),
		@clientomnispath varchar(255),
		@clientimispath varchar(255),
		@usermessage varchar(2048),
		@cmd varchar(2048),
		@tmpnum int
--Set defaults for optional paths
SET @clientomnispath = ''
SET @clientimispath =''
SET @installerpath = ''
		
--Check to see if the InstallerPath exists
set @tmpnum = (select count(*)
     		FROM System_Params
    		WHERE ParameterName = 'System_Control.InstallerPath')
if @tmpnum = 0
	goto endit
--Since Omnis suppresses machine name, resolve its address from its MAC address
--Will not retrieve address of local host!!
SET @MACaddress = (SELECT lower(net_address)
			FROM master.dbo.sysprocesses
			WHERE spid = @@spid)
--Stuff in the hypens for a real address as arp uses
SET @MACaddress = STUFF(@MACaddress, 11, 0, '-')
SET @MACaddress = STUFF(@MACaddress, 9, 0, '-')
SET @MACaddress = STUFF(@MACaddress, 7, 0, '-')
SET @MACaddress = STUFF(@MACaddress, 5, 0, '-')
SET @MACaddress = STUFF(@MACaddress, 3, 0, '-')
	
--Get the ipaddress of the machine
drop table #Macaddresses	
create table #Macaddresses (CMD_OUTPUT varchar(300) null)
insert into #Macaddresses exec master.dbo.xp_cmdshell 'arp -A'
	
--Get the ip address of the client
SET @machinename = (SELECT ltrim(rtrim(substring(CMD_OUTPUT,1,20))) 
			FROM #Macaddresses 
			WHERE CMD_OUTPUT like '%' + @MACaddress + '%')
--Get push install params from database
--iMIS installer path
SET @installerpath = (SELECT ShortValue
			FROM System_Params
			WHERE ParameterName = 'System_Control.InstallerPath')
		
--Client paths
SET @clientomnispath = (SELECT rtrim(ShortValue)
			FROM System_Params
			WHERE ParameterName = 'System_Control.ClientOmnisPath')
SET @clientimispath = (SELECT rtrim(ShortValue)
			FROM System_Params
			WHERE ParameterName = 'System_Control.ClientiMISPath')
--Message for client
SET @usermessage = (SELECT rtrim(ShortValue)
			FROM System_Params
			WHERE ParameterName = 'System_Control.UserUpgradeMsg')
if datalength (@usermessage) = 0 or @usermessage IS NULL -- default message
	set @usermessage = 'Your system is beginning iMIS upgrade procedures.  Exit iMIS and any running applications.  When prompted, follow the instructions to upgrade your current installation.' 
--If the Installer path is blank, DO NOT push
IF rtrim(@installerpath) = '' or datalength (@installerpath) = 0
	GOTO endit
IF @clientomnispath IS NULL
	SET @clientomnispath = ' '
IF @clientimispath IS NULL
	SET @clientimispath = ' '
--Check which optional parameters are actually set
IF  isnull(@clientomnispath,'') <> '' 
	SET @clientomnispath = ' /o ' + @clientomnispath
IF  isnull(@clientimispath,'') <> '' 
	SET @clientimispath = ' /i ' + @clientimispath
		
--Check the installer path ends with a \
IF right(@installerpath,1) <> '\'
	SET @installerpath = @installerpath + '\'
		
/*xCmd v1.0 for NT4/2000 - executes commands remotely
Freeware! 2001 Zoltan Csizmadia, zoltan_csizmadia@yahoo.com
		
Usage: xCmd.exe \\computer [options] command/exe arguments
		
Options:
   /D:directory           Set working directory
                          Default: Remote "%SystemRoot%\System32"
   /IDLE                  Idle priority class
   /NORMAL                Normal priority class
   /HIGH                  High priority class
   /REALTIME              Realtime priority class
   /C                     Copy the specified program to the remote mac
                          "%SystemRoot%\System32" directory
                          Commands's exe file must be absolute to loca
   /USER:user             User for remote connection
   /PWD:{password|*}      Password for remote connection
   /NOWAIT                Don't wait for remote process to terminate
Examples:
   xCmd.exe \\remote cmd       // Starts a "telnet" client
   xCmd.exe \\remote /nowait runme.exe
   xCmd.exe \\remote /user:administrator dir c:\
   xCmd.exe \\remote /user:somebody /pwd:* /d:d:\ test1.exe
   xCmd.exe \\remote /c /user:somebody /pwd:* /d:d:\ test2.exe
		
Notes:
- Input is passed to remote machine when you press the ENTER.
- Ctrl-C terminates the remote process
- Command and file path arguments have to be absolute to remote machin
  If you are using /c option, command exe file path must be absolute t
  local machine, but the arguments must be absolute to remote machine*/
	
--Display upgrade message to user
SET @cmd = 'net send ' + rtrim(@machinename) + '  "' + rtrim(@usermessage) + '"'
EXEC master.dbo.xp_cmdshell @cmd
--Launch installer
SET @cmd = 'xCmd \\' + rtrim(@machinename) + ' /C /NOWAIT '  + rtrim(@installerpath) + 'Setup.exe /z"/u' + rtrim(@clientomnispath) + rtrim(@clientimispath) + '"'
EXEC master.dbo.xp_cmdshell @cmd
endit:
RETURN

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_CreateLogins]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_CreateLogins]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE  [dbo].[sp_asi_CreateLogins]
AS
    -- script to fix up a restored iMIS db for iMIS15
    --    Henry Huey 13 Sept 2006
    --    Paul Bradshaw 15 Feb 2010
    SET NOCOUNT ON

    ------------------------------------
    -- create the IMIS role if necessary
    ------------------------------------
    IF NOT EXISTS (SELECT 1 FROM sys.database_principals WHERE [name] = 'IMIS' AND [type_desc] = 'DATABASE_ROLE' )
    BEGIN
	    CREATE ROLE [IMIS] AUTHORIZATION [dbo]
    END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_db_name]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_db_name]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE sp_asi_db_name (@input_version varchar(20) = '4.0.0.0') 
		AS 
 		declare @system_version varchar(20)
 		select (convert (varchar(64), db_name ()))
 
 		if @input_version <> '4.0.0.0'   -- iMIS passed in the version parameter (10.1 or higher client)
			begin
				select @system_version = ShortValue from System_Params 
    				where ParameterName = 'System_Control.Version' 
   				
				if @input_version >= @system_version
					goto endit -- versions match (db and client) so proceed without upgrade
    			end
 
 		-- fell through to this point; 
  		-- either there's no input parameter, so iMIS didn't pass one in, and upgrade is needed;
  		-- or there's a version mismatch between the db and the client, so an upgrade is needed
  		exec sp_asi_ClientUpgrade
 
  		endit: 
  		return

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_DeleteCmty]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_DeleteCmty]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE sp_asi_DeleteCmty 
 @cmty_seq int
 as
 delete from Cmty_Read_Tracking where COMMUNITY_SEQ = @cmty_seq
 delete from Cmty_News where COMMUNITY_SEQ = @cmty_seq
 delete from Cmty_Administrators where COMMUNITY_SEQ = @cmty_seq
 delete from Cmty_Subscription where COMMUNITY_SEQ = @cmty_seq
 delete from Cmty_Invitees where COMMUNITY_SEQ = @cmty_seq
 delete from Cmty_Discussion_Posts where COMMUNITY_SEQ = @cmty_seq
 delete from Cmty_Discussion_Forums where COMMUNITY_SEQ = @cmty_seq
 delete from Cmty_Shared_Files where COMMUNITY_SEQ = @cmty_seq
 delete from Cmty_Shared_Folders where COMMUNITY_SEQ = @cmty_seq
 delete from Cmty_Email_Notification where COMMUNITY_SEQ = @cmty_seq
 delete from Community where COMMUNITY_SEQ = @cmty_seq
 return

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_DeleteForum]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_DeleteForum]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE sp_asi_DeleteForum
 @forum_seq int
 as
 delete from Cmty_Read_Tracking where  FORUM_SEQ = @forum_seq
 delete from Cmty_Discussion_Posts where  FORUM_SEQ = @forum_seq
 delete from Cmty_Discussion_Forums where FORUM_SEQ = @forum_seq
 return

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_GetCounter2]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_GetCounter2]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[sp_asi_GetCounter2] @CounterName varchar(30), @CounterValue int out 
 AS 
    -- Ensure the counter exists
    INSERT INTO [dbo].[Counter] ([COUNTER_NAME], [LAST_VALUE]) 
        SELECT @CounterName, 0
         WHERE NOT EXISTS (SELECT 1 FROM [dbo].[Counter] WHERE [COUNTER_NAME] = @CounterName)

    -- Increment the counter value by 1 and return it atomically
    UPDATE [dbo].[Counter]
       SET [LAST_VALUE] = [LAST_VALUE] + 1,
           @CounterValue = [LAST_VALUE] + 1,
           [LAST_UPDATED] = GETDATE(),
           [UPDATED_BY] = USER_NAME()
     WHERE [COUNTER_NAME] = @CounterName


GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_Discussions]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_Discussions]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[sp_asi_Discussions]
 (@POST_SEQ_1 int,
  @TOPIC_SEQ_2 int,
  @FORUM_SEQ_3 int,
  @COMMUNITY_SEQ_4 int,
  @POST_TITLE_5 varchar(80),
  @TREE_LOCATION_6 varchar(255),
  @ID_7 varchar(10),
  @ANONYMOUS_FLAG_8 bit,
  @DATE_STORED_9 datetime)
 AS 
 DECLARE @find varchar(255)
 DECLARE @length  int
 DECLARE @thread_num  int
 DECLARE @date_last_post  datetime
 DECLARE @post_count int
 if @TOPIC_SEQ_2 = 0 
   BEGIN
     exec sp_asi_GetCounter2 'Cmty_Discussion_Topics', @TOPIC_SEQ_2 output
     SELECT @TREE_LOCATION_6 = NULL
     SELECT @date_last_post = @DATE_STORED_9
     SELECT @post_count = 1
   END
 else
     BEGIN
       IF @TREE_LOCATION_6 IS NULL
         SELECT @TREE_LOCATION_6 = '000'
       ELSE IF @TREE_LOCATION_6 = ''
         SELECT @TREE_LOCATION_6 = '000'
       SELECT @length = LEN(@TREE_LOCATION_6)-3
       SELECT @find = SUBSTRING(@TREE_LOCATION_6,1,@length) + 'zzz'
       SELECT @TREE_LOCATION_6 = MAX(TREE_LOCATION) FROM Cmty_Discussion_Posts WHERE TOPIC_SEQ = @TOPIC_SEQ_2 AND TREE_LOCATION < @find
       SELECT @thread_num = CAST(SUBSTRING(@TREE_LOCATION_6,@length+1,3) AS int)
       SELECT @TREE_LOCATION_6 = SUBSTRING(@TREE_LOCATION_6,1,@length)
       if @thread_num < 999 
          SELECT @thread_num = @thread_num + 1
       if @thread_num < 10 
         SELECT @TREE_LOCATION_6 = RTRIM(@TREE_LOCATION_6 + '00' + CAST(@thread_num AS char))
       else
 BEGIN
    if @thread_num < 100 
         SELECT @TREE_LOCATION_6 = RTRIM(@TREE_LOCATION_6 + '0' + CAST(@thread_num AS char))
         else
         SELECT @TREE_LOCATION_6 = RTRIM(@TREE_LOCATION_6 + CAST(@thread_num AS char))
 END
       if @TREE_LOCATION_6 IS NULL 
         SELECT @TREE_LOCATION_6 = '001'
       SELECT @date_last_post = NULL
       SELECT @post_count = NULL
     END
 INSERT INTO Cmty_Discussion_Posts 
  ( POST_SEQ,
   TOPIC_SEQ,
   FORUM_SEQ,
   COMMUNITY_SEQ,
   POST_TITLE,
   TREE_LOCATION,
   ID,
   ANONYMOUS_FLAG,
   DATE_STORED,
   STATUS,
  DATE_LAST_POST,
  POST_COUNT) 
 VALUES 
 ( @POST_SEQ_1,
  @TOPIC_SEQ_2,
  @FORUM_SEQ_3,
  @COMMUNITY_SEQ_4,
  @POST_TITLE_5,
  @TREE_LOCATION_6,
  @ID_7,
  @ANONYMOUS_FLAG_8,
  @DATE_STORED_9,
  'ACT',
  @date_last_post,
  @post_count)
 if @post_count IS NULL 
 UPDATE Cmty_Discussion_Posts SET DATE_LAST_POST = @DATE_STORED_9, POST_COUNT = POST_COUNT + 1
 WHERE TOPIC_SEQ = @TOPIC_SEQ_2 AND TREE_LOCATION IS NULL

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_FetchImage]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_FetchImage]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
Create Procedure sp_asi_FetchImage  @fieldname varchar(255),      @where varchar(255),      @pos int,      @size int AS declare @ptrval varchar(16),  @sqlstring varchar(255),  @tablename varchar(255) SELECT @tablename = SUBSTRING(@fieldname,1,CHARINDEX('.',@fieldname)-1) SELECT @sqlstring =  'declare @ptrval binary(16)' +     ' SELECT @ptrval=TEXTPTR(' + @fieldname + ')' +     ' FROM ' + @tablename + ' ' + @where +    ' if @ptrval <> NULL READTEXT ' + @fieldname + ' @ptrval ' +    CONVERT(varchar,@pos) + ' ' + CONVERT(varchar,@size) +    ' else SELECT NULL' EXECUTE (@sqlstring)

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_UpdateNameIndex]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_UpdateNameIndex]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE sp_asi_UpdateNameIndex 
 	@id varchar(10),			-- Name.ID
 	@fieldName varchar(61),			-- <Table>.<FIELD>
 	@fieldValue varchar(8000) = NULL,
 	@indexName varchar(31) = NULL
 AS
 	if @indexName is null
 	begin
 		select @indexName = (CASE WHEN ParameterName = 'Member_Control.Index1Fld' THEN '1'
 					  WHEN ParameterName = 'Member_Control.Index2Fld' THEN '2'
 					  WHEN ParameterName = 'Member_Control.Index3Fld' THEN '3'
 					  WHEN ParameterName = 'Member_Control.Index4Fld' THEN '4'
 				     END)
 		from System_Params where ParameterName like 'Member_Control.Index%Fld' and ShortValue = @fieldName
 	end
 	if @indexName is not null
 	begin
 		-- is this a delete
 		if @fieldValue is null
 		begin
 			delete from Name_Indexes where ID = @id and INDEX_NAME = @indexName
 		end
 		else
 		begin
 			-- Insert or update
 			-- Field is an index; check to see if it's a UD multiselect field
 			declare @udms int
 			set @udms = 0
 			select @udms = 1 where exists (select * from UD_Field where TABLE_NAME + '.' + FIELD_NAME = @fieldName and MULTI_SELECT = 1)
 			if @udms = 0
 			begin
 				-- is not a UD MS field; simple insert/update
 				update Name_Indexes
 				set INDEX_VALUE = UPPER(LEFT(@fieldValue, 30))
 				where ID = @id
 				and INDEX_NAME = @indexName
 				if @@ROWCOUNT = 0
 					insert into Name_Indexes (ID, INDEX_NAME, INDEX_VALUE, QUANTITY) values (@id, @indexName, UPPER(LEFT(@fieldValue, 30)), 0)
 			end
 			else
 			begin
 				-- Is a multiselect field
 				-- Delete existing index values
 				delete from Name_Indexes where ID = @id and INDEX_NAME = @indexName
 				-- Split on commas and insert new index values
 				declare @idx int
 				declare @value varchar(30)
 				set @idx = CHARINDEX(',', @fieldValue, 0)
 				while @idx > 0
 				begin
 					set @value = UPPER(LEFT(SUBSTRING(@fieldValue, 1, @idx - 1), 30))
 					insert into Name_Indexes (ID, INDEX_NAME, INDEX_VALUE, QUANTITY) values (@id, @indexName, @value, 0)
 					set @fieldValue = SUBSTRING(@fieldValue, @idx + 1, LEN(@fieldValue) - @idx)
 					set @idx = CHARINDEX(',', @fieldValue, 0)
 				end
 				insert into Name_Indexes (ID, INDEX_NAME, INDEX_VALUE, QUANTITY) values (@id, @indexName, UPPER(LEFT(@fieldValue, 30)), 0)
 			end
 		end
 	end

GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_FlowdownNameIndex]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_FlowdownNameIndex]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE sp_asi_FlowdownNameIndex 
 	@co_id varchar(10),
 	@fieldName varchar(61),
 	@fieldValue varchar(8000) = NULL,
 	@indexName varchar(31) = NULL
 AS
 if @indexName is null
 begin
   select @indexName = (case when ParameterName = 'Member_Control.Index1Fld' then '1'
     when ParameterName = 'Member_Control.Index2Fld' then '2'
     when ParameterName = 'Member_Control.Index3Fld' then '3'
     when ParameterName = 'Member_Control.Index4Fld' then '4'
     end) from System_Params where ParameterName like 'Member_Control.Index-3Fld' and ShortValue = @fieldName
 end
 if @indexName is not null
   begin
     declare @isAddress int
     select @isAddress = (case
       when LEFT(@fieldName,12) = 'Name_Address' then 1
       when @fieldName = 'Name.CITY' then 1
       when @fieldName = 'Name.STATE_PROVINCE' then 1
       when @fieldName = 'Name.ZIP' then 1
       when @fieldName = 'Name.COUNTRY' then 1
       when @fieldName = 'Name.MAIL_CODE' then 1
       when @fieldName = 'Name.CRRT' then 1
       when @fieldName = 'Name.BAR_CODE' then 1
       when @fieldName = 'Name.COUNTY' then 1
       when @fieldName = 'Name.FULL_ADDRESS' then 1
       when @fieldName = 'Name.WORK_PHONE' then 1
       when @fieldName = 'Name.FAX' then 1
       when @fieldName = 'Name.TOLL_FREE' then 1
       else 0
     end)
     declare @childID varchar(10)
     if @isAddress = 1
     begin
       declare Get_Address_Children cursor for select Name.ID from Name, Name_Address where CO_ID = @co_id AND COMPANY_RECORD = 0 AND Name.ID = Name_Address.ID AND Name.ADDRESS_NUM_1 = Name.MAIL_ADDRESS_NUM and Name.MAIL_ADDRESS_NUM = Name_Address.ADDRESS_NUM
       open Get_Address_Children
       fetch next from Get_Address_Children into @childID
       while @@FETCH_STATUS = 0
       begin
         exec sp_asi_UpdateNameIndex @childID, @fieldName, @fieldValue, @indexName
         fetch next from Get_Address_Children into @childID
       end
       close Get_Address_Children
       deallocate Get_Address_Children
     end
     else
     begin
       declare Get_Children cursor for select ID from Name where CO_ID = @co_id AND COMPANY_RECORD = 0
       open Get_Children
       fetch next from Get_Children into @childID
       while @@FETCH_STATUS = 0
       begin
         exec sp_asi_UpdateNameIndex @childID, @fieldName, @fieldValue, @indexName
         fetch next from Get_Children into @childID
       end
       close Get_Children
       deallocate Get_Children
     end
   end

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_FolderPath]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_FolderPath]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE sp_asi_FolderPath 
             @currentfolder int
 AS
 DECLARE         @currentparent int,
                         @folderpath varchar(2048)
 SET @currentparent = (SELECT FOLDER_PARENT FROM Cmty_Shared_Folders WHERE FOLDER_SEQ=@currentfolder)
 SET @folderpath = LTRIM(STR(@currentfolder))
 WHILE @currentparent > 0
 BEGIN
             SET @folderpath = STUFF(@folderpath, 1, 0, LTRIM(STR(@currentparent) + '\'))
             SET @currentfolder = @currentparent
             SET @currentparent = (SELECT FOLDER_PARENT FROM Cmty_Shared_Folders WHERE FOLDER_SEQ=@currentfolder)
 END
 select @folderpath as FOLDERPATH
 RETURN

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_FullAddress]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_FullAddress]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure sp_asi_FullAddress  
  @ADDRESS_1 varchar(40)=null, 
  @ADDRESS_2 varchar(40)=null,
  @ADDRESS_3 varchar(40)=null, 
  @CITY varchar(40)=null, 
  @STATE_PROVINCE varchar(15)=null, 
  @ZIP varchar(10)=null, 
  @COUNTRY varchar(25)=null
  as 
  declare 
  @formula varchar(255), 
  @code int,
  @addrlen int
  BEGIN 
  if datalength(@ADDRESS_1) = 0 and datalength(@ADDRESS_2) = 0 and datalength(@ADDRESS_3) = 0 and datalength(@CITY) = 0 
 and datalength(@STATE_PROVINCE) = 0 and datalength(@ZIP) = 0 and datalength(@COUNTRY) = 0
      begin
        select @formula=''
        select FULL_ADDRESS=@formula
        return
      end
  select @code = NULL
  select @code=ADDRESS_FORMAT from Country_Names where upper(COUNTRY)=upper(@COUNTRY) 
  select @code=isnull(@code,0)
  if @code=0  
    begin  if (not exists (select * from Country_Addr_Layouts where ADDRESS_FORMAT=0)) 
    insert into Country_Addr_Layouts (ADDRESS_FORMAT, ADDRESS_LAYOUT, FORMULA) 
  values (0, 'ADDRESS_1[N]ADDRESS_2[N]ADDRESS_3[N]CITY[C][S]STATE_PROVINCE[S]ZIP[N][U]COUNTRY', 
  'ADDRESS_1[N]ADDRESS_2[N]CITY[C][S]STATE_PROVINCE[S]ZIP[N][U]COUNTRY') 
    end 
  begin   
  select @formula=FORMULA from Country_Addr_Layouts where ADDRESS_FORMAT=@code 
  while charindex('[N]',@formula)>0 
    begin 
    select @formula=stuff(@formula,charindex('[N]',@formula),3,char(13)) 
    end 
  while charindex('[S]',@formula)>0 
    begin 
    select @formula=stuff(@formula,charindex('[S]',@formula),3,' ') 
    end 
  while charindex('[C]',@formula)>0 
    begin 
    select @formula=stuff(@formula,charindex('[C]',@formula),3,',') 
    end 
  if charindex('CITY',@formula)>0
    select @formula=stuff(@formula,charindex('CITY',@formula),4,'_CITY') 
  if charindex('ZIP',@formula)>0
    select @formula=stuff(@formula,charindex('ZIP',@formula),3,'_ZIP') 
  if charindex('COUNTRY',@formula)>0
    select @formula=stuff(@formula,charindex('COUNTRY',@formula),7,'_COUNTRY') 
  if charindex('[U]ADDRESS_1',@formula)>0 
    select @formula=stuff(@formula,charindex('[U]ADDRESS_1',@formula),12,upper(@ADDRESS_1)) 
  if charindex('[U]ADDRESS_2',@formula)>0 
    select @formula=stuff(@formula,charindex('[U]ADDRESS_2',@formula),12,upper(@ADDRESS_2))
  if charindex('[U]ADDRESS_3',@formula)>0 
    select @formula=stuff(@formula,charindex('[U]ADDRESS_3',@formula),12,upper(@ADDRESS_3)) 
  if charindex('[U]_CITY',@formula)>0 
    begin
    if charindex('[U]_CITY,',@formula)>0
      begin
      if datalength (@STATE_PROVINCE) = 0  
        select @formula=stuff(@formula,charindex('[U]_CITY,',@formula),9,'[U]_CITY') 
      end
    select @formula=stuff(@formula,charindex('[U]_CITY',@formula),8,upper(@CITY) )
    end
  if charindex('[U]STATE_PROVINCE',@formula)>0 
    select @formula=stuff(@formula,charindex('[U]STATE_PROVINCE',@formula),17,upper(@STATE_PROVINCE)) 
  if charindex('[U]_ZIP',@formula)>0 
    select @formula=stuff(@formula,charindex('[U]_ZIP',@formula),7,upper(@ZIP)) 
  if charindex('[U]_COUNTRY',@formula)>0 
    select @formula=stuff(@formula,charindex('[U]_COUNTRY',@formula),11,upper(@COUNTRY)) 
  if charindex('ADDRESS_1',@formula)>0 
    select @formula=stuff(@formula,charindex('ADDRESS_1',@formula),9,@ADDRESS_1) 
  if charindex('ADDRESS_2',@formula)>0 
    select @formula=stuff(@formula,charindex('ADDRESS_2',@formula),9,@ADDRESS_2) 
 if charindex('ADDRESS_3',@formula)>0 
    select @formula=stuff(@formula,charindex('ADDRESS_3',@formula),9,@ADDRESS_3) 
  if charindex('_CITY',@formula)>0 
    begin
    if charindex('_CITY,',@formula)>0
      begin
      if datalength (@STATE_PROVINCE) = 0  
        select @formula=stuff(@formula,charindex('_CITY,',@formula),6,'_CITY') 
      end
    select @formula=stuff(@formula,charindex('_CITY',@formula),5,@CITY) 
    end
  if charindex('STATE_PROVINCE',@formula)>0 
    select @formula=stuff(@formula,charindex('STATE_PROVINCE',@formula),14,@STATE_PROVINCE) 
  if charindex('_ZIP',@formula)>0 
    select @formula=stuff(@formula,charindex('_ZIP',@formula),4,@ZIP) 
  if charindex('_COUNTRY',@formula)>0 
    select @formula=stuff(@formula,charindex('_COUNTRY',@formula),8,@COUNTRY) 
  if charindex('US1',@formula)>0 
    select @formula=stuff(@formula,charindex('US1',@formula),3,'') 
  if charindex('US2',@formula)>0 
    select @formula=stuff(@formula,charindex('US2',@formula),3,'') 
  while charindex(char(13)+' ',@formula)>0      
    begin        
    select @formula=stuff(@formula,charindex(char(13)+' ',@formula),2,char(13))      
    end
  while charindex(char(13)+',',@formula)>0      
    begin        
    select @formula=stuff(@formula,charindex(char(13)+',',@formula),2,char(13))      
    end 
  while charindex(char(13)+char(13),@formula)>0      
    begin        
    select @formula=stuff(@formula,charindex(char(13)+char(13),@formula),2,char(13))      
    end    
  while charindex(char(13)+' '+char(13),@formula)>0      
    begin        
    select @formula=stuff(@formula,charindex(char(13)+' '+char(13),@formula),3,char(13))      
    end
  select @addrlen=datalength (@formula)
  while substring (@formula, @addrlen, 1)=char(13)
         select @formula=substring(@formula, 1, @addrlen-1)
  select @formula  FULL_ADDRESS 
  return 
  end 
  END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_GetCompanySort]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_GetCompanySort]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  StoredProcedure dbo.sp_asi_GetCompanySort  ******/

CREATE PROCEDURE dbo.sp_asi_GetCompanySort
	@CompanyName varchar(80),
	@CompanySort varchar(30) OUTPUT
AS
BEGIN
	SET NOCOUNT ON

	SET @CompanySort = dbo.fn_asi_GetCompanySort(@CompanyName)
	SELECT @CompanySort as CompanySort
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_GetCounter]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_GetCounter]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO


CREATE PROCEDURE [dbo].[sp_asi_GetCounter]  
 /*** sp_asi_GetCounter
      For a given CounterName, returns the next value. (Guaranteed unique).
      If you supply the optional second param "incrementBy", then you receive 
      the additional guarantee that you can use that many consecutive numbers, 
      all with a uniqueness guarantee.
      Sample use:  -----------------------------------------------------------
                   exec sp_asi_GetCounter  'MyCounterName', 3
      Returns:
                   101
      Now you know that 101, 102, 103 are all usable unique numbers
 ***/
    @counterName varchar(30) = '' ,
    @incrementBy   int = 1,
    @checksumOnOff int = 0 /* 1 = ON, 2 = OFF */
AS 
BEGIN
    -- Ensure the counter exists
    INSERT INTO [dbo].[Counter] ([COUNTER_NAME], [LAST_VALUE]) 
        SELECT @CounterName, 0
         WHERE NOT EXISTS (SELECT 1 FROM [dbo].[Counter] WHERE [COUNTER_NAME] = @CounterName)

    DECLARE @id varchar(10)
    DECLARE @lastValue int
    DECLARE @counterValue int
    
    IF @checksumOnOff = 1
    BEGIN
        UPDATE [dbo].[Counter] 
           SET LAST_VALUE = ([LAST_VALUE] + 10) - ([LAST_VALUE] % 10), 
               LAST_UPDATED = GETDATE(), 
               UPDATED_BY = USER_NAME(),
               HAS_CHECKSUM = 1
         WHERE COUNTER_NAME = 'Name'

        UPDATE [dbo].[Counter] 
           SET LAST_VALUE = ([LAST_VALUE] + 10) - ([LAST_VALUE] % 10), 
               LAST_UPDATED = GETDATE(), 
               UPDATED_BY = USER_NAME(),
               HAS_CHECKSUM = 1
         WHERE COUNTER_NAME = 'Prospect'
        RETURN
    END

    IF @checksumOnOff = 2
    BEGIN
        SELECT @lastValue = ([LAST_VALUE] + 10) - ([LAST_VALUE] % 10) FROM [dbo].[Counter] WHERE [COUNTER_NAME] = 'Name'
        UPDATE [dbo].[Counter] 
           SET LAST_VALUE = @lastValue, 
               LAST_UPDATED = GETDATE(), 
               UPDATED_BY = USER_NAME(),
               HAS_CHECKSUM = 0
         WHERE COUNTER_NAME = 'Name'

        SELECT @lastValue = ([LAST_VALUE] + 10) - ([LAST_VALUE] % 10) FROM [dbo].[Counter] WHERE [COUNTER_NAME] = 'Prospect'
        UPDATE [dbo].[Counter] 
           SET LAST_VALUE = @lastValue, 
               LAST_UPDATED = GETDATE(), 
               UPDATED_BY = USER_NAME(),
               HAS_CHECKSUM = 0
         WHERE COUNTER_NAME = 'Prospect'
        RETURN
    END
    
    -- @checksumOnOff parameter not specified, or specified as zero
    IF @counterName IN ('Name', 'Prospect') AND 
       (SELECT [ShortValue] FROM [dbo].[System_Params] WHERE [ParameterName] = 'Member_Control.UseChecksumForId') = 'YES'
    BEGIN
        -- Otherwise just get new "base" value for LastValue
        UPDATE [dbo].[Counter] 
           SET LAST_VALUE = CASE 
                            WHEN [HAS_CHECKSUM] = 0 THEN dbo.asi_ComputeValueWithMod11Checksum([LAST_VALUE] + @incrementBy) 
                            WHEN [HAS_CHECKSUM] = 1 THEN dbo.asi_ComputeValueWithMod11Checksum([LAST_VALUE] / 10  + @incrementBy)
                            END,
               @counterValue = LAST_VALUE + @incrementBy,
               LAST_UPDATED = GETDATE(), 
               UPDATED_BY = USER_NAME(),
               HAS_CHECKSUM = 1
         WHERE COUNTER_NAME = @counterName 

        SELECT (@counterValue - @incrementBy + 1) AS [LAST_VALUE]
    END 
    ELSE
    BEGIN
        -- No checksum
        UPDATE [dbo].[Counter] 
           SET LAST_VALUE = LAST_VALUE + @incrementBy, 
               @counterValue = LAST_VALUE + @incrementBy,
               LAST_UPDATED = GETDATE(), 
               UPDATED_BY = USER_NAME() 
         WHERE COUNTER_NAME = @counterName 
         
        SELECT (@counterValue - @incrementBy + 1) AS [LAST_VALUE]
    END
END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_GetFullName]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_GetFullName]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  StoredProcedure dbo.sp_asi_GetFullName  ******/

-- =============================================
-- This stored procedure calculates FullName based on the input parameters.
-- Input parameters are FirstName, MiddleName, LastName, Prefix, Suffix, Title, Designation,
-- Informal. Output parameter is FullName.
-- By default, FullName is calculated to 
-- @Prefix + ' ' + @FirstName + ' ' + @MiddleName + ' ' + @LastName
--        + ', ' + @Suffix + ', ' + @Designation
-- =============================================
CREATE PROCEDURE dbo.sp_asi_GetFullName
    @FirstName varchar(20) = NULL,
    @MiddleName varchar(20) = NULL,
    @LastName varchar(30) = NULL,
	@Prefix varchar(25) = NULL,
    @Suffix varchar(10) = NULL,
    @Designation varchar(20) = NULL,
    @Title varchar(80) = NULL,
    @Informal varchar(20) = NULL,
    @FullName varchar(70) OUTPUT
AS
BEGIN
	SET @FullName = dbo.fn_asi_GetFullName(@FirstName,@MiddleName,@LastName,@Prefix,@Suffix,@Designation,@Title,@Informal)
	SELECT @FullName as FullName

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_GetLastFirst]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_GetLastFirst]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  StoredProcedure dbo.sp_asi_GetLastFirst  ******/

-- =============================================
-- This stored procedure calculates LastFirst based on the input parameters.
-- Input parameters are LastName, FirstName.
-- Output parameter is LastFirst.
-- By default, LastFirst is calculated to 
-- @LastName + ', ' + @FirstName
-- if both parameters are not empty strings, otherwise
-- @LastName + ' ' + @FirstName
-- =============================================
CREATE PROCEDURE [dbo].[sp_asi_GetLastFirst]
    @LastName varchar(30) = NULL,
    @FirstName varchar(20) = NULL,
    @LastFirst varchar(30) OUTPUT
AS
BEGIN
	SET @LastFirst = dbo.fn_asi_GetLastFirst(@LastName, @FirstName)
	SELECT @LastFirst as LastFirst
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_MakeImisUser]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_MakeImisUser]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure [dbo].[sp_asi_MakeImisUser] @userid varchar(255), @userpassword varchar(255), @sapassword varchar(255)=NULL 
 as  
 declare @execSQL nvarchar(1000)
 declare @loginid varbinary (85)  
 select @loginid = sid from master..syslogins where loginname = @userid 
 if exists (select u.isaliased from sysusers u where u.isaliased = 1 and u.sid = @loginid and @loginid is not NULL) 
 	begin
 	exec sp_password NULL, @userpassword, @userid  
 	return 
 	end
 if @loginid is not null 
 	begin  
 	exec sp_password NULL, @userpassword, @userid  
 	end 
 else  begin  
 	exec sp_addlogin @userid, @userpassword 
 	select @loginid = sid from master..syslogins where loginname = @userid  
 	end  
 if not exists (select d.sid from sysusers d where d.sid = @loginid )  
 	begin   
 	if lower(@userid)='guest'  
 		begin   
 		if not exists (select d.sid from sysusers d where d.name = lower(@userid) and d.sid < 0)    
 			exec sp_adduser @userid, @userid   
        SELECT @execSQL = 'sp_addrolemember ''IMIS'', [' + @userid + ']'
        EXEC (@execSQL)
 		end  
 	else   
 		exec sp_adduser @userid, @userid, 'IMIS'  
 	end  
 else  begin  
 	declare @oldusername varchar(255)  
 	select @oldusername = u.name from  sysusers u where u.sid = @loginid 
 	if @oldusername <> @userid  
 		begin  
 		exec sp_dropuser @oldusername  
 		exec sp_adduser @userid, @userid, 'IMIS'  
 		end  
 	end 
 return

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_MeetingsFlowdown]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_MeetingsFlowdown]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[sp_asi_MeetingsFlowdown]
  (
  	@ID			VARCHAR(10),
  	@OLD_COMPANY		VARCHAR(80),
  	@NEW_COMPANY		VARCHAR(80),
  	@COMPANY_SORT		VARCHAR(90),
  	@OLD_CO_ID			VARCHAR(10), 
  	@NEW_CO_ID			VARCHAR(10),
  	@OLD_EMAIL			VARCHAR(100),
  	@NEW_EMAIL			VARCHAR(100),
  	@OLD_PHONE			VARCHAR(25),
  	@NEW_PHONE			VARCHAR(25),
  	@OLD_FAX			VARCHAR(25),
  	@NEW_FAX			VARCHAR(25),
  	@OLD_TOLL_FREE			VARCHAR(25),
  	@NEW_TOLL_FREE			VARCHAR(25),
  	@PREF_MAIL_CHANGED		VARCHAR(2),
  	@ADDRESS_1			VARCHAR(40),
  	@ADDRESS_2			VARCHAR(40),
  	@ADDRESS_3			VARCHAR(40),
  	@CITY				VARCHAR(40),
  	@STATE_PROVINCE		VARCHAR(15),
  	@ZIP				VARCHAR(10),
  	@COUNTRY			VARCHAR(25),
  	@BAR_CODE			VARCHAR(14),
  	@DPB				VARCHAR(8),
  	@OLD_PREF_MAIL_ADDR		VARCHAR(255),
  	@NEW_PREF_MAIL_ADDR		VARCHAR(255),
  	@OLD_FULL_NAME		VARCHAR(60),
  	@NEW_FULL_NAME		VARCHAR(60),
      @BADGE_FULL_NAME    VARCHAR(60),
  	@PREFIX				VARCHAR(10),
  	@FIRST_NAME			VARCHAR(20),
  	@MIDDLE_NAME		VARCHAR(20),
  	@LAST_NAME			VARCHAR(30),
  	@SUFFIX				VARCHAR(10),
  	@DESIGNATION		VARCHAR(20),
  	@LAST_FIRST			VARCHAR(30),
  	@OLD_TITLE			VARCHAR(80),
  	@NEW_TITLE			VARCHAR(80),
  	@OLD_INFORMAL		VARCHAR(20),
  	@NEW_INFORMAL		VARCHAR(20),
  	@MAINADDR_IS_PREFMAIL		VARCHAR(2),
  	@MAIN_ADDR_CHANGED		VARCHAR(2),
  	@MAIN_ADDRESS_1		VARCHAR(40),
  	@MAIN_ADDRESS_2		VARCHAR(40),
  	@MAIN_ADDRESS_3		VARCHAR(40),
  	@MAIN_CITY			VARCHAR(40),
  	@MAIN_STATE_PROVINCE		VARCHAR(15),
  	@MAIN_ZIP			VARCHAR(10),
  	@MAIN_COUNTRY			VARCHAR(25),
  	@MAIN_BAR_CODE		VARCHAR(14),
  	@MAIN_DPB			VARCHAR(8),
  	@OLD_MAIN_ADDR		VARCHAR(255),
  	@NEW_MAIN_ADDR		VARCHAR(255),
  	@OLD_PREF_MAIL_ADDR_1	VARCHAR(255),
  	@OLD_PREF_MAIL_ADDR_2	VARCHAR(40),
  	@OLD_PREF_MAIL_ADDR_3	VARCHAR(40),
  	@OLD_PREF_MAIL_CITY		VARCHAR(40),
  	@OLD_PREF_MAIL_STATE		VARCHAR(15),
  	@OLD_PREF_MAIL_ZIP		VARCHAR(10),
  	@OLD_PREF_MAIL_COUNTRY	VARCHAR(25),
  	@OLD_MAIN_ADDR_1		VARCHAR(255),
  	@OLD_MAIN_ADDR_2		VARCHAR(40),
  	@OLD_MAIN_ADDR_3		VARCHAR(40),
  	@OLD_MAIN_CITY		VARCHAR(40),
  	@OLD_MAIN_STATE		VARCHAR(15),
  	@OLD_MAIN_ZIP			VARCHAR(10),
  	@OLD_MAIN_COUNTRY		VARCHAR(25)
  )
  AS
 declare 
 @CompanyPurposes varchar(255), 
 @TitlePurposes varchar(255),
 @PrefPurpose varchar(255),
 @UseCompany bit,
 @UseTitle bit
 select @CompanyPurposes =ShortValue from System_Params where ParameterName = 'Member_Control.PrintCompanyWithAddressString'
 select @TitlePurposes =ShortValue from System_Params where ParameterName = 'Member_Control.PrintTitleWithAddressString'
 select @UseCompany=0
 select @UseTitle=0
  SELECT Orders.*, Name.COMPANY_RECORD, Name.ADDRESS_NUM_1, Name.MAIL_ADDRESS_NUM, 'N' as NAME_UPDATED, 
  	'N' as TITLE_UPDATED, 'N' as INFORMAL_UPDATED, 'N' as COMPANY_UPDATED, 'N' as ADDRESS_UPDATED, 
  	'N' as BLOCK_ADDRESS_UPDATE, 'N' as BLOCK_PREF_MAIL_UPDATE
  	INTO #tmp_meet_flowdown
  	FROM Orders INNER JOIN Name
  	ON Name.ID = Orders.ST_ID
  	WHERE
  	Orders.SOURCE_SYSTEM in ('MEETING','EXPO','EXHIBITION') AND
  	(Orders.ST_ID = @ID OR 
  	Orders.CO_ID = @ID)
   IF (select ShortValue from System_Params where ParameterName = 'Member_Control.DisableAutoFlowDown') = 'YES'
   BEGIN	
  	IF @OLD_COMPANY != @NEW_COMPANY
  	BEGIN
  	UPDATE #tmp_meet_flowdown set COMPANY_UPDATED = 'Y'
  		WHERE COMPANY = @OLD_COMPANY
  	UPDATE Orders SET Orders.COMPANY = @NEW_COMPANY,
  			Orders.COMPANY_SORT = @COMPANY_SORT
  		FROM #tmp_meet_flowdown, Orders
  		WHERE  Orders.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND
  		#tmp_meet_flowdown.COMPANY_UPDATED = 'Y'
  	UPDATE Order_Badge SET Order_Badge.COMPANY = @NEW_COMPANY
  		FROM #tmp_meet_flowdown, Order_Badge
  		WHERE Order_Badge.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND
  		#tmp_meet_flowdown.COMPANY_UPDATED = 'Y' AND
  		(Order_Badge.BADGE_TYPE = 'PRIMARY' OR Order_Badge.COMPANY = @OLD_COMPANY)
  	END
  	BEGIN
  	DELETE from #tmp_meet_flowdown where CO_ID = @ID
  	END
   END
  DELETE from #tmp_meet_flowdown where COMPANY_RECORD = 1 and CO_ID = @ID
  UPDATE #tmp_meet_flowdown SET BLOCK_ADDRESS_UPDATE = 'Y' 
  	WHERE CO_ID = @ID and ADDRESS_NUM_1 != MAIL_ADDRESS_NUM
  IF @MAINADDR_IS_PREFMAIL != 'Y'
  BEGIN
  UPDATE #tmp_meet_flowdown SET BLOCK_PREF_MAIL_UPDATE = 'Y' 
  	WHERE CO_ID = @ID
  END
  IF @OLD_CO_ID != @NEW_CO_ID
  BEGIN	
  UPDATE Orders SET Orders.CO_ID = @NEW_CO_ID
  	FROM #tmp_meet_flowdown, Orders
  	WHERE Orders.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND
  	Orders.ST_ID = @ID AND
  	Orders.CO_ID = @OLD_CO_ID
  END
  IF @OLD_EMAIL != @NEW_EMAIL
  BEGIN
  UPDATE Orders SET Orders.EMAIL = @NEW_EMAIL
  	FROM #tmp_meet_flowdown, Orders
  	WHERE Orders.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND
  	Orders.ST_ID = @ID AND
  	Orders.EMAIL = @OLD_EMAIL
  END
  IF @OLD_FULL_NAME != @NEW_FULL_NAME
  BEGIN
  IF @OLD_FULL_NAME = ' '
  	BEGIN
  	UPDATE #tmp_meet_flowdown set NAME_UPDATED = 'Y'
  		WHERE ST_ID = @ID AND	FULL_NAME = ' '
  	END
  ELSE
  	BEGIN
  	UPDATE #tmp_meet_flowdown set NAME_UPDATED = 'Y'
  		WHERE ST_ID = @ID AND	FULL_NAME LIKE '%' + @OLD_FULL_NAME + '%'
  	END
  UPDATE Orders SET         
  	Orders.FULL_NAME = @NEW_FULL_NAME,
  	Orders.PREFIX = @PREFIX,
  	Orders.FIRST_NAME = @FIRST_NAME,
  	Orders.MIDDLE_NAME = @MIDDLE_NAME,
  	Orders.LAST_NAME = @LAST_NAME,
  	Orders.SUFFIX = @SUFFIX,
  	Orders.DESIGNATION = @DESIGNATION,
  	Orders.LAST_FIRST = @LAST_FIRST
  	FROM #tmp_meet_flowdown, Orders
  	WHERE Orders.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND
  	#tmp_meet_flowdown.NAME_UPDATED = 'Y'
  UPDATE Order_Badge SET         
  	Order_Badge.FULL_NAME = @BADGE_FULL_NAME, /* jf - 12 sep 07 dt895 */
  	Order_Badge.PREFIX = @PREFIX,
  	Order_Badge.FIRST_NAME = @FIRST_NAME,
  	Order_Badge.MIDDLE_NAME = @MIDDLE_NAME,
  	Order_Badge.LAST_NAME = @LAST_NAME,
  	Order_Badge.SUFFIX = @SUFFIX,
  	Order_Badge.DESIGNATION = @DESIGNATION
  	FROM #tmp_meet_flowdown, Order_Badge
  	WHERE Order_Badge.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND
  	#tmp_meet_flowdown.NAME_UPDATED = 'Y' AND	
  	Order_Badge.BADGE_TYPE = 'PRIMARY'
  END
  IF @OLD_TITLE != @NEW_TITLE
  BEGIN
  IF @OLD_FULL_NAME = ' '
  	BEGIN
  	UPDATE #tmp_meet_flowdown set TITLE_UPDATED = 'Y'
  		WHERE ST_ID = @ID AND	FULL_NAME = ' '
  		AND TITLE = @OLD_TITLE
  	END
  ELSE
  	BEGIN
  	UPDATE #tmp_meet_flowdown set TITLE_UPDATED = 'Y'
  		WHERE ST_ID = @ID AND FULL_NAME LIKE '%' + @OLD_FULL_NAME + '%'
  		AND TITLE = @OLD_TITLE
  	END
  UPDATE Orders SET Orders.TITLE = @NEW_TITLE
  	FROM #tmp_meet_flowdown, Orders
  	WHERE Orders.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND
  	#tmp_meet_flowdown.TITLE_UPDATED = 'Y'
  UPDATE Order_Badge SET Order_Badge.TITLE = @NEW_TITLE
  	FROM #tmp_meet_flowdown, Order_Badge
  	WHERE Order_Badge.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND
  	#tmp_meet_flowdown.TITLE_UPDATED = 'Y' AND	
  	Order_Badge.BADGE_TYPE = 'PRIMARY'
  END
  IF @OLD_INFORMAL != @NEW_INFORMAL
  BEGIN
  UPDATE #tmp_meet_flowdown set INFORMAL_UPDATED = 'Y'
  	WHERE ST_ID = @ID AND INFORMAL = @OLD_INFORMAL
  UPDATE Orders SET Orders.INFORMAL = @NEW_INFORMAL
  	FROM #tmp_meet_flowdown, Orders
  	WHERE Orders.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND
  	#tmp_meet_flowdown.INFORMAL_UPDATED = 'Y'
  UPDATE Order_Badge SET Order_Badge.INFORMAL = @NEW_INFORMAL
  	FROM #tmp_meet_flowdown, Order_Badge
  	WHERE Order_Badge.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND
  	#tmp_meet_flowdown.INFORMAL_UPDATED = 'Y' AND	
  	Order_Badge.BADGE_TYPE = 'PRIMARY'
  END
  IF @OLD_PHONE != @NEW_PHONE
  BEGIN
  UPDATE Orders SET  Orders.PHONE = @NEW_PHONE
  	FROM #tmp_meet_flowdown, Orders
  	WHERE Orders.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND
  	Orders.PHONE = @OLD_PHONE
  END
  IF @OLD_FAX != @NEW_FAX
  BEGIN
  UPDATE Orders SET Orders.FAX = @NEW_FAX
  	FROM #tmp_meet_flowdown, Orders
  	WHERE Orders.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND
  	Orders.FAX = @OLD_FAX
  END
  IF @OLD_TOLL_FREE != @NEW_TOLL_FREE
  BEGIN
  UPDATE Orders SET Orders.TOLL_FREE = @NEW_TOLL_FREE
  	FROM #tmp_meet_flowdown, Orders
  	WHERE Orders.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND
  	Orders.TOLL_FREE = @OLD_TOLL_FREE
  END
  IF @OLD_COMPANY != @NEW_COMPANY
  BEGIN
  UPDATE #tmp_meet_flowdown set COMPANY_UPDATED = 'Y'
  	WHERE COMPANY = @OLD_COMPANY
  UPDATE Orders SET Orders.COMPANY = @NEW_COMPANY,
  		Orders.COMPANY_SORT = @COMPANY_SORT
  	FROM #tmp_meet_flowdown, Orders
  	WHERE  Orders.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND
  	#tmp_meet_flowdown.COMPANY_UPDATED = 'Y'
  UPDATE Order_Badge SET Order_Badge.COMPANY = @NEW_COMPANY
  	FROM #tmp_meet_flowdown, Order_Badge
  	WHERE Order_Badge.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND
  	#tmp_meet_flowdown.COMPANY_UPDATED = 'Y' AND
  	(Order_Badge.BADGE_TYPE = 'PRIMARY' OR Order_Badge.COMPANY = @OLD_COMPANY)
  END
  IF @PREF_MAIL_CHANGED = 'Y'
  BEGIN
 select @PrefPurpose=','+PURPOSE+',' from Name_Address
 join Name on Name.ID=Name_Address.ID 
 where Name.MAIL_ADDRESS_NUM=Name_Address.ADDRESS_NUM and Name.ID=@ID
 If charindex(@PrefPurpose,@CompanyPurposes)>0
 begin
  select @UseCompany=1
 end
 If charindex(@PrefPurpose,@TitlePurposes)>0
 begin
  select @UseTitle=1
 end
  UPDATE #tmp_meet_flowdown set ADDRESS_UPDATED = 'Y'
  WHERE ADDRESS_1 = @OLD_PREF_MAIL_ADDR_1  AND
  	ADDRESS_2 = @OLD_PREF_MAIL_ADDR_2  AND
  	ADDRESS_3 = @OLD_PREF_MAIL_ADDR_3  AND
  	CITY = @OLD_PREF_MAIL_CITY  AND
  	STATE_PROVINCE = @OLD_PREF_MAIL_STATE  AND
  	ZIP = @OLD_PREF_MAIL_ZIP  AND
  	COUNTRY = @OLD_PREF_MAIL_COUNTRY
  UPDATE Orders SET         
  		Orders.ADDRESS_1 = @ADDRESS_1,
  		Orders.ADDRESS_2 = @ADDRESS_2,
  		Orders.ADDRESS_3 = @ADDRESS_3,
  		Orders.CITY = @CITY,
  		Orders.STATE_PROVINCE = @STATE_PROVINCE,
  		Orders.ZIP = @ZIP,
  		Orders.COUNTRY = @COUNTRY,
  		Orders.DPB = @DPB,
  		Orders.BAR_CODE = @BAR_CODE,
  		Orders.FULL_ADDRESS = @NEW_PREF_MAIL_ADDR,
  		Orders.ST_PRINT_COMPANY = @UseCompany,
  		Orders.ST_PRINT_TITLE = @UseTitle,
  Orders.ST_ADDRESS_NUM=#tmp_meet_flowdown.MAIL_ADDRESS_NUM
  FROM #tmp_meet_flowdown, Orders
  WHERE Orders.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND	
  	#tmp_meet_flowdown.ADDRESS_UPDATED = 'Y' AND
  	#tmp_meet_flowdown.BLOCK_ADDRESS_UPDATE = 'N' AND
  	#tmp_meet_flowdown.BLOCK_PREF_MAIL_UPDATE  = 'N' 
  UPDATE Order_Badge SET         
  		Order_Badge.ADDRESS_1 = @ADDRESS_1,
  		Order_Badge.ADDRESS_2 = @ADDRESS_2,
  		Order_Badge.ADDRESS_3 = @ADDRESS_3,
  		Order_Badge.CITY = @CITY,
  		Order_Badge.STATE_PROVINCE = @STATE_PROVINCE,
  		Order_Badge.ZIP = @ZIP,
  		Order_Badge.COUNTRY = @COUNTRY,
  		Order_Badge.BAR_CODE = @BAR_CODE,
  		Order_Badge.FULL_ADDRESS = @NEW_PREF_MAIL_ADDR,
  		Order_Badge.ST_PRINT_COMPANY =  case Order_Badge.BADGE_TYPE when 'PRIMARY' then @UseCompany else Order_Badge.ST_PRINT_COMPANY end,
  		Order_Badge.ST_PRINT_TITLE = case Order_Badge.BADGE_TYPE when 'PRIMARY' then @UseTitle else Order_Badge.ST_PRINT_TITLE end 
  	FROM #tmp_meet_flowdown, Order_Badge
  	WHERE Order_Badge.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND
  	#tmp_meet_flowdown.ADDRESS_UPDATED = 'Y' AND
  	#tmp_meet_flowdown.BLOCK_ADDRESS_UPDATE = 'N' AND
  	#tmp_meet_flowdown.BLOCK_PREF_MAIL_UPDATE  = 'N' AND
  	(Order_Badge.BADGE_TYPE = 'PRIMARY' OR Order_Badge.FULL_ADDRESS LIKE @OLD_PREF_MAIL_ADDR)
  END
  IF @MAINADDR_IS_PREFMAIL != 'Y' AND @MAIN_ADDR_CHANGED = 'Y'
  BEGIN
  UPDATE #tmp_meet_flowdown set ADDRESS_UPDATED = 'Y'
  WHERE ADDRESS_1 = @OLD_MAIN_ADDR_1  AND
  	ADDRESS_2 = @OLD_MAIN_ADDR_2  AND
  	ADDRESS_3 = @OLD_MAIN_ADDR_3  AND
  	CITY = @OLD_MAIN_CITY  AND
  	STATE_PROVINCE = @OLD_MAIN_STATE  AND
  	ZIP = @OLD_MAIN_ZIP  AND
  	COUNTRY = @OLD_MAIN_COUNTRY
  UPDATE Orders SET         
  		Orders.ADDRESS_1 = @MAIN_ADDRESS_1,
  		Orders.ADDRESS_2 = @MAIN_ADDRESS_2,
  		Orders.ADDRESS_3 = @MAIN_ADDRESS_3,
  		Orders.CITY = @MAIN_CITY,
  		Orders.STATE_PROVINCE = @MAIN_STATE_PROVINCE,
  		Orders.ZIP = @MAIN_ZIP,
  		Orders.COUNTRY = @MAIN_COUNTRY,
  		Orders.DPB = @MAIN_DPB,
  		Orders.BAR_CODE = @MAIN_BAR_CODE,
  		Orders.FULL_ADDRESS = @NEW_MAIN_ADDR
  FROM #tmp_meet_flowdown, Orders
  WHERE Orders.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND
  	#tmp_meet_flowdown.CO_ID = @ID AND	
  	#tmp_meet_flowdown.ADDRESS_UPDATED = 'Y' AND
  	#tmp_meet_flowdown.BLOCK_ADDRESS_UPDATE = 'N' 
  UPDATE Order_Badge SET         
  		Order_Badge.ADDRESS_1 = @MAIN_ADDRESS_1,
  		Order_Badge.ADDRESS_2 = @MAIN_ADDRESS_2,
  		Order_Badge.ADDRESS_3 = @MAIN_ADDRESS_3,
  		Order_Badge.CITY = @MAIN_CITY,
  		Order_Badge.STATE_PROVINCE = @MAIN_STATE_PROVINCE,
  		Order_Badge.ZIP = @MAIN_ZIP,
  		Order_Badge.COUNTRY = @MAIN_COUNTRY,
  		Order_Badge.BAR_CODE = @MAIN_BAR_CODE,
  		Order_Badge.FULL_ADDRESS = @NEW_MAIN_ADDR
  	FROM #tmp_meet_flowdown, Order_Badge
  	WHERE Order_Badge.ORDER_NUMBER = #tmp_meet_flowdown.ORDER_NUMBER AND
  	#tmp_meet_flowdown.CO_ID = @ID AND
  	#tmp_meet_flowdown.ADDRESS_UPDATED = 'Y' AND
  	#tmp_meet_flowdown.BLOCK_ADDRESS_UPDATE = 'N' AND
  	(Order_Badge.BADGE_TYPE = 'PRIMARY' OR Order_Badge.FULL_ADDRESS LIKE @OLD_MAIN_ADDR)
  END
  drop table #tmp_meet_flowdown

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_NameAddressNameGlobalSync]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_NameAddressNameGlobalSync]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE sp_asi_NameAddressNameGlobalSync
 AS
 /* WORK PHONE #################### */
 DECLARE @WORK_PHONE_PURPOSE varchar(255)
 SELECT @WORK_PHONE_PURPOSE = (
     SELECT ShortValue FROM System_Params 
     WHERE ParameterName = 'Member_Control.' + (
         SELECT ShortValue FROM System_Params 
         WHERE ParameterName = 'Member_Control.SyncWorkPhoneToAddress'
     ) + 'Prompt'
 )
 IF @WORK_PHONE_PURPOSE IS NOT NULL
 BEGIN
     /* Name to Name_Address Synchronization - Parent Records */
     UPDATE Name_Address SET 
         PHONE = n.WORK_PHONE,
         LAST_UPDATED = GETDATE()
     FROM Name_Address na
     JOIN Name n ON n.ID = na.ID
     WHERE NOT n.WORK_PHONE = ''
     AND na.PHONE = ''
     AND na.PURPOSE = @WORK_PHONE_PURPOSE
     SELECT
         n.ID,
         n.WORK_PHONE AS VAL_BEFORE,
         na.PHONE AS VAL_AFTER
     INTO #tmp_SyncW
     FROM Name_Address na
     JOIN Name n ON n.ID = na.ID
     WHERE NOT na.PHONE = ''
     AND NOT na.PHONE = n.WORK_PHONE
     AND na.PURPOSE = @WORK_PHONE_PURPOSE
     IF (SELECT COUNT(*) FROM #tmp_SyncW) > 0
     BEGIN
         CREATE UNIQUE INDEX ndx_SyncW_ID ON #tmp_SyncW (ID)
         /* Name_Address to Name Synchronization - Parent Records */
         UPDATE Name SET
             WORK_PHONE = ts.VAL_AFTER,
             LAST_UPDATED = GETDATE()
         FROM #tmp_SyncW ts
         WHERE Name.ID = ts.ID
         /* Change Log Inserts - Parent Records */
         INSERT INTO Name_Log (DATE_TIME, LOG_TYPE, SUB_TYPE, USER_ID, ID, LOG_TEXT)
         SELECT
             GETDATE(), 'CHANGE', 'CHANGE', 'SYNC',
             ts.ID,
             'Name.WORK_PHONE: ' + ts.VAL_BEFORE + ' -> ' + ts.VAL_AFTER
         FROM #tmp_SyncW ts
         /* Meetings Flowdown - Parent Records */
         UPDATE Orders SET
             PHONE = ts.VAL_AFTER
         FROM #tmp_SyncW ts
         WHERE Orders.ST_ID = ts.ID
         AND Orders.SOURCE_SYSTEM = 'MEETING'
         AND Orders.PHONE = ts.VAL_BEFORE
         IF (
             SELECT COUNT(*) FROM System_Params 
             WHERE ParameterName = 'Member_Control.DisableAutoFlowDown' 
             AND ShortValue = 'YES'
         ) = 0
         BEGIN
             /* Name Parent to Child Flowdown Records */
             SELECT
                 n.ID,
                 ts.VAL_BEFORE,
                 ts.VAL_AFTER
             INTO #tmp_SyncChildrenW
             FROM #tmp_SyncW ts
             JOIN Name n ON n.CO_ID = ts.ID
             WHERE n.COMPANY_RECORD = 0
             AND n.WORK_PHONE = ts.VAL_BEFORE     
             IF (SELECT COUNT(*) FROM #tmp_SyncChildrenW) > 0
             BEGIN
                 /* Name_Address to Name Synchronization - Child Records */
                 UPDATE Name SET
                     WORK_PHONE = tsc.VAL_AFTER,
                     LAST_UPDATED = GETDATE()
                 FROM #tmp_SyncChildrenW tsc
                 WHERE Name.ID = tsc.ID
                 /* Change Log Inserts - Child Records */
                 INSERT INTO Name_Log (DATE_TIME, LOG_TYPE, SUB_TYPE, USER_ID, ID, LOG_TEXT)
                 SELECT
                     GETDATE(), 'CHANGE', 'CHANGE', 'SYNC',
                     tsc.ID,
                     'Name.WORK_PHONE: ' + tsc.VAL_BEFORE + ' -> ' + tsc.VAL_AFTER
                 FROM #tmp_SyncChildrenW tsc
                 /* Name to Name_Address Synchronization - Child Records */
                 UPDATE Name_Address SET 
                     PHONE = n.WORK_PHONE,
                     LAST_UPDATED = GETDATE()
                 FROM Name_Address na
                 JOIN Name n ON n.ID = na.ID
                 WHERE NOT n.WORK_PHONE = ''
                 AND na.PURPOSE = @WORK_PHONE_PURPOSE
             END
             DROP TABLE #tmp_SyncChildrenW
             /* Meetings Flowdown - Child Records */
             UPDATE Orders SET
                 PHONE = ts.VAL_AFTER
             FROM #tmp_SyncW ts
             WHERE Orders.CO_ID = ts.ID
             AND Orders.SOURCE_SYSTEM = 'MEETING'
             AND Orders.PHONE = ts.VAL_BEFORE
         END
     END
     DROP TABLE #tmp_SyncW
 END
 /* FAX #################### */
 DECLARE @FAX_PURPOSE varchar(255)
 SELECT @FAX_PURPOSE = (
     SELECT ShortValue FROM System_Params 
     WHERE ParameterName = 'Member_Control.' + (
         SELECT ShortValue FROM System_Params 
         WHERE ParameterName = 'Member_Control.SyncFaxToAddress'
     ) + 'Prompt'
 )
 IF @FAX_PURPOSE IS NOT NULL
 BEGIN
     /* Name to Name_Address Synchronization - Parent Records */
     UPDATE Name_Address SET 
         FAX = n.FAX,
         LAST_UPDATED = GETDATE()
     FROM Name_Address na
     JOIN Name n ON n.ID = na.ID
     WHERE NOT n.FAX = ''
     AND na.FAX = ''
     AND na.PURPOSE = @FAX_PURPOSE
     SELECT
         n.ID,
         n.FAX AS VAL_BEFORE,
         na.FAX AS VAL_AFTER
     INTO #tmp_SyncF
     FROM Name_Address na
     JOIN Name n ON n.ID = na.ID
     WHERE NOT na.FAX = ''
     AND NOT na.FAX = n.FAX
     AND na.PURPOSE = @FAX_PURPOSE
     IF (SELECT COUNT(*) FROM #tmp_SyncF) > 0
     BEGIN
         CREATE UNIQUE INDEX ndx_SyncF_ID ON #tmp_SyncF (ID)
         /* Name_Address to Name Synchronization - Parent Records */
         UPDATE Name SET
             FAX = ts.VAL_AFTER,
             LAST_UPDATED = GETDATE()
         FROM #tmp_SyncF ts
         WHERE Name.ID = ts.ID
         /* Change Log Inserts - Parent Records */
         INSERT INTO Name_Log (DATE_TIME, LOG_TYPE, SUB_TYPE, USER_ID, ID, LOG_TEXT)
         SELECT
             GETDATE(), 'CHANGE', 'CHANGE', 'SYNC',
             ts.ID,
             'Name.FAX: ' + ts.VAL_BEFORE + ' -> ' + ts.VAL_AFTER
         FROM #tmp_SyncF ts
         /* Meetings Flowdown - Parent Records */
         UPDATE Orders SET
             FAX = ts.VAL_AFTER
         FROM #tmp_SyncF ts
         WHERE Orders.ST_ID = ts.ID
         AND Orders.SOURCE_SYSTEM = 'MEETING'
         AND Orders.FAX = ts.VAL_BEFORE
         IF (
             SELECT COUNT(*) FROM System_Params 
             WHERE ParameterName = 'Member_Control.DisableAutoFlowDown' 
             AND ShortValue = 'YES'
         ) = 0
         BEGIN
             /* Name Parent to Child Flowdown Records */
             SELECT
                 n.ID,
                 ts.VAL_BEFORE,
                 ts.VAL_AFTER
             INTO #tmp_SyncChildrenF
             FROM #tmp_SyncF ts
             JOIN Name n ON n.CO_ID = ts.ID
             WHERE n.COMPANY_RECORD = 0
             AND n.FAX = ts.VAL_BEFORE     
             IF (SELECT COUNT(*) FROM #tmp_SyncChildrenF) > 0
             BEGIN
                 /* Name_Address to Name Synchronization - Child Records */
                 UPDATE Name SET
                     FAX = tsc.VAL_AFTER,
                     LAST_UPDATED = GETDATE()
                 FROM #tmp_SyncChildrenF tsc
                 WHERE Name.ID = tsc.ID
                 /* Change Log Inserts - Child Records */
                 INSERT INTO Name_Log (DATE_TIME, LOG_TYPE, SUB_TYPE, USER_ID, ID, LOG_TEXT)
                 SELECT
                     GETDATE(), 'CHANGE', 'CHANGE', 'SYNC',
                     tsc.ID,
                     'Name.FAX: ' + tsc.VAL_BEFORE + ' -> ' + tsc.VAL_AFTER
                 FROM #tmp_SyncChildrenF tsc
                 /* Name to Name_Address Synchronization - Child Records */
                 UPDATE Name_Address SET 
                     FAX = n.FAX,
                     LAST_UPDATED = GETDATE()
                 FROM Name_Address na
                 JOIN Name n ON n.ID = na.ID
                 WHERE NOT n.FAX = ''
                 AND na.PURPOSE = @FAX_PURPOSE
             END
             DROP TABLE #tmp_SyncChildrenF
             /* Meetings Flowdown - Child Records */
             UPDATE Orders SET
                 FAX = ts.VAL_AFTER
             FROM #tmp_SyncF ts
             WHERE Orders.CO_ID = ts.ID
             AND Orders.SOURCE_SYSTEM = 'MEETING'
             AND Orders.FAX = ts.VAL_BEFORE
         END
     END
     DROP TABLE #tmp_SyncF
 END
 /* EMAIL #################### */
 DECLARE @EMAIL_PURPOSE varchar(255)
 SELECT @EMAIL_PURPOSE = (
     SELECT ShortValue FROM System_Params 
     WHERE ParameterName = 'Member_Control.' + (
         SELECT ShortValue FROM System_Params 
         WHERE ParameterName = 'Member_Control.SyncEmailToAddress'
     ) + 'Prompt'
 )
 IF @EMAIL_PURPOSE IS NOT NULL
 BEGIN
     /* Name to Name_Address Synchronization - Parent Records */
     UPDATE Name_Address SET 
         EMAIL = n.EMAIL,
         LAST_UPDATED = GETDATE()
     FROM Name_Address na
     JOIN Name n ON n.ID = na.ID
     WHERE NOT n.EMAIL = ''
     AND na.EMAIL = ''
     AND na.PURPOSE = @EMAIL_PURPOSE
     SELECT
         n.ID,
         n.EMAIL AS VAL_BEFORE,
         na.EMAIL AS VAL_AFTER
     INTO #tmp_SyncE
     FROM Name_Address na
     JOIN Name n ON n.ID = na.ID
     WHERE NOT na.EMAIL = ''
     AND NOT na.EMAIL = n.EMAIL
     AND na.PURPOSE = @EMAIL_PURPOSE
     IF (SELECT COUNT(*) FROM #tmp_SyncE) > 0
     BEGIN
         CREATE UNIQUE INDEX ndx_SyncE_ID ON #tmp_SyncE (ID)
         /* Name_Address to Name Synchronization - Parent Records */
         UPDATE Name SET
             EMAIL = ts.VAL_AFTER,
             LAST_UPDATED = GETDATE()
         FROM #tmp_SyncE ts
         WHERE Name.ID = ts.ID
         /* Change Log Inserts - Parent Records */
         INSERT INTO Name_Log (DATE_TIME, LOG_TYPE, SUB_TYPE, USER_ID, ID, LOG_TEXT)
         SELECT
             GETDATE(), 'CHANGE', 'CHANGE', 'SYNC',
             ts.ID,
             'Name.EMAIL: ' + ts.VAL_BEFORE + ' -> ' + ts.VAL_AFTER
         FROM #tmp_SyncE ts
         /* Meetings Flowdown - Parent Records */
         UPDATE Orders SET
             EMAIL = ts.VAL_AFTER
         FROM #tmp_SyncE ts
         WHERE Orders.ST_ID = ts.ID
         AND Orders.SOURCE_SYSTEM = 'MEETING'
         AND Orders.EMAIL = ts.VAL_BEFORE
         /* Email no longer honored as part of user-defined flowdown */
         /*
         IF (
             SELECT COUNT(*) FROM System_Params 
             WHERE ParameterName = 'Member_Control.FlowDownFields'
             AND (ShortValue LIKE '%Name.EMAIL%' OR LongValue LIKE '%Name.EMAIL%')
         ) = 1
         BEGIN
             SELECT
                 n.ID,
                 ts.VAL_BEFORE,
                 ts.VAL_AFTER
             INTO #tmp_SyncChildrenE
             FROM #tmp_SyncE ts
             JOIN Name n ON n.CO_ID = ts.ID
             WHERE n.COMPANY_RECORD = 0
             AND n.EMAIL = ts.VAL_BEFORE     
             IF (SELECT COUNT(*) FROM #tmp_SyncChildrenE) > 0
             BEGIN
                 UPDATE Name SET
                     EMAIL = tsc.VAL_AFTER,
                     LAST_UPDATED = GETDATE()
                 FROM #tmp_SyncChildrenE tsc
                 WHERE Name.ID = tsc.ID
                 INSERT INTO Name_Log (DATE_TIME, LOG_TYPE, SUB_TYPE, USER_ID, ID, LOG_TEXT)
                 SELECT
                     GETDATE(), 'CHANGE', 'CHANGE', 'SYNC',
                     tsc.ID,
                     'Name.EMAIL: ' + tsc.VAL_BEFORE + ' -> ' + tsc.VAL_AFTER
                 FROM #tmp_SyncChildrenE tsc
                 UPDATE Name_Address SET 
                     EMAIL = n.EMAIL,
                     LAST_UPDATED = GETDATE()
                 FROM Name_Address na
                 JOIN Name n ON n.ID = na.ID
                 WHERE NOT n.EMAIL = ''
                 AND na.PURPOSE = @EMAIL_PURPOSE
             END
             DROP TABLE #tmp_SyncChildrenE
             UPDATE Orders SET
                 EMAIL = ts.VAL_AFTER
             FROM #tmp_SyncE ts
             WHERE Orders.CO_ID = ts.ID
             AND Orders.SOURCE_SYSTEM = 'MEETING'
             AND Orders.EMAIL = ts.VAL_BEFORE
         END
         */
     END
     DROP TABLE #tmp_SyncE
 END
 /* HOME PHONE #################### */
 DECLARE @HOME_PHONE_PURPOSE varchar(255)
 SELECT @HOME_PHONE_PURPOSE = (
     SELECT ShortValue FROM System_Params 
     WHERE ParameterName = 'Member_Control.' + (
         SELECT ShortValue FROM System_Params 
         WHERE ParameterName = 'Member_Control.SyncHomePhoneToAddress'
     ) + 'Prompt'
 )
 IF @HOME_PHONE_PURPOSE IS NOT NULL
 BEGIN
     /* Name to Name_Address Synchronization - Parent Records */
     UPDATE Name_Address SET 
         PHONE = n.HOME_PHONE,
         LAST_UPDATED = GETDATE()
     FROM Name_Address na
     JOIN Name n ON n.ID = na.ID
     WHERE NOT n.HOME_PHONE = ''
     AND na.PHONE = ''
     AND na.PURPOSE = @HOME_PHONE_PURPOSE
     SELECT
         n.ID,
         n.HOME_PHONE AS VAL_BEFORE,
         na.PHONE AS VAL_AFTER
     INTO #tmp_SyncH
     FROM Name_Address na
     JOIN Name n ON n.ID = na.ID
     WHERE NOT na.PHONE = ''
     AND NOT na.PHONE = n.HOME_PHONE
     AND na.PURPOSE = @HOME_PHONE_PURPOSE
     IF (SELECT COUNT(*) FROM #tmp_SyncH) > 0
     BEGIN
         CREATE UNIQUE INDEX ndx_SyncH_ID ON #tmp_SyncH (ID)
         UPDATE Name SET
             HOME_PHONE = ts.VAL_AFTER,
             LAST_UPDATED = GETDATE()
         FROM #tmp_SyncH ts
         WHERE Name.ID = ts.ID
         /* Change Log Inserts - Parent Records */
         INSERT INTO Name_Log (DATE_TIME, LOG_TYPE, SUB_TYPE, USER_ID, ID, LOG_TEXT)
         SELECT
             GETDATE(), 'CHANGE', 'CHANGE', 'SYNC',
             ts.ID,
             'Name.HOME_PHONE: ' + ts.VAL_BEFORE + ' -> ' + ts.VAL_AFTER
         FROM #tmp_SyncH ts
         /* Meetings Flowdown - Parent Records */
         /* N/A (Home phone not part of orders/meetings) */
         /* Home phone no longer honored as part of user-defined flowdown */
         /*
         IF (
             SELECT COUNT(*) FROM System_Params 
             WHERE ParameterName = 'Member_Control.FlowDownFields'
             AND (ShortValue LIKE '%Name.HOME_PHONE%' OR LongValue LIKE '%Name.HOME_PHONE%')
         ) = 1
         BEGIN
             SELECT
                 n.ID,
                 ts.VAL_BEFORE,
                 ts.VAL_AFTER
             INTO #tmp_SyncChildrenH
             FROM #tmp_SyncH ts
             JOIN Name n ON n.CO_ID = ts.ID
             WHERE n.COMPANY_RECORD = 0
             AND n.HOME_PHONE = ts.VAL_BEFORE     
             IF (SELECT COUNT(*) FROM #tmp_SyncChildrenH) > 0
             BEGIN
                 UPDATE Name SET
                     HOME_PHONE = tsc.VAL_AFTER,
                     LAST_UPDATED = GETDATE()
                 FROM #tmp_SyncChildrenH tsc
                 WHERE Name.ID = tsc.ID
                 INSERT INTO Name_Log (DATE_TIME, LOG_TYPE, SUB_TYPE, USER_ID, ID, LOG_TEXT)
                 SELECT
                     GETDATE(), 'CHANGE', 'CHANGE', 'SYNC',
                     tsc.ID,
                     'Name.HOME_PHONE: ' + tsc.VAL_BEFORE + ' -> ' + tsc.VAL_AFTER
                 FROM #tmp_SyncChildrenH tsc
                 UPDATE Name_Address SET 
                     PHONE = n.HOME_PHONE,
                     LAST_UPDATED = GETDATE()
                 FROM Name_Address na
                 JOIN Name n ON n.ID = na.ID
                 WHERE NOT n.HOME_PHONE = ''
                 AND na.PURPOSE = @HOME_PHONE_PURPOSE
             END
             DROP TABLE #tmp_SyncChildrenH
         END
         */
     END
     DROP TABLE #tmp_SyncH
 END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_NameProspectUnion]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_NameProspectUnion]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure sp_asi_NameProspectUnion 
 @ID varchar(15)='',
 @LastFirst varchar(30)='',
 @CompanySort varchar(30)='',
 @MaxCount integer=0 
 as
 set nocount on
 if @ID<>''
 -- Search by ID
 BEGIN
 select ID,PREFIX,LAST_FIRST,FIRST_NAME,MIDDLE_NAME,LAST_NAME,SUFFIX,FULL_NAME,TITLE,COMPANY,COMPANY_SORT,CITY,
 STATE_PROVINCE,ZIP,COUNTRY,HOME_PHONE,WORK_PHONE,FAX,EMAIL,ORG_CODE,MEMBER_TYPE,CATEGORY,STATUS,MAJOR_KEY,
 CO_ID,BT_ID,DUP_MATCH_KEY,FULL_ADDRESS,DESIGNATION,INFORMAL,TOLL_FREE,MAIL_CODE,CRRT,BAR_CODE,COUNTY,
 MAIL_ADDRESS_NUM,BILL_ADDRESS_NUM,GENDER,BIRTH_DATE,US_CONGRESS,STATE_SENATE,STATE_HOUSE,SIC_CODE,CHAPTER,
 FUNCTIONAL_TITLE,CONTACT_RANK,MEMBER_RECORD,COMPANY_RECORD,JOIN_DATE,SOURCE_CODE,PAID_THRU,MEMBER_STATUS,
 MEMBER_STATUS_DATE,PREVIOUS_MT,MT_CHANGE_DATE,CO_MEMBER_TYPE,EXCLUDE_MAIL,EXCLUDE_DIRECTORY,DATE_ADDED,
 LAST_UPDATED,UPDATED_BY,INTENT_TO_EDIT,ADDRESS_NUM_1,ADDRESS_NUM_2,ADDRESS_NUM_3,WEBSITE,'' ImisID,0 IsProspect
 from Name where ID = @ID
 UNION ALL
 select ProspectID ID,Prefix PREFIX,LastFirst LAST_FIRST,FirstName FIRST_NAME,
 MiddleName MIDDLE_NAME,LastName LAST_NAME,Suffix SUFFIX,FullName FULL_NAME,Title TITLE,
 Organization COMPANY,CompanySort COMPANY_SORT,City CITY,StateProvince STATE_PROVINCE,
 PostalCode IP,Country COUNTRY,HomePhone HOME_PHONE,WorkPhone WORK_PHONE,Fax FAX,Email EMAIL,
 '' ORG_CODE,ListCode MEMBER_TYPE,
 '' CATEGORY,'' STATUS,'' MAJOR_KEY,'' CO_ID,'' BT_ID,'' DUP_MATCH_KEY,'' FULL_ADDRESS,
 '' DESIGNATION,'' NFORMAL,'' TOLL_FREE,'' MAIL_CODE,'' CRRT,'' BAR_CODE,'' COUNTY,
 0 MAIL_ADDRESS_NUM,0 BILL_ADDRESS_NUM,'' GENDER,NULL BIRTH_DATE,'' US_CONGRESS,'' STATE_SENATE,
 '' STATE_HOUSE,'' SIC_CODE,'' CHAPTER,'' FUNCTIONAL_TITLE,0 CONTACT_RANK,0 MEMBER_RECORD,
 0 COMPANY_RECORD,NULL JOIN_DATE,'' SOURCE_CODE,NULL PAID_THRU,'' MEMBER_STATUS,NULL MEMBER_STATUS_DATE,
 '' PREVIOUS_MT,NULL MT_CHANGE_DATE,'' CO_MEMBER_TYPE,0 EXCLUDE_MAIL,0 EXCLUDE_DIRECTORY,
 NULL DATE_ADDED,NULL LAST_UPDATED,'' UPDATED_BY,'' INTENT_TO_EDIT,0 ADDRESS_NUM_1,
 0 ADDRESS_NUM_2,0 ADDRESS_NUM_3,'' WEBSITE,ImisID,1 IsProspect from Prospect
 where ProspectID = @ID
 END
 ELSE IF @LastFirst<>''
 -- Search by LastFirst
 BEGIN
 set rowcount @MaxCount
 select ID,PREFIX,LAST_FIRST,FIRST_NAME,MIDDLE_NAME,LAST_NAME,SUFFIX,FULL_NAME,TITLE,COMPANY,COMPANY_SORT,CITY,
 STATE_PROVINCE,ZIP,COUNTRY,HOME_PHONE,WORK_PHONE,FAX,EMAIL,ORG_CODE,MEMBER_TYPE,CATEGORY,STATUS,MAJOR_KEY,
 CO_ID,BT_ID,DUP_MATCH_KEY,FULL_ADDRESS,DESIGNATION,INFORMAL,TOLL_FREE,MAIL_CODE,CRRT,BAR_CODE,COUNTY,
 MAIL_ADDRESS_NUM,BILL_ADDRESS_NUM,GENDER,BIRTH_DATE,US_CONGRESS,STATE_SENATE,STATE_HOUSE,SIC_CODE,CHAPTER,
 FUNCTIONAL_TITLE,CONTACT_RANK,MEMBER_RECORD,COMPANY_RECORD,JOIN_DATE,SOURCE_CODE,PAID_THRU,MEMBER_STATUS,
 MEMBER_STATUS_DATE,PREVIOUS_MT,MT_CHANGE_DATE,CO_MEMBER_TYPE,EXCLUDE_MAIL,EXCLUDE_DIRECTORY,DATE_ADDED,
 LAST_UPDATED,UPDATED_BY,INTENT_TO_EDIT,ADDRESS_NUM_1,ADDRESS_NUM_2,ADDRESS_NUM_3,WEBSITE,'' ImisID,0 IsProspect
 from Name where LAST_FIRST like @LastFirst+'%'
 UNION ALL
 select ProspectID ID,Prefix PREFIX,LastFirst LAST_FIRST,FirstName FIRST_NAME,
 MiddleName MIDDLE_NAME,LastName LAST_NAME,Suffix SUFFIX,FullName FULL_NAME,Title TITLE,
 Organization COMPANY,CompanySort COMPANY_SORT,City CITY,StateProvince STATE_PROVINCE,
 PostalCode IP,Country COUNTRY,HomePhone HOME_PHONE,WorkPhone WORK_PHONE,Fax FAX,Email EMAIL,
 '' ORG_CODE,ListCode MEMBER_TYPE,
 '' CATEGORY,'' STATUS,'' MAJOR_KEY,'' CO_ID,'' BT_ID,'' DUP_MATCH_KEY,'' FULL_ADDRESS,
 '' DESIGNATION,'' NFORMAL,'' TOLL_FREE,'' MAIL_CODE,'' CRRT,'' BAR_CODE,'' COUNTY,
 0 MAIL_ADDRESS_NUM,0 BILL_ADDRESS_NUM,'' GENDER,NULL BIRTH_DATE,'' US_CONGRESS,'' STATE_SENATE,
 '' STATE_HOUSE,'' SIC_CODE,'' CHAPTER,'' FUNCTIONAL_TITLE,0 CONTACT_RANK,0 MEMBER_RECORD,
 0 COMPANY_RECORD,NULL JOIN_DATE,'' SOURCE_CODE,NULL PAID_THRU,'' MEMBER_STATUS,NULL MEMBER_STATUS_DATE,
 '' PREVIOUS_MT,NULL MT_CHANGE_DATE,'' CO_MEMBER_TYPE,0 EXCLUDE_MAIL,0 EXCLUDE_DIRECTORY,
 NULL DATE_ADDED,NULL LAST_UPDATED,'' UPDATED_BY,'' INTENT_TO_EDIT,0 ADDRESS_NUM_1,
 0 ADDRESS_NUM_2,0 ADDRESS_NUM_3,'' WEBSITE,ImisID,1 IsProspect from Prospect
 where LastFirst like @LastFirst+'%' and ImisID=''
 END
 ELSE
 -- Search by CompanySort
 BEGIN
 set rowcount @MaxCount
 select ID,PREFIX,LAST_FIRST,FIRST_NAME,MIDDLE_NAME,LAST_NAME,SUFFIX,FULL_NAME,TITLE,COMPANY,COMPANY_SORT,CITY,
 STATE_PROVINCE,ZIP,COUNTRY,HOME_PHONE,WORK_PHONE,FAX,EMAIL,ORG_CODE,MEMBER_TYPE,CATEGORY,STATUS,MAJOR_KEY,
 CO_ID,BT_ID,DUP_MATCH_KEY,FULL_ADDRESS,DESIGNATION,INFORMAL,TOLL_FREE,MAIL_CODE,CRRT,BAR_CODE,COUNTY,
 MAIL_ADDRESS_NUM,BILL_ADDRESS_NUM,GENDER,BIRTH_DATE,US_CONGRESS,STATE_SENATE,STATE_HOUSE,SIC_CODE,CHAPTER,
 FUNCTIONAL_TITLE,CONTACT_RANK,MEMBER_RECORD,COMPANY_RECORD,JOIN_DATE,SOURCE_CODE,PAID_THRU,MEMBER_STATUS,
 MEMBER_STATUS_DATE,PREVIOUS_MT,MT_CHANGE_DATE,CO_MEMBER_TYPE,EXCLUDE_MAIL,EXCLUDE_DIRECTORY,DATE_ADDED,
 LAST_UPDATED,UPDATED_BY,INTENT_TO_EDIT,ADDRESS_NUM_1,ADDRESS_NUM_2,ADDRESS_NUM_3,WEBSITE,'' ImisID,0 IsProspect
 from Name where COMPANY_SORT like @CompanySort+'%'
 UNION ALL
 select ProspectID ID,Prefix PREFIX,LastFirst LAST_FIRST,FirstName FIRST_NAME,
 MiddleName MIDDLE_NAME,LastName LAST_NAME,Suffix SUFFIX,FullName FULL_NAME,Title TITLE,
 Organization COMPANY,CompanySort COMPANY_SORT,City CITY,StateProvince STATE_PROVINCE,
 PostalCode IP,Country COUNTRY,HomePhone HOME_PHONE,WorkPhone WORK_PHONE,Fax FAX,Email EMAIL,
 '' ORG_CODE,ListCode MEMBER_TYPE,
 '' CATEGORY,'' STATUS,'' MAJOR_KEY,'' CO_ID,'' BT_ID,'' DUP_MATCH_KEY,'' FULL_ADDRESS,
 '' DESIGNATION,'' NFORMAL,'' TOLL_FREE,'' MAIL_CODE,'' CRRT,'' BAR_CODE,'' COUNTY,
 0 MAIL_ADDRESS_NUM,0 BILL_ADDRESS_NUM,'' GENDER,NULL BIRTH_DATE,'' US_CONGRESS,'' STATE_SENATE,
 '' STATE_HOUSE,'' SIC_CODE,'' CHAPTER,'' FUNCTIONAL_TITLE,0 CONTACT_RANK,0 MEMBER_RECORD,
 0 COMPANY_RECORD,NULL JOIN_DATE,'' SOURCE_CODE,NULL PAID_THRU,'' MEMBER_STATUS,NULL MEMBER_STATUS_DATE,
 '' PREVIOUS_MT,NULL MT_CHANGE_DATE,'' CO_MEMBER_TYPE,0 EXCLUDE_MAIL,0 EXCLUDE_DIRECTORY,
 NULL DATE_ADDED,NULL LAST_UPDATED,'' UPDATED_BY,'' INTENT_TO_EDIT,0 ADDRESS_NUM_1,
 0 ADDRESS_NUM_2,0 ADDRESS_NUM_3,'' WEBSITE,ImisID,1 IsProspect from Prospect
 where CompanySort like @CompanySort+'%' and ImisID=''
 END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_NameToNameAddressSync]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_NameToNameAddressSync]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE sp_asi_NameToNameAddressSync (
  @ID VARCHAR(10)
  )
  AS
  UPDATE Name_Address SET 
  PHONE = (
  SELECT HOME_PHONE FROM Name WHERE ID = @ID
  )
  WHERE ID = @ID
  AND PURPOSE = (
  SELECT ShortValue FROM System_Params 
  WHERE ParameterName = 
  'Member_Control.' + (
  SELECT ShortValue FROM System_Params 
  WHERE ParameterName = 'Member_Control.SyncHomePhoneToAddress'
  ) + 'Prompt'
  )
  UPDATE Name_Address SET
  PHONE = (
  SELECT WORK_PHONE FROM Name WHERE ID = @ID
  )
  WHERE ID = @ID
  AND PURPOSE = (
  SELECT ShortValue FROM System_Params 
  WHERE ParameterName = 
  'Member_Control.' + (
  SELECT ShortValue FROM System_Params 
  WHERE ParameterName = 'Member_Control.SyncWorkPhoneToAddress'
  ) + 'Prompt'
  )
  UPDATE Name_Address SET
  FAX = (
  SELECT FAX FROM Name WHERE ID = @ID
  )
  WHERE ID = @ID
  AND PURPOSE = (
  SELECT ShortValue FROM System_Params 
  WHERE ParameterName = 
  'Member_Control.' + (
  SELECT ShortValue FROM System_Params 
  WHERE ParameterName = 'Member_Control.SyncFaxToAddress'
  ) + 'Prompt'
  )
  UPDATE Name_Address SET
  EMAIL = (
  SELECT EMAIL FROM Name WHERE ID = @ID
  )
  WHERE ID = @ID
  AND PURPOSE = (
  SELECT ShortValue FROM System_Params 
  WHERE ParameterName = 
  'Member_Control.' + (
  SELECT ShortValue FROM System_Params 
  WHERE ParameterName = 'Member_Control.SyncEmailToAddress'
  ) + 'Prompt'
  )

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_sp_columns]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_sp_columns]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
--	Procedure for SQL2K (8.0) server, revised for iMIS
-- 	extensively revised (and simplified) for SQL Server 2005
CREATE PROCEDURE sp_asi_sp_columns (@table_name	 varchar(96))
as
select
'' TABLE_QUALIFIER,
'' TABLE_OWNER,
'' TABLE_NAME,
convert (varchar(96), c.name) COLUMN_NAME,
0 DATA_TYPE,
convert (varchar(96), t.name) 'TYPE_NAME',
convert(int, 
	case when t.name = 'float' then 15
	when t.name = 'real' then 7 		
	else OdbcPrec(c.xtype,c.length,c.xprec)
end) 'PRECISION', 
convert(int, case
	when t.name IN ('money', 'numeric','decimal') 
		then OdbcPrec(c.xtype,c.length,c.xprec)+2
	when t.name IN ('datetime') 
		then 16
	when t.name IN ('text', 'image') 
		then OdbcPrec(c.xtype,c.length,c.xprec)
	else c.length
	end) 'LENGTH',  
SCALE = convert(smallint, OdbcScale(c.xtype,c.xscale)),
0 RADIX,
isnullable NULLABLE,
NULL REMARKS,
colorder ORDINAL_POSITION
from syscolumns c
inner join systypes t on c.usertype = t.usertype
where id = (select id from sysobjects where name = @table_name)
and c.name <> 'TIME_STAMP'
order by ORDINAL_POSITION

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_sp_columns_ts]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_sp_columns_ts]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
--	Procedure for SQL2K (8.0) server, revised for iMIS
-- 	extensively revised (and simplified) for SQL Server 2005
CREATE PROCEDURE sp_asi_sp_columns_ts (@table_name varchar(96))
as
select
'' TABLE_QUALIFIER,
'' TABLE_OWNER,
'' TABLE_NAME,
convert (varchar(96), c.name) COLUMN_NAME,
0 DATA_TYPE,
convert (varchar(96), 
	case when ColumnProperty (c.id, c.name, 'IsIdentity') = 1
		then 'int identity'
	else t.name
	end) 
'TYPE_NAME',
convert(int, 
	case when t.name = 'float' then 15
	when t.name = 'real' then 7 		
	else OdbcPrec(c.xtype,c.length,c.xprec)
end) 'PRECISION', 
convert(int, case
	when t.name IN ('money', 'numeric','decimal') 
		then OdbcPrec(c.xtype,c.length,c.xprec)+2
	when t.name IN ('datetime') 
		then 16
	when t.name IN ('text', 'image') 
		then OdbcPrec(c.xtype,c.length,c.xprec)
	else c.length
	end) 'LENGTH',  
SCALE = convert(smallint, OdbcScale(c.xtype,c.xscale)),
0 RADIX,
isnullable NULLABLE,
NULL REMARKS,
colorder ORDINAL_POSITION
from syscolumns c
inner join systypes t on c.usertype = t.usertype
where id = (select id from sysobjects where name = @table_name)
order by ORDINAL_POSITION

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_sp_pkeys]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_sp_pkeys]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE sp_asi_sp_pkeys(
					@table_name		varchar(96),
					@table_owner 	varchar(96) = null,
					@table_qualifier varchar(96) = null )
		as
			DECLARE @table_id			int
			DECLARE @full_table_name	varchar(255) /* 2*128 + 1 */
			if @table_qualifier is not null
			begin
				if db_name() <> @table_qualifier
				begin	/* If qualifier doesn't match current database */
					raiserror (15250, -1,-1)
					return
				end
			end
			if @table_owner is null
			begin	/* If unqualified table name */
				SELECT @full_table_name = @table_name
			end
			else
			begin	/* Qualified table name */
				if @table_owner = ''
				begin	/* If empty owner name */
					SELECT @full_table_name = @table_owner
				end
				else
				begin
					SELECT @full_table_name = @table_owner + '.' + @table_name
				end
			end
			/*	Get Object ID */
			SELECT @table_id = object_id(@full_table_name)
			select
				TABLE_QUALIFIER = convert(varchar(96),db_name()),
				TABLE_OWNER = convert(varchar(96),user_name(o.uid)),
				TABLE_NAME = convert(varchar(96),o.name),
				COLUMN_NAME = convert(varchar(96),c.name),
				KEY_SEQ = convert(smallint,c1.colid),
				PK_NAME = convert(varchar(96),i.name)
			from
				sysindexes i, syscolumns c, sysobjects o, syscolumns c1
			where
				o.id = @table_id
				and o.id = c.id
				and o.id = i.id
				and (i.status & 0x800) = 0x800
				and c.name = index_col (@full_table_name, i.indid, c1.colid)
				and c1.colid <= i.keycnt	/* create rows from 1 to keycnt */
				and c1.id = @table_id
			order by 1, 2, 3, 5

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_suser_name]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_suser_name]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE sp_asi_suser_name AS 
		select (convert (varchar(64), suser_sname ()))

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_TreatProspectImport]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_TreatProspectImport]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure sp_asi_TreatProspectImport @Prefix varchar(5),@ListCode varchar(20),@CurrentLocalDate varchar (50)=''
   as
   set nocount on
   declare 
   @ProspectKey uniqueidentifier,
   @ProspectID varchar(15),
   @NewProspectID int,
   @Result int
   declare Get_Prospect cursor for 
   select ProspectKey from Prospect where ImportDate is null
   open Get_Prospect
   fetch next from Get_Prospect into @ProspectKey
   WHILE @@FETCH_STATUS = 0
    BEGIN
     exec @Result=sp_iboGetCounter 'Prospect',1,@NewProspectID output
     update Prospect set ListCode=@ListCode,ProspectID=@Prefix+convert(varchar(10),@NewProspectID),
     ImportDate=@CurrentLocalDate,
     LastFirst=
     CASE 
     WHEN rtrim(isnull(LastName,''))<>'' and rtrim(isnull(FirstName,''))<>''
     THEN substring(upper(LastName)+', '+upper(FirstName),1,30)
     WHEN rtrim(isnull(LastName,''))='' and rtrim(isnull(FirstName,''))='' and rtrim(isnull(Organization,''))=''
     THEN 'NODATA'
     ELSE ''
     END,
     CompanySort=
     CASE
     WHEN rtrim(isnull(Organization,''))<>'' and substring(upper(isnull(Organization,'')),1,4)='THE '
     THEN substring(upper(Organization),5,30)
     WHEN rtrim(isnull(Organization,''))<>'' and substring(upper(isnull(Organization,'')),1,4)<>'THE '
     THEN  substring(upper(Organization),1,30)
     ELSE ''
     END
     where ProspectKey=@ProspectKey
     fetch next from Get_Prospect into @ProspectKey
    END
   close Get_Prospect
   deallocate Get_Prospect
   delete Prospect where LastFirst='NODATA'

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_UnformatPhoneNumber]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_UnformatPhoneNumber]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure sp_asi_UnformatPhoneNumber
     @table VARCHAR(100),
     @column VARCHAR(100)
 AS
 DECLARE @sql VARCHAR(2000)
 DECLARE @phone VARCHAR(100)
 SET @sql = 'DECLARE csrPhone CURSOR GLOBAL FOR ' +
     'SELECT ' + @column + ' ' + 
      'FROM ' + @table + ' ' +
      'WHERE ' + @column + ' LIKE ''%[^0-9]%'' ' +
      'FOR UPDATE '
 EXEC(@sql)
 OPEN csrPhone
 FETCH NEXT FROM csrPhone INTO @phone
 SET NOCOUNT ON
 WHILE @@FETCH_STATUS = 0
 BEGIN
      WHILE PATINDEX('%[^0-9]%', @phone) > 0
           SET @phone = STUFF(@phone, PATINDEX('%[^0-9]%', @phone), 1, '')
      SET @sql = 'UPDATE ' + @table + ' ' +
           'SET ' + @column + ' = ''' + @phone + ''' ' +
           'WHERE CURRENT OF GLOBAL csrPhone '
      EXEC(@sql)
      FETCH NEXT FROM csrPhone INTO @phone
 END
 SET NOCOUNT OFF
 CLOSE csrPhone
 DEALLOCATE csrPhone

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_UnformatPhoneNumbers]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_UnformatPhoneNumbers]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
create procedure sp_asi_UnformatPhoneNumbers
 as
 	-- Name 
 	exec sp_asi_UnformatPhoneNumber 'Name','HOME_PHONE'
 	exec sp_asi_UnformatPhoneNumber 'Name','WORK_PHONE'
 	exec sp_asi_UnformatPhoneNumber 'Name','FAX'
 	exec sp_asi_UnformatPhoneNumber 'Name','TOLL_FREE'
 	-- Name_Address
 	exec sp_asi_UnformatPhoneNumber 'Name_Address','PHONE'
 	exec sp_asi_UnformatPhoneNumber 'Name_Address','FAX'
 	-- Meet_Hotel
 	exec sp_asi_UnformatPhoneNumber 'Meet_Hotel','PHONE'
 	exec sp_asi_UnformatPhoneNumber 'Meet_Hotel','FAX'
 	exec sp_asi_UnformatPhoneNumber 'Meet_Hotel','TOLL_FREE'
 	-- Orders
 	exec sp_asi_UnformatPhoneNumber 'Orders','PHONE'
 	exec sp_asi_UnformatPhoneNumber 'Orders','FAX'
 	exec sp_asi_UnformatPhoneNumber 'Orders','TOLL_FREE'
 	-- Product_Instance
 	exec sp_asi_UnformatPhoneNumber 'Product_Instance','PHONE'
 	exec sp_asi_UnformatPhoneNumber 'Product_Instance','FAX'
 	exec sp_asi_UnformatPhoneNumber 'Product_Instance','TOLL_FREE'
 	-- Ref_Client
 	exec sp_asi_UnformatPhoneNumber 'Ref_Client','PHONE'
 	exec sp_asi_UnformatPhoneNumber 'Ref_Client','FAX'
 	-- Ref_Provider
 	exec sp_asi_UnformatPhoneNumber 'Ref_Provider','PHONE'
 	-- Rpt_WorkingTbl
 	exec sp_asi_UnformatPhoneNumber 'Rpt_WorkingTbl','WORK_PHONE'
 	exec sp_asi_UnformatPhoneNumber 'Rpt_WorkingTbl','HOME_PHONE'
 	-- Exhb_Srvc_Comp
 	exec sp_asi_UnformatPhoneNumber 'Exhb_Srvc_Comp','CONTACT_PHONE'
 	-- Contacts
 	exec sp_asi_UnformatPhoneNumber 'Contacts','PHONE'
 	exec sp_asi_UnformatPhoneNumber 'Contacts','FAX'

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_UpdateCompanySort]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_UpdateCompanySort]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[sp_asi_UpdateCompanySort]
AS 
    BEGIN

        SET NOCOUNT ON

        SET ROWCOUNT 1000
        DECLARE @isDone BIT
        SET @isDone = 0
        WHILE ( @isDone = 0 ) 
            BEGIN
                BEGIN TRANSACTION
                UPDATE  Name
                SET     COMPANY_SORT = dbo.fn_asi_GetCompanySort(COMPANY)
                WHERE   ( COMPANY_SORT <> dbo.fn_asi_GetCompanySort(COMPANY) )
                        AND ( LEN(COMPANY_SORT) = 0 )
                IF @@ROWCOUNT = 0 
                    SET @isDone = 1
                COMMIT TRANSACTION
            END
        SET ROWCOUNT 0
    END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_UpdateCompanyTitleUse]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_UpdateCompanyTitleUse]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure sp_asi_UpdateCompanyTitleUse
 as
 set nocount on
 declare
 @CompanyPurposes varchar(255), 
 @TitlePurposes varchar(255),
 @PrefPurpose varchar(255),
 @UseCompany bit,
 @UseTitle bit,
 @OrderNumber float,
 @Id varchar(10)
 select @CompanyPurposes =ShortValue from System_Params where ParameterName = 'Member_Control.PrintCompanyWithAddressString'
 select @TitlePurposes =ShortValue from System_Params where ParameterName = 'Member_Control.PrintTitleWithAddressString'
 select @UseCompany=0
 select @UseTitle=0
 declare Get_Orders cursor for 
 select ORDER_NUMBER,ST_ID
 from Orders where STAGE not in ('CLOSED','CANCELED','COMPLETED')
 open Get_Orders
 fetch next from Get_Orders into @OrderNumber,@Id
 WHILE @@FETCH_STATUS = 0
 BEGIN
 select @PrefPurpose=','+PURPOSE+',' from Name_Address
 join Name on Name.ID=Name_Address.ID 
 where Name.MAIL_ADDRESS_NUM=Name_Address.ADDRESS_NUM and Name.ID=@Id
 If charindex(@PrefPurpose,@CompanyPurposes)>0
 begin
  select @UseCompany=1
 end
 If charindex(@PrefPurpose,@TitlePurposes)>0
 begin
  select @UseTitle=1
 end
 update Orders set ST_PRINT_COMPANY=@UseCompany,ST_PRINT_TITLE=@UseTitle
 where ORDER_NUMBER=@OrderNumber
 update Order_Badge set ST_PRINT_COMPANY=@UseCompany,ST_PRINT_TITLE=@UseTitle
 where ORDER_NUMBER=@OrderNumber and BADGE_TYPE='PRIMARY'
 select @UseCompany=0
 select @UseTitle=0
 fetch next from Get_Orders into @OrderNumber,@Id
 END
 close Get_Orders
 deallocate Get_Orders

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_UpdateDupMatchKey]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_UpdateDupMatchKey]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
/****** Object:  StoredProcedure dbo.sp_asi_UpdateDupMatchKey  ******/
 -- =============================================
 -- This stored procedure calculates the Name.DUP_MATCH_KEY value - update the formula as required
 -- =============================================
 create procedure dbo.sp_asi_UpdateDupMatchKey
 as
 begin
 	-- controls update messages being sent to display
 	set nocount on
 	update Name
 		set DUP_MATCH_KEY=dbo.fn_asi_GetDupMatchKey(ID)
 		where DUP_MATCH_KEY<>dbo.fn_asi_GetDupMatchKey(ID)
 end
 GRANT EXECUTE on fn_asi_convert_foreign_chars to IMIS

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_UpdateEventFR]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_UpdateEventFR]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure sp_asi_UpdateEventFR
 as
 set nocount on
 declare
 @MeetCode varchar(10),
 @Appeal varchar(40), 
 @Campaign varchar(10),
 @Fund varchar(5),
 @OrderNumber float,
 @FairMarketValue money,
 @ProductCode varchar(31),
 @ProdTitle varchar(60),
 @RefNum int,
 @Status varchar(1),
 @ActivityType varchar(10),
 @Seqn int,
 @Id varchar(10),
 @TransDate datetime,
 @TransNumber int,
 @Result int,
 @NewSeqn int,
 @Amount money,
 @SourceCode varchar(40)
 declare Get_FREvents cursor for 
 select 
 max(m.MEET_APPEAL) MEET_APPEAL,
 max(m.MEET_CAMPAIGN) MEET_CAMPAIGN,
 max(m.ORG_CODE) ORG_CODE,
 max(m.STATUS) STATUS,
 max(p.TAXABLE_VALUE) TAXABLE_VALUE,
 p.PRODUCT_CODE,
 max(p.TITLE) TITLE,
 max(om.ORDER_NUMBER) ORDER_NUMBER,
 max(o.INVOICE_REFERENCE_NUM) INVOICE_REFERENCE_NUM,
 max(ol.EXTENDED_AMOUNT) EXTENDED_AMOUNT,
 max(t.ACTIVITY_TYPE) ACTIVITY_TYPE,
 max(t.ACTIVITY_SEQN) ACTIVITY_SEQN,
 t.ST_ID,
 max(t.TRANSACTION_DATE) TRANSACTION_DATE,
 max(t.TRANS_NUMBER) TRANS_NUMBER,
 max(t.SOURCE_CODE) SOURCE_CODE 
 from Meet_Master m
 join Order_Meet om on m.MEETING=om.MEETING
 join Orders o on om.ORDER_NUMBER=o.ORDER_NUMBER
 join Order_Lines ol on ol.ORDER_NUMBER=o.ORDER_NUMBER
 join Product p on p.PRODUCT_MAJOR=m.MEETING
 join Trans t on t.INVOICE_REFERENCE_NUM=o.INVOICE_REFERENCE_NUM
 where m.IS_FR_MEET=1 and t.TRANSACTION_TYPE='DIST' and t.JOURNAL_TYPE='IN'
 and t.SOURCE_SYSTEM='MEETING' and ol.PRODUCT_CODE=p.PRODUCT_CODE and ol.EXTENDED_AMOUNT>0
 group by p.PRODUCT_CODE,t.ST_ID
 open Get_FREvents 
 fetch next from Get_FREvents into @Appeal,@Campaign,@Fund,@Status,@FairMarketValue,@ProductCode,@ProdTitle,
 @OrderNumber,@RefNum,@Amount,@ActivityType,@Seqn,@Id,@TransDate,@TransNumber,@SourceCode
 WHILE @@FETCH_STATUS = 0
 BEGIN
 if NOT EXISTS(select * from Activity where ID=@Id and PRODUCT_CODE=@ProductCode and ACTIVITY_TYPE='GIFT')
 BEGIN
 If @Status<>'C'
 begin
 update Order_Lines set MEET_APPEAL=@Appeal,MEET_CAMPAIGN=@Campaign,ORG_CODE=@Fund,
 FAIR_MARKET_VALUE=@FairMarketValue,IS_FR_ITEM=1
 where PRODUCT_CODE=@ProductCode
 end
 update Product set APPEAL_CODE=@Appeal,CAMPAIGN_CODE=@Campaign,ORG_CODE=@Fund,
 IS_FR_ITEM=1 where PRODUCT_CODE=@ProductCode
 update Product_Function set IS_FR_ITEM=1 where PRODUCT_CODE=@ProductCode
 if isnull(@Appeal,'')='' and isnull(@SourceCode,'')<>''
 begin
 select @Appeal=@SourceCode
 end
 update Trans set SOURCE_CODE=@Appeal,CAMPAIGN_CODE=@Campaign,
 IS_FR_ITEM=1, ACTIVITY_TYPE=CASE ACTIVITY_TYPE WHEN 'PLEDGE' THEN 'GIFT' ELSE ACTIVITY_TYPE END 
 where INVOICE_REFERENCE_NUM=@RefNum and TRANSACTION_TYPE='DIST'
 exec @Result=sp_iboGetCounter 'Activity',1,@NewSeqn output
 insert into Activity(SEQN,ID,ACTIVITY_TYPE,PRODUCT_CODE,OTHER_CODE,TRANSACTION_DATE,DESCRIPTION, 
 EFFECTIVE_DATE,AMOUNT,SOURCE_CODE,SOURCE_SYSTEM,CO_ID,MEMBER_TYPE,ORIGINATING_TRANS_NUM,
 ORG_CODE,CAMPAIGN_CODE,OTHER_ID,TAXABLE_VALUE)
 select @NewSeqn,@Id,'GIFT',@ProductCode,'GIFT',@TransDate,@ProdTitle,
 NULL,@Amount,@Appeal,'MEETING', 
 (CASE n.COMPANY_RECORD WHEN 1 then n.ID WHEN 0 then n.CO_ID END), 
 n.MEMBER_TYPE,@TransNumber,@Fund,@Campaign,@Id,@FairMarketValue 
 from Name n where n.ID =@Id
 END
 fetch next from Get_FREvents into @Appeal,@Campaign,@Fund,@Status,@FairMarketValue,@ProductCode,@ProdTitle,
 @OrderNumber,@RefNum,@Amount,@ActivityType,@Seqn,@Id,@TransDate,@TransNumber,@SourceCode
 END
 close Get_FREvents 
 deallocate Get_FREvents
 update Trans set Trans.SOURCE_CODE=a.SOURCE_CODE,Trans.CAMPAIGN_CODE=a.CAMPAIGN_CODE,Trans.IS_FR_ITEM=1
 from Trans
 join Activity a on a.ORIGINATING_TRANS_NUM=Trans.TRANS_NUMBER
 join Invoice i on i.ORIGINATING_TRANS_NUM=a.ORIGINATING_TRANS_NUM
 where Trans.TRANSACTION_TYPE='DIST' and Trans.JOURNAL_TYPE='IN' and Trans.SOURCE_SYSTEM='MEETING'
 and Trans.IS_FR_ITEM=0 and Trans.INVOICE_REFERENCE_NUM=i.REFERENCE_NUM
 and a.ACTIVITY_TYPE in ('GIFT','PLEDGE')
 update Trans set INSTALL_BILL_DATE=NULL where SOURCE_SYSTEM='MEETING'
 update Invoice set INSTALL_BILL_DATE=NULL where SOURCE_SYSTEM='MEETING'
 update Activity set ACTIVITY_TYPE='GIFT' where ACTIVITY_TYPE='PLEDGE'
 and SOURCE_SYSTEM='MEETING'

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_UpdateFullName]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_UpdateFullName]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[sp_asi_UpdateFullName]
AS 
    BEGIN

        DECLARE @prefixes varchar(1000)
        SELECT @prefixes = ShortValue from System_Params where ParameterName = 'Member_Control.IncludePrefixString'

    -- controls update messages being sent to display
        SET NOCOUNT ON 

        SET ROWCOUNT 1000
        DECLARE @isDone BIT
        SET @isDone = 0
        WHILE ( @isDone = 0 ) 
            BEGIN
                BEGIN TRANSACTION
                UPDATE  Name
                SET     FULL_NAME = ISNULL(LTRIM(
                                       ISNULL( CASE WHEN CHARINDEX(',' + PREFIX + ',' ,',' + ISNULL(@prefixes,'') + ',') > 0 
                                             THEN ISNULL(SUBSTRING(SUBSTRING(@prefixes, 
                                                                             CHARINDEX(',' + PREFIX + ',' ,',' + @prefixes + ','), 
                                                                             DATALENGTH(PREFIX)),
                                                                   1,
                                                                   DATALENGTH(SUBSTRING(@prefixes,
                                                                                        CHARINDEX(','+PREFIX+',' , ',' + (@prefixes)+','),
                                                                                        DATALENGTH(PREFIX)))
                                                                   * ABS(SIGN(SIGN(DATALENGTH(SUBSTRING(@prefixes,
                                                                                              CHARINDEX(','+PREFIX+',' , ',' + @prefixes+','),
                                                                                              DATALENGTH(PREFIX)))-1) + 
                                                                                              SIGN(ASCII(SUBSTRING(@prefixes,
                                                                                                                   CHARINDEX(','+PREFIX+',' , ',' + @prefixes+','),
                                                                                                                   DATALENGTH(PREFIX)))-32)))) +
                                                         SUBSTRING(' ', 1, ABS(SIGN(SIGN(DATALENGTH(SUBSTRING(@prefixes, CHARINDEX(','+PREFIX+',' , ',' + @prefixes + ','),
                                                 DATALENGTH(PREFIX)))-1) + SIGN(ASCII(SUBSTRING(@prefixes, CHARINDEX(',' + PREFIX + ',' , ',' + @prefixes + ','), DATALENGTH(PREFIX)))-32)))),'') 
                                             END ,'')
                                        +
                                         SUBSTRING(FIRST_NAME, 1 ,DATALENGTH(FIRST_NAME) * ABS(SIGN(SIGN(DATALENGTH(FIRST_NAME)-1) + COALESCE(SIGN(ASCII(FIRST_NAME)-32), 0))))
                                        + SUBSTRING(' ', 1, ABS(SIGN(SIGN(DATALENGTH(FIRST_NAME)-1) + COALESCE(SIGN(ASCII(FIRST_NAME)-32), 0)))) 
                                        + SUBSTRING(MIDDLE_NAME, 1, DATALENGTH(MIDDLE_NAME) * ABS(SIGN(SIGN(DATALENGTH(MIDDLE_NAME)-1) + COALESCE(SIGN(ASCII(MIDDLE_NAME)-32), 0)))) 
                                        + SUBSTRING(' ', 1, ABS(SIGN(SIGN(DATALENGTH(MIDDLE_NAME)-1) + COALESCE(SIGN(ASCII(MIDDLE_NAME)-32), 0)))) 
                                        + SUBSTRING(LAST_NAME, 1, DATALENGTH(LAST_NAME) * ABS(SIGN(SIGN(DATALENGTH(LAST_NAME)-1) + COALESCE(SIGN(ASCII(LAST_NAME)-32), 0)))) 
                                        + SUBSTRING(', ', 1, 2 * ABS(SIGN(SIGN(DATALENGTH(LTRIM(RTRIM(SUFFIX))))))) 
                                        + SUBSTRING(SUFFIX, 1, DATALENGTH(SUFFIX) * ABS(SIGN(SIGN(DATALENGTH(LTRIM(RTRIM(SUFFIX))))))) 
                                        + SUBSTRING(', ', 1 ,2 * ABS(SIGN(SIGN(DATALENGTH(LTRIM(RTRIM(DESIGNATION))))))) 
                                        + SUBSTRING(DESIGNATION, 1, DATALENGTH(DESIGNATION) * ABS(SIGN(SIGN(DATALENGTH(DESIGNATION)-1) + COALESCE(SIGN(ASCII(DESIGNATION)-32), 0))))
                                        ),'')
                WHERE   FULL_NAME <> ISNULL(LTRIM(
                                       ISNULL( CASE WHEN CHARINDEX(',' + PREFIX + ',' ,',' + ISNULL(@prefixes,'') + ',') > 0 
                                             THEN ISNULL(SUBSTRING(SUBSTRING(@prefixes, 
                                                                             CHARINDEX(',' + PREFIX + ',' ,',' + @prefixes + ','), 
                                                                             DATALENGTH(PREFIX)),
                                                                   1,
                                                                   DATALENGTH(SUBSTRING(@prefixes,
                                                                                        CHARINDEX(','+PREFIX+',' , ',' + (@prefixes)+','),
                                                                                        DATALENGTH(PREFIX)))
                                                                   * ABS(SIGN(SIGN(DATALENGTH(SUBSTRING(@prefixes,
                                                                                              CHARINDEX(','+PREFIX+',' , ',' + @prefixes+','),
                                                                                              DATALENGTH(PREFIX)))-1) + 
                                                                                              SIGN(ASCII(SUBSTRING(@prefixes,
                                                                                                                   CHARINDEX(','+PREFIX+',' , ',' + @prefixes+','),
                                                                                                                   DATALENGTH(PREFIX)))-32)))) +
                                                         SUBSTRING(' ', 1, ABS(SIGN(SIGN(DATALENGTH(SUBSTRING(@prefixes, CHARINDEX(','+PREFIX+',' , ',' + @prefixes + ','),
                                                 DATALENGTH(PREFIX)))-1) + SIGN(ASCII(SUBSTRING(@prefixes, CHARINDEX(',' + PREFIX + ',' , ',' + @prefixes + ','), DATALENGTH(PREFIX)))-32)))),'') 
                                             END ,'')
                                        +
                                         SUBSTRING(FIRST_NAME, 1 ,DATALENGTH(FIRST_NAME) * ABS(SIGN(SIGN(DATALENGTH(FIRST_NAME)-1) + COALESCE(SIGN(ASCII(FIRST_NAME)-32), 0))))
                                        + SUBSTRING(' ', 1, ABS(SIGN(SIGN(DATALENGTH(FIRST_NAME)-1) + COALESCE(SIGN(ASCII(FIRST_NAME)-32), 0)))) 
                                        + SUBSTRING(MIDDLE_NAME, 1, DATALENGTH(MIDDLE_NAME) * ABS(SIGN(SIGN(DATALENGTH(MIDDLE_NAME)-1) + COALESCE(SIGN(ASCII(MIDDLE_NAME)-32), 0)))) 
                                        + SUBSTRING(' ', 1, ABS(SIGN(SIGN(DATALENGTH(MIDDLE_NAME)-1) + COALESCE(SIGN(ASCII(MIDDLE_NAME)-32), 0)))) 
                                        + SUBSTRING(LAST_NAME, 1, DATALENGTH(LAST_NAME) * ABS(SIGN(SIGN(DATALENGTH(LAST_NAME)-1) + COALESCE(SIGN(ASCII(LAST_NAME)-32), 0)))) 
                                        + SUBSTRING(', ', 1, 2 * ABS(SIGN(SIGN(DATALENGTH(LTRIM(RTRIM(SUFFIX))))))) 
                                        + SUBSTRING(SUFFIX, 1, DATALENGTH(SUFFIX) * ABS(SIGN(SIGN(DATALENGTH(LTRIM(RTRIM(SUFFIX))))))) 
                                        + SUBSTRING(', ', 1 ,2 * ABS(SIGN(SIGN(DATALENGTH(LTRIM(RTRIM(DESIGNATION))))))) 
                                        + SUBSTRING(DESIGNATION, 1, DATALENGTH(DESIGNATION) * ABS(SIGN(SIGN(DATALENGTH(DESIGNATION)-1) + COALESCE(SIGN(ASCII(DESIGNATION)-32), 0))))
                                        ),'')

                IF @@ROWCOUNT = 0 
                    SET @isDone = 1
                COMMIT TRANSACTION
            END
        SET ROWCOUNT 0
    END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_UpdateLastFirst]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_UpdateLastFirst]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO

CREATE PROCEDURE [dbo].[sp_asi_UpdateLastFirst]
AS 
    BEGIN

        SET NOCOUNT ON

        SET ROWCOUNT 1000
        DECLARE @isDone BIT
        SET @isDone = 0
        WHILE ( @isDone = 0 ) 
            BEGIN
                BEGIN TRANSACTION
                UPDATE  Name
                SET     LAST_FIRST = dbo.fn_asi_GetLastFirst(LAST_NAME,
                                                             FIRST_NAME)
                WHERE   LAST_FIRST <> dbo.fn_asi_GetLastFirst(LAST_NAME,
                                                              FIRST_NAME)
                IF @@ROWCOUNT = 0 
                    SET @isDone = 1
                COMMIT TRANSACTION
            END
        SET ROWCOUNT 0
    END


GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_UpdateTransSoftCredit]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_UpdateTransSoftCredit]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE procedure sp_asi_UpdateTransSoftCredit
 as
 set nocount on
 declare
 @TransNumber int,
 @BtId varchar(10),
 @StId varchar(10),
 @Amount money,
 @TotalAmount money,
 @DistAmount money,
 @ActivitySeqn int,
 @Percent float,
 @TotalPercent float,
 @count int,
 @ProductCode varchar(31),
 @InvRefNum int,
 @JournalType varchar(5)
 create table #SplitGiftRows (
 TransNumber int,
 StId varchar(10),
 Amount money,
 ActivitySeqn int,
 ProductCode varchar(31)
 )
 select @Percent=100
 declare Get_Trans cursor for 
 select TRANS_NUMBER,max(BT_ID),max(ST_ID),-max(AMOUNT),-sum(AMOUNT),max(ACTIVITY_SEQN),max(PRODUCT_CODE),
 max(INVOICE_REFERENCE_NUM),max(JOURNAL_TYPE)
 from Trans where TRANSACTION_TYPE='DIST' and SOURCE_SYSTEM='FR' and BT_ID<>ST_ID
 group by TRANS_NUMBER
 open Get_Trans
 fetch next from Get_Trans into @TransNumber,@BtId,@StId,@Amount,@TotalAmount,@ActivitySeqn,@ProductCode,@InvRefNum,@JournalType
 WHILE @@FETCH_STATUS = 0
 BEGIN
 if @TotalAmount=@Amount
 BEGIN
 if @JournalType in ('CM','DM')
 BEGIN
 select @ActivitySeqn=max(ACTIVITY_SEQN) from Trans
 join Invoice on REFERENCE_NUM=@InvRefNum
 where TRANS_NUMBER=ORIGINATING_TRANS_NUM
 and TRANSACTION_TYPE='DIST' and PRODUCT_CODE=@ProductCode
 group by ACTIVITY_SEQN
 END
 begin transaction
 insert into Trans_SoftCredit(TRANS_NUMBER,SOFT_CREDIT_ID,PERCENTAGE,AMOUNT,ORIGINATING_ACTIVITY_SEQN,PRODUCT_CODE)
 values(@TransNumber,@StId,@Percent,@Amount,@ActivitySeqn,@ProductCode)
 update Trans set ST_ID=@BtId where TRANS_NUMBER=@TransNumber
 commit transaction
 END
 ELSE
 BEGIN
 truncate table #SplitGiftRows
 insert into #SplitGiftRows(TransNumber,StId,Amount,ActivitySeqn,ProductCode)
 select max(ORIGINATING_TRANS_NUM),max(OTHER_ID),sum(AMOUNT),max(SEQN),max(PRODUCT_CODE) from Activity
 where ORIGINATING_TRANS_NUM=@TransNumber
 group by ORIGINATING_TRANS_NUM,PRODUCT_CODE
 declare Get_Dist cursor for 
 select TransNumber,StId,Amount,ActivitySeqn,ProductCode from #SplitGiftRows
 open Get_Dist
 fetch next from Get_Dist into @TransNumber,@StId,@DistAmount,@ActivitySeqn,@ProductCode
 WHILE @@FETCH_STATUS = 0
 BEGIN
 if @DistAmount<>0
 BEGIN
 select @ActivitySeqn=max(ACTIVITY_SEQN) from Trans
 join Invoice on REFERENCE_NUM=@InvRefNum
 where TRANS_NUMBER=ORIGINATING_TRANS_NUM
 and TRANSACTION_TYPE='DIST' and PRODUCT_CODE=@ProductCode
 group by ACTIVITY_SEQN
 END
 insert into Trans_SoftCredit(TRANS_NUMBER,SOFT_CREDIT_ID,PERCENTAGE,AMOUNT,ORIGINATING_ACTIVITY_SEQN,PRODUCT_CODE)
 values(@TransNumber,@StId,@Percent,@DistAmount,@ActivitySeqn,@ProductCode)
 fetch next from Get_Dist into @TransNumber,@StId,@DistAmount,@ActivitySeqn,@ProductCode
 END
 close Get_Dist
 deallocate Get_Dist
 update Trans set ST_ID=@BtId where TRANS_NUMBER=@TransNumber
 END
 fetch next from Get_Trans into @TransNumber,@BtId,@StId,@Amount,@TotalAmount,@ActivitySeqn,@ProductCode,@InvRefNum,@JournalType
 END
 close Get_Trans
 deallocate Get_Trans

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_asi_user_name]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[sp_asi_user_name]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE sp_asi_user_name AS 
		select (convert (varchar(64), user_name ()))

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SqlQueryNotificationStoredProcedure-ef9cd00c-591a-43ac-ab54-629d9525cc2d]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[SqlQueryNotificationStoredProcedure-ef9cd00c-591a-43ac-ab54-629d9525cc2d]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [SqlQueryNotificationStoredProcedure-ef9cd00c-591a-43ac-ab54-629d9525cc2d] AS BEGIN BEGIN TRANSACTION; RECEIVE TOP(0) conversation_handle FROM [SqlQueryNotificationService-ef9cd00c-591a-43ac-ab54-629d9525cc2d]; IF (SELECT COUNT(*) FROM [SqlQueryNotificationService-ef9cd00c-591a-43ac-ab54-629d9525cc2d] WHERE message_type_name = 'http://schemas.microsoft.com/SQL/ServiceBroker/DialogTimer') > 0 BEGIN if ((SELECT COUNT(*) FROM sys.services WHERE name = 'SqlQueryNotificationService-ef9cd00c-591a-43ac-ab54-629d9525cc2d') > 0)   DROP SERVICE [SqlQueryNotificationService-ef9cd00c-591a-43ac-ab54-629d9525cc2d]; if (OBJECT_ID('SqlQueryNotificationService-ef9cd00c-591a-43ac-ab54-629d9525cc2d', 'SQ') IS NOT NULL)   DROP QUEUE [SqlQueryNotificationService-ef9cd00c-591a-43ac-ab54-629d9525cc2d]; DROP PROCEDURE [SqlQueryNotificationStoredProcedure-ef9cd00c-591a-43ac-ab54-629d9525cc2d]; END COMMIT TRANSACTION; END
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[temp_GetBusinessItem]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[temp_GetBusinessItem]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[temp_GetBusinessItem] 
	@tablename varchar(256), 
	@namespace varchar(256) = null, 
	@baseclass varchar(256) = 'BusinessItem' AS
BEGIN
SET NOCOUNT ON

IF @namespace IS NOT NULL
BEGIN
SELECT
'
using System;
using Asi;
using Asi.Business;
using System.Data;
using Asi.Business.Common;

namespace Asi.Business.' + @namespace + '
{
	public class ' + @tablename + ' : ' + @baseclass + '
	{
		#region Constructors
		/// <summary>
		/// Initializes a new instance of <see cref="' + @tablename + '"/> from a <see cref="DataRowBuilder"/>.
		/// </summary>
		/// <param name="builder">A <see cref="DataRowBuilder"/> object. </param>
		public ' + @tablename + '(DataRowBuilder builder):base(builder){}
		#endregion Constructors

		#region Properties'
END

SELECT
'
		/// <summary>
		/// 
		/// </summary>
		/// <value></value>
		public ' +
CASE c.name
   WHEN 'bigint' THEN 'int'
   WHEN 'binary' THEN 'bool'
   WHEN 'bit' THEN 'bool'
   WHEN 'char' THEN 'string'
   WHEN 'datetime' THEN 'DateTime'
   WHEN 'decimal' THEN 'decimal'
   WHEN 'float' THEN 'decimal'
   WHEN 'image' THEN 'byte[]'
   WHEN 'int' THEN 'int'
   WHEN 'money' THEN 'decimal'
   WHEN 'nchar' THEN 'string'
   WHEN 'ntext' THEN 'string'
   WHEN 'numeric' THEN 'decimal'
   WHEN 'nvarchar' THEN 'string'
   WHEN 'real' THEN 'decimal'
   WHEN 'smalldatetime' THEN 'DateTime'
   WHEN 'smallint' THEN 'int'
   WHEN 'smallmoney' THEN 'decimal'
   WHEN 'text' THEN 'string'
   WHEN 'timestamp' THEN 'DateTime'
   WHEN 'tinyint' THEN 'int'
   WHEN 'uniqueidentifier' THEN 'Guid'
   WHEN 'varbinary' THEN 'byte[]'
   WHEN 'varchar' THEN 'string'
   ELSE c.name
END
+ ' ' + b.name + '
		{
			get
			{
				return Get' + 
CASE c.name
   WHEN 'bigint' THEN 'Int'
   WHEN 'binary' THEN 'Bool'
   WHEN 'bit' THEN 'Bool'
   WHEN 'char' THEN 'String'
   WHEN 'datetime' THEN 'DateTime'
   WHEN 'decimal' THEN 'Decimal'
   WHEN 'float' THEN 'Decimal'
   WHEN 'image' THEN 'byte[]'
   WHEN 'int' THEN 'Int'
   WHEN 'money' THEN 'Decimal'
   WHEN 'nchar' THEN 'String'
   WHEN 'ntext' THEN 'String'
   WHEN 'numeric' THEN 'Decimal'
   WHEN 'nvarchar' THEN 'String'
   WHEN 'real' THEN 'Decimal'
   WHEN 'smalldatetime' THEN 'DateTime'
   WHEN 'smallint' THEN 'Int'
   WHEN 'smallmoney' THEN 'Decimal'
   WHEN 'text' THEN 'String'
   WHEN 'timestamp' THEN 'DateTime'
   WHEN 'tinyint' THEN 'Int'
   WHEN 'uniqueidentifier' THEN 'Guid'
   WHEN 'varbinary' THEN 'byte[]'
   WHEN 'varchar' THEN 'String'
   ELSE c.name
END
+ '("' + b.name + '");
			}
			set
			{
				this["' + b.name + '"] = value;
			}
		}
'
  FROM sysobjects a, syscolumns b, systypes c
 WHERE a.xtype = 'U'
   AND a.name = @tablename
   AND a.id = b.id
   AND b.xtype = c.xtype
   AND b.xusertype = c.xusertype
   AND b.name NOT IN ('UpdatedByUserKey', 'CreatedByUserKey')
 ORDER BY b.name

SELECT
'
		public User ' + LEFT(b.name,13) + '
		{
			get
			{
				return UserController.User(' + b.name + ', this.BusinessContainer);
			}
		}
'
  FROM sysobjects a, syscolumns b
 WHERE a.xtype = 'U'
   AND a.name = @tablename
   AND a.id = b.id
   AND b.name IN ('UpdatedByUserKey', 'CreatedByUserKey')
 ORDER BY b.name

IF @namespace IS NOT NULL
BEGIN
	DECLARE @KeyCol varchar(256), @KeyType varchar(256), @pname varchar(256), @params varchar(1000), @assign varchar(1000)

	DECLARE GetKeys CURSOR FOR
	SELECT d.name, 
		CASE f.name
		   WHEN 'bigint' THEN 'int'
		   WHEN 'binary' THEN 'bool'
		   WHEN 'bit' THEN 'bool'
		   WHEN 'char' THEN 'string'
		   WHEN 'datetime' THEN 'DateTime'
		   WHEN 'decimal' THEN 'decimal'
		   WHEN 'float' THEN 'decimal'
		   WHEN 'image' THEN 'byte[]'
		   WHEN 'int' THEN 'int'
		   WHEN 'money' THEN 'decimal'
		   WHEN 'nchar' THEN 'string'
		   WHEN 'ntext' THEN 'string'
		   WHEN 'numeric' THEN 'decimal'
		   WHEN 'nvarchar' THEN 'string'
		   WHEN 'real' THEN 'decimal'
		   WHEN 'smalldatetime' THEN 'DateTime'
		   WHEN 'smallint' THEN 'int'
		   WHEN 'smallmoney' THEN 'decimal'
		   WHEN 'text' THEN 'string'
		   WHEN 'timestamp' THEN 'DateTime'
		   WHEN 'tinyint' THEN 'int'
		   WHEN 'uniqueidentifier' THEN 'Guid'
		   WHEN 'varbinary' THEN 'byte[]'
		   WHEN 'varchar' THEN 'string'
		   ELSE f.name
		END
	  FROM sysobjects a, sysindexes b, sysobjects c, syscolumns d, sysindexkeys e, systypes f
	 WHERE a.id = b.id
	   AND a.id = c.parent_obj
	   AND c.name = b.name
	   AND b.indid = e.indid
	   AND d.colid = e.colid
	   AND a.id = d.id
	   AND a.id = e.id
	   AND a.name = @tablename
	   AND c.xtype='PK'
	   AND d.xtype = f.xtype
	   AND d.xusertype = f.xusertype
	
	OPEN GetKeys
	
	FETCH NEXT FROM GetKeys INTO @KeyCol, @KeyType
	SET @params = ''
	SET @assign = ''
	
	WHILE @@FETCH_STATUS = 0
	BEGIN
		set @pname = LOWER(SUBSTRING(@KeyCol,1,1)) + SUBSTRING(@KeyCol,2,LEN(@KeyCol))
		SET @params = @params + @KeyType + ' ' + @pname + ', '
		SET @assign = @assign + '			this["' + @KeyCol + '"] = ' + @pname + ';
'
		
		FETCH NEXT FROM GetKeys INTO @KeyCol, @KeyType
	END
	
	CLOSE GetKeys
	
	DEALLOCATE GetKeys

SELECT
'
		#endregion Properties

		#region Methods
		protected internal void InitializeNew(' + SUBSTRING(@params,1,LEN(@params) - 1) + ')
		{
			base.InitializeNew();
' + @assign + '		}
		#endregion Methods
		
		#region StaticProperties
		#endregion StaticProperties

		#region Static Members
		#endregion Static Members
	}
}
'
END

SET NOCOUNT ON

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[temp_GetProperties]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[temp_GetProperties]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[temp_GetProperties] 
	@tablename varchar(256), 
	@namespace varchar(256) = null, 
	@inherits varchar(256) = null AS
BEGIN
SET NOCOUNT ON

IF @namespace IS NOT NULL
BEGIN
SELECT
'
using System;
using Asi;
using Asi.Business;
using System.Data;
using Asi.Business.Common;

namespace Asi.Business.' + @namespace + '
{
	public class ' + @tablename + ' : ' + @inherits + '
	{
		#region Constructors
		/// <summary>
		/// Initializes a new instance of <see cref="' + @tablename + '"/> from a <see cref="DataRowBuilder"/>.
		/// </summary>
		/// <param name="builder">A <see cref="DataRowBuilder"/> object. </param>
		public ' + @tablename + '(DataRowBuilder builder):base(builder){}
		#endregion Constructors

		#region Properties'
END

SELECT
'
		/// <summary>
		/// 
		/// </summary>
		/// <value></value>
		public ' +
CASE c.name
   WHEN 'bigint' THEN 'int'
   WHEN 'binary' THEN 'bool'
   WHEN 'bit' THEN 'bool'
   WHEN 'char' THEN 'string'
   WHEN 'datetime' THEN 'DateTime'
   WHEN 'decimal' THEN 'decimal'
   WHEN 'float' THEN 'decimal'
   WHEN 'image' THEN 'byte[]'
   WHEN 'int' THEN 'int'
   WHEN 'money' THEN 'decimal'
   WHEN 'nchar' THEN 'string'
   WHEN 'ntext' THEN 'string'
   WHEN 'numeric' THEN 'decimal'
   WHEN 'nvarchar' THEN 'string'
   WHEN 'real' THEN 'decimal'
   WHEN 'smalldatetime' THEN 'DateTime'
   WHEN 'smallint' THEN 'int'
   WHEN 'smallmoney' THEN 'decimal'
   WHEN 'text' THEN 'string'
   WHEN 'timestamp' THEN 'DateTime'
   WHEN 'tinyint' THEN 'int'
   WHEN 'uniqueidentifier' THEN 'Guid'
   WHEN 'varbinary' THEN 'byte[]'
   WHEN 'varchar' THEN 'string'
   ELSE c.name
END
+ ' ' + b.name + '
		{
			get
			{
				return Get' + 
CASE c.name
   WHEN 'bigint' THEN 'Int'
   WHEN 'binary' THEN 'Bool'
   WHEN 'bit' THEN 'Bool'
   WHEN 'char' THEN 'String'
   WHEN 'datetime' THEN 'DateTime'
   WHEN 'decimal' THEN 'Decimal'
   WHEN 'float' THEN 'Decimal'
   WHEN 'image' THEN 'byte[]'
   WHEN 'int' THEN 'Int'
   WHEN 'money' THEN 'Decimal'
   WHEN 'nchar' THEN 'String'
   WHEN 'ntext' THEN 'String'
   WHEN 'numeric' THEN 'Decimal'
   WHEN 'nvarchar' THEN 'String'
   WHEN 'real' THEN 'Decimal'
   WHEN 'smalldatetime' THEN 'DateTime'
   WHEN 'smallint' THEN 'Int'
   WHEN 'smallmoney' THEN 'Decimal'
   WHEN 'text' THEN 'String'
   WHEN 'timestamp' THEN 'DateTime'
   WHEN 'tinyint' THEN 'Int'
   WHEN 'uniqueidentifier' THEN 'Guid'
   WHEN 'varbinary' THEN 'byte[]'
   WHEN 'varchar' THEN 'String'
   ELSE c.name
END
+ '("' + b.name + '");
			}
			set
			{
				this["' + b.name + '"] = value;
			}
		}
'
  FROM sysobjects a, syscolumns b, systypes c
 WHERE a.xtype = 'U'
   AND a.name = @tablename
   AND a.id = b.id
   AND b.xtype = c.xtype
   AND b.xusertype = c.xusertype
   AND b.name NOT IN ('UpdatedByUserKey', 'CreatedByUserKey')
 ORDER BY b.name

SELECT
'
		public User ' + LEFT(b.name,13) + '
		{
			get
			{
				return UserController.User(' + b.name + ', this.BusinessContainer);
			}
		}
'
  FROM sysobjects a, syscolumns b
 WHERE a.xtype = 'U'
   AND a.name = @tablename
   AND a.id = b.id
   AND b.name IN ('UpdatedByUserKey', 'CreatedByUserKey')
 ORDER BY b.name

IF @namespace IS NOT NULL
BEGIN
	DECLARE @KeyCol varchar(256), @KeyType varchar(256), @pname varchar(256), @params varchar(1000), @assign varchar(1000)

	DECLARE GetKeys CURSOR FOR
	SELECT d.name, 
		CASE f.name
		   WHEN 'bigint' THEN 'int'
		   WHEN 'binary' THEN 'bool'
		   WHEN 'bit' THEN 'bool'
		   WHEN 'char' THEN 'string'
		   WHEN 'datetime' THEN 'DateTime'
		   WHEN 'decimal' THEN 'decimal'
		   WHEN 'float' THEN 'decimal'
		   WHEN 'image' THEN 'byte[]'
		   WHEN 'int' THEN 'int'
		   WHEN 'money' THEN 'decimal'
		   WHEN 'nchar' THEN 'string'
		   WHEN 'ntext' THEN 'string'
		   WHEN 'numeric' THEN 'decimal'
		   WHEN 'nvarchar' THEN 'string'
		   WHEN 'real' THEN 'decimal'
		   WHEN 'smalldatetime' THEN 'DateTime'
		   WHEN 'smallint' THEN 'int'
		   WHEN 'smallmoney' THEN 'decimal'
		   WHEN 'text' THEN 'string'
		   WHEN 'timestamp' THEN 'DateTime'
		   WHEN 'tinyint' THEN 'int'
		   WHEN 'uniqueidentifier' THEN 'Guid'
		   WHEN 'varbinary' THEN 'byte[]'
		   WHEN 'varchar' THEN 'string'
		   ELSE f.name
		END
	  FROM sysobjects a, sysindexes b, sysobjects c, syscolumns d, sysindexkeys e, systypes f
	 WHERE a.id = b.id
	   AND a.id = c.parent_obj
	   AND c.name = b.name
	   AND b.indid = e.indid
	   AND d.colid = e.colid
	   AND a.id = d.id
	   AND a.id = e.id
	   AND a.name = 'GroupMemberDetail'
	   AND c.xtype='PK'
	   AND d.xtype = f.xtype
	   AND d.xusertype = f.xusertype
	
	OPEN GetKeys
	
	FETCH NEXT FROM GetKeys INTO @KeyCol, @KeyType
	SET @params = ''
	SET @assign = ''
	
	WHILE @@FETCH_STATUS = 0
	BEGIN
		set @pname = LOWER(SUBSTRING(@KeyCol,1,1)) + SUBSTRING(@KeyCol,2,LEN(@KeyCol))
		SET @params = @params + @KeyType + ' ' + @pname + ', '
		SET @assign = @assign + '			this["' + @KeyCol + '"] = ' + @pname + ';
'
		
		FETCH NEXT FROM GetKeys INTO @KeyCol, @KeyType
	END
	
	CLOSE GetKeys
	
	DEALLOCATE GetKeys

SELECT
'
		#endregion Properties

		#region Methods
		protected internal void InitializeNew(' + SUBSTRING(@params,1,LEN(@params) - 1) + ')
		{
			base.InitializeNew();
' + @assign + '		}
		#endregion Methods
		
		#region StaticProperties
		#endregion StaticProperties

		#region Static Members
		#endregion Static Members
	}
}
'
END

SET NOCOUNT ON

END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[TempDeleteSystemConfigVar]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[TempDeleteSystemConfigVar]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE TempDeleteSystemConfigVar 
		@ParameterName nvarchar(255)
AS
BEGIN
	DECLARE 
		@PropertyDefinitionKey uniqueidentifier

	SELECT @PropertyDefinitionKey = PropertyDefinitionKey
	  FROM SystemConfigParameterRef
	 WHERE ParameterName = @ParameterName

	DELETE FROM SystemConfig WHERE ParameterName = @ParameterName

	DELETE FROM SystemConfigPageParameterRef WHERE ParameterName = @ParameterName

	DELETE FROM SystemConfigParameterRef WHERE ParameterName = @ParameterName

	DELETE FROM PropertyDefinition WHERE PropertyDefinitionKey = @PropertyDefinitionKey
END

GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[TempUpdateSysConfig]') AND type in (N'P', N'PC'))
    DROP PROCEDURE [dbo].[TempUpdateSysConfig]
GO

SET ANSI_DEFAULTS ON
SET IMPLICIT_TRANSACTIONS OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
GO
CREATE PROCEDURE [dbo].[TempUpdateSysConfig] @ParameterName nvarchar(255), @ParameterDescription nvarchar(500), @SortOrder int, @FieldLength int = 0 AS
BEGIN
	UPDATE SystemConfigParameterRef SET Description = @ParameterDescription WHERE ParameterName = @ParameterName
	UPDATE SystemConfigPageParameterRef SET SortOrder = @SortOrder WHERE ParameterName = @ParameterName

	IF @FieldLength > 0
		UPDATE a
		   SET HIControlWidth = @FieldLength
		  FROM PropertyDefinition a inner join SystemConfigParameterRef b on a.PropertyDefinitionKey = b.PropertyDefinitionKey
		 WHERE b.ParameterName = @ParameterName
END

GO

